(function(define){var __define; typeof define === "function" && (__define=define,define=null);
// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"bU1QP":[function(require,module,exports) {
var u = globalThis.process?.argv || [];
var h = ()=>globalThis.process?.env || {};
var B = new Set(u), _ = (e)=>B.has(e), G = u.filter((e)=>e.startsWith("--") && e.includes("=")).map((e)=>e.split("=")).reduce((e, [t, o])=>(e[t] = o, e), {});
var U = _("--dry-run"), g = ()=>_("--verbose") || h().VERBOSE === "true", N = g();
var m = (e = "", ...t)=>console.log(e.padEnd(9), "|", ...t);
var y = (...e)=>console.error("\uD83D\uDD34 ERROR".padEnd(9), "|", ...e), v = (...e)=>m("\uD83D\uDD35 INFO", ...e), f = (...e)=>m("\uD83D\uDFE0 WARN", ...e), M = 0, i = (...e)=>g() && m(`\u{1F7E1} ${M++}`, ...e);
var b = ()=>{
    let e = globalThis.browser?.runtime || globalThis.chrome?.runtime, t = ()=>setInterval(e.getPlatformInfo, 24e3);
    e.onStartup.addListener(t), t();
};
var n = {
    "isContentScript": false,
    "isBackground": true,
    "isReact": false,
    "runtimes": [
        "background-service-runtime"
    ],
    "host": "localhost",
    "port": 1815,
    "entryFilePath": "/Applications/Github/instagram-ai-auto-image--thumbnail-replacer/.plasmo/static/background/index.ts",
    "bundleId": "c338908e704c91f1",
    "envHash": "d99a5ffa57acd638",
    "verbose": "false",
    "secure": false,
    "serverPort": 49836
};
module.bundle.HMR_BUNDLE_ID = n.bundleId;
globalThis.process = {
    argv: [],
    env: {
        VERBOSE: n.verbose
    }
};
var D = module.bundle.Module;
function H(e) {
    D.call(this, e), this.hot = {
        data: module.bundle.hotData[e],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(t) {
            this._acceptCallbacks.push(t || function() {});
        },
        dispose: function(t) {
            this._disposeCallbacks.push(t);
        }
    }, module.bundle.hotData[e] = void 0;
}
module.bundle.Module = H;
module.bundle.hotData = {};
var c = globalThis.browser || globalThis.chrome || null;
function R() {
    return !n.host || n.host === "0.0.0.0" ? location.protocol.indexOf("http") === 0 ? location.hostname : "localhost" : n.host;
}
function x() {
    return !n.host || n.host === "0.0.0.0" ? "localhost" : n.host;
}
function d() {
    return n.port || location.port;
}
var P = "__plasmo_runtime_page_", S = "__plasmo_runtime_script_";
var O = `${n.secure ? "https" : "http"}://${R()}:${d()}/`;
async function k(e = 1470) {
    for(;;)try {
        await fetch(O);
        break;
    } catch  {
        await new Promise((o)=>setTimeout(o, e));
    }
}
if (c.runtime.getManifest().manifest_version === 3) {
    let e = c.runtime.getURL("/__plasmo_hmr_proxy__?url=");
    globalThis.addEventListener("fetch", function(t) {
        let o = t.request.url;
        if (o.startsWith(e)) {
            let s = new URL(decodeURIComponent(o.slice(e.length)));
            s.hostname === n.host && s.port === `${n.port}` ? (s.searchParams.set("t", Date.now().toString()), t.respondWith(fetch(s).then((r)=>new Response(r.body, {
                    headers: {
                        "Content-Type": r.headers.get("Content-Type") ?? "text/javascript"
                    }
                })))) : t.respondWith(new Response("Plasmo HMR", {
                status: 200,
                statusText: "Testing"
            }));
        }
    });
}
function E(e, t) {
    let { modules: o } = e;
    return o ? !!o[t] : !1;
}
function C(e = d()) {
    let t = x();
    return `${n.secure || location.protocol === "https:" && !/localhost|127.0.0.1|0.0.0.0/.test(t) ? "wss" : "ws"}://${t}:${e}/`;
}
function L(e) {
    typeof e.message == "string" && y("[plasmo/parcel-runtime]: " + e.message);
}
function T(e) {
    if (typeof globalThis.WebSocket > "u") return;
    let t = new WebSocket(C(Number(d()) + 1));
    return t.addEventListener("message", async function(o) {
        let s = JSON.parse(o.data);
        await e(s);
    }), t.addEventListener("error", L), t;
}
function A(e) {
    if (typeof globalThis.WebSocket > "u") return;
    let t = new WebSocket(C());
    return t.addEventListener("message", async function(o) {
        let s = JSON.parse(o.data);
        if (s.type === "update" && await e(s.assets), s.type === "error") for (let r of s.diagnostics.ansi){
            let l = r.codeframe || r.stack;
            f("[plasmo/parcel-runtime]: " + r.message + `
` + l + `

` + r.hints.join(`
`));
        }
    }), t.addEventListener("error", L), t.addEventListener("open", ()=>{
        v(`[plasmo/parcel-runtime]: Connected to HMR server for ${n.entryFilePath}`);
    }), t.addEventListener("close", ()=>{
        f(`[plasmo/parcel-runtime]: Connection to the HMR server is closed for ${n.entryFilePath}`);
    }), t;
}
var w = module.bundle.parent, a = {
    buildReady: !1,
    bgChanged: !1,
    csChanged: !1,
    pageChanged: !1,
    scriptPorts: new Set,
    pagePorts: new Set
};
async function p(e = !1) {
    if (e || a.buildReady && a.pageChanged) {
        i("BGSW Runtime - reloading Page");
        for (let t of a.pagePorts)t.postMessage(null);
    }
    if (e || a.buildReady && (a.bgChanged || a.csChanged)) {
        i("BGSW Runtime - reloading CS");
        let t = await c?.tabs.query({
            active: !0
        });
        for (let o of a.scriptPorts){
            let s = t.some((r)=>r.id === o.sender.tab?.id);
            o.postMessage({
                __plasmo_cs_active_tab__: s
            });
        }
        c.runtime.reload();
    }
}
if (!w || !w.isParcelRequire) {
    b();
    let e = A(async (t)=>{
        i("BGSW Runtime - On HMR Update"), a.bgChanged ||= t.filter((s)=>s.envHash === n.envHash).some((s)=>E(module.bundle, s.id));
        let o = t.find((s)=>s.type === "json");
        if (o) {
            let s = new Set(t.map((l)=>l.id)), r = Object.values(o.depsByBundle).map((l)=>Object.values(l)).flat();
            a.bgChanged ||= r.every((l)=>s.has(l));
        }
        p();
    });
    e.addEventListener("open", ()=>{
        let t = setInterval(()=>e.send("ping"), 24e3);
        e.addEventListener("close", ()=>clearInterval(t));
    }), e.addEventListener("close", async ()=>{
        await k(), p(!0);
    });
}
T(async (e)=>{
    switch(i("BGSW Runtime - On Build Repackaged"), e.type){
        case "build_ready":
            a.buildReady ||= !0, p();
            break;
        case "cs_changed":
            a.csChanged ||= !0, p();
            break;
    }
});
c.runtime.onConnect.addListener(function(e) {
    let t = e.name.startsWith(P), o = e.name.startsWith(S);
    if (t || o) {
        let s = t ? a.pagePorts : a.scriptPorts;
        s.add(e), e.onDisconnect.addListener(()=>{
            s.delete(e);
        }), e.onMessage.addListener(function(r) {
            i("BGSW Runtime - On source changed", r), r.__plasmo_cs_changed__ && (a.csChanged ||= !0), r.__plasmo_page_changed__ && (a.pageChanged ||= !0), p();
        });
    }
});
c.runtime.onMessage.addListener(function(t) {
    return t.__plasmo_full_reload__ && (i("BGSW Runtime - On top-level code changed"), p()), !0;
});

},{}],"8oeFb":[function(require,module,exports) {
var _background = require("../../../src/background");

},{"../../../src/background":"kimL1"}],"kimL1":[function(require,module,exports) {
var _storage = require("@plasmohq/storage");
var _browser = require("convex/browser");
var _api = require("../convex/_generated/api");
const storage = new (0, _storage.Storage)();
const CONVEX_URL = "https://insightful-flamingo-560.convex.cloud";
const STRIPE_PRICE_ID = "price_1Sn2VYRW1CkBuCyAtpyz4kwK";
const convex = new (0, _browser.ConvexHttpClient)(CONVEX_URL);
chrome.runtime.onInstalled.addListener(async (details)=>{
    if (details.reason === "install") {
        await storage.set("credits", 1);
        await storage.set("isPremium", false);
        await storage.set("isAuthenticated", false);
        console.log("[Instagram AI Optimizer] Extension installed");
    }
});
chrome.action.onClicked.addListener((tab)=>{
    if (tab.url?.includes("instagram.com")) chrome.tabs.sendMessage(tab.id, {
        type: "TOGGLE_PANEL"
    });
});
chrome.runtime.onMessage.addListener((message, sender, sendResponse)=>{
    handleMessage(message, sender, sendResponse);
    return true;
});
async function handleMessage(message, _sender, sendResponse) {
    try {
        switch(message.type){
            case "GET_AUTH_STATE":
                {
                    const isAuthenticated = await storage.get("isAuthenticated");
                    const odch123 = await storage.get("odch123");
                    sendResponse({
                        isAuthenticated: isAuthenticated ?? false,
                        odch123
                    });
                    break;
                }
            case "SET_AUTH_STATE":
                await storage.set("isAuthenticated", message.payload.isAuthenticated);
                if (message.payload.odch123) await storage.set("odch123", message.payload.odch123);
                if (message.payload.isAuthenticated && message.payload.odch123 && message.payload.email) try {
                    await convex.mutation((0, _api.api).profiles.create, {
                        odch123: message.payload.odch123,
                        email: message.payload.email
                    });
                } catch (e) {
                    console.log("[Instagram AI Optimizer] Profile may already exist");
                }
                sendResponse({
                    success: true
                });
                break;
            case "GET_CREDITS":
                {
                    const odch123 = await storage.get("odch123");
                    if (odch123 && CONVEX_URL) try {
                        const profile = await convex.query((0, _api.api).profiles.getByUserId, {
                            odch123
                        });
                        if (profile) {
                            await storage.set("credits", profile.credits);
                            await storage.set("isPremium", profile.isPremium);
                            sendResponse({
                                credits: profile.isPremium ? -1 : profile.credits
                            });
                            break;
                        }
                    } catch (e) {
                        console.error("[Instagram AI Optimizer] Failed to fetch profile:", e);
                    }
                    const credits = await storage.get("credits");
                    sendResponse({
                        credits: credits ?? 1
                    });
                    break;
                }
            case "SET_CREDITS":
                await storage.set("credits", message.payload);
                sendResponse({
                    success: true
                });
                break;
            case "DECREMENT_CREDITS":
                {
                    const odch123 = await storage.get("odch123");
                    if (odch123 && CONVEX_URL) try {
                        const result = await convex.mutation((0, _api.api).profiles.decrementCredits, {
                            odch123
                        });
                        await storage.set("credits", result.credits);
                        sendResponse(result);
                        break;
                    } catch (e) {
                        console.error("[Instagram AI Optimizer] Failed to decrement credits:", e);
                    }
                    const currentCredits = await storage.get("credits") ?? 1;
                    const isPremium = await storage.get("isPremium");
                    if (isPremium) sendResponse({
                        credits: -1
                    });
                    else if (currentCredits > 0) {
                        const newCredits = currentCredits - 1;
                        await storage.set("credits", newCredits);
                        sendResponse({
                            credits: newCredits
                        });
                    } else sendResponse({
                        credits: 0,
                        error: "No credits remaining"
                    });
                    break;
                }
            case "SET_PREMIUM":
                {
                    const odch123 = await storage.get("odch123");
                    if (odch123 && CONVEX_URL) try {
                        await convex.mutation((0, _api.api).profiles.setPremium, {
                            odch123,
                            isPremium: message.payload
                        });
                    } catch (e) {
                        console.error("[Instagram AI Optimizer] Failed to set premium:", e);
                    }
                    await storage.set("isPremium", message.payload);
                    if (message.payload) await storage.set("credits", -1);
                    sendResponse({
                        success: true
                    });
                    break;
                }
            case "GET_USER_STATE":
                {
                    const odch123 = await storage.get("odch123");
                    if (odch123 && CONVEX_URL) try {
                        const profile = await convex.query((0, _api.api).profiles.getByUserId, {
                            odch123
                        });
                        if (profile) {
                            await storage.set("credits", profile.credits);
                            await storage.set("isPremium", profile.isPremium);
                            sendResponse({
                                isAuthenticated: true,
                                isPremium: profile.isPremium,
                                credits: profile.isPremium ? -1 : profile.credits,
                                odch123
                            });
                            break;
                        }
                    } catch (e) {
                        console.error("[Instagram AI Optimizer] Failed to fetch user state:", e);
                    }
                    const [isAuthenticated, isPremium, credits] = await Promise.all([
                        storage.get("isAuthenticated"),
                        storage.get("isPremium"),
                        storage.get("credits")
                    ]);
                    sendResponse({
                        isAuthenticated: isAuthenticated ?? false,
                        isPremium: isPremium ?? false,
                        credits: isPremium ? -1 : credits ?? 1,
                        odch123
                    });
                    break;
                }
            case "OPTIMIZE_IMAGE":
                if (CONVEX_URL) try {
                    const result = await convex.action((0, _api.api).ai.enhance.enhanceImage, {
                        imageUrl: message.payload.imageUrl,
                        stylePreset: message.payload.stylePreset,
                        enhancementLevel: "moderate",
                        useFullPipeline: false
                    });
                    sendResponse({
                        success: result.success,
                        aiImageUrl: result.enhancedUrl || message.payload.imageUrl,
                        error: result.error,
                        processingTimeMs: result.processingTimeMs
                    });
                    break;
                } catch (e) {
                    console.error("[Instagram AI Optimizer] AI enhancement failed:", e);
                    sendResponse({
                        success: false,
                        aiImageUrl: message.payload.imageUrl,
                        error: String(e)
                    });
                    break;
                }
                sendResponse({
                    success: false,
                    aiImageUrl: message.payload.imageUrl,
                    error: "Convex not configured"
                });
                break;
            case "CREATE_CHECKOUT":
                {
                    const odch123 = await storage.get("odch123");
                    if (!odch123) {
                        sendResponse({
                            error: "Not authenticated"
                        });
                        break;
                    }
                    if (CONVEX_URL && STRIPE_PRICE_ID) try {
                        const result = await convex.action((0, _api.api).stripe.createCheckoutSession, {
                            odch123,
                            priceId: STRIPE_PRICE_ID,
                            successUrl: "https://www.instagram.com/?payment=success",
                            cancelUrl: "https://www.instagram.com/?payment=cancelled"
                        });
                        sendResponse(result);
                        break;
                    } catch (e) {
                        console.error("[Instagram AI Optimizer] Failed to create checkout:", e);
                        sendResponse({
                            error: String(e)
                        });
                        break;
                    }
                    sendResponse({
                        error: "Stripe not configured"
                    });
                    break;
                }
            default:
                sendResponse({
                    error: "Unknown message type"
                });
        }
    } catch (error) {
        console.error("[Instagram AI Optimizer] Message handling error:", error);
        sendResponse({
            error: String(error)
        });
    }
}
chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab)=>{
    if (changeInfo.status === "complete" && tab.url?.includes("instagram.com")) {
        const url = new URL(tab.url);
        if (url.searchParams.get("payment") === "success") {
            storage.set("isPremium", true);
            storage.set("credits", -1);
            chrome.tabs.sendMessage(tabId, {
                type: "PAYMENT_SUCCESS"
            }).catch(()=>{});
        }
        chrome.tabs.sendMessage(tabId, {
            type: "PAGE_LOADED"
        }).catch(()=>{});
    }
});

},{"@plasmohq/storage":"i0YkM","convex/browser":"iiMQR","../convex/_generated/api":"k9cSC"}],"i0YkM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BaseStorage", ()=>o);
parcelHelpers.export(exports, "Storage", ()=>g);
var _pify = require("pify");
var _pifyDefault = parcelHelpers.interopDefault(_pify);
var l = ()=>{
    try {
        let e = globalThis.navigator?.userAgent.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
        if (e[1] === "Chrome") return parseInt(e[2]) < 100 || globalThis.chrome.runtime?.getManifest()?.manifest_version === 2;
    } catch  {
        return !1;
    }
    return !1;
};
var o = class {
    #r;
    #t;
    get primaryClient() {
        return this.#t;
    }
    #e;
    get secondaryClient() {
        return this.#e;
    }
    #a;
    get area() {
        return this.#a;
    }
    get hasWebApi() {
        try {
            return typeof window < "u" && !!window.localStorage;
        } catch (e) {
            return console.error(e), !1;
        }
    }
    #s = new Map;
    #i;
    get copiedKeySet() {
        return this.#i;
    }
    isCopied = (e)=>this.hasWebApi && (this.allCopied || this.copiedKeySet.has(e));
    #n = !1;
    get allCopied() {
        return this.#n;
    }
    getExtStorageApi = ()=>globalThis.browser?.storage || globalThis.chrome?.storage;
    get hasExtensionApi() {
        try {
            return !!this.getExtStorageApi();
        } catch (e) {
            return console.error(e), !1;
        }
    }
    isWatchSupported = ()=>this.hasExtensionApi;
    keyNamespace = "";
    isValidKey = (e)=>e.startsWith(this.keyNamespace);
    getNamespacedKey = (e)=>`${this.keyNamespace}${e}`;
    getUnnamespacedKey = (e)=>e.slice(this.keyNamespace.length);
    serde = {
        serializer: JSON.stringify,
        deserializer: JSON.parse
    };
    constructor({ area: e = "sync", allCopied: t = !1, copiedKeyList: s = [], serde: r = {} } = {}){
        this.setCopiedKeySet(s), this.#a = e, this.#n = t, this.serde = {
            ...this.serde,
            ...r
        };
        try {
            this.hasWebApi && (t || s.length > 0) && (this.#e = window.localStorage);
        } catch  {}
        try {
            this.hasExtensionApi && (this.#r = this.getExtStorageApi(), l() ? this.#t = (0, _pifyDefault.default)(this.#r[this.area], {
                exclude: [
                    "getBytesInUse"
                ],
                errorFirst: !1
            }) : this.#t = this.#r[this.area]);
        } catch  {}
    }
    setCopiedKeySet(e) {
        this.#i = new Set(e);
    }
    rawGetAll = ()=>this.#t?.get();
    getAll = async ()=>{
        let e = await this.rawGetAll();
        return Object.entries(e).filter(([t])=>this.isValidKey(t)).reduce((t, [s, r])=>(t[this.getUnnamespacedKey(s)] = r, t), {});
    };
    copy = async (e)=>{
        let t = e === void 0;
        if (!t && !this.copiedKeySet.has(e) || !this.allCopied || !this.hasExtensionApi) return !1;
        let s = this.allCopied ? await this.rawGetAll() : await this.#t.get((t ? [
            ...this.copiedKeySet
        ] : [
            e
        ]).map(this.getNamespacedKey));
        if (!s) return !1;
        let r = !1;
        for(let a in s){
            let i = s[a], n = this.#e?.getItem(a);
            this.#e?.setItem(a, i), r ||= i !== n;
        }
        return r;
    };
    rawGet = async (e)=>(await this.rawGetMany([
            e
        ]))[e];
    rawGetMany = async (e)=>this.hasExtensionApi ? await this.#t.get(e) : e.filter(this.isCopied).reduce((t, s)=>(t[s] = this.#e?.getItem(s), t), {});
    rawSet = async (e, t)=>await this.rawSetMany({
            [e]: t
        });
    rawSetMany = async (e)=>(this.#e && Object.entries(e).filter(([t])=>this.isCopied(t)).forEach(([t, s])=>this.#e.setItem(t, s)), this.hasExtensionApi && await this.#t.set(e), null);
    clear = async (e = !1)=>{
        e && this.#e?.clear(), await this.#t.clear();
    };
    rawRemove = async (e)=>{
        await this.rawRemoveMany([
            e
        ]);
    };
    rawRemoveMany = async (e)=>{
        this.#e && e.filter(this.isCopied).forEach((t)=>this.#e.removeItem(t)), this.hasExtensionApi && await this.#t.remove(e);
    };
    removeAll = async ()=>{
        let e = await this.getAll(), t = Object.keys(e);
        await this.removeMany(t);
    };
    watch = (e)=>{
        let t = this.isWatchSupported();
        return t && this.#o(e), t;
    };
    #o = (e)=>{
        for(let t in e){
            let s = this.getNamespacedKey(t), r = this.#s.get(s)?.callbackSet || new Set;
            if (r.add(e[t]), r.size > 1) continue;
            let a = (i, n)=>{
                if (n !== this.area || !i[s]) return;
                let h = this.#s.get(s);
                if (!h) throw new Error(`Storage comms does not exist for nsKey: ${s}`);
                Promise.all([
                    this.parseValue(i[s].newValue),
                    this.parseValue(i[s].oldValue)
                ]).then(([y, d])=>{
                    for (let p of h.callbackSet)p({
                        newValue: y,
                        oldValue: d
                    }, n);
                });
            };
            this.#r.onChanged.addListener(a), this.#s.set(s, {
                callbackSet: r,
                listener: a
            });
        }
    };
    unwatch = (e)=>{
        let t = this.isWatchSupported();
        return t && this.#c(e), t;
    };
    #c(e) {
        for(let t in e){
            let s = this.getNamespacedKey(t), r = e[t], a = this.#s.get(s);
            a && (a.callbackSet.delete(r), a.callbackSet.size === 0 && (this.#s.delete(s), this.#r.onChanged.removeListener(a.listener)));
        }
    }
    unwatchAll = ()=>this.#h();
    #h() {
        this.#s.forEach(({ listener: e })=>this.#r.onChanged.removeListener(e)), this.#s.clear();
    }
    async getItem(e) {
        return this.get(e);
    }
    async getItems(e) {
        return await this.getMany(e);
    }
    async setItem(e, t) {
        await this.set(e, t);
    }
    async setItems(e) {
        await await this.setMany(e);
    }
    async removeItem(e) {
        return this.remove(e);
    }
    async removeItems(e) {
        return await this.removeMany(e);
    }
}, g = class extends o {
    get = async (e)=>{
        let t = this.getNamespacedKey(e), s = await this.rawGet(t);
        return this.parseValue(s);
    };
    getMany = async (e)=>{
        let t = e.map(this.getNamespacedKey), s = await this.rawGetMany(t), r = await Promise.all(Object.values(s).map(this.parseValue));
        return Object.keys(s).reduce((a, i, n)=>(a[this.getUnnamespacedKey(i)] = r[n], a), {});
    };
    set = async (e, t)=>{
        let s = this.getNamespacedKey(e), r = this.serde.serializer(t);
        return this.rawSet(s, r);
    };
    setMany = async (e)=>{
        let t = Object.entries(e).reduce((s, [r, a])=>(s[this.getNamespacedKey(r)] = this.serde.serializer(a), s), {});
        return await this.rawSetMany(t);
    };
    remove = async (e)=>{
        let t = this.getNamespacedKey(e);
        return this.rawRemove(t);
    };
    removeMany = async (e)=>{
        let t = e.map(this.getNamespacedKey);
        return await this.rawRemoveMany(t);
    };
    setNamespace = (e)=>{
        this.keyNamespace = e;
    };
    parseValue = async (e)=>{
        try {
            if (e !== void 0) return this.serde.deserializer(e);
        } catch (t) {
            console.error(t);
        }
    };
};

},{"pify":"6Hkib","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"6Hkib":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>pify);
const processFunction = (function_, options, proxy, unwrapped)=>function(...arguments_) {
        const P = options.promiseModule;
        return new P((resolve, reject)=>{
            if (options.multiArgs) arguments_.push((...result)=>{
                if (options.errorFirst) {
                    if (result[0]) reject(result);
                    else {
                        result.shift();
                        resolve(result);
                    }
                } else resolve(result);
            });
            else if (options.errorFirst) arguments_.push((error, result)=>{
                if (error) reject(error);
                else resolve(result);
            });
            else arguments_.push(resolve);
            const self = this === proxy ? unwrapped : this;
            Reflect.apply(function_, self, arguments_);
        });
    };
const filterCache = new WeakMap();
function pify(input, options) {
    options = {
        exclude: [
            /.+(?:Sync|Stream)$/
        ],
        errorFirst: true,
        promiseModule: Promise,
        ...options
    };
    const objectType = typeof input;
    if (!(input !== null && (objectType === "object" || objectType === "function"))) throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${input === null ? "null" : objectType}\``);
    const filter = (target, key)=>{
        let cached = filterCache.get(target);
        if (!cached) {
            cached = {};
            filterCache.set(target, cached);
        }
        if (key in cached) return cached[key];
        const match = (pattern)=>typeof pattern === "string" || typeof key === "symbol" ? key === pattern : pattern.test(key);
        const descriptor = Reflect.getOwnPropertyDescriptor(target, key);
        const writableOrConfigurableOwn = descriptor === undefined || descriptor.writable || descriptor.configurable;
        const included = options.include ? options.include.some((element)=>match(element)) : !options.exclude.some((element)=>match(element));
        const shouldFilter = included && writableOrConfigurableOwn;
        cached[key] = shouldFilter;
        return shouldFilter;
    };
    const cache = new WeakMap();
    const proxy = new Proxy(input, {
        apply (target, thisArg, args) {
            const cached = cache.get(target);
            if (cached) return Reflect.apply(cached, thisArg, args);
            const pified = options.excludeMain ? target : processFunction(target, options, proxy, target);
            cache.set(target, pified);
            return Reflect.apply(pified, thisArg, args);
        },
        get (target, key) {
            const property = target[key];
            // eslint-disable-next-line no-use-extend-native/no-use-extend-native
            if (!filter(target, key) || property === Function.prototype[key]) return property;
            const cached = cache.get(property);
            if (cached) return cached;
            if (typeof property === "function") {
                const pified = processFunction(property, options, proxy, target);
                cache.set(property, pified);
                return pified;
            }
            return property;
        }
    });
    return proxy;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"iIXqM":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"iiMQR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BaseConvexClient", ()=>(0, _clientJs.BaseConvexClient));
parcelHelpers.export(exports, "ConvexClient", ()=>(0, _simpleClientJs.ConvexClient));
parcelHelpers.export(exports, "ConvexHttpClient", ()=>(0, _httpClientJs.ConvexHttpClient));
var _clientJs = require("./sync/client.js");
var _simpleClientJs = require("./simple_client.js");
var _httpClientJs = require("./http_client.js");
"use strict";

},{"./sync/client.js":"a81Q3","./simple_client.js":"cnboC","./http_client.js":"dDOXz","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"a81Q3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BaseConvexClient", ()=>BaseConvexClient);
var _indexJs = require("../../index.js");
var _indexJs1 = require("../../values/index.js");
var _loggingJs = require("../logging.js");
var _localStateJs = require("./local_state.js");
var _requestManagerJs = require("./request_manager.js");
var _optimisticUpdatesImplJs = require("./optimistic_updates_impl.js");
var _remoteQuerySetJs = require("./remote_query_set.js");
var _udfPathUtilsJs = require("./udf_path_utils.js");
var _webSocketManagerJs = require("./web_socket_manager.js");
var _sessionJs = require("./session.js");
var _authenticationManagerJs = require("./authentication_manager.js");
var _metricsJs = require("./metrics.js");
var _indexJs2 = require("../../common/index.js");
var _errorsJs = require("../../values/errors.js");
var _indexJs3 = require("../../vendor/jwt-decode/index.js");
"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
class BaseConvexClient {
    /**
   * @param address - The url of your Convex deployment, often provided
   * by an environment variable. E.g. `https://small-mouse-123.convex.cloud`.
   * @param onTransition - A callback receiving an array of query tokens
   * corresponding to query results that have changed -- additional handlers
   * can be added via `addOnTransitionHandler`.
   * @param options - See {@link BaseConvexClientOptions} for a full description.
   */ constructor(address, onTransition, options){
        __publicField(this, "address");
        __publicField(this, "state");
        __publicField(this, "requestManager");
        __publicField(this, "webSocketManager");
        __publicField(this, "authenticationManager");
        __publicField(this, "remoteQuerySet");
        __publicField(this, "optimisticQueryResults");
        __publicField(this, "_transitionHandlerCounter", 0);
        __publicField(this, "_nextRequestId");
        __publicField(this, "_onTransitionFns", /* @__PURE__ */ new Map());
        __publicField(this, "_sessionId");
        __publicField(this, "firstMessageReceived", false);
        __publicField(this, "debug");
        __publicField(this, "logger");
        __publicField(this, "maxObservedTimestamp");
        __publicField(this, "connectionStateSubscribers", /* @__PURE__ */ new Map());
        __publicField(this, "nextConnectionStateSubscriberId", 0);
        __publicField(this, "_lastPublishedConnectionState");
        /**
     * Call this whenever the connection state may have changed in a way that could
     * require publishing it. Schedules a possibly update.
     */ __publicField(this, "markConnectionStateDirty", ()=>{
            Promise.resolve().then(()=>{
                const curConnectionState = this.connectionState();
                if (JSON.stringify(curConnectionState) !== JSON.stringify(this._lastPublishedConnectionState)) {
                    this._lastPublishedConnectionState = curConnectionState;
                    for (const cb of this.connectionStateSubscribers.values())cb(curConnectionState);
                }
            });
        });
        // Instance property so that `mark()` doesn't need to be called as a method.
        __publicField(this, "mark", (name)=>{
            if (this.debug) (0, _metricsJs.mark)(name, this.sessionId);
        });
        if (typeof address === "object") throw new Error("Passing a ClientConfig object is no longer supported. Pass the URL of the Convex deployment as a string directly.");
        if (options?.skipConvexDeploymentUrlCheck !== true) (0, _indexJs2.validateDeploymentUrl)(address);
        options = {
            ...options
        };
        const authRefreshTokenLeewaySeconds = options.authRefreshTokenLeewaySeconds ?? 2;
        let webSocketConstructor = options.webSocketConstructor;
        if (!webSocketConstructor && typeof WebSocket === "undefined") throw new Error("No WebSocket global variable defined! To use Convex in an environment without WebSocket try the HTTP client: https://docs.convex.dev/api/classes/browser.ConvexHttpClient");
        webSocketConstructor = webSocketConstructor || WebSocket;
        this.debug = options.reportDebugInfoToConvex ?? false;
        this.address = address;
        this.logger = options.logger === false ? (0, _loggingJs.instantiateNoopLogger)({
            verbose: options.verbose ?? false
        }) : options.logger !== true && options.logger ? options.logger : (0, _loggingJs.instantiateDefaultLogger)({
            verbose: options.verbose ?? false
        });
        const i = address.search("://");
        if (i === -1) throw new Error("Provided address was not an absolute URL.");
        const origin = address.substring(i + 3);
        const protocol = address.substring(0, i);
        let wsProtocol;
        if (protocol === "http") wsProtocol = "ws";
        else if (protocol === "https") wsProtocol = "wss";
        else throw new Error(`Unknown parent protocol ${protocol}`);
        const wsUri = `${wsProtocol}://${origin}/api/${(0, _indexJs.version)}/sync`;
        this.state = new (0, _localStateJs.LocalSyncState)();
        this.remoteQuerySet = new (0, _remoteQuerySetJs.RemoteQuerySet)((queryId)=>this.state.queryPath(queryId), this.logger);
        this.requestManager = new (0, _requestManagerJs.RequestManager)(this.logger, this.markConnectionStateDirty);
        const pauseSocket = ()=>{
            this.webSocketManager.pause();
            this.state.pause();
        };
        this.authenticationManager = new (0, _authenticationManagerJs.AuthenticationManager)(this.state, {
            authenticate: (token)=>{
                const message = this.state.setAuth(token);
                this.webSocketManager.sendMessage(message);
                return message.baseVersion;
            },
            stopSocket: ()=>this.webSocketManager.stop(),
            tryRestartSocket: ()=>this.webSocketManager.tryRestart(),
            pauseSocket,
            resumeSocket: ()=>this.webSocketManager.resume(),
            clearAuth: ()=>{
                this.clearAuth();
            }
        }, {
            logger: this.logger,
            refreshTokenLeewaySeconds: authRefreshTokenLeewaySeconds
        });
        this.optimisticQueryResults = new (0, _optimisticUpdatesImplJs.OptimisticQueryResults)();
        this.addOnTransitionHandler((transition)=>{
            onTransition(transition.queries.map((q)=>q.token));
        });
        this._nextRequestId = 0;
        this._sessionId = (0, _sessionJs.newSessionId)();
        const { unsavedChangesWarning } = options;
        if (typeof window === "undefined" || typeof window.addEventListener === "undefined") {
            if (unsavedChangesWarning === true) throw new Error("unsavedChangesWarning requested, but window.addEventListener not found! Remove {unsavedChangesWarning: true} from Convex client options.");
        } else if (unsavedChangesWarning !== false) window.addEventListener("beforeunload", (e)=>{
            if (this.requestManager.hasIncompleteRequests()) {
                e.preventDefault();
                const confirmationMessage = "Are you sure you want to leave? Your changes may not be saved.";
                (e || window.event).returnValue = confirmationMessage;
                return confirmationMessage;
            }
        });
        this.webSocketManager = new (0, _webSocketManagerJs.WebSocketManager)(wsUri, {
            onOpen: (reconnectMetadata)=>{
                this.mark("convexWebSocketOpen");
                this.webSocketManager.sendMessage({
                    ...reconnectMetadata,
                    type: "Connect",
                    sessionId: this._sessionId,
                    maxObservedTimestamp: this.maxObservedTimestamp
                });
                const oldRemoteQueryResults = new Set(this.remoteQuerySet.remoteQueryResults().keys());
                this.remoteQuerySet = new (0, _remoteQuerySetJs.RemoteQuerySet)((queryId)=>this.state.queryPath(queryId), this.logger);
                const [querySetModification, authModification] = this.state.restart(oldRemoteQueryResults);
                if (authModification) this.webSocketManager.sendMessage(authModification);
                this.webSocketManager.sendMessage(querySetModification);
                for (const message of this.requestManager.restart())this.webSocketManager.sendMessage(message);
            },
            onResume: ()=>{
                const [querySetModification, authModification] = this.state.resume();
                if (authModification) this.webSocketManager.sendMessage(authModification);
                if (querySetModification) this.webSocketManager.sendMessage(querySetModification);
                for (const message of this.requestManager.resume())this.webSocketManager.sendMessage(message);
            },
            onMessage: (serverMessage)=>{
                if (!this.firstMessageReceived) {
                    this.firstMessageReceived = true;
                    this.mark("convexFirstMessageReceived");
                    this.reportMarks();
                }
                switch(serverMessage.type){
                    case "Transition":
                        {
                            this.observedTimestamp(serverMessage.endVersion.ts);
                            this.authenticationManager.onTransition(serverMessage);
                            this.remoteQuerySet.transition(serverMessage);
                            this.state.transition(serverMessage);
                            const completedRequests = this.requestManager.removeCompleted(this.remoteQuerySet.timestamp());
                            this.notifyOnQueryResultChanges(completedRequests);
                            break;
                        }
                    case "MutationResponse":
                        {
                            if (serverMessage.success) this.observedTimestamp(serverMessage.ts);
                            const completedMutationInfo = this.requestManager.onResponse(serverMessage);
                            if (completedMutationInfo !== null) this.notifyOnQueryResultChanges(/* @__PURE__ */ new Map([
                                [
                                    completedMutationInfo.requestId,
                                    completedMutationInfo.result
                                ]
                            ]));
                            break;
                        }
                    case "ActionResponse":
                        this.requestManager.onResponse(serverMessage);
                        break;
                    case "AuthError":
                        this.authenticationManager.onAuthError(serverMessage);
                        break;
                    case "FatalError":
                        {
                            const error = (0, _loggingJs.logFatalError)(this.logger, serverMessage.error);
                            this.webSocketManager.terminate();
                            throw error;
                        }
                    default:
                        serverMessage;
                }
                return {
                    hasSyncedPastLastReconnect: this.hasSyncedPastLastReconnect()
                };
            },
            onServerDisconnectError: options.onServerDisconnectError
        }, webSocketConstructor, this.logger, this.markConnectionStateDirty, this.debug);
        this.mark("convexClientConstructed");
        if (options.expectAuth) pauseSocket();
    }
    /**
   * Return true if there is outstanding work from prior to the time of the most recent restart.
   * This indicates that the client has not proven itself to have gotten past the issue that
   * potentially led to the restart. Use this to influence when to reset backoff after a failure.
   */ hasSyncedPastLastReconnect() {
        const hasSyncedPastLastReconnect = this.requestManager.hasSyncedPastLastReconnect() || this.state.hasSyncedPastLastReconnect();
        return hasSyncedPastLastReconnect;
    }
    observedTimestamp(observedTs) {
        if (this.maxObservedTimestamp === void 0 || this.maxObservedTimestamp.lessThanOrEqual(observedTs)) this.maxObservedTimestamp = observedTs;
    }
    getMaxObservedTimestamp() {
        return this.maxObservedTimestamp;
    }
    /**
   * Compute the current query results based on the remoteQuerySet and the
   * current optimistic updates and call `onTransition` for all the changed
   * queries.
   *
   * @param completedMutations - A set of mutation IDs whose optimistic updates
   * are no longer needed.
   */ notifyOnQueryResultChanges(completedRequests) {
        const remoteQueryResults = this.remoteQuerySet.remoteQueryResults();
        const queryTokenToValue = /* @__PURE__ */ new Map();
        for (const [queryId, result] of remoteQueryResults){
            const queryToken = this.state.queryToken(queryId);
            if (queryToken !== null) {
                const query = {
                    result,
                    udfPath: this.state.queryPath(queryId),
                    args: this.state.queryArgs(queryId)
                };
                queryTokenToValue.set(queryToken, query);
            }
        }
        const changedQueryTokens = this.optimisticQueryResults.ingestQueryResultsFromServer(queryTokenToValue, new Set(completedRequests.keys()));
        this.handleTransition({
            queries: changedQueryTokens.map((token)=>{
                const optimisticResult = this.optimisticQueryResults.rawQueryResult(token);
                return {
                    token,
                    modification: {
                        kind: "Updated",
                        result: optimisticResult
                    }
                };
            }),
            reflectedMutations: Array.from(completedRequests).map(([requestId, result])=>({
                    requestId,
                    result
                })),
            timestamp: this.remoteQuerySet.timestamp()
        });
    }
    handleTransition(transition) {
        for (const fn of this._onTransitionFns.values())fn(transition);
    }
    /**
   * Add a handler that will be called on a transition.
   *
   * Any external side effects (e.g. setting React state) should be handled here.
   *
   * @param fn
   *
   * @returns
   */ addOnTransitionHandler(fn) {
        const id = this._transitionHandlerCounter++;
        this._onTransitionFns.set(id, fn);
        return ()=>this._onTransitionFns.delete(id);
    }
    /**
   * Get the current JWT auth token and decoded claims.
   */ getCurrentAuthClaims() {
        const authToken = this.state.getAuth();
        let decoded = {};
        if (authToken && authToken.tokenType === "User") try {
            decoded = authToken ? (0, _indexJs3.jwtDecode)(authToken.value) : {};
        } catch  {
            decoded = {};
        }
        else return void 0;
        return {
            token: authToken.value,
            decoded
        };
    }
    /**
   * Set the authentication token to be used for subsequent queries and mutations.
   * `fetchToken` will be called automatically again if a token expires.
   * `fetchToken` should return `null` if the token cannot be retrieved, for example
   * when the user's rights were permanently revoked.
   * @param fetchToken - an async function returning the JWT-encoded OpenID Connect Identity Token
   * @param onChange - a callback that will be called when the authentication status changes
   */ setAuth(fetchToken, onChange) {
        this.authenticationManager.setConfig(fetchToken, onChange);
    }
    hasAuth() {
        return this.state.hasAuth();
    }
    /** @internal */ setAdminAuth(value, fakeUserIdentity) {
        const message = this.state.setAdminAuth(value, fakeUserIdentity);
        this.webSocketManager.sendMessage(message);
    }
    clearAuth() {
        const message = this.state.clearAuth();
        this.webSocketManager.sendMessage(message);
    }
    /**
     * Subscribe to a query function.
     *
     * Whenever this query's result changes, the `onTransition` callback
     * passed into the constructor will be called.
     *
     * @param name - The name of the query.
     * @param args - An arguments object for the query. If this is omitted, the
     * arguments will be `{}`.
     * @param options - A {@link SubscribeOptions} options object for this query.
  
     * @returns An object containing a {@link QueryToken} corresponding to this
     * query and an `unsubscribe` callback.
     */ subscribe(name, args, options) {
        const argsObject = (0, _indexJs2.parseArgs)(args);
        const { modification, queryToken, unsubscribe } = this.state.subscribe(name, argsObject, options?.journal, options?.componentPath);
        if (modification !== null) this.webSocketManager.sendMessage(modification);
        return {
            queryToken,
            unsubscribe: ()=>{
                const modification2 = unsubscribe();
                if (modification2) this.webSocketManager.sendMessage(modification2);
            }
        };
    }
    /**
   * A query result based only on the current, local state.
   *
   * The only way this will return a value is if we're already subscribed to the
   * query or its value has been set optimistically.
   */ localQueryResult(udfPath, args) {
        const argsObject = (0, _indexJs2.parseArgs)(args);
        const queryToken = (0, _udfPathUtilsJs.serializePathAndArgs)(udfPath, argsObject);
        return this.optimisticQueryResults.queryResult(queryToken);
    }
    /**
   * Get query result by query token based on current, local state
   *
   * The only way this will return a value is if we're already subscribed to the
   * query or its value has been set optimistically.
   *
   * @internal
   */ localQueryResultByToken(queryToken) {
        return this.optimisticQueryResults.queryResult(queryToken);
    }
    /**
   * Whether local query result is available for a token.
   *
   * This method does not throw if the result is an error.
   *
   * @internal
   */ hasLocalQueryResultByToken(queryToken) {
        return this.optimisticQueryResults.hasQueryResult(queryToken);
    }
    /**
   * @internal
   */ localQueryLogs(udfPath, args) {
        const argsObject = (0, _indexJs2.parseArgs)(args);
        const queryToken = (0, _udfPathUtilsJs.serializePathAndArgs)(udfPath, argsObject);
        return this.optimisticQueryResults.queryLogs(queryToken);
    }
    /**
   * Retrieve the current {@link QueryJournal} for this query function.
   *
   * If we have not yet received a result for this query, this will be `undefined`.
   *
   * @param name - The name of the query.
   * @param args - The arguments object for this query.
   * @returns The query's {@link QueryJournal} or `undefined`.
   */ queryJournal(name, args) {
        const argsObject = (0, _indexJs2.parseArgs)(args);
        const queryToken = (0, _udfPathUtilsJs.serializePathAndArgs)(name, argsObject);
        return this.state.queryJournal(queryToken);
    }
    /**
   * Get the current {@link ConnectionState} between the client and the Convex
   * backend.
   *
   * @returns The {@link ConnectionState} with the Convex backend.
   */ connectionState() {
        const wsConnectionState = this.webSocketManager.connectionState();
        return {
            hasInflightRequests: this.requestManager.hasInflightRequests(),
            isWebSocketConnected: wsConnectionState.isConnected,
            hasEverConnected: wsConnectionState.hasEverConnected,
            connectionCount: wsConnectionState.connectionCount,
            connectionRetries: wsConnectionState.connectionRetries,
            timeOfOldestInflightRequest: this.requestManager.timeOfOldestInflightRequest(),
            inflightMutations: this.requestManager.inflightMutations(),
            inflightActions: this.requestManager.inflightActions()
        };
    }
    /**
   * Subscribe to the {@link ConnectionState} between the client and the Convex
   * backend, calling a callback each time it changes.
   *
   * Subscribed callbacks will be called when any part of ConnectionState changes.
   * ConnectionState may grow in future versions (e.g. to provide a array of
   * inflight requests) in which case callbacks would be called more frequently.
   *
   * @returns An unsubscribe function to stop listening.
   */ subscribeToConnectionState(cb) {
        const id = this.nextConnectionStateSubscriberId++;
        this.connectionStateSubscribers.set(id, cb);
        return ()=>{
            this.connectionStateSubscribers.delete(id);
        };
    }
    /**
     * Execute a mutation function.
     *
     * @param name - The name of the mutation.
     * @param args - An arguments object for the mutation. If this is omitted,
     * the arguments will be `{}`.
     * @param options - A {@link MutationOptions} options object for this mutation.
  
     * @returns - A promise of the mutation's result.
     */ async mutation(name, args, options) {
        const result = await this.mutationInternal(name, args, options);
        if (!result.success) {
            if (result.errorData !== void 0) throw (0, _loggingJs.forwardData)(result, new (0, _errorsJs.ConvexError)((0, _loggingJs.createHybridErrorStacktrace)("mutation", name, result)));
            throw new Error((0, _loggingJs.createHybridErrorStacktrace)("mutation", name, result));
        }
        return result.value;
    }
    /**
   * @internal
   */ async mutationInternal(udfPath, args, options, componentPath) {
        const { mutationPromise } = this.enqueueMutation(udfPath, args, options, componentPath);
        return mutationPromise;
    }
    /**
   * @internal
   */ enqueueMutation(udfPath, args, options, componentPath) {
        const mutationArgs = (0, _indexJs2.parseArgs)(args);
        this.tryReportLongDisconnect();
        const requestId = this.nextRequestId;
        this._nextRequestId++;
        if (options !== void 0) {
            const optimisticUpdate = options.optimisticUpdate;
            if (optimisticUpdate !== void 0) {
                const wrappedUpdate = (localQueryStore)=>{
                    const result = optimisticUpdate(localQueryStore, mutationArgs);
                    if (result instanceof Promise) this.logger.warn("Optimistic update handler returned a Promise. Optimistic updates should be synchronous.");
                };
                const changedQueryTokens = this.optimisticQueryResults.applyOptimisticUpdate(wrappedUpdate, requestId);
                const changedQueries = changedQueryTokens.map((token)=>{
                    const localResult = this.localQueryResultByToken(token);
                    return {
                        token,
                        modification: {
                            kind: "Updated",
                            result: localResult === void 0 ? void 0 : {
                                success: true,
                                value: localResult,
                                logLines: []
                            }
                        }
                    };
                });
                this.handleTransition({
                    queries: changedQueries,
                    reflectedMutations: [],
                    timestamp: this.remoteQuerySet.timestamp()
                });
            }
        }
        const message = {
            type: "Mutation",
            requestId,
            udfPath,
            componentPath,
            args: [
                (0, _indexJs1.convexToJson)(mutationArgs)
            ]
        };
        const mightBeSent = this.webSocketManager.sendMessage(message);
        const mutationPromise = this.requestManager.request(message, mightBeSent);
        return {
            requestId,
            mutationPromise
        };
    }
    /**
   * Execute an action function.
   *
   * @param name - The name of the action.
   * @param args - An arguments object for the action. If this is omitted,
   * the arguments will be `{}`.
   * @returns A promise of the action's result.
   */ async action(name, args) {
        const result = await this.actionInternal(name, args);
        if (!result.success) {
            if (result.errorData !== void 0) throw (0, _loggingJs.forwardData)(result, new (0, _errorsJs.ConvexError)((0, _loggingJs.createHybridErrorStacktrace)("action", name, result)));
            throw new Error((0, _loggingJs.createHybridErrorStacktrace)("action", name, result));
        }
        return result.value;
    }
    /**
   * @internal
   */ async actionInternal(udfPath, args, componentPath) {
        const actionArgs = (0, _indexJs2.parseArgs)(args);
        const requestId = this.nextRequestId;
        this._nextRequestId++;
        this.tryReportLongDisconnect();
        const message = {
            type: "Action",
            requestId,
            udfPath,
            componentPath,
            args: [
                (0, _indexJs1.convexToJson)(actionArgs)
            ]
        };
        const mightBeSent = this.webSocketManager.sendMessage(message);
        return this.requestManager.request(message, mightBeSent);
    }
    /**
   * Close any network handles associated with this client and stop all subscriptions.
   *
   * Call this method when you're done with an {@link BaseConvexClient} to
   * dispose of its sockets and resources.
   *
   * @returns A `Promise` fulfilled when the connection has been completely closed.
   */ async close() {
        this.authenticationManager.stop();
        return this.webSocketManager.terminate();
    }
    /**
   * Return the address for this client, useful for creating a new client.
   *
   * Not guaranteed to match the address with which this client was constructed:
   * it may be canonicalized.
   */ get url() {
        return this.address;
    }
    /**
   * @internal
   */ get nextRequestId() {
        return this._nextRequestId;
    }
    /**
   * @internal
   */ get sessionId() {
        return this._sessionId;
    }
    /**
   * Reports performance marks to the server. This should only be called when
   * we have a functional websocket.
   */ reportMarks() {
        if (this.debug) {
            const report = (0, _metricsJs.getMarksReport)(this.sessionId);
            this.webSocketManager.sendMessage({
                type: "Event",
                eventType: "ClientConnect",
                event: report
            });
        }
    }
    tryReportLongDisconnect() {
        if (!this.debug) return;
        const timeOfOldestRequest = this.connectionState().timeOfOldestInflightRequest;
        if (timeOfOldestRequest === null || Date.now() - timeOfOldestRequest.getTime() <= 60000) return;
        const endpoint = `${this.address}/api/debug_event`;
        fetch(endpoint, {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Convex-Client": `npm-${(0, _indexJs.version)}`
            },
            body: JSON.stringify({
                event: "LongWebsocketDisconnect"
            })
        }).then((response)=>{
            if (!response.ok) this.logger.warn("Analytics request failed with response:", response.body);
        }).catch((error)=>{
            this.logger.warn("Analytics response failed with error:", error);
        });
    }
}

},{"../../index.js":"76BIQ","../../values/index.js":"atHbO","../logging.js":"7g7UR","./local_state.js":"7PqtT","./request_manager.js":"eGwJR","./optimistic_updates_impl.js":"cS9qU","./remote_query_set.js":"kauB4","./udf_path_utils.js":"fXv0g","./web_socket_manager.js":"5kaU3","./session.js":"9X9lR","./authentication_manager.js":"3mEc9","./metrics.js":"iv6lu","../../common/index.js":"jSbKo","../../values/errors.js":"8sUSC","../../vendor/jwt-decode/index.js":"22F8D","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"76BIQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
"use strict";
const version = "1.31.2";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"atHbO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "convexToJson", ()=>(0, _valueJs.convexToJson));
parcelHelpers.export(exports, "jsonToConvex", ()=>(0, _valueJs.jsonToConvex));
parcelHelpers.export(exports, "v", ()=>(0, _validatorJs.v));
parcelHelpers.export(exports, "asObjectValidator", ()=>(0, _validatorJs.asObjectValidator));
parcelHelpers.export(exports, "compareValues", ()=>(0, _compareJs.compareValues));
parcelHelpers.export(exports, "Base64", ()=>_base64Js);
var _valueJs = require("./value.js");
var _validatorJs = require("./validator.js");
var _base64Js = require("./base64.js");
var _errorsJs = require("./errors.js");
parcelHelpers.exportAll(_errorsJs, exports);
var _compareJs = require("./compare.js");
"use strict";

},{"./value.js":"3LQpF","./validator.js":"7gq7W","./base64.js":"lq3JD","./errors.js":"8sUSC","./compare.js":"dXnVy","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"3LQpF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "slowBigIntToBase64", ()=>slowBigIntToBase64);
parcelHelpers.export(exports, "slowBase64ToBigInt", ()=>slowBase64ToBigInt);
parcelHelpers.export(exports, "modernBigIntToBase64", ()=>modernBigIntToBase64);
parcelHelpers.export(exports, "modernBase64ToBigInt", ()=>modernBase64ToBigInt);
parcelHelpers.export(exports, "bigIntToBase64", ()=>bigIntToBase64);
parcelHelpers.export(exports, "base64ToBigInt", ()=>base64ToBigInt);
parcelHelpers.export(exports, "jsonToConvex", ()=>jsonToConvex);
parcelHelpers.export(exports, "stringifyValueForError", ()=>stringifyValueForError);
parcelHelpers.export(exports, "convexToJson", ()=>convexToJson);
parcelHelpers.export(exports, "convexOrUndefinedToJson", ()=>convexOrUndefinedToJson);
parcelHelpers.export(exports, "patchValueToJson", ()=>patchValueToJson);
var _base64Js = require("./base64.js");
var _indexJs = require("../common/index.js");
"use strict";
const LITTLE_ENDIAN = true;
const MIN_INT64 = BigInt("-9223372036854775808");
const MAX_INT64 = BigInt("9223372036854775807");
const ZERO = BigInt("0");
const EIGHT = BigInt("8");
const TWOFIFTYSIX = BigInt("256");
function isSpecial(n) {
    return Number.isNaN(n) || !Number.isFinite(n) || Object.is(n, -0);
}
function slowBigIntToBase64(value) {
    if (value < ZERO) value -= MIN_INT64 + MIN_INT64;
    let hex = value.toString(16);
    if (hex.length % 2 === 1) hex = "0" + hex;
    const bytes = new Uint8Array(new ArrayBuffer(8));
    let i = 0;
    for (const hexByte of hex.match(/.{2}/g).reverse()){
        bytes.set([
            parseInt(hexByte, 16)
        ], i++);
        value >>= EIGHT;
    }
    return _base64Js.fromByteArray(bytes);
}
function slowBase64ToBigInt(encoded) {
    const integerBytes = _base64Js.toByteArray(encoded);
    if (integerBytes.byteLength !== 8) throw new Error(`Received ${integerBytes.byteLength} bytes, expected 8 for $integer`);
    let value = ZERO;
    let power = ZERO;
    for (const byte of integerBytes){
        value += BigInt(byte) * TWOFIFTYSIX ** power;
        power++;
    }
    if (value > MAX_INT64) value += MIN_INT64 + MIN_INT64;
    return value;
}
function modernBigIntToBase64(value) {
    if (value < MIN_INT64 || MAX_INT64 < value) throw new Error(`BigInt ${value} does not fit into a 64-bit signed integer.`);
    const buffer = new ArrayBuffer(8);
    new DataView(buffer).setBigInt64(0, value, true);
    return _base64Js.fromByteArray(new Uint8Array(buffer));
}
function modernBase64ToBigInt(encoded) {
    const integerBytes = _base64Js.toByteArray(encoded);
    if (integerBytes.byteLength !== 8) throw new Error(`Received ${integerBytes.byteLength} bytes, expected 8 for $integer`);
    const intBytesView = new DataView(integerBytes.buffer);
    return intBytesView.getBigInt64(0, true);
}
const bigIntToBase64 = DataView.prototype.setBigInt64 ? modernBigIntToBase64 : slowBigIntToBase64;
const base64ToBigInt = DataView.prototype.getBigInt64 ? modernBase64ToBigInt : slowBase64ToBigInt;
const MAX_IDENTIFIER_LEN = 1024;
function validateObjectField(k) {
    if (k.length > MAX_IDENTIFIER_LEN) throw new Error(`Field name ${k} exceeds maximum field name length ${MAX_IDENTIFIER_LEN}.`);
    if (k.startsWith("$")) throw new Error(`Field name ${k} starts with a '$', which is reserved.`);
    for(let i = 0; i < k.length; i += 1){
        const charCode = k.charCodeAt(i);
        if (charCode < 32 || charCode >= 127) throw new Error(`Field name ${k} has invalid character '${k[i]}': Field names can only contain non-control ASCII characters`);
    }
}
function jsonToConvex(value) {
    if (value === null) return value;
    if (typeof value === "boolean") return value;
    if (typeof value === "number") return value;
    if (typeof value === "string") return value;
    if (Array.isArray(value)) return value.map((value2)=>jsonToConvex(value2));
    if (typeof value !== "object") throw new Error(`Unexpected type of ${value}`);
    const entries = Object.entries(value);
    if (entries.length === 1) {
        const key = entries[0][0];
        if (key === "$bytes") {
            if (typeof value.$bytes !== "string") throw new Error(`Malformed $bytes field on ${value}`);
            return _base64Js.toByteArray(value.$bytes).buffer;
        }
        if (key === "$integer") {
            if (typeof value.$integer !== "string") throw new Error(`Malformed $integer field on ${value}`);
            return base64ToBigInt(value.$integer);
        }
        if (key === "$float") {
            if (typeof value.$float !== "string") throw new Error(`Malformed $float field on ${value}`);
            const floatBytes = _base64Js.toByteArray(value.$float);
            if (floatBytes.byteLength !== 8) throw new Error(`Received ${floatBytes.byteLength} bytes, expected 8 for $float`);
            const floatBytesView = new DataView(floatBytes.buffer);
            const float = floatBytesView.getFloat64(0, LITTLE_ENDIAN);
            if (!isSpecial(float)) throw new Error(`Float ${float} should be encoded as a number`);
            return float;
        }
        if (key === "$set") throw new Error(`Received a Set which is no longer supported as a Convex type.`);
        if (key === "$map") throw new Error(`Received a Map which is no longer supported as a Convex type.`);
    }
    const out = {};
    for (const [k, v] of Object.entries(value)){
        validateObjectField(k);
        out[k] = jsonToConvex(v);
    }
    return out;
}
const MAX_VALUE_FOR_ERROR_LEN = 16384;
function stringifyValueForError(value) {
    const str = JSON.stringify(value, (_key, value2)=>{
        if (value2 === void 0) return "undefined";
        if (typeof value2 === "bigint") return `${value2.toString()}n`;
        return value2;
    });
    if (str.length > MAX_VALUE_FOR_ERROR_LEN) {
        const rest = "[...truncated]";
        let truncateAt = MAX_VALUE_FOR_ERROR_LEN - rest.length;
        const codePoint = str.codePointAt(truncateAt - 1);
        if (codePoint !== void 0 && codePoint > 65535) truncateAt -= 1;
        return str.substring(0, truncateAt) + rest;
    }
    return str;
}
function convexToJsonInternal(value, originalValue, context, includeTopLevelUndefined) {
    if (value === void 0) {
        const contextText = context && ` (present at path ${context} in original object ${stringifyValueForError(originalValue)})`;
        throw new Error(`undefined is not a valid Convex value${contextText}. To learn about Convex's supported types, see https://docs.convex.dev/using/types.`);
    }
    if (value === null) return value;
    if (typeof value === "bigint") {
        if (value < MIN_INT64 || MAX_INT64 < value) throw new Error(`BigInt ${value} does not fit into a 64-bit signed integer.`);
        return {
            $integer: bigIntToBase64(value)
        };
    }
    if (typeof value === "number") {
        if (isSpecial(value)) {
            const buffer = new ArrayBuffer(8);
            new DataView(buffer).setFloat64(0, value, LITTLE_ENDIAN);
            return {
                $float: _base64Js.fromByteArray(new Uint8Array(buffer))
            };
        } else return value;
    }
    if (typeof value === "boolean") return value;
    if (typeof value === "string") return value;
    if (value instanceof ArrayBuffer) return {
        $bytes: _base64Js.fromByteArray(new Uint8Array(value))
    };
    if (Array.isArray(value)) return value.map((value2, i)=>convexToJsonInternal(value2, originalValue, context + `[${i}]`, false));
    if (value instanceof Set) throw new Error(errorMessageForUnsupportedType(context, "Set", [
        ...value
    ], originalValue));
    if (value instanceof Map) throw new Error(errorMessageForUnsupportedType(context, "Map", [
        ...value
    ], originalValue));
    if (!(0, _indexJs.isSimpleObject)(value)) {
        const theType = value?.constructor?.name;
        const typeName = theType ? `${theType} ` : "";
        throw new Error(errorMessageForUnsupportedType(context, typeName, value, originalValue));
    }
    const out = {};
    const entries = Object.entries(value);
    entries.sort(([k1, _v1], [k2, _v2])=>k1 === k2 ? 0 : k1 < k2 ? -1 : 1);
    for (const [k, v] of entries){
        if (v !== void 0) {
            validateObjectField(k);
            out[k] = convexToJsonInternal(v, originalValue, context + `.${k}`, false);
        } else if (includeTopLevelUndefined) {
            validateObjectField(k);
            out[k] = convexOrUndefinedToJsonInternal(v, originalValue, context + `.${k}`);
        }
    }
    return out;
}
function errorMessageForUnsupportedType(context, typeName, value, originalValue) {
    if (context) return `${typeName}${stringifyValueForError(value)} is not a supported Convex type (present at path ${context} in original object ${stringifyValueForError(originalValue)}). To learn about Convex's supported types, see https://docs.convex.dev/using/types.`;
    else return `${typeName}${stringifyValueForError(value)} is not a supported Convex type.`;
}
function convexOrUndefinedToJsonInternal(value, originalValue, context) {
    if (value === void 0) return {
        $undefined: null
    };
    else {
        if (originalValue === void 0) throw new Error(`Programming error. Current value is ${stringifyValueForError(value)} but original value is undefined`);
        return convexToJsonInternal(value, originalValue, context, false);
    }
}
function convexToJson(value) {
    return convexToJsonInternal(value, value, "", false);
}
function convexOrUndefinedToJson(value) {
    return convexOrUndefinedToJsonInternal(value, value, "");
}
function patchValueToJson(value) {
    return convexToJsonInternal(value, value, "", true);
}

},{"./base64.js":"lq3JD","../common/index.js":"jSbKo","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"lq3JD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "byteLength", ()=>byteLength);
parcelHelpers.export(exports, "toByteArray", ()=>toByteArray);
parcelHelpers.export(exports, "fromByteArray", ()=>fromByteArray);
parcelHelpers.export(exports, "fromByteArrayUrlSafeNoPadding", ()=>fromByteArrayUrlSafeNoPadding);
"use strict";
var lookup = [];
var revLookup = [];
var Arr = Uint8Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for(var i = 0, len = code.length; i < len; ++i){
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(_b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for(i = 0; i < len; i += 4){
        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
    }
    return arr;
}
function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i = start; i < end; i += 3){
        tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
        output.push(tripletToBase64(tmp));
    }
    return output.join("");
}
function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength)parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
    } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
    }
    return parts.join("");
}
function fromByteArrayUrlSafeNoPadding(uint8) {
    return fromByteArray(uint8).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"jSbKo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "parseArgs", ()=>parseArgs);
parcelHelpers.export(exports, "validateDeploymentUrl", ()=>validateDeploymentUrl);
parcelHelpers.export(exports, "isSimpleObject", ()=>isSimpleObject);
"use strict";
function parseArgs(args) {
    if (args === void 0) return {};
    if (!isSimpleObject(args)) throw new Error(`The arguments to a Convex function must be an object. Received: ${args}`);
    return args;
}
function validateDeploymentUrl(deploymentUrl) {
    if (typeof deploymentUrl === "undefined") throw new Error(`Client created with undefined deployment address. If you used an environment variable, check that it's set.`);
    if (typeof deploymentUrl !== "string") throw new Error(`Invalid deployment address: found ${deploymentUrl}".`);
    if (!(deploymentUrl.startsWith("http:") || deploymentUrl.startsWith("https:"))) throw new Error(`Invalid deployment address: Must start with "https://" or "http://". Found "${deploymentUrl}".`);
    try {
        new URL(deploymentUrl);
    } catch  {
        throw new Error(`Invalid deployment address: "${deploymentUrl}" is not a valid URL. If you believe this URL is correct, use the \`skipConvexDeploymentUrlCheck\` option to bypass this.`);
    }
    if (deploymentUrl.endsWith(".convex.site")) throw new Error(`Invalid deployment address: "${deploymentUrl}" ends with .convex.site, which is used for HTTP Actions. Convex deployment URLs typically end with .convex.cloud? If you believe this URL is correct, use the \`skipConvexDeploymentUrlCheck\` option to bypass this.`);
}
function isSimpleObject(value) {
    const isObject = typeof value === "object";
    const prototype = Object.getPrototypeOf(value);
    const isSimple = prototype === null || prototype === Object.prototype || // Objects generated from other contexts (e.g. across Node.js `vm` modules) will not satisfy the previous
    // conditions but are still simple objects.
    prototype?.constructor?.name === "Object";
    return isObject && isSimple;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"7gq7W":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isValidator", ()=>isValidator);
parcelHelpers.export(exports, "asObjectValidator", ()=>asObjectValidator);
parcelHelpers.export(exports, "v", ()=>v);
var _validatorsJs = require("./validators.js");
"use strict";
function isValidator(v2) {
    return !!v2.isConvexValidator;
}
function asObjectValidator(obj) {
    if (isValidator(obj)) return obj;
    else return v.object(obj);
}
const v = {
    /**
   * Validates that the value corresponds to an ID of a document in given table.
   * @param tableName The name of the table.
   */ id: (tableName)=>{
        return new (0, _validatorsJs.VId)({
            isOptional: "required",
            tableName
        });
    },
    /**
   * Validates that the value is of type Null.
   */ null: ()=>{
        return new (0, _validatorsJs.VNull)({
            isOptional: "required"
        });
    },
    /**
   * Validates that the value is of Convex type Float64 (Number in JS).
   *
   * Alias for `v.float64()`
   */ number: ()=>{
        return new (0, _validatorsJs.VFloat64)({
            isOptional: "required"
        });
    },
    /**
   * Validates that the value is of Convex type Float64 (Number in JS).
   */ float64: ()=>{
        return new (0, _validatorsJs.VFloat64)({
            isOptional: "required"
        });
    },
    /**
   * @deprecated Use `v.int64()` instead
   */ bigint: ()=>{
        return new (0, _validatorsJs.VInt64)({
            isOptional: "required"
        });
    },
    /**
   * Validates that the value is of Convex type Int64 (BigInt in JS).
   */ int64: ()=>{
        return new (0, _validatorsJs.VInt64)({
            isOptional: "required"
        });
    },
    /**
   * Validates that the value is of type Boolean.
   */ boolean: ()=>{
        return new (0, _validatorsJs.VBoolean)({
            isOptional: "required"
        });
    },
    /**
   * Validates that the value is of type String.
   */ string: ()=>{
        return new (0, _validatorsJs.VString)({
            isOptional: "required"
        });
    },
    /**
   * Validates that the value is of Convex type Bytes (constructed in JS via `ArrayBuffer`).
   */ bytes: ()=>{
        return new (0, _validatorsJs.VBytes)({
            isOptional: "required"
        });
    },
    /**
   * Validates that the value is equal to the given literal value.
   * @param literal The literal value to compare against.
   */ literal: (literal)=>{
        return new (0, _validatorsJs.VLiteral)({
            isOptional: "required",
            value: literal
        });
    },
    /**
   * Validates that the value is an Array of the given element type.
   * @param element The validator for the elements of the array.
   */ array: (element)=>{
        return new (0, _validatorsJs.VArray)({
            isOptional: "required",
            element
        });
    },
    /**
   * Validates that the value is an Object with the given properties.
   * @param fields An object specifying the validator for each property.
   */ object: (fields)=>{
        return new (0, _validatorsJs.VObject)({
            isOptional: "required",
            fields
        });
    },
    /**
   * Validates that the value is a Record with keys and values that match the given types.
   * @param keys The validator for the keys of the record. This cannot contain string literals.
   * @param values The validator for the values of the record.
   */ record: (keys, values)=>{
        return new (0, _validatorsJs.VRecord)({
            isOptional: "required",
            key: keys,
            value: values
        });
    },
    /**
   * Validates that the value matches one of the given validators.
   * @param members The validators to match against.
   */ union: (...members)=>{
        return new (0, _validatorsJs.VUnion)({
            isOptional: "required",
            members
        });
    },
    /**
   * Does not validate the value.
   */ any: ()=>{
        return new (0, _validatorsJs.VAny)({
            isOptional: "required"
        });
    },
    /**
   * Allows not specifying a value for a property in an Object.
   * @param value The property value validator to make optional.
   *
   * ```typescript
   * const objectWithOptionalFields = v.object({
   *   requiredField: v.string(),
   *   optionalField: v.optional(v.string()),
   * });
   * ```
   */ optional: (value)=>{
        return value.asOptional();
    },
    /**
   * Allows specifying a value or null.
   */ nullable: (value)=>{
        return v.union(value, v.null());
    }
};

},{"./validators.js":"44f7d","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"44f7d":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VId", ()=>VId);
parcelHelpers.export(exports, "VFloat64", ()=>VFloat64);
parcelHelpers.export(exports, "VInt64", ()=>VInt64);
parcelHelpers.export(exports, "VBoolean", ()=>VBoolean);
parcelHelpers.export(exports, "VBytes", ()=>VBytes);
parcelHelpers.export(exports, "VString", ()=>VString);
parcelHelpers.export(exports, "VNull", ()=>VNull);
parcelHelpers.export(exports, "VAny", ()=>VAny);
parcelHelpers.export(exports, "VObject", ()=>VObject);
parcelHelpers.export(exports, "VLiteral", ()=>VLiteral);
parcelHelpers.export(exports, "VArray", ()=>VArray);
parcelHelpers.export(exports, "VRecord", ()=>VRecord);
parcelHelpers.export(exports, "VUnion", ()=>VUnion);
var _valueJs = require("./value.js");
"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
const UNDEFINED_VALIDATOR_ERROR_URL = "https://docs.convex.dev/error#undefined-validator";
function throwUndefinedValidatorError(context, fieldName) {
    const fieldInfo = fieldName !== void 0 ? ` for field "${fieldName}"` : "";
    throw new Error(`A validator is undefined${fieldInfo} in ${context}. This is often caused by circular imports. See ${UNDEFINED_VALIDATOR_ERROR_URL} for details.`);
}
class BaseValidator {
    constructor({ isOptional }){
        /**
     * Only for TypeScript, the TS type of the JS values validated
     * by this validator.
     */ __publicField(this, "type");
        /**
     * Only for TypeScript, if this an Object validator, then
     * this is the TS type of its property names.
     */ __publicField(this, "fieldPaths");
        /**
     * Whether this is an optional Object property value validator.
     */ __publicField(this, "isOptional");
        /**
     * Always `"true"`.
     */ __publicField(this, "isConvexValidator");
        this.isOptional = isOptional;
        this.isConvexValidator = true;
    }
}
class VId extends BaseValidator {
    /**
   * Usually you'd use `v.id(tableName)` instead.
   */ constructor({ isOptional, tableName }){
        super({
            isOptional
        });
        /**
     * The name of the table that the validated IDs must belong to.
     */ __publicField(this, "tableName");
        /**
     * The kind of validator, `"id"`.
     */ __publicField(this, "kind", "id");
        if (typeof tableName !== "string") throw new Error("v.id(tableName) requires a string");
        this.tableName = tableName;
    }
    /** @internal */ get json() {
        return {
            type: "id",
            tableName: this.tableName
        };
    }
    /** @internal */ asOptional() {
        return new VId({
            isOptional: "optional",
            tableName: this.tableName
        });
    }
}
class VFloat64 extends BaseValidator {
    constructor(){
        super(...arguments);
        /**
     * The kind of validator, `"float64"`.
     */ __publicField(this, "kind", "float64");
    }
    /** @internal */ get json() {
        return {
            type: "number"
        };
    }
    /** @internal */ asOptional() {
        return new VFloat64({
            isOptional: "optional"
        });
    }
}
class VInt64 extends BaseValidator {
    constructor(){
        super(...arguments);
        /**
     * The kind of validator, `"int64"`.
     */ __publicField(this, "kind", "int64");
    }
    /** @internal */ get json() {
        return {
            type: "bigint"
        };
    }
    /** @internal */ asOptional() {
        return new VInt64({
            isOptional: "optional"
        });
    }
}
class VBoolean extends BaseValidator {
    constructor(){
        super(...arguments);
        /**
     * The kind of validator, `"boolean"`.
     */ __publicField(this, "kind", "boolean");
    }
    /** @internal */ get json() {
        return {
            type: this.kind
        };
    }
    /** @internal */ asOptional() {
        return new VBoolean({
            isOptional: "optional"
        });
    }
}
class VBytes extends BaseValidator {
    constructor(){
        super(...arguments);
        /**
     * The kind of validator, `"bytes"`.
     */ __publicField(this, "kind", "bytes");
    }
    /** @internal */ get json() {
        return {
            type: this.kind
        };
    }
    /** @internal */ asOptional() {
        return new VBytes({
            isOptional: "optional"
        });
    }
}
class VString extends BaseValidator {
    constructor(){
        super(...arguments);
        /**
     * The kind of validator, `"string"`.
     */ __publicField(this, "kind", "string");
    }
    /** @internal */ get json() {
        return {
            type: this.kind
        };
    }
    /** @internal */ asOptional() {
        return new VString({
            isOptional: "optional"
        });
    }
}
class VNull extends BaseValidator {
    constructor(){
        super(...arguments);
        /**
     * The kind of validator, `"null"`.
     */ __publicField(this, "kind", "null");
    }
    /** @internal */ get json() {
        return {
            type: this.kind
        };
    }
    /** @internal */ asOptional() {
        return new VNull({
            isOptional: "optional"
        });
    }
}
class VAny extends BaseValidator {
    constructor(){
        super(...arguments);
        /**
     * The kind of validator, `"any"`.
     */ __publicField(this, "kind", "any");
    }
    /** @internal */ get json() {
        return {
            type: this.kind
        };
    }
    /** @internal */ asOptional() {
        return new VAny({
            isOptional: "optional"
        });
    }
}
class VObject extends BaseValidator {
    /**
   * Usually you'd use `v.object({ ... })` instead.
   */ constructor({ isOptional, fields }){
        super({
            isOptional
        });
        /**
     * An object with the validator for each property.
     */ __publicField(this, "fields");
        /**
     * The kind of validator, `"object"`.
     */ __publicField(this, "kind", "object");
        globalThis.Object.entries(fields).forEach(([fieldName, validator])=>{
            if (validator === void 0) throwUndefinedValidatorError("v.object()", fieldName);
            if (!validator.isConvexValidator) throw new Error("v.object() entries must be validators");
        });
        this.fields = fields;
    }
    /** @internal */ get json() {
        return {
            type: this.kind,
            value: globalThis.Object.fromEntries(globalThis.Object.entries(this.fields).map(([k, v])=>[
                    k,
                    {
                        fieldType: v.json,
                        optional: v.isOptional === "optional" ? true : false
                    }
                ]))
        };
    }
    /** @internal */ asOptional() {
        return new VObject({
            isOptional: "optional",
            fields: this.fields
        });
    }
    /**
   * Create a new VObject with the specified fields omitted.
   * @param fields The field names to omit from this VObject.
   */ omit(...fields) {
        const newFields = {
            ...this.fields
        };
        for (const field of fields)delete newFields[field];
        return new VObject({
            isOptional: this.isOptional,
            fields: newFields
        });
    }
    /**
   * Create a new VObject with only the specified fields.
   * @param fields The field names to pick from this VObject.
   */ pick(...fields) {
        const newFields = {};
        for (const field of fields)newFields[field] = this.fields[field];
        return new VObject({
            isOptional: this.isOptional,
            fields: newFields
        });
    }
    /**
   * Create a new VObject with all fields marked as optional.
   */ partial() {
        const newFields = {};
        for (const [key, validator] of globalThis.Object.entries(this.fields))newFields[key] = validator.asOptional();
        return new VObject({
            isOptional: this.isOptional,
            fields: newFields
        });
    }
    /**
   * Create a new VObject with additional fields merged in.
   * @param fields An object with additional validators to merge into this VObject.
   */ extend(fields) {
        return new VObject({
            isOptional: this.isOptional,
            fields: {
                ...this.fields,
                ...fields
            }
        });
    }
}
class VLiteral extends BaseValidator {
    /**
   * Usually you'd use `v.literal(value)` instead.
   */ constructor({ isOptional, value }){
        super({
            isOptional
        });
        /**
     * The value that the validated values must be equal to.
     */ __publicField(this, "value");
        /**
     * The kind of validator, `"literal"`.
     */ __publicField(this, "kind", "literal");
        if (typeof value !== "string" && typeof value !== "boolean" && typeof value !== "number" && typeof value !== "bigint") throw new Error("v.literal(value) must be a string, number, or boolean");
        this.value = value;
    }
    /** @internal */ get json() {
        return {
            type: this.kind,
            value: (0, _valueJs.convexToJson)(this.value)
        };
    }
    /** @internal */ asOptional() {
        return new VLiteral({
            isOptional: "optional",
            value: this.value
        });
    }
}
class VArray extends BaseValidator {
    /**
   * Usually you'd use `v.array(element)` instead.
   */ constructor({ isOptional, element }){
        super({
            isOptional
        });
        /**
     * The validator for the elements of the array.
     */ __publicField(this, "element");
        /**
     * The kind of validator, `"array"`.
     */ __publicField(this, "kind", "array");
        if (element === void 0) throwUndefinedValidatorError("v.array()");
        this.element = element;
    }
    /** @internal */ get json() {
        return {
            type: this.kind,
            value: this.element.json
        };
    }
    /** @internal */ asOptional() {
        return new VArray({
            isOptional: "optional",
            element: this.element
        });
    }
}
class VRecord extends BaseValidator {
    /**
   * Usually you'd use `v.record(key, value)` instead.
   */ constructor({ isOptional, key, value }){
        super({
            isOptional
        });
        /**
     * The validator for the keys of the record.
     */ __publicField(this, "key");
        /**
     * The validator for the values of the record.
     */ __publicField(this, "value");
        /**
     * The kind of validator, `"record"`.
     */ __publicField(this, "kind", "record");
        if (key === void 0) throwUndefinedValidatorError("v.record()", "key");
        if (value === void 0) throwUndefinedValidatorError("v.record()", "value");
        if (key.isOptional === "optional") throw new Error("Record validator cannot have optional keys");
        if (value.isOptional === "optional") throw new Error("Record validator cannot have optional values");
        if (!key.isConvexValidator || !value.isConvexValidator) throw new Error("Key and value of v.record() but be validators");
        this.key = key;
        this.value = value;
    }
    /** @internal */ get json() {
        return {
            type: this.kind,
            // This cast is needed because TypeScript thinks the key type is too wide
            keys: this.key.json,
            values: {
                fieldType: this.value.json,
                optional: false
            }
        };
    }
    /** @internal */ asOptional() {
        return new VRecord({
            isOptional: "optional",
            key: this.key,
            value: this.value
        });
    }
}
class VUnion extends BaseValidator {
    /**
   * Usually you'd use `v.union(...members)` instead.
   */ constructor({ isOptional, members }){
        super({
            isOptional
        });
        /**
     * The array of validators, one of which must match the value.
     */ __publicField(this, "members");
        /**
     * The kind of validator, `"union"`.
     */ __publicField(this, "kind", "union");
        members.forEach((member, index)=>{
            if (member === void 0) throwUndefinedValidatorError("v.union()", `member at index ${index}`);
            if (!member.isConvexValidator) throw new Error("All members of v.union() must be validators");
        });
        this.members = members;
    }
    /** @internal */ get json() {
        return {
            type: this.kind,
            value: this.members.map((v)=>v.json)
        };
    }
    /** @internal */ asOptional() {
        return new VUnion({
            isOptional: "optional",
            members: this.members
        });
    }
}

},{"./value.js":"3LQpF","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"8sUSC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ConvexError", ()=>ConvexError);
var _valueJs = require("./value.js");
"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var _a, _b;
const IDENTIFYING_FIELD = Symbol.for("ConvexError");
class ConvexError extends (_b = Error, _a = IDENTIFYING_FIELD, _b) {
    constructor(data){
        super(typeof data === "string" ? data : (0, _valueJs.stringifyValueForError)(data));
        __publicField(this, "name", "ConvexError");
        __publicField(this, "data");
        __publicField(this, _a, true);
        this.data = data;
    }
}

},{"./value.js":"3LQpF","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"dXnVy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "compareValues", ()=>compareValues);
var _compareUtf8Js = require("./compare_utf8.js");
"use strict";
function compareValues(k1, k2) {
    return compareAsTuples(makeComparable(k1), makeComparable(k2));
}
function compareAsTuples(a, b) {
    if (a[0] === b[0]) return compareSameTypeValues(a[1], b[1]);
    else if (a[0] < b[0]) return -1;
    return 1;
}
function compareSameTypeValues(v1, v2) {
    if (v1 === void 0 || v1 === null) return 0;
    if (typeof v1 === "number") {
        if (typeof v2 !== "number") throw new Error(`Unexpected type ${v2}`);
        return compareNumbers(v1, v2);
    }
    if (typeof v1 === "string") {
        if (typeof v2 !== "string") throw new Error(`Unexpected type ${v2}`);
        return (0, _compareUtf8Js.compareUTF8)(v1, v2);
    }
    if (typeof v1 === "bigint" || typeof v1 === "boolean" || typeof v1 === "string") return v1 < v2 ? -1 : v1 === v2 ? 0 : 1;
    if (!Array.isArray(v1) || !Array.isArray(v2)) throw new Error(`Unexpected type ${v1}`);
    for(let i = 0; i < v1.length && i < v2.length; i++){
        const cmp = compareAsTuples(v1[i], v2[i]);
        if (cmp !== 0) return cmp;
    }
    if (v1.length < v2.length) return -1;
    if (v1.length > v2.length) return 1;
    return 0;
}
function compareNumbers(v1, v2) {
    if (isNaN(v1) || isNaN(v2)) {
        const buffer1 = new ArrayBuffer(8);
        const buffer2 = new ArrayBuffer(8);
        new DataView(buffer1).setFloat64(0, v1, /* little-endian */ true);
        new DataView(buffer2).setFloat64(0, v2, /* little-endian */ true);
        const v1Bits = BigInt(new DataView(buffer1).getBigInt64(0, /* little-endian */ true));
        const v2Bits = BigInt(new DataView(buffer2).getBigInt64(0, /* little-endian */ true));
        const v1Sign = (v1Bits & 0x8000000000000000n) !== 0n;
        const v2Sign = (v2Bits & 0x8000000000000000n) !== 0n;
        if (isNaN(v1) !== isNaN(v2)) {
            if (isNaN(v1)) return v1Sign ? -1 : 1;
            return v2Sign ? 1 : -1;
        }
        if (v1Sign !== v2Sign) return v1Sign ? -1 : 1;
        return v1Bits < v2Bits ? -1 : v1Bits === v2Bits ? 0 : 1;
    }
    if (Object.is(v1, v2)) return 0;
    if (Object.is(v1, -0)) return Object.is(v2, 0) ? -1 : -Math.sign(v2);
    if (Object.is(v2, -0)) return Object.is(v1, 0) ? 1 : Math.sign(v1);
    return v1 < v2 ? -1 : 1;
}
function makeComparable(v) {
    if (v === void 0) return [
        0,
        void 0
    ];
    if (v === null) return [
        1,
        null
    ];
    if (typeof v === "bigint") return [
        2,
        v
    ];
    if (typeof v === "number") return [
        3,
        v
    ];
    if (typeof v === "boolean") return [
        4,
        v
    ];
    if (typeof v === "string") return [
        5,
        v
    ];
    if (v instanceof ArrayBuffer) return [
        6,
        Array.from(new Uint8Array(v)).map(makeComparable)
    ];
    if (Array.isArray(v)) return [
        7,
        v.map(makeComparable)
    ];
    const keys = Object.keys(v).sort();
    const pojo = keys.map((k)=>[
            k,
            v[k]
        ]);
    return [
        8,
        pojo.map(makeComparable)
    ];
}

},{"./compare_utf8.js":"liM7H","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"liM7H":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "compareUTF8", ()=>compareUTF8);
parcelHelpers.export(exports, "utf16LengthForCodePoint", ()=>utf16LengthForCodePoint);
parcelHelpers.export(exports, "greaterThan", ()=>greaterThan);
parcelHelpers.export(exports, "greaterThanEq", ()=>greaterThanEq);
parcelHelpers.export(exports, "lessThan", ()=>lessThan);
parcelHelpers.export(exports, "lessThanEq", ()=>lessThanEq);
"use strict";
function compareUTF8(a, b) {
    const aLength = a.length;
    const bLength = b.length;
    const length = Math.min(aLength, bLength);
    for(let i = 0; i < length;){
        const aCodePoint = a.codePointAt(i);
        const bCodePoint = b.codePointAt(i);
        if (aCodePoint !== bCodePoint) {
            if (aCodePoint < 128 && bCodePoint < 128) return aCodePoint - bCodePoint;
            const aLength2 = utf8Bytes(aCodePoint, aBytes);
            const bLength2 = utf8Bytes(bCodePoint, bBytes);
            return compareArrays(aBytes, aLength2, bBytes, bLength2);
        }
        i += utf16LengthForCodePoint(aCodePoint);
    }
    return aLength - bLength;
}
function compareArrays(a, aLength, b, bLength) {
    const length = Math.min(aLength, bLength);
    for(let i = 0; i < length; i++){
        const aValue = a[i];
        const bValue = b[i];
        if (aValue !== bValue) return aValue - bValue;
    }
    return aLength - bLength;
}
function utf16LengthForCodePoint(aCodePoint) {
    return aCodePoint > 65535 ? 2 : 1;
}
const arr = ()=>Array.from({
        length: 4
    }, ()=>0);
const aBytes = arr();
const bBytes = arr();
function utf8Bytes(codePoint, bytes) {
    if (codePoint < 128) {
        bytes[0] = codePoint;
        return 1;
    }
    let count;
    let offset;
    if (codePoint <= 2047) {
        count = 1;
        offset = 192;
    } else if (codePoint <= 65535) {
        count = 2;
        offset = 224;
    } else if (codePoint <= 1114111) {
        count = 3;
        offset = 240;
    } else throw new Error("Invalid code point");
    bytes[0] = (codePoint >> 6 * count) + offset;
    let i = 1;
    for(; count > 0; count--){
        const temp = codePoint >> 6 * (count - 1);
        bytes[i++] = 128 | temp & 63;
    }
    return i;
}
function greaterThan(a, b) {
    return compareUTF8(a, b) > 0;
}
function greaterThanEq(a, b) {
    return compareUTF8(a, b) >= 0;
}
function lessThan(a, b) {
    return compareUTF8(a, b) < 0;
}
function lessThanEq(a, b) {
    return compareUTF8(a, b) <= 0;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"7g7UR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DefaultLogger", ()=>DefaultLogger);
parcelHelpers.export(exports, "instantiateDefaultLogger", ()=>instantiateDefaultLogger);
parcelHelpers.export(exports, "instantiateNoopLogger", ()=>instantiateNoopLogger);
parcelHelpers.export(exports, "logForFunction", ()=>logForFunction);
parcelHelpers.export(exports, "logFatalError", ()=>logFatalError);
parcelHelpers.export(exports, "createHybridErrorStacktrace", ()=>createHybridErrorStacktrace);
parcelHelpers.export(exports, "forwardData", ()=>forwardData);
"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
const INFO_COLOR = "color:rgb(0, 145, 255)";
function prefix_for_source(source) {
    switch(source){
        case "query":
            return "Q";
        case "mutation":
            return "M";
        case "action":
            return "A";
        case "any":
            return "?";
    }
}
class DefaultLogger {
    constructor(options){
        __publicField(this, "_onLogLineFuncs");
        __publicField(this, "_verbose");
        this._onLogLineFuncs = {};
        this._verbose = options.verbose;
    }
    addLogLineListener(func) {
        let id = Math.random().toString(36).substring(2, 15);
        for(let i = 0; i < 10; i++){
            if (this._onLogLineFuncs[id] === void 0) break;
            id = Math.random().toString(36).substring(2, 15);
        }
        this._onLogLineFuncs[id] = func;
        return ()=>{
            delete this._onLogLineFuncs[id];
        };
    }
    logVerbose(...args) {
        if (this._verbose) for (const func of Object.values(this._onLogLineFuncs))func("debug", `${/* @__PURE__ */ new Date().toISOString()}`, ...args);
    }
    log(...args) {
        for (const func of Object.values(this._onLogLineFuncs))func("info", ...args);
    }
    warn(...args) {
        for (const func of Object.values(this._onLogLineFuncs))func("warn", ...args);
    }
    error(...args) {
        for (const func of Object.values(this._onLogLineFuncs))func("error", ...args);
    }
}
function instantiateDefaultLogger(options) {
    const logger = new DefaultLogger(options);
    logger.addLogLineListener((level, ...args)=>{
        switch(level){
            case "debug":
                console.debug(...args);
                break;
            case "info":
                console.log(...args);
                break;
            case "warn":
                console.warn(...args);
                break;
            case "error":
                console.error(...args);
                break;
            default:
                level;
                console.log(...args);
        }
    });
    return logger;
}
function instantiateNoopLogger(options) {
    return new DefaultLogger(options);
}
function logForFunction(logger, type, source, udfPath, message) {
    const prefix = prefix_for_source(source);
    if (typeof message === "object") message = `ConvexError ${JSON.stringify(message.errorData, null, 2)}`;
    if (type === "info") {
        const match = message.match(/^\[.*?\] /);
        if (match === null) {
            logger.error(`[CONVEX ${prefix}(${udfPath})] Could not parse console.log`);
            return;
        }
        const level = message.slice(1, match[0].length - 2);
        const args = message.slice(match[0].length);
        logger.log(`%c[CONVEX ${prefix}(${udfPath})] [${level}]`, INFO_COLOR, args);
    } else logger.error(`[CONVEX ${prefix}(${udfPath})] ${message}`);
}
function logFatalError(logger, message) {
    const errorMessage = `[CONVEX FATAL ERROR] ${message}`;
    logger.error(errorMessage);
    return new Error(errorMessage);
}
function createHybridErrorStacktrace(source, udfPath, result) {
    const prefix = prefix_for_source(source);
    return `[CONVEX ${prefix}(${udfPath})] ${result.errorMessage}
  Called by client`;
}
function forwardData(result, error) {
    error.data = result.errorData;
    return error;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"7PqtT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LocalSyncState", ()=>LocalSyncState);
var _indexJs = require("../../values/index.js");
var _udfPathUtilsJs = require("./udf_path_utils.js");
"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
class LocalSyncState {
    constructor(){
        __publicField(this, "nextQueryId");
        __publicField(this, "querySetVersion");
        __publicField(this, "querySet");
        __publicField(this, "queryIdToToken");
        __publicField(this, "identityVersion");
        __publicField(this, "auth");
        __publicField(this, "outstandingQueriesOlderThanRestart");
        __publicField(this, "outstandingAuthOlderThanRestart");
        __publicField(this, "paused");
        __publicField(this, "pendingQuerySetModifications");
        this.nextQueryId = 0;
        this.querySetVersion = 0;
        this.identityVersion = 0;
        this.querySet = /* @__PURE__ */ new Map();
        this.queryIdToToken = /* @__PURE__ */ new Map();
        this.outstandingQueriesOlderThanRestart = /* @__PURE__ */ new Set();
        this.outstandingAuthOlderThanRestart = false;
        this.paused = false;
        this.pendingQuerySetModifications = /* @__PURE__ */ new Map();
    }
    hasSyncedPastLastReconnect() {
        return this.outstandingQueriesOlderThanRestart.size === 0 && !this.outstandingAuthOlderThanRestart;
    }
    markAuthCompletion() {
        this.outstandingAuthOlderThanRestart = false;
    }
    subscribe(udfPath, args, journal, componentPath) {
        const canonicalizedUdfPath = (0, _udfPathUtilsJs.canonicalizeUdfPath)(udfPath);
        const queryToken = (0, _udfPathUtilsJs.serializePathAndArgs)(canonicalizedUdfPath, args);
        const existingEntry = this.querySet.get(queryToken);
        if (existingEntry !== void 0) {
            existingEntry.numSubscribers += 1;
            return {
                queryToken,
                modification: null,
                unsubscribe: ()=>this.removeSubscriber(queryToken)
            };
        } else {
            const queryId = this.nextQueryId++;
            const query = {
                id: queryId,
                canonicalizedUdfPath,
                args,
                numSubscribers: 1,
                journal,
                componentPath
            };
            this.querySet.set(queryToken, query);
            this.queryIdToToken.set(queryId, queryToken);
            const baseVersion = this.querySetVersion;
            const newVersion = this.querySetVersion + 1;
            const add = {
                type: "Add",
                queryId,
                udfPath: canonicalizedUdfPath,
                args: [
                    (0, _indexJs.convexToJson)(args)
                ],
                journal,
                componentPath
            };
            if (this.paused) this.pendingQuerySetModifications.set(queryId, add);
            else this.querySetVersion = newVersion;
            const modification = {
                type: "ModifyQuerySet",
                baseVersion,
                newVersion,
                modifications: [
                    add
                ]
            };
            return {
                queryToken,
                modification,
                unsubscribe: ()=>this.removeSubscriber(queryToken)
            };
        }
    }
    transition(transition) {
        for (const modification of transition.modifications)switch(modification.type){
            case "QueryUpdated":
            case "QueryFailed":
                {
                    this.outstandingQueriesOlderThanRestart.delete(modification.queryId);
                    const journal = modification.journal;
                    if (journal !== void 0) {
                        const queryToken = this.queryIdToToken.get(modification.queryId);
                        if (queryToken !== void 0) this.querySet.get(queryToken).journal = journal;
                    }
                    break;
                }
            case "QueryRemoved":
                this.outstandingQueriesOlderThanRestart.delete(modification.queryId);
                break;
            default:
                modification;
                throw new Error(`Invalid modification ${modification.type}`);
        }
    }
    queryId(udfPath, args) {
        const canonicalizedUdfPath = (0, _udfPathUtilsJs.canonicalizeUdfPath)(udfPath);
        const queryToken = (0, _udfPathUtilsJs.serializePathAndArgs)(canonicalizedUdfPath, args);
        const existingEntry = this.querySet.get(queryToken);
        if (existingEntry !== void 0) return existingEntry.id;
        return null;
    }
    isCurrentOrNewerAuthVersion(version) {
        return version >= this.identityVersion;
    }
    getAuth() {
        return this.auth;
    }
    setAuth(value) {
        this.auth = {
            tokenType: "User",
            value
        };
        const baseVersion = this.identityVersion;
        if (!this.paused) this.identityVersion = baseVersion + 1;
        return {
            type: "Authenticate",
            baseVersion,
            ...this.auth
        };
    }
    setAdminAuth(value, actingAs) {
        const auth = {
            tokenType: "Admin",
            value,
            impersonating: actingAs
        };
        this.auth = auth;
        const baseVersion = this.identityVersion;
        if (!this.paused) this.identityVersion = baseVersion + 1;
        return {
            type: "Authenticate",
            baseVersion,
            ...auth
        };
    }
    clearAuth() {
        this.auth = void 0;
        this.markAuthCompletion();
        const baseVersion = this.identityVersion;
        if (!this.paused) this.identityVersion = baseVersion + 1;
        return {
            type: "Authenticate",
            tokenType: "None",
            baseVersion
        };
    }
    hasAuth() {
        return !!this.auth;
    }
    isNewAuth(value) {
        return this.auth?.value !== value;
    }
    queryPath(queryId) {
        const pathAndArgs = this.queryIdToToken.get(queryId);
        if (pathAndArgs) return this.querySet.get(pathAndArgs).canonicalizedUdfPath;
        return null;
    }
    queryArgs(queryId) {
        const pathAndArgs = this.queryIdToToken.get(queryId);
        if (pathAndArgs) return this.querySet.get(pathAndArgs).args;
        return null;
    }
    queryToken(queryId) {
        return this.queryIdToToken.get(queryId) ?? null;
    }
    queryJournal(queryToken) {
        return this.querySet.get(queryToken)?.journal;
    }
    restart(oldRemoteQueryResults) {
        this.unpause();
        this.outstandingQueriesOlderThanRestart.clear();
        const modifications = [];
        for (const localQuery of this.querySet.values()){
            const add = {
                type: "Add",
                queryId: localQuery.id,
                udfPath: localQuery.canonicalizedUdfPath,
                args: [
                    (0, _indexJs.convexToJson)(localQuery.args)
                ],
                journal: localQuery.journal,
                componentPath: localQuery.componentPath
            };
            modifications.push(add);
            if (!oldRemoteQueryResults.has(localQuery.id)) this.outstandingQueriesOlderThanRestart.add(localQuery.id);
        }
        this.querySetVersion = 1;
        const querySet = {
            type: "ModifyQuerySet",
            baseVersion: 0,
            newVersion: 1,
            modifications
        };
        if (!this.auth) {
            this.identityVersion = 0;
            return [
                querySet,
                void 0
            ];
        }
        this.outstandingAuthOlderThanRestart = true;
        const authenticate = {
            type: "Authenticate",
            baseVersion: 0,
            ...this.auth
        };
        this.identityVersion = 1;
        return [
            querySet,
            authenticate
        ];
    }
    pause() {
        this.paused = true;
    }
    resume() {
        const querySet = this.pendingQuerySetModifications.size > 0 ? {
            type: "ModifyQuerySet",
            baseVersion: this.querySetVersion,
            newVersion: ++this.querySetVersion,
            modifications: Array.from(this.pendingQuerySetModifications.values())
        } : void 0;
        const authenticate = this.auth !== void 0 ? {
            type: "Authenticate",
            baseVersion: this.identityVersion++,
            ...this.auth
        } : void 0;
        this.unpause();
        return [
            querySet,
            authenticate
        ];
    }
    unpause() {
        this.paused = false;
        this.pendingQuerySetModifications.clear();
    }
    removeSubscriber(queryToken) {
        const localQuery = this.querySet.get(queryToken);
        if (localQuery.numSubscribers > 1) {
            localQuery.numSubscribers -= 1;
            return null;
        } else {
            this.querySet.delete(queryToken);
            this.queryIdToToken.delete(localQuery.id);
            this.outstandingQueriesOlderThanRestart.delete(localQuery.id);
            const baseVersion = this.querySetVersion;
            const newVersion = this.querySetVersion + 1;
            const remove = {
                type: "Remove",
                queryId: localQuery.id
            };
            if (this.paused) {
                if (this.pendingQuerySetModifications.has(localQuery.id)) this.pendingQuerySetModifications.delete(localQuery.id);
                else this.pendingQuerySetModifications.set(localQuery.id, remove);
            } else this.querySetVersion = newVersion;
            return {
                type: "ModifyQuerySet",
                baseVersion,
                newVersion,
                modifications: [
                    remove
                ]
            };
        }
    }
}

},{"../../values/index.js":"atHbO","./udf_path_utils.js":"fXv0g","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"fXv0g":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "canonicalizeUdfPath", ()=>canonicalizeUdfPath);
parcelHelpers.export(exports, "serializePathAndArgs", ()=>serializePathAndArgs);
parcelHelpers.export(exports, "serializePaginatedPathAndArgs", ()=>serializePaginatedPathAndArgs);
parcelHelpers.export(exports, "serializedQueryTokenIsPaginated", ()=>serializedQueryTokenIsPaginated);
var _indexJs = require("../../values/index.js");
"use strict";
function canonicalizeUdfPath(udfPath) {
    const pieces = udfPath.split(":");
    let moduleName;
    let functionName;
    if (pieces.length === 1) {
        moduleName = pieces[0];
        functionName = "default";
    } else {
        moduleName = pieces.slice(0, pieces.length - 1).join(":");
        functionName = pieces[pieces.length - 1];
    }
    if (moduleName.endsWith(".js")) moduleName = moduleName.slice(0, -3);
    return `${moduleName}:${functionName}`;
}
function serializePathAndArgs(udfPath, args) {
    return JSON.stringify({
        udfPath: canonicalizeUdfPath(udfPath),
        args: (0, _indexJs.convexToJson)(args)
    });
}
function serializePaginatedPathAndArgs(udfPath, args, options) {
    const { initialNumItems, id } = options;
    const result = JSON.stringify({
        type: "paginated",
        udfPath: canonicalizeUdfPath(udfPath),
        args: (0, _indexJs.convexToJson)(args),
        options: (0, _indexJs.convexToJson)({
            initialNumItems,
            id
        })
    });
    return result;
}
function serializedQueryTokenIsPaginated(token) {
    return JSON.parse(token).type === "paginated";
}

},{"../../values/index.js":"atHbO","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"eGwJR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RequestManager", ()=>RequestManager);
var _indexJs = require("../../values/index.js");
var _loggingJs = require("../logging.js");
"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
class RequestManager {
    constructor(logger, markConnectionStateDirty){
        this.logger = logger;
        this.markConnectionStateDirty = markConnectionStateDirty;
        __publicField(this, "inflightRequests");
        __publicField(this, "requestsOlderThanRestart");
        __publicField(this, "inflightMutationsCount", 0);
        __publicField(this, "inflightActionsCount", 0);
        this.inflightRequests = /* @__PURE__ */ new Map();
        this.requestsOlderThanRestart = /* @__PURE__ */ new Set();
    }
    request(message, sent) {
        const result = new Promise((resolve)=>{
            const status = sent ? "Requested" : "NotSent";
            this.inflightRequests.set(message.requestId, {
                message,
                status: {
                    status,
                    requestedAt: /* @__PURE__ */ new Date(),
                    onResult: resolve
                }
            });
            if (message.type === "Mutation") this.inflightMutationsCount++;
            else if (message.type === "Action") this.inflightActionsCount++;
        });
        this.markConnectionStateDirty();
        return result;
    }
    /**
   * Update the state after receiving a response.
   *
   * @returns A RequestId if the request is complete and its optimistic update
   * can be dropped, null otherwise.
   */ onResponse(response) {
        const requestInfo = this.inflightRequests.get(response.requestId);
        if (requestInfo === void 0) return null;
        if (requestInfo.status.status === "Completed") return null;
        const udfType = requestInfo.message.type === "Mutation" ? "mutation" : "action";
        const udfPath = requestInfo.message.udfPath;
        for (const line of response.logLines)(0, _loggingJs.logForFunction)(this.logger, "info", udfType, udfPath, line);
        const status = requestInfo.status;
        let result;
        let onResolve;
        if (response.success) {
            result = {
                success: true,
                logLines: response.logLines,
                value: (0, _indexJs.jsonToConvex)(response.result)
            };
            onResolve = ()=>status.onResult(result);
        } else {
            const errorMessage = response.result;
            const { errorData } = response;
            (0, _loggingJs.logForFunction)(this.logger, "error", udfType, udfPath, errorMessage);
            result = {
                success: false,
                errorMessage,
                errorData: errorData !== void 0 ? (0, _indexJs.jsonToConvex)(errorData) : void 0,
                logLines: response.logLines
            };
            onResolve = ()=>status.onResult(result);
        }
        if (response.type === "ActionResponse" || !response.success) {
            onResolve();
            this.inflightRequests.delete(response.requestId);
            this.requestsOlderThanRestart.delete(response.requestId);
            if (requestInfo.message.type === "Action") this.inflightActionsCount--;
            else if (requestInfo.message.type === "Mutation") this.inflightMutationsCount--;
            this.markConnectionStateDirty();
            return {
                requestId: response.requestId,
                result
            };
        }
        requestInfo.status = {
            status: "Completed",
            result,
            ts: response.ts,
            onResolve
        };
        return null;
    }
    // Remove and returns completed requests.
    removeCompleted(ts) {
        const completeRequests = /* @__PURE__ */ new Map();
        for (const [requestId, requestInfo] of this.inflightRequests.entries()){
            const status = requestInfo.status;
            if (status.status === "Completed" && status.ts.lessThanOrEqual(ts)) {
                status.onResolve();
                completeRequests.set(requestId, status.result);
                if (requestInfo.message.type === "Mutation") this.inflightMutationsCount--;
                else if (requestInfo.message.type === "Action") this.inflightActionsCount--;
                this.inflightRequests.delete(requestId);
                this.requestsOlderThanRestart.delete(requestId);
            }
        }
        if (completeRequests.size > 0) this.markConnectionStateDirty();
        return completeRequests;
    }
    restart() {
        this.requestsOlderThanRestart = new Set(this.inflightRequests.keys());
        const allMessages = [];
        for (const [requestId, value] of this.inflightRequests){
            if (value.status.status === "NotSent") {
                value.status.status = "Requested";
                allMessages.push(value.message);
                continue;
            }
            if (value.message.type === "Mutation") allMessages.push(value.message);
            else if (value.message.type === "Action") {
                this.inflightRequests.delete(requestId);
                this.requestsOlderThanRestart.delete(requestId);
                this.inflightActionsCount--;
                if (value.status.status === "Completed") throw new Error("Action should never be in 'Completed' state");
                value.status.onResult({
                    success: false,
                    errorMessage: "Connection lost while action was in flight",
                    logLines: []
                });
            }
        }
        this.markConnectionStateDirty();
        return allMessages;
    }
    resume() {
        const allMessages = [];
        for (const [, value] of this.inflightRequests)if (value.status.status === "NotSent") {
            value.status.status = "Requested";
            allMessages.push(value.message);
            continue;
        }
        return allMessages;
    }
    /**
   * @returns true if there are any requests that have been requested but have
   * not be completed yet.
   */ hasIncompleteRequests() {
        for (const requestInfo of this.inflightRequests.values()){
            if (requestInfo.status.status === "Requested") return true;
        }
        return false;
    }
    /**
   * @returns true if there are any inflight requests, including ones that have
   * completed on the server, but have not been applied.
   */ hasInflightRequests() {
        return this.inflightRequests.size > 0;
    }
    /**
   * @returns true if there are any inflight requests, that have been hanging around
   * since prior to the most recent restart.
   */ hasSyncedPastLastReconnect() {
        return this.requestsOlderThanRestart.size === 0;
    }
    timeOfOldestInflightRequest() {
        if (this.inflightRequests.size === 0) return null;
        let oldestInflightRequest = Date.now();
        for (const request of this.inflightRequests.values()){
            if (request.status.status !== "Completed") {
                if (request.status.requestedAt.getTime() < oldestInflightRequest) oldestInflightRequest = request.status.requestedAt.getTime();
            }
        }
        return new Date(oldestInflightRequest);
    }
    /**
   * @returns The number of mutations currently in flight.
   */ inflightMutations() {
        return this.inflightMutationsCount;
    }
    /**
   * @returns The number of actions currently in flight.
   */ inflightActions() {
        return this.inflightActionsCount;
    }
}

},{"../../values/index.js":"atHbO","../logging.js":"7g7UR","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"cS9qU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "OptimisticQueryResults", ()=>OptimisticQueryResults);
var _apiJs = require("../../server/api.js");
var _indexJs = require("../../common/index.js");
var _loggingJs = require("../logging.js");
var _udfPathUtilsJs = require("./udf_path_utils.js");
var _errorsJs = require("../../values/errors.js");
"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
class OptimisticLocalStoreImpl {
    constructor(queryResults){
        // A references of the query results in OptimisticQueryResults
        __publicField(this, "queryResults");
        // All of the queries modified by this class
        __publicField(this, "modifiedQueries");
        this.queryResults = queryResults;
        this.modifiedQueries = [];
    }
    getQuery(query, ...args) {
        const queryArgs = (0, _indexJs.parseArgs)(args[0]);
        const name = (0, _apiJs.getFunctionName)(query);
        const queryResult = this.queryResults.get((0, _udfPathUtilsJs.serializePathAndArgs)(name, queryArgs));
        if (queryResult === void 0) return void 0;
        return OptimisticLocalStoreImpl.queryValue(queryResult.result);
    }
    getAllQueries(query) {
        const queriesWithName = [];
        const name = (0, _apiJs.getFunctionName)(query);
        for (const queryResult of this.queryResults.values())if (queryResult.udfPath === (0, _udfPathUtilsJs.canonicalizeUdfPath)(name)) queriesWithName.push({
            args: queryResult.args,
            value: OptimisticLocalStoreImpl.queryValue(queryResult.result)
        });
        return queriesWithName;
    }
    setQuery(queryReference, args, value) {
        const queryArgs = (0, _indexJs.parseArgs)(args);
        const name = (0, _apiJs.getFunctionName)(queryReference);
        const queryToken = (0, _udfPathUtilsJs.serializePathAndArgs)(name, queryArgs);
        let result;
        if (value === void 0) result = void 0;
        else result = {
            success: true,
            value,
            // It's an optimistic update, so there are no function logs to show.
            logLines: []
        };
        const query = {
            udfPath: name,
            args: queryArgs,
            result
        };
        this.queryResults.set(queryToken, query);
        this.modifiedQueries.push(queryToken);
    }
    static queryValue(result) {
        if (result === void 0) return void 0;
        else if (result.success) return result.value;
        else return void 0;
    }
}
class OptimisticQueryResults {
    constructor(){
        __publicField(this, "queryResults");
        __publicField(this, "optimisticUpdates");
        this.queryResults = /* @__PURE__ */ new Map();
        this.optimisticUpdates = [];
    }
    /**
   * Apply all optimistic updates on top of server query results
   */ ingestQueryResultsFromServer(serverQueryResults, optimisticUpdatesToDrop) {
        this.optimisticUpdates = this.optimisticUpdates.filter((updateAndId)=>{
            return !optimisticUpdatesToDrop.has(updateAndId.mutationId);
        });
        const oldQueryResults = this.queryResults;
        this.queryResults = new Map(serverQueryResults);
        const localStore = new OptimisticLocalStoreImpl(this.queryResults);
        for (const updateAndId of this.optimisticUpdates)updateAndId.update(localStore);
        const changedQueries = [];
        for (const [queryToken, query] of this.queryResults){
            const oldQuery = oldQueryResults.get(queryToken);
            if (oldQuery === void 0 || oldQuery.result !== query.result) changedQueries.push(queryToken);
        }
        return changedQueries;
    }
    applyOptimisticUpdate(update, mutationId) {
        this.optimisticUpdates.push({
            update,
            mutationId
        });
        const localStore = new OptimisticLocalStoreImpl(this.queryResults);
        update(localStore);
        return localStore.modifiedQueries;
    }
    /**
   * "Raw" with respect to errors vs values, but query results still have
   * optimistic updates applied.
   *
   * @internal
   */ rawQueryResult(queryToken) {
        const query = this.queryResults.get(queryToken);
        if (query === void 0) return void 0;
        return query.result;
    }
    queryResult(queryToken) {
        const query = this.queryResults.get(queryToken);
        if (query === void 0) return void 0;
        const result = query.result;
        if (result === void 0) return void 0;
        else if (result.success) return result.value;
        else {
            if (result.errorData !== void 0) throw (0, _loggingJs.forwardData)(result, new (0, _errorsJs.ConvexError)((0, _loggingJs.createHybridErrorStacktrace)("query", query.udfPath, result)));
            throw new Error((0, _loggingJs.createHybridErrorStacktrace)("query", query.udfPath, result));
        }
    }
    hasQueryResult(queryToken) {
        return this.queryResults.get(queryToken) !== void 0;
    }
    /**
   * @internal
   */ queryLogs(queryToken) {
        const query = this.queryResults.get(queryToken);
        return query?.result?.logLines;
    }
}

},{"../../server/api.js":"9nMwO","../../common/index.js":"jSbKo","../logging.js":"7g7UR","./udf_path_utils.js":"fXv0g","../../values/errors.js":"8sUSC","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"9nMwO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getFunctionName", ()=>getFunctionName);
parcelHelpers.export(exports, "makeFunctionReference", ()=>makeFunctionReference);
parcelHelpers.export(exports, "filterApi", ()=>filterApi);
parcelHelpers.export(exports, "justInternal", ()=>justInternal);
parcelHelpers.export(exports, "justPublic", ()=>justPublic);
parcelHelpers.export(exports, "justQueries", ()=>justQueries);
parcelHelpers.export(exports, "justMutations", ()=>justMutations);
parcelHelpers.export(exports, "justActions", ()=>justActions);
parcelHelpers.export(exports, "justPaginatedQueries", ()=>justPaginatedQueries);
parcelHelpers.export(exports, "justSchedulable", ()=>justSchedulable);
parcelHelpers.export(exports, "anyApi", ()=>anyApi);
var _functionNameJs = require("./functionName.js");
var _pathsJs = require("./components/paths.js");
"use strict";
function getFunctionName(functionReference) {
    const address = (0, _pathsJs.getFunctionAddress)(functionReference);
    if (address.name === void 0) {
        if (address.functionHandle !== void 0) throw new Error(`Expected function reference like "api.file.func" or "internal.file.func", but received function handle ${address.functionHandle}`);
        else if (address.reference !== void 0) throw new Error(`Expected function reference in the current component like "api.file.func" or "internal.file.func", but received reference ${address.reference}`);
        throw new Error(`Expected function reference like "api.file.func" or "internal.file.func", but received ${JSON.stringify(address)}`);
    }
    if (typeof functionReference === "string") return functionReference;
    const name = functionReference[0, _functionNameJs.functionName];
    if (!name) throw new Error(`${functionReference} is not a functionReference`);
    return name;
}
function makeFunctionReference(name) {
    return {
        [(0, _functionNameJs.functionName)]: name
    };
}
function createApi(pathParts = []) {
    const handler = {
        get (_, prop) {
            if (typeof prop === "string") {
                const newParts = [
                    ...pathParts,
                    prop
                ];
                return createApi(newParts);
            } else if (prop === (0, _functionNameJs.functionName)) {
                if (pathParts.length < 2) {
                    const found = [
                        "api",
                        ...pathParts
                    ].join(".");
                    throw new Error(`API path is expected to be of the form \`api.moduleName.functionName\`. Found: \`${found}\``);
                }
                const path = pathParts.slice(0, -1).join("/");
                const exportName = pathParts[pathParts.length - 1];
                if (exportName === "default") return path;
                else return path + ":" + exportName;
            } else if (prop === Symbol.toStringTag) return "FunctionReference";
            else return void 0;
        }
    };
    return new Proxy({}, handler);
}
function filterApi(api) {
    return api;
}
function justInternal(api) {
    return api;
}
function justPublic(api) {
    return api;
}
function justQueries(api) {
    return api;
}
function justMutations(api) {
    return api;
}
function justActions(api) {
    return api;
}
function justPaginatedQueries(api) {
    return api;
}
function justSchedulable(api) {
    return api;
}
const anyApi = createApi();

},{"./functionName.js":"ifh4x","./components/paths.js":"alov9","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"ifh4x":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "functionName", ()=>functionName);
"use strict";
const functionName = Symbol.for("functionName");

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"alov9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "toReferencePath", ()=>toReferencePath);
parcelHelpers.export(exports, "setReferencePath", ()=>setReferencePath);
parcelHelpers.export(exports, "extractReferencePath", ()=>extractReferencePath);
parcelHelpers.export(exports, "isFunctionHandle", ()=>isFunctionHandle);
parcelHelpers.export(exports, "getFunctionAddress", ()=>getFunctionAddress);
var _functionNameJs = require("../functionName.js");
"use strict";
const toReferencePath = Symbol.for("toReferencePath");
function setReferencePath(obj, value) {
    obj[toReferencePath] = value;
}
function extractReferencePath(reference) {
    return reference[toReferencePath] ?? null;
}
function isFunctionHandle(s) {
    return s.startsWith("function://");
}
function getFunctionAddress(functionReference) {
    let functionAddress;
    if (typeof functionReference === "string") {
        if (isFunctionHandle(functionReference)) functionAddress = {
            functionHandle: functionReference
        };
        else functionAddress = {
            name: functionReference
        };
    } else if (functionReference[0, _functionNameJs.functionName]) functionAddress = {
        name: functionReference[0, _functionNameJs.functionName]
    };
    else {
        const referencePath = extractReferencePath(functionReference);
        if (!referencePath) throw new Error(`${functionReference} is not a functionReference`);
        functionAddress = {
            reference: referencePath
        };
    }
    return functionAddress;
}

},{"../functionName.js":"ifh4x","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"kauB4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RemoteQuerySet", ()=>RemoteQuerySet);
var _indexJs = require("../../values/index.js");
var _longJs = require("../../vendor/long.js");
var _loggingJs = require("../logging.js");
"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
class RemoteQuerySet {
    constructor(queryPath, logger){
        __publicField(this, "version");
        __publicField(this, "remoteQuerySet");
        __publicField(this, "queryPath");
        __publicField(this, "logger");
        this.version = {
            querySet: 0,
            ts: (0, _longJs.Long).fromNumber(0),
            identity: 0
        };
        this.remoteQuerySet = /* @__PURE__ */ new Map();
        this.queryPath = queryPath;
        this.logger = logger;
    }
    transition(transition) {
        const start = transition.startVersion;
        if (this.version.querySet !== start.querySet || this.version.ts.notEquals(start.ts) || this.version.identity !== start.identity) throw new Error(`Invalid start version: ${start.ts.toString()}:${start.querySet}:${start.identity}, transitioning from ${this.version.ts.toString()}:${this.version.querySet}:${this.version.identity}`);
        for (const modification of transition.modifications)switch(modification.type){
            case "QueryUpdated":
                {
                    const queryPath = this.queryPath(modification.queryId);
                    if (queryPath) for (const line of modification.logLines)(0, _loggingJs.logForFunction)(this.logger, "info", "query", queryPath, line);
                    const value = (0, _indexJs.jsonToConvex)(modification.value ?? null);
                    this.remoteQuerySet.set(modification.queryId, {
                        success: true,
                        value,
                        logLines: modification.logLines
                    });
                    break;
                }
            case "QueryFailed":
                {
                    const queryPath = this.queryPath(modification.queryId);
                    if (queryPath) for (const line of modification.logLines)(0, _loggingJs.logForFunction)(this.logger, "info", "query", queryPath, line);
                    const { errorData } = modification;
                    this.remoteQuerySet.set(modification.queryId, {
                        success: false,
                        errorMessage: modification.errorMessage,
                        errorData: errorData !== void 0 ? (0, _indexJs.jsonToConvex)(errorData) : void 0,
                        logLines: modification.logLines
                    });
                    break;
                }
            case "QueryRemoved":
                this.remoteQuerySet.delete(modification.queryId);
                break;
            default:
                modification;
                throw new Error(`Invalid modification ${modification.type}`);
        }
        this.version = transition.endVersion;
    }
    remoteQueryResults() {
        return this.remoteQuerySet;
    }
    timestamp() {
        return this.version.ts;
    }
}

},{"../../values/index.js":"atHbO","../../vendor/long.js":"dnRaE","../logging.js":"7g7UR","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"dnRaE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Long", ()=>Long);
"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
class Long {
    constructor(low, high){
        __publicField(this, "low");
        __publicField(this, "high");
        __publicField(this, "__isUnsignedLong__");
        this.low = low | 0;
        this.high = high | 0;
        this.__isUnsignedLong__ = true;
    }
    static isLong(obj) {
        return (obj && obj.__isUnsignedLong__) === true;
    }
    // prettier-ignore
    static fromBytesLE(bytes) {
        return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24);
    }
    // prettier-ignore
    toBytesLE() {
        const hi = this.high;
        const lo = this.low;
        return [
            lo & 255,
            lo >>> 8 & 255,
            lo >>> 16 & 255,
            lo >>> 24,
            hi & 255,
            hi >>> 8 & 255,
            hi >>> 16 & 255,
            hi >>> 24
        ];
    }
    static fromNumber(value) {
        if (isNaN(value)) return UZERO;
        if (value < 0) return UZERO;
        if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;
        return new Long(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0);
    }
    toString() {
        return (BigInt(this.high) * BigInt(TWO_PWR_32_DBL) + BigInt(this.low)).toString();
    }
    equals(other) {
        if (!Long.isLong(other)) other = Long.fromValue(other);
        if (this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;
        return this.high === other.high && this.low === other.low;
    }
    notEquals(other) {
        return !this.equals(other);
    }
    comp(other) {
        if (!Long.isLong(other)) other = Long.fromValue(other);
        if (this.equals(other)) return 0;
        return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
    }
    lessThanOrEqual(other) {
        return this.comp(/* validates */ other) <= 0;
    }
    static fromValue(val) {
        if (typeof val === "number") return Long.fromNumber(val);
        return new Long(val.low, val.high);
    }
}
const UZERO = new Long(0, 0);
const TWO_PWR_16_DBL = 65536;
const TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
const TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
const MAX_UNSIGNED_VALUE = new Long(-1, -1);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"5kaU3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "WebSocketManager", ()=>WebSocketManager);
var _protocolJs = require("./protocol.js");
"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
const CLOSE_NORMAL = 1e3;
const CLOSE_GOING_AWAY = 1001;
const CLOSE_NO_STATUS = 1005;
const CLOSE_NOT_FOUND = 4040;
let firstTime;
function monotonicMillis() {
    if (firstTime === void 0) firstTime = Date.now();
    if (typeof performance === "undefined" || !performance.now) return Date.now();
    return Math.round(firstTime + performance.now());
}
function prettyNow() {
    return `t=${Math.round((monotonicMillis() - firstTime) / 100) / 10}s`;
}
const serverDisconnectErrors = {
    // A known error, e.g. during a restart or push
    InternalServerError: {
        timeout: 1e3
    },
    // ErrorMetadata::overloaded() messages that we realy should back off
    SubscriptionsWorkerFullError: {
        timeout: 3e3
    },
    TooManyConcurrentRequests: {
        timeout: 3e3
    },
    CommitterFullError: {
        timeout: 3e3
    },
    AwsTooManyRequestsException: {
        timeout: 3e3
    },
    ExecuteFullError: {
        timeout: 3e3
    },
    SystemTimeoutError: {
        timeout: 3e3
    },
    ExpiredInQueue: {
        timeout: 3e3
    },
    // ErrorMetadata::feature_temporarily_unavailable() that typically indicate a deploy just happened
    VectorIndexesUnavailable: {
        timeout: 1e3
    },
    SearchIndexesUnavailable: {
        timeout: 1e3
    },
    TableSummariesUnavailable: {
        timeout: 1e3
    },
    // More ErrorMetadata::overloaded()
    VectorIndexTooLarge: {
        timeout: 3e3
    },
    SearchIndexTooLarge: {
        timeout: 3e3
    },
    TooManyWritesInTimePeriod: {
        timeout: 3e3
    }
};
function classifyDisconnectError(s) {
    if (s === void 0) return "Unknown";
    for (const prefix of Object.keys(serverDisconnectErrors)){
        if (s.startsWith(prefix)) return prefix;
    }
    return "Unknown";
}
class WebSocketManager {
    constructor(uri, callbacks, webSocketConstructor, logger, markConnectionStateDirty, debug){
        this.markConnectionStateDirty = markConnectionStateDirty;
        this.debug = debug;
        __publicField(this, "socket");
        __publicField(this, "connectionCount");
        __publicField(this, "_hasEverConnected", false);
        __publicField(this, "lastCloseReason");
        // State for assembling the split-up Transition currently being received.
        __publicField(this, "transitionChunkBuffer", null);
        /** Upon HTTPS/WSS failure, the first jittered backoff duration, in ms. */ __publicField(this, "defaultInitialBackoff");
        /** We backoff exponentially, but we need to cap that--this is the jittered max. */ __publicField(this, "maxBackoff");
        /** How many times have we failed consecutively? */ __publicField(this, "retries");
        /** How long before lack of server response causes us to initiate a reconnect,
     * in ms */ __publicField(this, "serverInactivityThreshold");
        __publicField(this, "reconnectDueToServerInactivityTimeout");
        __publicField(this, "uri");
        __publicField(this, "onOpen");
        __publicField(this, "onResume");
        __publicField(this, "onMessage");
        __publicField(this, "webSocketConstructor");
        __publicField(this, "logger");
        __publicField(this, "onServerDisconnectError");
        this.webSocketConstructor = webSocketConstructor;
        this.socket = {
            state: "disconnected"
        };
        this.connectionCount = 0;
        this.lastCloseReason = "InitialConnect";
        this.defaultInitialBackoff = 1e3;
        this.maxBackoff = 16e3;
        this.retries = 0;
        this.serverInactivityThreshold = 6e4;
        this.reconnectDueToServerInactivityTimeout = null;
        this.uri = uri;
        this.onOpen = callbacks.onOpen;
        this.onResume = callbacks.onResume;
        this.onMessage = callbacks.onMessage;
        this.onServerDisconnectError = callbacks.onServerDisconnectError;
        this.logger = logger;
        this.connect();
    }
    setSocketState(state) {
        this.socket = state;
        this._logVerbose(`socket state changed: ${this.socket.state}, paused: ${"paused" in this.socket ? this.socket.paused : void 0}`);
        this.markConnectionStateDirty();
    }
    assembleTransition(chunk) {
        if (chunk.partNumber < 0 || chunk.partNumber >= chunk.totalParts || chunk.totalParts === 0 || this.transitionChunkBuffer && (this.transitionChunkBuffer.totalParts !== chunk.totalParts || this.transitionChunkBuffer.transitionId !== chunk.transitionId)) {
            this.transitionChunkBuffer = null;
            throw new Error("Invalid TransitionChunk");
        }
        if (this.transitionChunkBuffer === null) this.transitionChunkBuffer = {
            chunks: [],
            totalParts: chunk.totalParts,
            transitionId: chunk.transitionId
        };
        if (chunk.partNumber !== this.transitionChunkBuffer.chunks.length) {
            const expectedLength = this.transitionChunkBuffer.chunks.length;
            this.transitionChunkBuffer = null;
            throw new Error(`TransitionChunk received out of order: expected part ${expectedLength}, got ${chunk.partNumber}`);
        }
        this.transitionChunkBuffer.chunks.push(chunk.chunk);
        if (this.transitionChunkBuffer.chunks.length === chunk.totalParts) {
            const fullJson = this.transitionChunkBuffer.chunks.join("");
            this.transitionChunkBuffer = null;
            const transition = (0, _protocolJs.parseServerMessage)(JSON.parse(fullJson));
            if (transition.type !== "Transition") throw new Error(`Expected Transition, got ${transition.type} after assembling chunks`);
            return transition;
        }
        return null;
    }
    connect() {
        if (this.socket.state === "terminated") return;
        if (this.socket.state !== "disconnected" && this.socket.state !== "stopped") throw new Error("Didn't start connection from disconnected state: " + this.socket.state);
        const ws = new this.webSocketConstructor(this.uri);
        this._logVerbose("constructed WebSocket");
        this.setSocketState({
            state: "connecting",
            ws,
            paused: "no"
        });
        this.resetServerInactivityTimeout();
        ws.onopen = ()=>{
            this.logger.logVerbose("begin ws.onopen");
            if (this.socket.state !== "connecting") throw new Error("onopen called with socket not in connecting state");
            this.setSocketState({
                state: "ready",
                ws,
                paused: this.socket.paused === "yes" ? "uninitialized" : "no"
            });
            this.resetServerInactivityTimeout();
            if (this.socket.paused === "no") {
                this._hasEverConnected = true;
                this.onOpen({
                    connectionCount: this.connectionCount,
                    lastCloseReason: this.lastCloseReason,
                    clientTs: monotonicMillis()
                });
            }
            if (this.lastCloseReason !== "InitialConnect") {
                if (this.lastCloseReason) this.logger.log("WebSocket reconnected at", prettyNow(), "after disconnect due to", this.lastCloseReason);
                else this.logger.log("WebSocket reconnected at", prettyNow());
            }
            this.connectionCount += 1;
            this.lastCloseReason = null;
        };
        ws.onerror = (error)=>{
            this.transitionChunkBuffer = null;
            const message = error.message;
            if (message) this.logger.log(`WebSocket error message: ${message}`);
        };
        ws.onmessage = (message)=>{
            this.resetServerInactivityTimeout();
            const messageLength = message.data.length;
            let serverMessage = (0, _protocolJs.parseServerMessage)(JSON.parse(message.data));
            this._logVerbose(`received ws message with type ${serverMessage.type}`);
            if (serverMessage.type === "Ping") return;
            if (serverMessage.type === "TransitionChunk") {
                const transition = this.assembleTransition(serverMessage);
                if (!transition) return;
                serverMessage = transition;
                this._logVerbose(`assembled full ws message of type ${serverMessage.type}`);
            }
            if (this.transitionChunkBuffer !== null) {
                this.transitionChunkBuffer = null;
                this.logger.log(`Received unexpected ${serverMessage.type} while buffering TransitionChunks`);
            }
            if (serverMessage.type === "Transition") this.reportLargeTransition({
                messageLength,
                transition: serverMessage
            });
            const response = this.onMessage(serverMessage);
            if (response.hasSyncedPastLastReconnect) {
                this.retries = 0;
                this.markConnectionStateDirty();
            }
        };
        ws.onclose = (event)=>{
            this._logVerbose("begin ws.onclose");
            this.transitionChunkBuffer = null;
            if (this.lastCloseReason === null) this.lastCloseReason = event.reason || `closed with code ${event.code}`;
            if (event.code !== CLOSE_NORMAL && event.code !== CLOSE_GOING_AWAY && // This commonly gets fired on mobile apps when the app is backgrounded
            event.code !== CLOSE_NO_STATUS && event.code !== CLOSE_NOT_FOUND) {
                let msg = `WebSocket closed with code ${event.code}`;
                if (event.reason) msg += `: ${event.reason}`;
                this.logger.log(msg);
                if (this.onServerDisconnectError && event.reason) this.onServerDisconnectError(msg);
            }
            const reason = classifyDisconnectError(event.reason);
            this.scheduleReconnect(reason);
            return;
        };
    }
    /**
   * @returns The state of the {@link Socket}.
   */ socketState() {
        return this.socket.state;
    }
    /**
   * @param message - A ClientMessage to send.
   * @returns Whether the message (might have been) sent.
   */ sendMessage(message) {
        const messageForLog = {
            type: message.type,
            ...message.type === "Authenticate" && message.tokenType === "User" ? {
                value: `...${message.value.slice(-7)}`
            } : {}
        };
        if (this.socket.state === "ready" && this.socket.paused === "no") {
            const encodedMessage = (0, _protocolJs.encodeClientMessage)(message);
            const request = JSON.stringify(encodedMessage);
            let sent = false;
            try {
                this.socket.ws.send(request);
                sent = true;
            } catch (error) {
                this.logger.log(`Failed to send message on WebSocket, reconnecting: ${error}`);
                this.closeAndReconnect("FailedToSendMessage");
            }
            this._logVerbose(`${sent ? "sent" : "failed to send"} message with type ${message.type}: ${JSON.stringify(messageForLog)}`);
            return true;
        }
        this._logVerbose(`message not sent (socket state: ${this.socket.state}, paused: ${"paused" in this.socket ? this.socket.paused : void 0}): ${JSON.stringify(messageForLog)}`);
        return false;
    }
    resetServerInactivityTimeout() {
        if (this.socket.state === "terminated") return;
        if (this.reconnectDueToServerInactivityTimeout !== null) {
            clearTimeout(this.reconnectDueToServerInactivityTimeout);
            this.reconnectDueToServerInactivityTimeout = null;
        }
        this.reconnectDueToServerInactivityTimeout = setTimeout(()=>{
            this.closeAndReconnect("InactiveServer");
        }, this.serverInactivityThreshold);
    }
    scheduleReconnect(reason) {
        this.socket = {
            state: "disconnected"
        };
        const backoff = this.nextBackoff(reason);
        this.markConnectionStateDirty();
        this.logger.log(`Attempting reconnect in ${Math.round(backoff)}ms`);
        setTimeout(()=>this.connect(), backoff);
    }
    /**
   * Close the WebSocket and schedule a reconnect.
   *
   * This should be used when we hit an error and would like to restart the session.
   */ closeAndReconnect(closeReason) {
        this._logVerbose(`begin closeAndReconnect with reason ${closeReason}`);
        switch(this.socket.state){
            case "disconnected":
            case "terminated":
            case "stopped":
                return;
            case "connecting":
            case "ready":
                this.lastCloseReason = closeReason;
                this.close();
                this.scheduleReconnect("client");
                return;
            default:
                this.socket;
        }
    }
    /**
   * Close the WebSocket, being careful to clear the onclose handler to avoid re-entrant
   * calls. Use this instead of directly calling `ws.close()`
   *
   * It is the callers responsibility to update the state after this method is called so that the
   * closed socket is not accessible or used again after this method is called
   */ close() {
        this.transitionChunkBuffer = null;
        switch(this.socket.state){
            case "disconnected":
            case "terminated":
            case "stopped":
                return Promise.resolve();
            case "connecting":
                {
                    const ws = this.socket.ws;
                    ws.onmessage = (_message)=>{
                        this._logVerbose("Ignoring message received after close");
                    };
                    return new Promise((r)=>{
                        ws.onclose = ()=>{
                            this._logVerbose("Closed after connecting");
                            r();
                        };
                        ws.onopen = ()=>{
                            this._logVerbose("Opened after connecting");
                            ws.close();
                        };
                    });
                }
            case "ready":
                {
                    this._logVerbose("ws.close called");
                    const ws = this.socket.ws;
                    ws.onmessage = (_message)=>{
                        this._logVerbose("Ignoring message received after close");
                    };
                    const result = new Promise((r)=>{
                        ws.onclose = ()=>{
                            r();
                        };
                    });
                    ws.close();
                    return result;
                }
            default:
                this.socket;
                return Promise.resolve();
        }
    }
    /**
   * Close the WebSocket and do not reconnect.
   * @returns A Promise that resolves when the WebSocket `onClose` callback is called.
   */ terminate() {
        if (this.reconnectDueToServerInactivityTimeout) clearTimeout(this.reconnectDueToServerInactivityTimeout);
        switch(this.socket.state){
            case "terminated":
            case "stopped":
            case "disconnected":
            case "connecting":
            case "ready":
                {
                    const result = this.close();
                    this.setSocketState({
                        state: "terminated"
                    });
                    return result;
                }
            default:
                this.socket;
                throw new Error(`Invalid websocket state: ${this.socket.state}`);
        }
    }
    stop() {
        switch(this.socket.state){
            case "terminated":
                return Promise.resolve();
            case "connecting":
            case "stopped":
            case "disconnected":
            case "ready":
                {
                    const result = this.close();
                    this.socket = {
                        state: "stopped"
                    };
                    return result;
                }
            default:
                this.socket;
                return Promise.resolve();
        }
    }
    /**
   * Create a new WebSocket after a previous `stop()`, unless `terminate()` was
   * called before.
   */ tryRestart() {
        switch(this.socket.state){
            case "stopped":
                break;
            case "terminated":
            case "connecting":
            case "ready":
            case "disconnected":
                this.logger.logVerbose("Restart called without stopping first");
                return;
            default:
                this.socket;
        }
        this.connect();
    }
    pause() {
        switch(this.socket.state){
            case "disconnected":
            case "stopped":
            case "terminated":
                return;
            case "connecting":
            case "ready":
                this.socket = {
                    ...this.socket,
                    paused: "yes"
                };
                return;
            default:
                this.socket;
                return;
        }
    }
    /**
   * Resume the state machine if previously paused.
   */ resume() {
        switch(this.socket.state){
            case "connecting":
                this.socket = {
                    ...this.socket,
                    paused: "no"
                };
                return;
            case "ready":
                if (this.socket.paused === "uninitialized") {
                    this.socket = {
                        ...this.socket,
                        paused: "no"
                    };
                    this.onOpen({
                        connectionCount: this.connectionCount,
                        lastCloseReason: this.lastCloseReason,
                        clientTs: monotonicMillis()
                    });
                } else if (this.socket.paused === "yes") {
                    this.socket = {
                        ...this.socket,
                        paused: "no"
                    };
                    this.onResume();
                }
                return;
            case "terminated":
            case "stopped":
            case "disconnected":
                return;
            default:
                this.socket;
        }
        this.connect();
    }
    connectionState() {
        return {
            isConnected: this.socket.state === "ready",
            hasEverConnected: this._hasEverConnected,
            connectionCount: this.connectionCount,
            connectionRetries: this.retries
        };
    }
    _logVerbose(message) {
        this.logger.logVerbose(message);
    }
    nextBackoff(reason) {
        const initialBackoff = reason === "client" ? 100 : reason === "Unknown" ? this.defaultInitialBackoff : serverDisconnectErrors[reason].timeout;
        const baseBackoff = initialBackoff * Math.pow(2, this.retries);
        this.retries += 1;
        const actualBackoff = Math.min(baseBackoff, this.maxBackoff);
        const jitter = actualBackoff * (Math.random() - 0.5);
        return actualBackoff + jitter;
    }
    reportLargeTransition({ transition, messageLength }) {
        if (transition.clientClockSkew === void 0 || transition.serverTs === void 0) return;
        const transitionTransitTime = monotonicMillis() - // client time now
        // clientClockSkew = (server time + upstream latency) - client time
        // clientClockSkew is "how many milliseconds behind (slow) is the client clock"
        // but the latency of the Connect message inflates this, making it appear further behind
        transition.clientClockSkew - transition.serverTs / 1e6;
        const prettyTransitionTime = `${Math.round(transitionTransitTime)}ms`;
        const prettyMessageMB = `${Math.round(messageLength / 1e4) / 100}MB`;
        const bytesPerSecond = messageLength / (transitionTransitTime / 1e3);
        const prettyBytesPerSecond = `${Math.round(bytesPerSecond / 1e4) / 100}MB per second`;
        this._logVerbose(`received ${prettyMessageMB} transition in ${prettyTransitionTime} at ${prettyBytesPerSecond}`);
        if (messageLength > 2e7) this.logger.log(`received query results totaling more that 20MB (${prettyMessageMB}) which will take a long time to download on slower connections`);
        else if (transitionTransitTime > 2e4) this.logger.log(`received query results totaling ${prettyMessageMB} which took more than 20s to arrive (${prettyTransitionTime})`);
        if (this.debug) this.sendMessage({
            type: "Event",
            eventType: "ClientReceivedTransition",
            event: {
                transitionTransitTime,
                messageLength
            }
        });
    }
}

},{"./protocol.js":"2RMAW","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"2RMAW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u64ToLong", ()=>u64ToLong);
parcelHelpers.export(exports, "longToU64", ()=>longToU64);
parcelHelpers.export(exports, "parseServerMessage", ()=>parseServerMessage);
parcelHelpers.export(exports, "encodeClientMessage", ()=>encodeClientMessage);
var _indexJs = require("../../values/index.js");
var _longJs = require("../../vendor/long.js");
"use strict";
function u64ToLong(encoded) {
    const integerBytes = (0, _indexJs.Base64).toByteArray(encoded);
    return (0, _longJs.Long).fromBytesLE(Array.from(integerBytes));
}
function longToU64(raw) {
    const integerBytes = new Uint8Array(raw.toBytesLE());
    return (0, _indexJs.Base64).fromByteArray(integerBytes);
}
function parseServerMessage(encoded) {
    switch(encoded.type){
        case "FatalError":
        case "AuthError":
        case "ActionResponse":
        case "TransitionChunk":
        case "Ping":
            return {
                ...encoded
            };
        case "MutationResponse":
            if (encoded.success) return {
                ...encoded,
                ts: u64ToLong(encoded.ts)
            };
            else return {
                ...encoded
            };
        case "Transition":
            return {
                ...encoded,
                startVersion: {
                    ...encoded.startVersion,
                    ts: u64ToLong(encoded.startVersion.ts)
                },
                endVersion: {
                    ...encoded.endVersion,
                    ts: u64ToLong(encoded.endVersion.ts)
                }
            };
        default:
            encoded;
    }
    return void 0;
}
function encodeClientMessage(message) {
    switch(message.type){
        case "Authenticate":
        case "ModifyQuerySet":
        case "Mutation":
        case "Action":
        case "Event":
            return {
                ...message
            };
        case "Connect":
            if (message.maxObservedTimestamp !== void 0) return {
                ...message,
                maxObservedTimestamp: longToU64(message.maxObservedTimestamp)
            };
            else return {
                ...message,
                maxObservedTimestamp: void 0
            };
        default:
            message;
    }
    return void 0;
}

},{"../../values/index.js":"atHbO","../../vendor/long.js":"dnRaE","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"9X9lR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "newSessionId", ()=>newSessionId);
"use strict";
function newSessionId() {
    return uuidv4();
}
function uuidv4() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c)=>{
        const r = Math.random() * 16 | 0, v = c === "x" ? r : r & 3 | 8;
        return v.toString(16);
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"3mEc9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AuthenticationManager", ()=>AuthenticationManager);
var _indexJs = require("../../vendor/jwt-decode/index.js");
"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
const MAXIMUM_REFRESH_DELAY = 1728000000;
const MAX_TOKEN_CONFIRMATION_ATTEMPTS = 2;
class AuthenticationManager {
    constructor(syncState, callbacks, config){
        __publicField(this, "authState", {
            state: "noAuth"
        });
        // Used to detect races involving `setConfig` calls
        // while a token is being fetched.
        __publicField(this, "configVersion", 0);
        // Shared by the BaseClient so that the auth manager can easily inspect it
        __publicField(this, "syncState");
        // Passed down by BaseClient, sends a message to the server
        __publicField(this, "authenticate");
        __publicField(this, "stopSocket");
        __publicField(this, "tryRestartSocket");
        __publicField(this, "pauseSocket");
        __publicField(this, "resumeSocket");
        // Passed down by BaseClient, sends a message to the server
        __publicField(this, "clearAuth");
        __publicField(this, "logger");
        __publicField(this, "refreshTokenLeewaySeconds");
        // Number of times we have attempted to confirm the latest token. We retry up
        // to `MAX_TOKEN_CONFIRMATION_ATTEMPTS` times.
        __publicField(this, "tokenConfirmationAttempts", 0);
        this.syncState = syncState;
        this.authenticate = callbacks.authenticate;
        this.stopSocket = callbacks.stopSocket;
        this.tryRestartSocket = callbacks.tryRestartSocket;
        this.pauseSocket = callbacks.pauseSocket;
        this.resumeSocket = callbacks.resumeSocket;
        this.clearAuth = callbacks.clearAuth;
        this.logger = config.logger;
        this.refreshTokenLeewaySeconds = config.refreshTokenLeewaySeconds;
    }
    async setConfig(fetchToken, onChange) {
        this.resetAuthState();
        this._logVerbose("pausing WS for auth token fetch");
        this.pauseSocket();
        const token = await this.fetchTokenAndGuardAgainstRace(fetchToken, {
            forceRefreshToken: false
        });
        if (token.isFromOutdatedConfig) return;
        if (token.value) {
            this.setAuthState({
                state: "waitingForServerConfirmationOfCachedToken",
                config: {
                    fetchToken,
                    onAuthChange: onChange
                },
                hasRetried: false
            });
            this.authenticate(token.value);
        } else {
            this.setAuthState({
                state: "initialRefetch",
                config: {
                    fetchToken,
                    onAuthChange: onChange
                }
            });
            await this.refetchToken();
        }
        this._logVerbose("resuming WS after auth token fetch");
        this.resumeSocket();
    }
    onTransition(serverMessage) {
        if (!this.syncState.isCurrentOrNewerAuthVersion(serverMessage.endVersion.identity)) return;
        if (serverMessage.endVersion.identity <= serverMessage.startVersion.identity) return;
        if (this.authState.state === "waitingForServerConfirmationOfCachedToken") {
            this._logVerbose("server confirmed auth token is valid");
            this.refetchToken();
            this.authState.config.onAuthChange(true);
            return;
        }
        if (this.authState.state === "waitingForServerConfirmationOfFreshToken") {
            this._logVerbose("server confirmed new auth token is valid");
            this.scheduleTokenRefetch(this.authState.token);
            this.tokenConfirmationAttempts = 0;
            if (!this.authState.hadAuth) this.authState.config.onAuthChange(true);
        }
    }
    onAuthError(serverMessage) {
        if (serverMessage.authUpdateAttempted === false && (this.authState.state === "waitingForServerConfirmationOfFreshToken" || this.authState.state === "waitingForServerConfirmationOfCachedToken")) {
            this._logVerbose("ignoring non-auth token expired error");
            return;
        }
        const { baseVersion } = serverMessage;
        if (!this.syncState.isCurrentOrNewerAuthVersion(baseVersion + 1)) {
            this._logVerbose("ignoring auth error for previous auth attempt");
            return;
        }
        this.tryToReauthenticate(serverMessage);
        return;
    }
    // This is similar to `refetchToken` defined below, in fact we
    // don't represent them as different states, but it is different
    // in that we pause the WebSocket so that mutations
    // don't retry with bad auth.
    async tryToReauthenticate(serverMessage) {
        this._logVerbose(`attempting to reauthenticate: ${serverMessage.error}`);
        if (// No way to fetch another token, kaboom
        this.authState.state === "noAuth" || // We failed on a fresh token. After a small number of retries, we give up
        // and clear the auth state to avoid infinite retries.
        this.authState.state === "waitingForServerConfirmationOfFreshToken" && this.tokenConfirmationAttempts >= MAX_TOKEN_CONFIRMATION_ATTEMPTS) {
            this.logger.error(`Failed to authenticate: "${serverMessage.error}", check your server auth config`);
            if (this.syncState.hasAuth()) this.syncState.clearAuth();
            if (this.authState.state !== "noAuth") this.setAndReportAuthFailed(this.authState.config.onAuthChange);
            return;
        }
        if (this.authState.state === "waitingForServerConfirmationOfFreshToken") {
            this.tokenConfirmationAttempts++;
            this._logVerbose(`retrying reauthentication, ${MAX_TOKEN_CONFIRMATION_ATTEMPTS - this.tokenConfirmationAttempts} attempts remaining`);
        }
        await this.stopSocket();
        const token = await this.fetchTokenAndGuardAgainstRace(this.authState.config.fetchToken, {
            forceRefreshToken: true
        });
        if (token.isFromOutdatedConfig) return;
        if (token.value && this.syncState.isNewAuth(token.value)) {
            this.authenticate(token.value);
            this.setAuthState({
                state: "waitingForServerConfirmationOfFreshToken",
                config: this.authState.config,
                token: token.value,
                hadAuth: this.authState.state === "notRefetching" || this.authState.state === "waitingForScheduledRefetch"
            });
        } else {
            this._logVerbose("reauthentication failed, could not fetch a new token");
            if (this.syncState.hasAuth()) this.syncState.clearAuth();
            this.setAndReportAuthFailed(this.authState.config.onAuthChange);
        }
        this.tryRestartSocket();
    }
    // Force refetch the token and schedule another refetch
    // before the token expires - an active client should never
    // need to reauthenticate.
    async refetchToken() {
        if (this.authState.state === "noAuth") return;
        this._logVerbose("refetching auth token");
        const token = await this.fetchTokenAndGuardAgainstRace(this.authState.config.fetchToken, {
            forceRefreshToken: true
        });
        if (token.isFromOutdatedConfig) return;
        if (token.value) {
            if (this.syncState.isNewAuth(token.value)) {
                this.setAuthState({
                    state: "waitingForServerConfirmationOfFreshToken",
                    hadAuth: this.syncState.hasAuth(),
                    token: token.value,
                    config: this.authState.config
                });
                this.authenticate(token.value);
            } else this.setAuthState({
                state: "notRefetching",
                config: this.authState.config
            });
        } else {
            this._logVerbose("refetching token failed");
            if (this.syncState.hasAuth()) this.clearAuth();
            this.setAndReportAuthFailed(this.authState.config.onAuthChange);
        }
        this._logVerbose("restarting WS after auth token fetch (if currently stopped)");
        this.tryRestartSocket();
    }
    scheduleTokenRefetch(token) {
        if (this.authState.state === "noAuth") return;
        const decodedToken = this.decodeToken(token);
        if (!decodedToken) {
            this.logger.error("Auth token is not a valid JWT, cannot refetch the token");
            return;
        }
        const { iat, exp } = decodedToken;
        if (!iat || !exp) {
            this.logger.error("Auth token does not have required fields, cannot refetch the token");
            return;
        }
        const tokenValiditySeconds = exp - iat;
        if (tokenValiditySeconds <= 2) {
            this.logger.error("Auth token does not live long enough, cannot refetch the token");
            return;
        }
        let delay = Math.min(MAXIMUM_REFRESH_DELAY, (tokenValiditySeconds - this.refreshTokenLeewaySeconds) * 1e3);
        if (delay <= 0) {
            this.logger.warn(`Refetching auth token immediately, configured leeway ${this.refreshTokenLeewaySeconds}s is larger than the token's lifetime ${tokenValiditySeconds}s`);
            delay = 0;
        }
        const refetchTokenTimeoutId = setTimeout(()=>{
            this._logVerbose("running scheduled token refetch");
            this.refetchToken();
        }, delay);
        this.setAuthState({
            state: "waitingForScheduledRefetch",
            refetchTokenTimeoutId,
            config: this.authState.config
        });
        this._logVerbose(`scheduled preemptive auth token refetching in ${delay}ms`);
    }
    // Protects against simultaneous calls to `setConfig`
    // while we're fetching a token
    async fetchTokenAndGuardAgainstRace(fetchToken, fetchArgs) {
        const originalConfigVersion = ++this.configVersion;
        this._logVerbose(`fetching token with config version ${originalConfigVersion}`);
        const token = await fetchToken(fetchArgs);
        if (this.configVersion !== originalConfigVersion) {
            this._logVerbose(`stale config version, expected ${originalConfigVersion}, got ${this.configVersion}`);
            return {
                isFromOutdatedConfig: true
            };
        }
        return {
            isFromOutdatedConfig: false,
            value: token
        };
    }
    stop() {
        this.resetAuthState();
        this.configVersion++;
        this._logVerbose(`config version bumped to ${this.configVersion}`);
    }
    setAndReportAuthFailed(onAuthChange) {
        onAuthChange(false);
        this.resetAuthState();
    }
    resetAuthState() {
        this.setAuthState({
            state: "noAuth"
        });
    }
    setAuthState(newAuth) {
        const authStateForLog = newAuth.state === "waitingForServerConfirmationOfFreshToken" ? {
            hadAuth: newAuth.hadAuth,
            state: newAuth.state,
            token: `...${newAuth.token.slice(-7)}`
        } : {
            state: newAuth.state
        };
        this._logVerbose(`setting auth state to ${JSON.stringify(authStateForLog)}`);
        switch(newAuth.state){
            case "waitingForScheduledRefetch":
            case "notRefetching":
            case "noAuth":
                this.tokenConfirmationAttempts = 0;
                break;
            case "waitingForServerConfirmationOfFreshToken":
            case "waitingForServerConfirmationOfCachedToken":
            case "initialRefetch":
                break;
            default:
                newAuth;
        }
        if (this.authState.state === "waitingForScheduledRefetch") {
            clearTimeout(this.authState.refetchTokenTimeoutId);
            this.syncState.markAuthCompletion();
        }
        this.authState = newAuth;
    }
    decodeToken(token) {
        try {
            return (0, _indexJs.jwtDecode)(token);
        } catch (e) {
            this._logVerbose(`Error decoding token: ${e instanceof Error ? e.message : "Unknown error"}`);
            return null;
        }
    }
    _logVerbose(message) {
        this.logger.logVerbose(`${message} [v${this.configVersion}]`);
    }
}

},{"../../vendor/jwt-decode/index.js":"22F8D","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"22F8D":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "InvalidTokenError", ()=>InvalidTokenError);
parcelHelpers.export(exports, "jwtDecode", ()=>jwtDecode);
"use strict";
class InvalidTokenError extends Error {
}
InvalidTokenError.prototype.name = "InvalidTokenError";
function b64DecodeUnicode(str) {
    return decodeURIComponent(atob(str).replace(/(.)/g, (_m, p)=>{
        let code = p.charCodeAt(0).toString(16).toUpperCase();
        if (code.length < 2) code = "0" + code;
        return "%" + code;
    }));
}
function base64UrlDecode(str) {
    let output = str.replace(/-/g, "+").replace(/_/g, "/");
    switch(output.length % 4){
        case 0:
            break;
        case 2:
            output += "==";
            break;
        case 3:
            output += "=";
            break;
        default:
            throw new Error("base64 string is not of the correct length");
    }
    try {
        return b64DecodeUnicode(output);
    } catch  {
        return atob(output);
    }
}
function jwtDecode(token, options) {
    if (typeof token !== "string") throw new InvalidTokenError("Invalid token specified: must be a string");
    options || (options = {});
    const pos = options.header === true ? 0 : 1;
    const part = token.split(".")[pos];
    if (typeof part !== "string") throw new InvalidTokenError(`Invalid token specified: missing part #${pos + 1}`);
    let decoded;
    try {
        decoded = base64UrlDecode(part);
    } catch (e) {
        throw new InvalidTokenError(`Invalid token specified: invalid base64 for part #${pos + 1} (${e.message})`);
    }
    try {
        return JSON.parse(decoded);
    } catch (e) {
        throw new InvalidTokenError(`Invalid token specified: invalid json for part #${pos + 1} (${e.message})`);
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"iv6lu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mark", ()=>mark);
parcelHelpers.export(exports, "getMarksReport", ()=>getMarksReport);
"use strict";
const markNames = [
    "convexClientConstructed",
    "convexWebSocketOpen",
    "convexFirstMessageReceived"
];
function mark(name, sessionId) {
    const detail = {
        sessionId
    };
    if (typeof performance === "undefined" || !performance.mark) return;
    performance.mark(name, {
        detail
    });
}
function performanceMarkToJson(mark2) {
    let name = mark2.name.slice(6);
    name = name.charAt(0).toLowerCase() + name.slice(1);
    return {
        name,
        startTime: mark2.startTime
    };
}
function getMarksReport(sessionId) {
    if (typeof performance === "undefined" || !performance.getEntriesByName) return [];
    const allMarks = [];
    for (const name of markNames){
        const marks = performance.getEntriesByName(name).filter((entry)=>entry.entryType === "mark").filter((mark2)=>mark2.detail.sessionId === sessionId);
        allMarks.push(...marks);
    }
    return allMarks.map(performanceMarkToJson);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"cnboC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setDefaultWebSocketConstructor", ()=>setDefaultWebSocketConstructor);
parcelHelpers.export(exports, "ConvexClient", ()=>ConvexClient);
var _indexJs = require("../common/index.js");
var _indexJs1 = require("./index.js");
var _apiJs = require("../server/api.js");
var _paginatedQueryClientJs = require("./sync/paginated_query_client.js");
var _udfPathUtilsJs = require("./sync/udf_path_utils.js");
"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
let defaultWebSocketConstructor;
function setDefaultWebSocketConstructor(ws) {
    defaultWebSocketConstructor = ws;
}
class ConvexClient {
    /**
   * Construct a client and immediately initiate a WebSocket connection to the passed address.
   *
   * @public
   */ constructor(address, options = {}){
        __publicField(this, "listeners");
        __publicField(this, "_client");
        __publicField(this, "_paginatedClient");
        // A synthetic server event to run callbacks the first time
        __publicField(this, "callNewListenersWithCurrentValuesTimer");
        __publicField(this, "_closed");
        __publicField(this, "_disabled");
        if (options.skipConvexDeploymentUrlCheck !== true) (0, _indexJs.validateDeploymentUrl)(address);
        const { disabled, ...baseOptions } = options;
        this._closed = false;
        this._disabled = !!disabled;
        if (defaultWebSocketConstructor && !("webSocketConstructor" in baseOptions) && typeof WebSocket === "undefined") baseOptions.webSocketConstructor = defaultWebSocketConstructor;
        if (typeof window === "undefined" && !("unsavedChangesWarning" in baseOptions)) baseOptions.unsavedChangesWarning = false;
        if (!this.disabled) {
            this._client = new (0, _indexJs1.BaseConvexClient)(address, ()=>{}, // NOP, let the paginated query client do it all
            baseOptions);
            this._paginatedClient = new (0, _paginatedQueryClientJs.PaginatedQueryClient)(this._client, (transition)=>this._transition(transition));
        }
        this.listeners = /* @__PURE__ */ new Set();
    }
    /**
   * Once closed no registered callbacks will fire again.
   */ get closed() {
        return this._closed;
    }
    get client() {
        if (this._client) return this._client;
        throw new Error("ConvexClient is disabled");
    }
    /**
   * @internal
   */ get paginatedClient() {
        if (this._paginatedClient) return this._paginatedClient;
        throw new Error("ConvexClient is disabled");
    }
    get disabled() {
        return this._disabled;
    }
    /**
   * Call a callback whenever a new result for a query is received. The callback
   * will run soon after being registered if a result for the query is already
   * in memory.
   *
   * The return value is an {@link Unsubscribe} object which is both a function
   * an an object with properties. Both of the patterns below work with this object:
   *
   *```ts
   * // call the return value as a function
   * const unsubscribe = client.onUpdate(api.messages.list, {}, (messages) => {
   *   console.log(messages);
   * });
   * unsubscribe();
   *
   * // unpack the return value into its properties
   * const {
   *   getCurrentValue,
   *   unsubscribe,
   * } = client.onUpdate(api.messages.list, {}, (messages) => {
   *   console.log(messages);
   * });
   *```
   *
   * @param query - A {@link server.FunctionReference} for the public query to run.
   * @param args - The arguments to run the query with.
   * @param callback - Function to call when the query result updates.
   * @param onError - Function to call when the query result updates with an error.
   * If not provided, errors will be thrown instead of calling the callback.
   *
   * @return an {@link Unsubscribe} function to stop calling the onUpdate function.
   */ onUpdate(query, args, callback, onError) {
        if (this.disabled) return this.createDisabledUnsubscribe();
        const { queryToken, unsubscribe } = this.client.subscribe((0, _apiJs.getFunctionName)(query), args);
        const queryInfo = {
            queryToken,
            callback,
            onError,
            unsubscribe,
            hasEverRun: false,
            query,
            args,
            paginationOptions: void 0
        };
        this.listeners.add(queryInfo);
        if (this.queryResultReady(queryToken) && this.callNewListenersWithCurrentValuesTimer === void 0) this.callNewListenersWithCurrentValuesTimer = setTimeout(()=>this.callNewListenersWithCurrentValues(), 0);
        const unsubscribeProps = {
            unsubscribe: ()=>{
                if (this.closed) return;
                this.listeners.delete(queryInfo);
                unsubscribe();
            },
            getCurrentValue: ()=>this.client.localQueryResultByToken(queryToken),
            getQueryLogs: ()=>this.client.localQueryLogs(queryToken)
        };
        const ret = unsubscribeProps.unsubscribe;
        Object.assign(ret, unsubscribeProps);
        return ret;
    }
    /**
   * Call a callback whenever a new result for a paginated query is received.
   *
   * This is an experimental preview: the final API may change.
   * In particular, caching behavior, page splitting, and required paginated query options
   * may change.
   *
   * @param query - A {@link server.FunctionReference} for the public query to run.
   * @param args - The arguments to run the query with.
   * @param options - Options for the paginated query including initialNumItems and id.
   * @param callback - Function to call when the query result updates.
   * @param onError - Function to call when the query result updates with an error.
   *
   * @return an {@link Unsubscribe} function to stop calling the callback.
   */ onPaginatedUpdate_experimental(query, args, options, callback, onError) {
        if (this.disabled) return this.createDisabledUnsubscribe();
        const paginationOptions = {
            initialNumItems: options.initialNumItems,
            id: -1
        };
        const { paginatedQueryToken, unsubscribe } = this.paginatedClient.subscribe((0, _apiJs.getFunctionName)(query), args, // Simple client doesn't use IDs, there's no expectation that these queries remain separate.
        paginationOptions);
        const queryInfo = {
            queryToken: paginatedQueryToken,
            callback,
            onError,
            unsubscribe,
            hasEverRun: false,
            query,
            args,
            paginationOptions
        };
        this.listeners.add(queryInfo);
        if (!!this.paginatedClient.localQueryResultByToken(paginatedQueryToken) && this.callNewListenersWithCurrentValuesTimer === void 0) this.callNewListenersWithCurrentValuesTimer = setTimeout(()=>this.callNewListenersWithCurrentValues(), 0);
        const unsubscribeProps = {
            unsubscribe: ()=>{
                if (this.closed) return;
                this.listeners.delete(queryInfo);
                unsubscribe();
            },
            getCurrentValue: ()=>{
                const result = this.paginatedClient.localQueryResult((0, _apiJs.getFunctionName)(query), args, paginationOptions);
                return result;
            },
            getQueryLogs: ()=>[]
        };
        const ret = unsubscribeProps.unsubscribe;
        Object.assign(ret, unsubscribeProps);
        return ret;
    }
    // Run all callbacks that have never been run before if they have a query
    // result available now.
    callNewListenersWithCurrentValues() {
        this.callNewListenersWithCurrentValuesTimer = void 0;
        this._transition({
            queries: [],
            paginatedQueries: []
        }, true);
    }
    queryResultReady(queryToken) {
        return this.client.hasLocalQueryResultByToken(queryToken);
    }
    createDisabledUnsubscribe() {
        const disabledUnsubscribe = ()=>{};
        const unsubscribeProps = {
            unsubscribe: disabledUnsubscribe,
            getCurrentValue: ()=>void 0,
            getQueryLogs: ()=>void 0
        };
        Object.assign(disabledUnsubscribe, unsubscribeProps);
        return disabledUnsubscribe;
    }
    async close() {
        if (this.disabled) return;
        this.listeners.clear();
        this._closed = true;
        if (this._paginatedClient) this._paginatedClient = void 0;
        return this.client.close();
    }
    /**
   * Get the current JWT auth token and decoded claims.
   */ getAuth() {
        if (this.disabled) return;
        return this.client.getCurrentAuthClaims();
    }
    /**
   * Set the authentication token to be used for subsequent queries and mutations.
   * `fetchToken` will be called automatically again if a token expires.
   * `fetchToken` should return `null` if the token cannot be retrieved, for example
   * when the user's rights were permanently revoked.
   * @param fetchToken - an async function returning the JWT (typically an OpenID Connect Identity Token)
   * @param onChange - a callback that will be called when the authentication status changes
   */ setAuth(fetchToken, onChange) {
        if (this.disabled) return;
        this.client.setAuth(fetchToken, onChange ?? (()=>{}));
    }
    /**
   * @internal
   */ setAdminAuth(token, identity) {
        if (this.closed) throw new Error("ConvexClient has already been closed.");
        if (this.disabled) return;
        this.client.setAdminAuth(token, identity);
    }
    /**
   * @internal
   */ _transition({ queries, paginatedQueries }, callNewListeners = false) {
        const updatedQueries = [
            ...queries.map((q)=>q.token),
            ...paginatedQueries.map((q)=>q.token)
        ];
        for (const queryInfo of this.listeners){
            const { callback, queryToken, onError, hasEverRun } = queryInfo;
            const isPaginatedQuery = (0, _udfPathUtilsJs.serializedQueryTokenIsPaginated)(queryToken);
            const hasResultReady = isPaginatedQuery ? !!this.paginatedClient.localQueryResultByToken(queryToken) : this.client.hasLocalQueryResultByToken(queryToken);
            if (updatedQueries.includes(queryToken) || callNewListeners && !hasEverRun && hasResultReady) {
                queryInfo.hasEverRun = true;
                let newValue;
                try {
                    if (isPaginatedQuery) newValue = this.paginatedClient.localQueryResultByToken(queryToken);
                    else newValue = this.client.localQueryResultByToken(queryToken);
                } catch (error) {
                    if (!(error instanceof Error)) throw error;
                    if (onError) onError(error, "Second argument to onUpdate onError is reserved for later use");
                    else Promise.reject(error);
                    continue;
                }
                callback(newValue, "Second argument to onUpdate callback is reserved for later use");
            }
        }
    }
    /**
   * Execute a mutation function.
   *
   * @param mutation - A {@link server.FunctionReference} for the public mutation
   * to run.
   * @param args - An arguments object for the mutation.
   * @param options - A {@link MutationOptions} options object for the mutation.
   * @returns A promise of the mutation's result.
   */ async mutation(mutation, args, options) {
        if (this.disabled) throw new Error("ConvexClient is disabled");
        return await this.client.mutation((0, _apiJs.getFunctionName)(mutation), args, options);
    }
    /**
   * Execute an action function.
   *
   * @param action - A {@link server.FunctionReference} for the public action
   * to run.
   * @param args - An arguments object for the action.
   * @returns A promise of the action's result.
   */ async action(action, args) {
        if (this.disabled) throw new Error("ConvexClient is disabled");
        return await this.client.action((0, _apiJs.getFunctionName)(action), args);
    }
    /**
   * Fetch a query result once.
   *
   * @param query - A {@link server.FunctionReference} for the public query
   * to run.
   * @param args - An arguments object for the query.
   * @returns A promise of the query's result.
   */ async query(query, args) {
        if (this.disabled) throw new Error("ConvexClient is disabled");
        const value = this.client.localQueryResult((0, _apiJs.getFunctionName)(query), args);
        if (value !== void 0) return Promise.resolve(value);
        return new Promise((resolve, reject)=>{
            const { unsubscribe } = this.onUpdate(query, args, (value2)=>{
                unsubscribe();
                resolve(value2);
            }, (e)=>{
                unsubscribe();
                reject(e);
            });
        });
    }
    /**
   * Get the current {@link ConnectionState} between the client and the Convex
   * backend.
   *
   * @returns The {@link ConnectionState} with the Convex backend.
   */ connectionState() {
        if (this.disabled) throw new Error("ConvexClient is disabled");
        return this.client.connectionState();
    }
    /**
   * Subscribe to the {@link ConnectionState} between the client and the Convex
   * backend, calling a callback each time it changes.
   *
   * Subscribed callbacks will be called when any part of ConnectionState changes.
   * ConnectionState may grow in future versions (e.g. to provide a array of
   * inflight requests) in which case callbacks would be called more frequently.
   *
   * @returns An unsubscribe function to stop listening.
   */ subscribeToConnectionState(cb) {
        if (this.disabled) return ()=>{};
        return this.client.subscribeToConnectionState(cb);
    }
}

},{"../common/index.js":"jSbKo","./index.js":"iiMQR","../server/api.js":"9nMwO","./sync/paginated_query_client.js":"itfeA","./sync/udf_path_utils.js":"fXv0g","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"itfeA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PaginatedQueryClient", ()=>PaginatedQueryClient);
var _udfPathUtilsJs = require("./udf_path_utils.js");
var _paginationJs = require("./pagination.js");
var _longJs = require("../../vendor/long.js");
"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
class PaginatedQueryClient {
    constructor(client, onTransition){
        this.client = client;
        this.onTransition = onTransition;
        __publicField(this, "paginatedQuerySet", /* @__PURE__ */ new Map());
        // hold onto a real Transition so we can construct synthetic ones with that timestamp
        __publicField(this, "lastTransitionTs");
        this.lastTransitionTs = (0, _longJs.Long).fromNumber(0);
        this.client.addOnTransitionHandler((transition)=>this.onBaseTransition(transition));
    }
    /**
   * Subscribe to a paginated query.
   *
   * @param name - The name of the paginated query function
   * @param args - Arguments for the query (excluding paginationOpts)
   * @param options - Pagination options including initialNumItems
   * @returns Object with paginatedQueryToken and unsubscribe function
   */ subscribe(name, args, options) {
        const canonicalizedUdfPath = (0, _udfPathUtilsJs.canonicalizeUdfPath)(name);
        const token = (0, _udfPathUtilsJs.serializePaginatedPathAndArgs)(canonicalizedUdfPath, args, options);
        const unsubscribe = ()=>this.removePaginatedQuerySubscriber(token);
        const existingEntry = this.paginatedQuerySet.get(token);
        if (existingEntry) {
            existingEntry.numSubscribers += 1;
            return {
                paginatedQueryToken: token,
                unsubscribe
            };
        }
        this.paginatedQuerySet.set(token, {
            token,
            canonicalizedUdfPath,
            args,
            numSubscribers: 1,
            options: {
                initialNumItems: options.initialNumItems
            },
            nextPageKey: 0,
            pageKeys: [],
            pageKeyToQuery: /* @__PURE__ */ new Map(),
            ongoingSplits: /* @__PURE__ */ new Map(),
            skip: false,
            id: options.id
        });
        this.addPageToPaginatedQuery(token, null, options.initialNumItems);
        return {
            paginatedQueryToken: token,
            unsubscribe
        };
    }
    /**
   * Get current results for a paginated query based on local state.
   *
   * Throws an error when one of the pages has errored.
   */ localQueryResult(name, args, options) {
        const canonicalizedUdfPath = (0, _udfPathUtilsJs.canonicalizeUdfPath)(name);
        const token = (0, _udfPathUtilsJs.serializePaginatedPathAndArgs)(canonicalizedUdfPath, args, options);
        return this.localQueryResultByToken(token);
    }
    /**
   * @internal
   */ localQueryResultByToken(token) {
        const paginatedQuery = this.paginatedQuerySet.get(token);
        if (!paginatedQuery) return void 0;
        const activePages = this.activePageQueryTokens(paginatedQuery);
        if (activePages.length === 0) return {
            results: [],
            status: "LoadingFirstPage",
            loadMore: (numItems)=>{
                return this.loadMoreOfPaginatedQuery(token, numItems);
            }
        };
        let allResults = [];
        let hasUndefined = false;
        let isDone = false;
        for (const pageToken of activePages){
            const result = this.client.localQueryResultByToken(pageToken);
            if (result === void 0) {
                hasUndefined = true;
                isDone = false;
                continue;
            }
            const paginationResult = (0, _paginationJs.asPaginationResult)(result);
            allResults = allResults.concat(paginationResult.page);
            isDone = !!paginationResult.isDone;
        }
        let status;
        if (hasUndefined) status = allResults.length === 0 ? "LoadingFirstPage" : "LoadingMore";
        else if (isDone) status = "Exhausted";
        else status = "CanLoadMore";
        return {
            results: allResults,
            status,
            loadMore: (numItems)=>{
                return this.loadMoreOfPaginatedQuery(token, numItems);
            }
        };
    }
    onBaseTransition(transition) {
        const changedBaseTokens = transition.queries.map((q)=>q.token);
        const changed = this.queriesContainingTokens(changedBaseTokens);
        let paginatedQueries = [];
        if (changed.length > 0) {
            this.processPaginatedQuerySplits(changed, (token)=>this.client.localQueryResultByToken(token));
            paginatedQueries = changed.map((token)=>({
                    token,
                    modification: {
                        kind: "Updated",
                        result: this.localQueryResultByToken(token)
                    }
                }));
        }
        const extendedTransition = {
            ...transition,
            paginatedQueries
        };
        this.onTransition(extendedTransition);
    }
    /**
   * Load more items for a paginated query.
   *
   * This *always* causes a transition, the status of the query
   * has probably changed from "CanLoadMore" to "LoadingMore".
   * Data might have changed too: maybe a subscription to this page
   * query already exists (unlikely but possible) or this page query
   * has an optimistic update providing some initial data.
   *
   * @internal
   */ loadMoreOfPaginatedQuery(token, numItems) {
        this.mustGetPaginatedQuery(token);
        const lastPageToken = this.queryTokenForLastPageOfPaginatedQuery(token);
        const lastPageResult = this.client.localQueryResultByToken(lastPageToken);
        if (!lastPageResult) return false;
        const paginationResult = (0, _paginationJs.asPaginationResult)(lastPageResult);
        if (paginationResult.isDone) return false;
        this.addPageToPaginatedQuery(token, paginationResult.continueCursor, numItems);
        const loadMoreTransition = {
            timestamp: this.lastTransitionTs,
            reflectedMutations: [],
            queries: [],
            paginatedQueries: [
                {
                    token,
                    modification: {
                        kind: "Updated",
                        result: this.localQueryResultByToken(token)
                    }
                }
            ]
        };
        this.onTransition(loadMoreTransition);
        return true;
    }
    /**
   * @internal
   */ queriesContainingTokens(queryTokens) {
        if (queryTokens.length === 0) return [];
        const changed = [];
        const queryTokenSet = new Set(queryTokens);
        for (const [paginatedToken, paginatedQuery] of this.paginatedQuerySet){
            for (const pageToken of this.allQueryTokens(paginatedQuery))if (queryTokenSet.has(pageToken)) {
                changed.push(paginatedToken);
                break;
            }
        }
        return changed;
    }
    /**
   * @internal
   */ processPaginatedQuerySplits(changed, getResult) {
        for (const paginatedQueryToken of changed){
            const paginatedQuery = this.mustGetPaginatedQuery(paginatedQueryToken);
            const { ongoingSplits, pageKeyToQuery, pageKeys } = paginatedQuery;
            for (const [pageKey, [splitKey1, splitKey2]] of ongoingSplits){
                const bothNewPagesLoaded = getResult(pageKeyToQuery.get(splitKey1).queryToken) !== void 0 && getResult(pageKeyToQuery.get(splitKey2).queryToken) !== void 0;
                if (bothNewPagesLoaded) this.completePaginatedQuerySplit(paginatedQuery, pageKey, splitKey1, splitKey2);
            }
            for (const pageKey of pageKeys){
                if (ongoingSplits.has(pageKey)) continue;
                const pageToken = pageKeyToQuery.get(pageKey).queryToken;
                const pageResult = getResult(pageToken);
                if (!pageResult) continue;
                const result = (0, _paginationJs.asPaginationResult)(pageResult);
                const shouldSplit = result.splitCursor && (result.pageStatus === "SplitRecommended" || result.pageStatus === "SplitRequired" || // This client-driven page splitting condition will change in the future.
                result.page.length > paginatedQuery.options.initialNumItems * 2);
                if (shouldSplit) this.splitPaginatedQueryPage(paginatedQuery, pageKey, result.splitCursor, // we just checked
                result.continueCursor);
            }
        }
    }
    splitPaginatedQueryPage(paginatedQuery, pageKey, splitCursor, continueCursor) {
        const splitKey1 = paginatedQuery.nextPageKey++;
        const splitKey2 = paginatedQuery.nextPageKey++;
        const paginationOpts = {
            cursor: continueCursor,
            numItems: paginatedQuery.options.initialNumItems,
            id: paginatedQuery.id
        };
        const firstSubscription = this.client.subscribe(paginatedQuery.canonicalizedUdfPath, {
            ...paginatedQuery.args,
            paginationOpts: {
                ...paginationOpts,
                cursor: null,
                // Start from beginning for first split
                endCursor: splitCursor
            }
        });
        paginatedQuery.pageKeyToQuery.set(splitKey1, firstSubscription);
        const secondSubscription = this.client.subscribe(paginatedQuery.canonicalizedUdfPath, {
            ...paginatedQuery.args,
            paginationOpts: {
                ...paginationOpts,
                cursor: splitCursor,
                endCursor: continueCursor
            }
        });
        paginatedQuery.pageKeyToQuery.set(splitKey2, secondSubscription);
        paginatedQuery.ongoingSplits.set(pageKey, [
            splitKey1,
            splitKey2
        ]);
    }
    /**
   * @internal
   */ addPageToPaginatedQuery(token, continueCursor, numItems) {
        const paginatedQuery = this.mustGetPaginatedQuery(token);
        const pageKey = paginatedQuery.nextPageKey++;
        const paginationOpts = {
            cursor: continueCursor,
            numItems,
            id: paginatedQuery.id
        };
        const pageArgs = {
            ...paginatedQuery.args,
            paginationOpts
        };
        const subscription = this.client.subscribe(paginatedQuery.canonicalizedUdfPath, pageArgs);
        paginatedQuery.pageKeys.push(pageKey);
        paginatedQuery.pageKeyToQuery.set(pageKey, subscription);
        return subscription;
    }
    removePaginatedQuerySubscriber(token) {
        const paginatedQuery = this.paginatedQuerySet.get(token);
        if (!paginatedQuery) return;
        paginatedQuery.numSubscribers -= 1;
        if (paginatedQuery.numSubscribers > 0) return;
        for (const subscription of paginatedQuery.pageKeyToQuery.values())subscription.unsubscribe();
        this.paginatedQuerySet.delete(token);
    }
    completePaginatedQuerySplit(paginatedQuery, pageKey, splitKey1, splitKey2) {
        const originalQuery = paginatedQuery.pageKeyToQuery.get(pageKey);
        paginatedQuery.pageKeyToQuery.delete(pageKey);
        const pageIndex = paginatedQuery.pageKeys.indexOf(pageKey);
        paginatedQuery.pageKeys.splice(pageIndex, 1, splitKey1, splitKey2);
        paginatedQuery.ongoingSplits.delete(pageKey);
        originalQuery.unsubscribe();
    }
    /** The query tokens for all active pages, in result order */ activePageQueryTokens(paginatedQuery) {
        return paginatedQuery.pageKeys.map((pageKey)=>paginatedQuery.pageKeyToQuery.get(pageKey).queryToken);
    }
    allQueryTokens(paginatedQuery) {
        return Array.from(paginatedQuery.pageKeyToQuery.values()).map((sub)=>sub.queryToken);
    }
    queryTokenForLastPageOfPaginatedQuery(token) {
        const paginatedQuery = this.mustGetPaginatedQuery(token);
        const lastPageKey = paginatedQuery.pageKeys[paginatedQuery.pageKeys.length - 1];
        if (lastPageKey === void 0) throw new Error(`No pages for paginated query ${token}`);
        return paginatedQuery.pageKeyToQuery.get(lastPageKey).queryToken;
    }
    mustGetPaginatedQuery(token) {
        const paginatedQuery = this.paginatedQuerySet.get(token);
        if (!paginatedQuery) throw new Error("paginated query no longer exists for token " + token);
        return paginatedQuery;
    }
}

},{"./udf_path_utils.js":"fXv0g","./pagination.js":"bpXzy","../../vendor/long.js":"dnRaE","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"bpXzy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "asPaginationArgs", ()=>asPaginationArgs);
parcelHelpers.export(exports, "asPaginationResult", ()=>asPaginationResult);
"use strict";
function asPaginationArgs(value) {
    if (typeof value.paginationOpts.numItems !== "number") throw new Error(`Not valid paginated query args: ${JSON.stringify(value)}`);
    return value;
}
function asPaginationResult(value) {
    if (typeof value !== "object" || value === null || !Array.isArray(value.page) || typeof value.isDone !== "boolean" || typeof value.continueCursor !== "string") throw new Error(`Not a valid paginated query result: ${value?.toString()}`);
    return value;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"dDOXz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "STATUS_CODE_OK", ()=>STATUS_CODE_OK);
parcelHelpers.export(exports, "STATUS_CODE_BAD_REQUEST", ()=>STATUS_CODE_BAD_REQUEST);
parcelHelpers.export(exports, "STATUS_CODE_UDF_FAILED", ()=>STATUS_CODE_UDF_FAILED);
parcelHelpers.export(exports, "setFetch", ()=>setFetch);
parcelHelpers.export(exports, "ConvexHttpClient", ()=>ConvexHttpClient);
var _apiJs = require("../server/api.js");
var _indexJs = require("../common/index.js");
var _indexJs1 = require("../index.js");
var _indexJs2 = require("../values/index.js");
var _loggingJs = require("./logging.js");
"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
const STATUS_CODE_OK = 200;
const STATUS_CODE_BAD_REQUEST = 400;
const STATUS_CODE_UDF_FAILED = 560;
let specifiedFetch = void 0;
function setFetch(f) {
    specifiedFetch = f;
}
class ConvexHttpClient {
    /**
   * Create a new {@link ConvexHttpClient}.
   *
   * @param address - The url of your Convex deployment, often provided
   * by an environment variable. E.g. `https://small-mouse-123.convex.cloud`.
   * @param options - An object of options.
   * - `skipConvexDeploymentUrlCheck` - Skip validating that the Convex deployment URL looks like
   * `https://happy-animal-123.convex.cloud` or localhost. This can be useful if running a self-hosted
   * Convex backend that uses a different URL.
   * - `logger` - A logger or a boolean. If not provided, logs to the console.
   * You can construct your own logger to customize logging to log elsewhere
   * or not log at all, or use `false` as a shorthand for a no-op logger.
   * A logger is an object with 4 methods: log(), warn(), error(), and logVerbose().
   * These methods can receive multiple arguments of any types, like console.log().
   * - `auth` - A JWT containing identity claims accessible in Convex functions.
   * This identity may expire so it may be necessary to call `setAuth()` later,
   * but for short-lived clients it's convenient to specify this value here.
   * - `fetch` - A custom fetch implementation to use for all HTTP requests made by this client.
   */ constructor(address, options){
        __publicField(this, "address");
        __publicField(this, "auth");
        __publicField(this, "adminAuth");
        __publicField(this, "encodedTsPromise");
        __publicField(this, "debug");
        __publicField(this, "fetchOptions");
        __publicField(this, "fetch");
        __publicField(this, "logger");
        __publicField(this, "mutationQueue", []);
        __publicField(this, "isProcessingQueue", false);
        if (typeof options === "boolean") throw new Error("skipConvexDeploymentUrlCheck as the second argument is no longer supported. Please pass an options object, `{ skipConvexDeploymentUrlCheck: true }`.");
        const opts = options ?? {};
        if (opts.skipConvexDeploymentUrlCheck !== true) (0, _indexJs.validateDeploymentUrl)(address);
        this.logger = options?.logger === false ? (0, _loggingJs.instantiateNoopLogger)({
            verbose: false
        }) : options?.logger !== true && options?.logger ? options.logger : (0, _loggingJs.instantiateDefaultLogger)({
            verbose: false
        });
        this.address = address;
        this.debug = true;
        this.auth = void 0;
        this.adminAuth = void 0;
        this.fetch = options?.fetch;
        if (options?.auth) this.setAuth(options.auth);
    }
    /**
   * Obtain the {@link ConvexHttpClient}'s URL to its backend.
   * @deprecated Use url, which returns the url without /api at the end.
   *
   * @returns The URL to the Convex backend, including the client's API version.
   */ backendUrl() {
        return `${this.address}/api`;
    }
    /**
   * Return the address for this client, useful for creating a new client.
   *
   * Not guaranteed to match the address with which this client was constructed:
   * it may be canonicalized.
   */ get url() {
        return this.address;
    }
    /**
   * Set the authentication token to be used for subsequent queries and mutations.
   *
   * Should be called whenever the token changes (i.e. due to expiration and refresh).
   *
   * @param value - JWT-encoded OpenID Connect identity token.
   */ setAuth(value) {
        this.clearAuth();
        this.auth = value;
    }
    /**
   * Set admin auth token to allow calling internal queries, mutations, and actions
   * and acting as an identity.
   *
   * @internal
   */ setAdminAuth(token, actingAsIdentity) {
        this.clearAuth();
        if (actingAsIdentity !== void 0) {
            const bytes = new TextEncoder().encode(JSON.stringify(actingAsIdentity));
            const actingAsIdentityEncoded = btoa(String.fromCodePoint(...bytes));
            this.adminAuth = `${token}:${actingAsIdentityEncoded}`;
        } else this.adminAuth = token;
    }
    /**
   * Clear the current authentication token if set.
   */ clearAuth() {
        this.auth = void 0;
        this.adminAuth = void 0;
    }
    /**
   * Sets whether the result log lines should be printed on the console or not.
   *
   * @internal
   */ setDebug(debug) {
        this.debug = debug;
    }
    /**
   * Used to customize the fetch behavior in some runtimes.
   *
   * @internal
   */ setFetchOptions(fetchOptions) {
        this.fetchOptions = fetchOptions;
    }
    /**
   * This API is experimental: it may change or disappear.
   *
   * Execute a Convex query function at the same timestamp as every other
   * consistent query execution run by this HTTP client.
   *
   * This doesn't make sense for long-lived ConvexHttpClients as Convex
   * backends can read a limited amount into the past: beyond 30 seconds
   * in the past may not be available.
   *
   * Create a new client to use a consistent time.
   *
   * @param name - The name of the query.
   * @param args - The arguments object for the query. If this is omitted,
   * the arguments will be `{}`.
   * @returns A promise of the query's result.
   *
   * @deprecated This API is experimental: it may change or disappear.
   */ async consistentQuery(query, ...args) {
        const queryArgs = (0, _indexJs.parseArgs)(args[0]);
        const timestampPromise = this.getTimestamp();
        return await this.queryInner(query, queryArgs, {
            timestampPromise
        });
    }
    async getTimestamp() {
        if (this.encodedTsPromise) return this.encodedTsPromise;
        return this.encodedTsPromise = this.getTimestampInner();
    }
    async getTimestampInner() {
        const localFetch = this.fetch || specifiedFetch || fetch;
        const headers = {
            "Content-Type": "application/json",
            "Convex-Client": `npm-${(0, _indexJs1.version)}`
        };
        const response = await localFetch(`${this.address}/api/query_ts`, {
            ...this.fetchOptions,
            method: "POST",
            headers
        });
        if (!response.ok) throw new Error(await response.text());
        const { ts } = await response.json();
        return ts;
    }
    /**
   * Execute a Convex query function.
   *
   * @param name - The name of the query.
   * @param args - The arguments object for the query. If this is omitted,
   * the arguments will be `{}`.
   * @returns A promise of the query's result.
   */ async query(query, ...args) {
        const queryArgs = (0, _indexJs.parseArgs)(args[0]);
        return await this.queryInner(query, queryArgs, {});
    }
    async queryInner(query, queryArgs, options) {
        const name = (0, _apiJs.getFunctionName)(query);
        const args = [
            (0, _indexJs2.convexToJson)(queryArgs)
        ];
        const headers = {
            "Content-Type": "application/json",
            "Convex-Client": `npm-${(0, _indexJs1.version)}`
        };
        if (this.adminAuth) headers["Authorization"] = `Convex ${this.adminAuth}`;
        else if (this.auth) headers["Authorization"] = `Bearer ${this.auth}`;
        const localFetch = this.fetch || specifiedFetch || fetch;
        const timestamp = options.timestampPromise ? await options.timestampPromise : void 0;
        const body = JSON.stringify({
            path: name,
            format: "convex_encoded_json",
            args,
            ...timestamp ? {
                ts: timestamp
            } : {}
        });
        const endpoint = timestamp ? `${this.address}/api/query_at_ts` : `${this.address}/api/query`;
        const response = await localFetch(endpoint, {
            ...this.fetchOptions,
            body,
            method: "POST",
            headers
        });
        if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) throw new Error(await response.text());
        const respJSON = await response.json();
        if (this.debug) for (const line of respJSON.logLines ?? [])(0, _loggingJs.logForFunction)(this.logger, "info", "query", name, line);
        switch(respJSON.status){
            case "success":
                return (0, _indexJs2.jsonToConvex)(respJSON.value);
            case "error":
                if (respJSON.errorData !== void 0) throw forwardErrorData(respJSON.errorData, new (0, _indexJs2.ConvexError)(respJSON.errorMessage));
                throw new Error(respJSON.errorMessage);
            default:
                throw new Error(`Invalid response: ${JSON.stringify(respJSON)}`);
        }
    }
    async mutationInner(mutation, mutationArgs) {
        const name = (0, _apiJs.getFunctionName)(mutation);
        const body = JSON.stringify({
            path: name,
            format: "convex_encoded_json",
            args: [
                (0, _indexJs2.convexToJson)(mutationArgs)
            ]
        });
        const headers = {
            "Content-Type": "application/json",
            "Convex-Client": `npm-${(0, _indexJs1.version)}`
        };
        if (this.adminAuth) headers["Authorization"] = `Convex ${this.adminAuth}`;
        else if (this.auth) headers["Authorization"] = `Bearer ${this.auth}`;
        const localFetch = this.fetch || specifiedFetch || fetch;
        const response = await localFetch(`${this.address}/api/mutation`, {
            ...this.fetchOptions,
            body,
            method: "POST",
            headers
        });
        if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) throw new Error(await response.text());
        const respJSON = await response.json();
        if (this.debug) for (const line of respJSON.logLines ?? [])(0, _loggingJs.logForFunction)(this.logger, "info", "mutation", name, line);
        switch(respJSON.status){
            case "success":
                return (0, _indexJs2.jsonToConvex)(respJSON.value);
            case "error":
                if (respJSON.errorData !== void 0) throw forwardErrorData(respJSON.errorData, new (0, _indexJs2.ConvexError)(respJSON.errorMessage));
                throw new Error(respJSON.errorMessage);
            default:
                throw new Error(`Invalid response: ${JSON.stringify(respJSON)}`);
        }
    }
    async processMutationQueue() {
        if (this.isProcessingQueue) return;
        this.isProcessingQueue = true;
        while(this.mutationQueue.length > 0){
            const { mutation, args, resolve, reject } = this.mutationQueue.shift();
            try {
                const result = await this.mutationInner(mutation, args);
                resolve(result);
            } catch (error) {
                reject(error);
            }
        }
        this.isProcessingQueue = false;
    }
    enqueueMutation(mutation, args) {
        return new Promise((resolve, reject)=>{
            this.mutationQueue.push({
                mutation,
                args,
                resolve,
                reject
            });
            this.processMutationQueue();
        });
    }
    /**
   * Execute a Convex mutation function. Mutations are queued by default.
   *
   * @param name - The name of the mutation.
   * @param args - The arguments object for the mutation. If this is omitted,
   * the arguments will be `{}`.
   * @param options - An optional object containing
   * @returns A promise of the mutation's result.
   */ async mutation(mutation, ...args) {
        const [fnArgs, options] = args;
        const mutationArgs = (0, _indexJs.parseArgs)(fnArgs);
        const queued = !options?.skipQueue;
        if (queued) return await this.enqueueMutation(mutation, mutationArgs);
        else return await this.mutationInner(mutation, mutationArgs);
    }
    /**
   * Execute a Convex action function. Actions are not queued.
   *
   * @param name - The name of the action.
   * @param args - The arguments object for the action. If this is omitted,
   * the arguments will be `{}`.
   * @returns A promise of the action's result.
   */ async action(action, ...args) {
        const actionArgs = (0, _indexJs.parseArgs)(args[0]);
        const name = (0, _apiJs.getFunctionName)(action);
        const body = JSON.stringify({
            path: name,
            format: "convex_encoded_json",
            args: [
                (0, _indexJs2.convexToJson)(actionArgs)
            ]
        });
        const headers = {
            "Content-Type": "application/json",
            "Convex-Client": `npm-${(0, _indexJs1.version)}`
        };
        if (this.adminAuth) headers["Authorization"] = `Convex ${this.adminAuth}`;
        else if (this.auth) headers["Authorization"] = `Bearer ${this.auth}`;
        const localFetch = this.fetch || specifiedFetch || fetch;
        const response = await localFetch(`${this.address}/api/action`, {
            ...this.fetchOptions,
            body,
            method: "POST",
            headers
        });
        if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) throw new Error(await response.text());
        const respJSON = await response.json();
        if (this.debug) for (const line of respJSON.logLines ?? [])(0, _loggingJs.logForFunction)(this.logger, "info", "action", name, line);
        switch(respJSON.status){
            case "success":
                return (0, _indexJs2.jsonToConvex)(respJSON.value);
            case "error":
                if (respJSON.errorData !== void 0) throw forwardErrorData(respJSON.errorData, new (0, _indexJs2.ConvexError)(respJSON.errorMessage));
                throw new Error(respJSON.errorMessage);
            default:
                throw new Error(`Invalid response: ${JSON.stringify(respJSON)}`);
        }
    }
    /**
   * Execute a Convex function of an unknown type. These function calls are not queued.
   *
   * @param name - The name of the function.
   * @param args - The arguments object for the function. If this is omitted,
   * the arguments will be `{}`.
   * @returns A promise of the function's result.
   *
   * @internal
   */ async function(anyFunction, componentPath, ...args) {
        const functionArgs = (0, _indexJs.parseArgs)(args[0]);
        const name = typeof anyFunction === "string" ? anyFunction : (0, _apiJs.getFunctionName)(anyFunction);
        const body = JSON.stringify({
            componentPath,
            path: name,
            format: "convex_encoded_json",
            args: (0, _indexJs2.convexToJson)(functionArgs)
        });
        const headers = {
            "Content-Type": "application/json",
            "Convex-Client": `npm-${(0, _indexJs1.version)}`
        };
        if (this.adminAuth) headers["Authorization"] = `Convex ${this.adminAuth}`;
        else if (this.auth) headers["Authorization"] = `Bearer ${this.auth}`;
        const localFetch = this.fetch || specifiedFetch || fetch;
        const response = await localFetch(`${this.address}/api/function`, {
            ...this.fetchOptions,
            body,
            method: "POST",
            headers
        });
        if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) throw new Error(await response.text());
        const respJSON = await response.json();
        if (this.debug) for (const line of respJSON.logLines ?? [])(0, _loggingJs.logForFunction)(this.logger, "info", "any", name, line);
        switch(respJSON.status){
            case "success":
                return (0, _indexJs2.jsonToConvex)(respJSON.value);
            case "error":
                if (respJSON.errorData !== void 0) throw forwardErrorData(respJSON.errorData, new (0, _indexJs2.ConvexError)(respJSON.errorMessage));
                throw new Error(respJSON.errorMessage);
            default:
                throw new Error(`Invalid response: ${JSON.stringify(respJSON)}`);
        }
    }
}
function forwardErrorData(errorData, error) {
    error.data = (0, _indexJs2.jsonToConvex)(errorData);
    return error;
}

},{"../server/api.js":"9nMwO","../common/index.js":"jSbKo","../index.js":"76BIQ","../values/index.js":"atHbO","./logging.js":"7g7UR","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"k9cSC":[function(require,module,exports) {
/* eslint-disable */ /**
 * Generated `api` utility.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "api", ()=>api);
parcelHelpers.export(exports, "internal", ()=>internal);
parcelHelpers.export(exports, "components", ()=>components);
var _server = require("convex/server");
const api = (0, _server.anyApi);
const internal = (0, _server.anyApi);
const components = (0, _server.componentsGeneric)();

},{"convex/server":"jepZP","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"jepZP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "actionGeneric", ()=>(0, _registrationImplJs.actionGeneric));
parcelHelpers.export(exports, "httpActionGeneric", ()=>(0, _registrationImplJs.httpActionGeneric));
parcelHelpers.export(exports, "mutationGeneric", ()=>(0, _registrationImplJs.mutationGeneric));
parcelHelpers.export(exports, "queryGeneric", ()=>(0, _registrationImplJs.queryGeneric));
parcelHelpers.export(exports, "internalActionGeneric", ()=>(0, _registrationImplJs.internalActionGeneric));
parcelHelpers.export(exports, "internalMutationGeneric", ()=>(0, _registrationImplJs.internalMutationGeneric));
parcelHelpers.export(exports, "internalQueryGeneric", ()=>(0, _registrationImplJs.internalQueryGeneric));
parcelHelpers.export(exports, "cronJobs", ()=>(0, _cronJs.cronJobs));
parcelHelpers.export(exports, "httpRouter", ()=>(0, _routerJs.httpRouter));
parcelHelpers.export(exports, "HttpRouter", ()=>(0, _routerJs.HttpRouter));
parcelHelpers.export(exports, "ROUTABLE_HTTP_METHODS", ()=>(0, _routerJs.ROUTABLE_HTTP_METHODS));
parcelHelpers.export(exports, "anyApi", ()=>(0, _apiJs.anyApi));
parcelHelpers.export(exports, "getFunctionName", ()=>(0, _apiJs.getFunctionName));
parcelHelpers.export(exports, "makeFunctionReference", ()=>(0, _apiJs.makeFunctionReference));
parcelHelpers.export(exports, "filterApi", ()=>(0, _apiJs.filterApi));
parcelHelpers.export(exports, "defineApp", ()=>(0, _indexJs.defineApp));
parcelHelpers.export(exports, "defineComponent", ()=>(0, _indexJs.defineComponent));
parcelHelpers.export(exports, "componentsGeneric", ()=>(0, _indexJs.componentsGeneric));
parcelHelpers.export(exports, "createFunctionHandle", ()=>(0, _indexJs.createFunctionHandle));
parcelHelpers.export(exports, "currentSystemUdfInComponent", ()=>(0, _indexJs.currentSystemUdfInComponent));
parcelHelpers.export(exports, "getFunctionAddress", ()=>(0, _indexJs.getFunctionAddress));
parcelHelpers.export(exports, "defineTable", ()=>(0, _schemaJs.defineTable));
parcelHelpers.export(exports, "defineSchema", ()=>(0, _schemaJs.defineSchema));
var _databaseJs = require("./database.js");
parcelHelpers.exportAll(_databaseJs, exports);
var _registrationImplJs = require("./impl/registration_impl.js");
var _paginationJs = require("./pagination.js");
parcelHelpers.exportAll(_paginationJs, exports);
var _searchFilterBuilderJs = require("./search_filter_builder.js");
parcelHelpers.exportAll(_searchFilterBuilderJs, exports);
var _storageJs = require("./storage.js");
parcelHelpers.exportAll(_storageJs, exports);
var _cronJs = require("./cron.js");
var _routerJs = require("./router.js");
var _apiJs = require("./api.js");
var _indexJs = require("./components/index.js");
var _schemaJs = require("./schema.js");
"use strict";

},{"./database.js":"jHgoL","./impl/registration_impl.js":"dLYyq","./pagination.js":"l2LyC","./search_filter_builder.js":"f5Cbq","./storage.js":"dI7vT","./cron.js":"4G5Pl","./router.js":"kNXNC","./api.js":"9nMwO","./components/index.js":"fIWeD","./schema.js":"7S7L3","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"jHgoL":[function(require,module,exports) {
"use strict";

},{}],"dLYyq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "validateReturnValue", ()=>validateReturnValue);
parcelHelpers.export(exports, "invokeFunction", ()=>invokeFunction);
parcelHelpers.export(exports, "mutationGeneric", ()=>mutationGeneric);
parcelHelpers.export(exports, "internalMutationGeneric", ()=>internalMutationGeneric);
parcelHelpers.export(exports, "queryGeneric", ()=>queryGeneric);
parcelHelpers.export(exports, "internalQueryGeneric", ()=>internalQueryGeneric);
parcelHelpers.export(exports, "actionGeneric", ()=>actionGeneric);
parcelHelpers.export(exports, "internalActionGeneric", ()=>internalActionGeneric);
parcelHelpers.export(exports, "httpActionGeneric", ()=>httpActionGeneric);
var _indexJs = require("../../values/index.js");
var _actionsImplJs = require("./actions_impl.js");
var _vectorSearchImplJs = require("./vector_search_impl.js");
var _authenticationImplJs = require("./authentication_impl.js");
var _databaseImplJs = require("./database_impl.js");
var _queryImplJs = require("./query_impl.js");
var _schedulerImplJs = require("./scheduler_impl.js");
var _storageImplJs = require("./storage_impl.js");
var _indexJs1 = require("../../common/index.js");
var _syscallJs = require("./syscall.js");
var _validatorJs = require("../../values/validator.js");
var _pathsJs = require("../components/paths.js");
"use strict";
async function invokeMutation(func, argsStr) {
    const requestId = "";
    const args = (0, _indexJs.jsonToConvex)(JSON.parse(argsStr));
    const mutationCtx = {
        db: (0, _databaseImplJs.setupWriter)(),
        auth: (0, _authenticationImplJs.setupAuth)(requestId),
        storage: (0, _storageImplJs.setupStorageWriter)(requestId),
        scheduler: (0, _schedulerImplJs.setupMutationScheduler)(),
        runQuery: (reference, args2)=>runUdf("query", reference, args2),
        runMutation: (reference, args2)=>runUdf("mutation", reference, args2)
    };
    const result = await invokeFunction(func, mutationCtx, args);
    validateReturnValue(result);
    return JSON.stringify((0, _indexJs.convexToJson)(result === void 0 ? null : result));
}
function validateReturnValue(v2) {
    if (v2 instanceof (0, _queryImplJs.QueryInitializerImpl) || v2 instanceof (0, _queryImplJs.QueryImpl)) throw new Error("Return value is a Query. Results must be retrieved with `.collect()`, `.take(n), `.unique()`, or `.first()`.");
}
async function invokeFunction(func, ctx, args) {
    let result;
    try {
        result = await Promise.resolve(func(ctx, ...args));
    } catch (thrown) {
        throw serializeConvexErrorData(thrown);
    }
    return result;
}
function dontCallDirectly(funcType, handler) {
    return (ctx, args)=>{
        globalThis.console.warn(`Convex functions should not directly call other Convex functions. Consider calling a helper function instead. e.g. \`export const foo = ${funcType}(...); await foo(ctx);\` is not supported. See https://docs.convex.dev/production/best-practices/#use-helper-functions-to-write-shared-code`);
        return handler(ctx, args);
    };
}
function serializeConvexErrorData(thrown) {
    if (typeof thrown === "object" && thrown !== null && Symbol.for("ConvexError") in thrown) {
        const error = thrown;
        error.data = JSON.stringify((0, _indexJs.convexToJson)(error.data === void 0 ? null : error.data));
        error.ConvexErrorSymbol = Symbol.for("ConvexError");
        return error;
    } else return thrown;
}
function assertNotBrowser() {
    if (typeof window === "undefined" || window.__convexAllowFunctionsInBrowser) return;
    const isRealBrowser = Object.getOwnPropertyDescriptor(globalThis, "window")?.get?.toString().includes("[native code]") ?? false;
    if (isRealBrowser) console.error("Convex functions should not be imported in the browser. This will throw an error in future versions of `convex`. If this is a false negative, please report it to Convex support.");
}
function strictReplacer(key, value) {
    if (value === void 0) throw new Error(`A validator is undefined for field "${key}". This is often caused by circular imports. See https://docs.convex.dev/error#undefined-validator for details.`);
    return value;
}
function exportArgs(functionDefinition) {
    return ()=>{
        let args = (0, _indexJs.v).any();
        if (typeof functionDefinition === "object" && functionDefinition.args !== void 0) args = (0, _validatorJs.asObjectValidator)(functionDefinition.args);
        return JSON.stringify(args.json, strictReplacer);
    };
}
function exportReturns(functionDefinition) {
    return ()=>{
        let returns;
        if (typeof functionDefinition === "object" && functionDefinition.returns !== void 0) returns = (0, _validatorJs.asObjectValidator)(functionDefinition.returns);
        return JSON.stringify(returns ? returns.json : null, strictReplacer);
    };
}
const mutationGeneric = (functionDefinition)=>{
    const handler = typeof functionDefinition === "function" ? functionDefinition : functionDefinition.handler;
    const func = dontCallDirectly("mutation", handler);
    assertNotBrowser();
    func.isMutation = true;
    func.isPublic = true;
    func.invokeMutation = (argsStr)=>invokeMutation(handler, argsStr);
    func.exportArgs = exportArgs(functionDefinition);
    func.exportReturns = exportReturns(functionDefinition);
    func._handler = handler;
    return func;
};
const internalMutationGeneric = (functionDefinition)=>{
    const handler = typeof functionDefinition === "function" ? functionDefinition : functionDefinition.handler;
    const func = dontCallDirectly("internalMutation", handler);
    assertNotBrowser();
    func.isMutation = true;
    func.isInternal = true;
    func.invokeMutation = (argsStr)=>invokeMutation(handler, argsStr);
    func.exportArgs = exportArgs(functionDefinition);
    func.exportReturns = exportReturns(functionDefinition);
    func._handler = handler;
    return func;
};
async function invokeQuery(func, argsStr) {
    const requestId = "";
    const args = (0, _indexJs.jsonToConvex)(JSON.parse(argsStr));
    const queryCtx = {
        db: (0, _databaseImplJs.setupReader)(),
        auth: (0, _authenticationImplJs.setupAuth)(requestId),
        storage: (0, _storageImplJs.setupStorageReader)(requestId),
        runQuery: (reference, args2)=>runUdf("query", reference, args2)
    };
    const result = await invokeFunction(func, queryCtx, args);
    validateReturnValue(result);
    return JSON.stringify((0, _indexJs.convexToJson)(result === void 0 ? null : result));
}
const queryGeneric = (functionDefinition)=>{
    const handler = typeof functionDefinition === "function" ? functionDefinition : functionDefinition.handler;
    const func = dontCallDirectly("query", handler);
    assertNotBrowser();
    func.isQuery = true;
    func.isPublic = true;
    func.invokeQuery = (argsStr)=>invokeQuery(handler, argsStr);
    func.exportArgs = exportArgs(functionDefinition);
    func.exportReturns = exportReturns(functionDefinition);
    func._handler = handler;
    return func;
};
const internalQueryGeneric = (functionDefinition)=>{
    const handler = typeof functionDefinition === "function" ? functionDefinition : functionDefinition.handler;
    const func = dontCallDirectly("internalQuery", handler);
    assertNotBrowser();
    func.isQuery = true;
    func.isInternal = true;
    func.invokeQuery = (argsStr)=>invokeQuery(handler, argsStr);
    func.exportArgs = exportArgs(functionDefinition);
    func.exportReturns = exportReturns(functionDefinition);
    func._handler = handler;
    return func;
};
async function invokeAction(func, requestId, argsStr) {
    const args = (0, _indexJs.jsonToConvex)(JSON.parse(argsStr));
    const calls = (0, _actionsImplJs.setupActionCalls)(requestId);
    const ctx = {
        ...calls,
        auth: (0, _authenticationImplJs.setupAuth)(requestId),
        scheduler: (0, _schedulerImplJs.setupActionScheduler)(requestId),
        storage: (0, _storageImplJs.setupStorageActionWriter)(requestId),
        vectorSearch: (0, _vectorSearchImplJs.setupActionVectorSearch)(requestId)
    };
    const result = await invokeFunction(func, ctx, args);
    return JSON.stringify((0, _indexJs.convexToJson)(result === void 0 ? null : result));
}
const actionGeneric = (functionDefinition)=>{
    const handler = typeof functionDefinition === "function" ? functionDefinition : functionDefinition.handler;
    const func = dontCallDirectly("action", handler);
    assertNotBrowser();
    func.isAction = true;
    func.isPublic = true;
    func.invokeAction = (requestId, argsStr)=>invokeAction(handler, requestId, argsStr);
    func.exportArgs = exportArgs(functionDefinition);
    func.exportReturns = exportReturns(functionDefinition);
    func._handler = handler;
    return func;
};
const internalActionGeneric = (functionDefinition)=>{
    const handler = typeof functionDefinition === "function" ? functionDefinition : functionDefinition.handler;
    const func = dontCallDirectly("internalAction", handler);
    assertNotBrowser();
    func.isAction = true;
    func.isInternal = true;
    func.invokeAction = (requestId, argsStr)=>invokeAction(handler, requestId, argsStr);
    func.exportArgs = exportArgs(functionDefinition);
    func.exportReturns = exportReturns(functionDefinition);
    func._handler = handler;
    return func;
};
async function invokeHttpAction(func, request) {
    const requestId = "";
    const calls = (0, _actionsImplJs.setupActionCalls)(requestId);
    const ctx = {
        ...calls,
        auth: (0, _authenticationImplJs.setupAuth)(requestId),
        storage: (0, _storageImplJs.setupStorageActionWriter)(requestId),
        scheduler: (0, _schedulerImplJs.setupActionScheduler)(requestId),
        vectorSearch: (0, _vectorSearchImplJs.setupActionVectorSearch)(requestId)
    };
    return await invokeFunction(func, ctx, [
        request
    ]);
}
const httpActionGeneric = (func)=>{
    const q = dontCallDirectly("httpAction", func);
    assertNotBrowser();
    q.isHttp = true;
    q.invokeHttpAction = (request)=>invokeHttpAction(func, request);
    q._handler = func;
    return q;
};
async function runUdf(udfType, f, args) {
    const queryArgs = (0, _indexJs1.parseArgs)(args);
    const syscallArgs = {
        udfType,
        args: (0, _indexJs.convexToJson)(queryArgs),
        ...(0, _pathsJs.getFunctionAddress)(f)
    };
    const result = await (0, _syscallJs.performAsyncSyscall)("1.0/runUdf", syscallArgs);
    return (0, _indexJs.jsonToConvex)(result);
}

},{"../../values/index.js":"atHbO","./actions_impl.js":"3XS4h","./vector_search_impl.js":"4IIBV","./authentication_impl.js":"7KLSH","./database_impl.js":"wY8GT","./query_impl.js":"3Rpkd","./scheduler_impl.js":"4nyCw","./storage_impl.js":"k4feZ","../../common/index.js":"jSbKo","./syscall.js":"4FNDy","../../values/validator.js":"7gq7W","../components/paths.js":"alov9","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"3XS4h":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setupActionCalls", ()=>setupActionCalls);
var _indexJs = require("../../values/index.js");
var _indexJs1 = require("../../index.js");
var _syscallJs = require("./syscall.js");
var _indexJs2 = require("../../common/index.js");
var _pathsJs = require("../components/paths.js");
"use strict";
function syscallArgs(requestId, functionReference, args) {
    const address = (0, _pathsJs.getFunctionAddress)(functionReference);
    return {
        ...address,
        args: (0, _indexJs.convexToJson)((0, _indexJs2.parseArgs)(args)),
        version: (0, _indexJs1.version),
        requestId
    };
}
function setupActionCalls(requestId) {
    return {
        runQuery: async (query, args)=>{
            const result = await (0, _syscallJs.performAsyncSyscall)("1.0/actions/query", syscallArgs(requestId, query, args));
            return (0, _indexJs.jsonToConvex)(result);
        },
        runMutation: async (mutation, args)=>{
            const result = await (0, _syscallJs.performAsyncSyscall)("1.0/actions/mutation", syscallArgs(requestId, mutation, args));
            return (0, _indexJs.jsonToConvex)(result);
        },
        runAction: async (action, args)=>{
            const result = await (0, _syscallJs.performAsyncSyscall)("1.0/actions/action", syscallArgs(requestId, action, args));
            return (0, _indexJs.jsonToConvex)(result);
        }
    };
}

},{"../../values/index.js":"atHbO","../../index.js":"76BIQ","./syscall.js":"4FNDy","../../common/index.js":"jSbKo","../components/paths.js":"alov9","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"4FNDy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "performSyscall", ()=>performSyscall);
parcelHelpers.export(exports, "performAsyncSyscall", ()=>performAsyncSyscall);
parcelHelpers.export(exports, "performJsSyscall", ()=>performJsSyscall);
var _errorsJs = require("../../values/errors.js");
var _valueJs = require("../../values/value.js");
"use strict";
function performSyscall(op, arg) {
    if (typeof Convex === "undefined" || Convex.syscall === void 0) throw new Error("The Convex database and auth objects are being used outside of a Convex backend. Did you mean to use `useQuery` or `useMutation` to call a Convex function?");
    const resultStr = Convex.syscall(op, JSON.stringify(arg));
    return JSON.parse(resultStr);
}
async function performAsyncSyscall(op, arg) {
    if (typeof Convex === "undefined" || Convex.asyncSyscall === void 0) throw new Error("The Convex database and auth objects are being used outside of a Convex backend. Did you mean to use `useQuery` or `useMutation` to call a Convex function?");
    let resultStr;
    try {
        resultStr = await Convex.asyncSyscall(op, JSON.stringify(arg));
    } catch (e) {
        if (e.data !== void 0) {
            const rethrown = new (0, _errorsJs.ConvexError)(e.message);
            rethrown.data = (0, _valueJs.jsonToConvex)(e.data);
            throw rethrown;
        }
        throw new Error(e.message);
    }
    return JSON.parse(resultStr);
}
function performJsSyscall(op, arg) {
    if (typeof Convex === "undefined" || Convex.jsSyscall === void 0) throw new Error("The Convex database and auth objects are being used outside of a Convex backend. Did you mean to use `useQuery` or `useMutation` to call a Convex function?");
    return Convex.jsSyscall(op, arg);
}

},{"../../values/errors.js":"8sUSC","../../values/value.js":"3LQpF","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"4IIBV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setupActionVectorSearch", ()=>setupActionVectorSearch);
parcelHelpers.export(exports, "VectorQueryImpl", ()=>VectorQueryImpl);
parcelHelpers.export(exports, "ExpressionImpl", ()=>ExpressionImpl);
parcelHelpers.export(exports, "serializeExpression", ()=>serializeExpression);
parcelHelpers.export(exports, "filterBuilderImpl", ()=>filterBuilderImpl);
var _syscallJs = require("./syscall.js");
var _indexJs = require("../../index.js");
var _vectorSearchJs = require("../vector_search.js");
var _validateJs = require("./validate.js");
var _valueJs = require("../../values/value.js");
"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
function setupActionVectorSearch(requestId) {
    return async (tableName, indexName, query)=>{
        (0, _validateJs.validateArg)(tableName, 1, "vectorSearch", "tableName");
        (0, _validateJs.validateArg)(indexName, 2, "vectorSearch", "indexName");
        (0, _validateJs.validateArg)(query, 3, "vectorSearch", "query");
        if (!query.vector || !Array.isArray(query.vector) || query.vector.length === 0) throw Error("`vector` must be a non-empty Array in vectorSearch");
        return await new VectorQueryImpl(requestId, tableName + "." + indexName, query).collect();
    };
}
class VectorQueryImpl {
    constructor(requestId, indexName, query){
        __publicField(this, "requestId");
        __publicField(this, "state");
        this.requestId = requestId;
        const filters = query.filter ? serializeExpression(query.filter(filterBuilderImpl)) : null;
        this.state = {
            type: "preparing",
            query: {
                indexName,
                limit: query.limit,
                vector: query.vector,
                expressions: filters
            }
        };
    }
    async collect() {
        if (this.state.type === "consumed") throw new Error("This query is closed and can't emit any more values.");
        const query = this.state.query;
        this.state = {
            type: "consumed"
        };
        const { results } = await (0, _syscallJs.performAsyncSyscall)("1.0/actions/vectorSearch", {
            requestId: this.requestId,
            version: (0, _indexJs.version),
            query
        });
        return results;
    }
}
class ExpressionImpl extends (0, _vectorSearchJs.FilterExpression) {
    constructor(inner){
        super();
        __publicField(this, "inner");
        this.inner = inner;
    }
    serialize() {
        return this.inner;
    }
}
function serializeExpression(expr) {
    if (expr instanceof ExpressionImpl) return expr.serialize();
    else return {
        $literal: (0, _valueJs.convexOrUndefinedToJson)(expr)
    };
}
const filterBuilderImpl = {
    //  Comparisons  /////////////////////////////////////////////////////////////
    eq (fieldName, value) {
        if (typeof fieldName !== "string") throw new Error("The first argument to `q.eq` must be a field name.");
        return new ExpressionImpl({
            $eq: [
                serializeExpression(new ExpressionImpl({
                    $field: fieldName
                })),
                serializeExpression(value)
            ]
        });
    },
    //  Logic  ///////////////////////////////////////////////////////////////////
    or (...exprs) {
        return new ExpressionImpl({
            $or: exprs.map(serializeExpression)
        });
    }
};

},{"./syscall.js":"4FNDy","../../index.js":"76BIQ","../vector_search.js":"4ecPM","./validate.js":"4awhk","../../values/value.js":"3LQpF","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"4ecPM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FilterExpression", ()=>FilterExpression);
"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
class FilterExpression {
    /**
   * @internal
   */ constructor(){
        // Property for nominal type support.
        __publicField(this, "_isExpression");
        // Property to distinguish expressions by the type they resolve to.
        __publicField(this, "_value");
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"4awhk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "validateArg", ()=>validateArg);
parcelHelpers.export(exports, "validateArgIsInteger", ()=>validateArgIsInteger);
parcelHelpers.export(exports, "validateArgIsNonNegativeInteger", ()=>validateArgIsNonNegativeInteger);
"use strict";
function validateArg(arg, idx, method, argName) {
    if (arg === void 0) throw new TypeError(`Must provide arg ${idx} \`${argName}\` to \`${method}\``);
}
function validateArgIsInteger(arg, idx, method, argName) {
    if (!Number.isInteger(arg)) throw new TypeError(`Arg ${idx} \`${argName}\` to \`${method}\` must be an integer`);
}
function validateArgIsNonNegativeInteger(arg, idx, method, argName) {
    if (!Number.isInteger(arg) || arg < 0) throw new TypeError(`Arg ${idx} \`${argName}\` to \`${method}\` must be a non-negative integer`);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"7KLSH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setupAuth", ()=>setupAuth);
var _syscallJs = require("./syscall.js");
"use strict";
function setupAuth(requestId) {
    return {
        getUserIdentity: async ()=>{
            return await (0, _syscallJs.performAsyncSyscall)("1.0/getUserIdentity", {
                requestId
            });
        }
    };
}

},{"./syscall.js":"4FNDy","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"wY8GT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setupReader", ()=>setupReader);
parcelHelpers.export(exports, "setupWriter", ()=>setupWriter);
var _indexJs = require("../../values/index.js");
var _syscallJs = require("./syscall.js");
var _queryImplJs = require("./query_impl.js");
var _validateJs = require("./validate.js");
var _indexJs1 = require("../../index.js");
var _valueJs = require("../../values/value.js");
"use strict";
async function get(table, id, isSystem) {
    (0, _validateJs.validateArg)(id, 1, "get", "id");
    if (typeof id !== "string") throw new Error(`Invalid argument \`id\` for \`db.get\`, expected string but got '${typeof id}': ${id}`);
    const args = {
        id: (0, _indexJs.convexToJson)(id),
        isSystem,
        version: (0, _indexJs1.version),
        table
    };
    const syscallJSON = await (0, _syscallJs.performAsyncSyscall)("1.0/get", args);
    return (0, _indexJs.jsonToConvex)(syscallJSON);
}
function setupReader() {
    const reader = (isSystem = false)=>{
        return {
            get: async (arg0, arg1)=>{
                return arg1 !== void 0 ? await get(arg0, arg1, isSystem) : await get(void 0, arg0, isSystem);
            },
            query: (tableName)=>{
                return new TableReader(tableName, isSystem).query();
            },
            normalizeId: (tableName, id)=>{
                (0, _validateJs.validateArg)(tableName, 1, "normalizeId", "tableName");
                (0, _validateJs.validateArg)(id, 2, "normalizeId", "id");
                const accessingSystemTable = tableName.startsWith("_");
                if (accessingSystemTable !== isSystem) throw new Error(`${accessingSystemTable ? "System" : "User"} tables can only be accessed from db.${isSystem ? "" : "system."}normalizeId().`);
                const syscallJSON = (0, _syscallJs.performSyscall)("1.0/db/normalizeId", {
                    table: tableName,
                    idString: id
                });
                const syscallResult = (0, _indexJs.jsonToConvex)(syscallJSON);
                return syscallResult.id;
            },
            // We set the system reader on the next line
            system: null,
            table: (tableName)=>{
                return new TableReader(tableName, isSystem);
            }
        };
    };
    const { system: _, ...rest } = reader(true);
    const r = reader();
    r.system = rest;
    return r;
}
async function insert(tableName, value) {
    if (tableName.startsWith("_")) throw new Error("System tables (prefixed with `_`) are read-only.");
    (0, _validateJs.validateArg)(tableName, 1, "insert", "table");
    (0, _validateJs.validateArg)(value, 2, "insert", "value");
    const syscallJSON = await (0, _syscallJs.performAsyncSyscall)("1.0/insert", {
        table: tableName,
        value: (0, _indexJs.convexToJson)(value)
    });
    const syscallResult = (0, _indexJs.jsonToConvex)(syscallJSON);
    return syscallResult._id;
}
async function patch(table, id, value) {
    (0, _validateJs.validateArg)(id, 1, "patch", "id");
    (0, _validateJs.validateArg)(value, 2, "patch", "value");
    await (0, _syscallJs.performAsyncSyscall)("1.0/shallowMerge", {
        id: (0, _indexJs.convexToJson)(id),
        value: (0, _valueJs.patchValueToJson)(value),
        table
    });
}
async function replace(table, id, value) {
    (0, _validateJs.validateArg)(id, 1, "replace", "id");
    (0, _validateJs.validateArg)(value, 2, "replace", "value");
    await (0, _syscallJs.performAsyncSyscall)("1.0/replace", {
        id: (0, _indexJs.convexToJson)(id),
        value: (0, _indexJs.convexToJson)(value),
        table
    });
}
async function delete_(table, id) {
    (0, _validateJs.validateArg)(id, 1, "delete", "id");
    await (0, _syscallJs.performAsyncSyscall)("1.0/remove", {
        id: (0, _indexJs.convexToJson)(id),
        table
    });
}
function setupWriter() {
    const reader = setupReader();
    return {
        get: reader.get,
        query: reader.query,
        normalizeId: reader.normalizeId,
        system: reader.system,
        insert: async (table, value)=>{
            return await insert(table, value);
        },
        patch: async (arg0, arg1, arg2)=>{
            return arg2 !== void 0 ? await patch(arg0, arg1, arg2) : await patch(void 0, arg0, arg1);
        },
        replace: async (arg0, arg1, arg2)=>{
            return arg2 !== void 0 ? await replace(arg0, arg1, arg2) : await replace(void 0, arg0, arg1);
        },
        delete: async (arg0, arg1)=>{
            return arg1 !== void 0 ? await delete_(arg0, arg1) : await delete_(void 0, arg0);
        },
        table: (tableName)=>{
            return new TableWriter(tableName, false);
        }
    };
}
class TableReader {
    constructor(tableName, isSystem){
        this.tableName = tableName;
        this.isSystem = isSystem;
    }
    async get(id) {
        return get(this.tableName, id, this.isSystem);
    }
    query() {
        const accessingSystemTable = this.tableName.startsWith("_");
        if (accessingSystemTable !== this.isSystem) throw new Error(`${accessingSystemTable ? "System" : "User"} tables can only be accessed from db.${this.isSystem ? "" : "system."}query().`);
        return new (0, _queryImplJs.QueryInitializerImpl)(this.tableName);
    }
}
class TableWriter extends TableReader {
    async insert(value) {
        return insert(this.tableName, value);
    }
    async patch(id, value) {
        return patch(this.tableName, id, value);
    }
    async replace(id, value) {
        return replace(this.tableName, id, value);
    }
    async delete(id) {
        return delete_(this.tableName, id);
    }
}

},{"../../values/index.js":"atHbO","./syscall.js":"4FNDy","./query_impl.js":"3Rpkd","./validate.js":"4awhk","../../index.js":"76BIQ","../../values/value.js":"3LQpF","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"3Rpkd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "QueryInitializerImpl", ()=>QueryInitializerImpl);
parcelHelpers.export(exports, "QueryImpl", ()=>QueryImpl);
var _indexJs = require("../../values/index.js");
var _syscallJs = require("./syscall.js");
var _filterBuilderImplJs = require("./filter_builder_impl.js");
var _indexRangeBuilderImplJs = require("./index_range_builder_impl.js");
var _searchFilterBuilderImplJs = require("./search_filter_builder_impl.js");
var _validateJs = require("./validate.js");
var _indexJs1 = require("../../index.js");
"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
const MAX_QUERY_OPERATORS = 256;
class QueryInitializerImpl {
    constructor(tableName){
        __publicField(this, "tableName");
        this.tableName = tableName;
    }
    withIndex(indexName, indexRange) {
        (0, _validateJs.validateArg)(indexName, 1, "withIndex", "indexName");
        let rangeBuilder = (0, _indexRangeBuilderImplJs.IndexRangeBuilderImpl).new();
        if (indexRange !== void 0) rangeBuilder = indexRange(rangeBuilder);
        return new QueryImpl({
            source: {
                type: "IndexRange",
                indexName: this.tableName + "." + indexName,
                range: rangeBuilder.export(),
                order: null
            },
            operators: []
        });
    }
    withSearchIndex(indexName, searchFilter) {
        (0, _validateJs.validateArg)(indexName, 1, "withSearchIndex", "indexName");
        (0, _validateJs.validateArg)(searchFilter, 2, "withSearchIndex", "searchFilter");
        const searchFilterBuilder = (0, _searchFilterBuilderImplJs.SearchFilterBuilderImpl).new();
        return new QueryImpl({
            source: {
                type: "Search",
                indexName: this.tableName + "." + indexName,
                filters: searchFilter(searchFilterBuilder).export()
            },
            operators: []
        });
    }
    fullTableScan() {
        return new QueryImpl({
            source: {
                type: "FullTableScan",
                tableName: this.tableName,
                order: null
            },
            operators: []
        });
    }
    order(order) {
        return this.fullTableScan().order(order);
    }
    // This is internal API and should not be exposed to developers yet.
    async count() {
        const syscallJSON = await (0, _syscallJs.performAsyncSyscall)("1.0/count", {
            table: this.tableName
        });
        const syscallResult = (0, _indexJs.jsonToConvex)(syscallJSON);
        return syscallResult;
    }
    filter(predicate) {
        return this.fullTableScan().filter(predicate);
    }
    limit(n) {
        return this.fullTableScan().limit(n);
    }
    collect() {
        return this.fullTableScan().collect();
    }
    take(n) {
        return this.fullTableScan().take(n);
    }
    paginate(paginationOpts) {
        return this.fullTableScan().paginate(paginationOpts);
    }
    first() {
        return this.fullTableScan().first();
    }
    unique() {
        return this.fullTableScan().unique();
    }
    [Symbol.asyncIterator]() {
        return this.fullTableScan()[Symbol.asyncIterator]();
    }
}
function throwClosedError(type) {
    throw new Error(type === "consumed" ? "This query is closed and can't emit any more values." : "This query has been chained with another operator and can't be reused.");
}
class QueryImpl {
    constructor(query){
        __publicField(this, "state");
        __publicField(this, "tableNameForErrorMessages");
        this.state = {
            type: "preparing",
            query
        };
        if (query.source.type === "FullTableScan") this.tableNameForErrorMessages = query.source.tableName;
        else this.tableNameForErrorMessages = query.source.indexName.split(".")[0];
    }
    takeQuery() {
        if (this.state.type !== "preparing") throw new Error("A query can only be chained once and can't be chained after iteration begins.");
        const query = this.state.query;
        this.state = {
            type: "closed"
        };
        return query;
    }
    startQuery() {
        if (this.state.type === "executing") throw new Error("Iteration can only begin on a query once.");
        if (this.state.type === "closed" || this.state.type === "consumed") throwClosedError(this.state.type);
        const query = this.state.query;
        const { queryId } = (0, _syscallJs.performSyscall)("1.0/queryStream", {
            query,
            version: (0, _indexJs1.version)
        });
        this.state = {
            type: "executing",
            queryId
        };
        return queryId;
    }
    closeQuery() {
        if (this.state.type === "executing") {
            const queryId = this.state.queryId;
            (0, _syscallJs.performSyscall)("1.0/queryCleanup", {
                queryId
            });
        }
        this.state = {
            type: "consumed"
        };
    }
    order(order) {
        (0, _validateJs.validateArg)(order, 1, "order", "order");
        const query = this.takeQuery();
        if (query.source.type === "Search") throw new Error("Search queries must always be in relevance order. Can not set order manually.");
        if (query.source.order !== null) throw new Error("Queries may only specify order at most once");
        query.source.order = order;
        return new QueryImpl(query);
    }
    filter(predicate) {
        (0, _validateJs.validateArg)(predicate, 1, "filter", "predicate");
        const query = this.takeQuery();
        if (query.operators.length >= MAX_QUERY_OPERATORS) throw new Error(`Can't construct query with more than ${MAX_QUERY_OPERATORS} operators`);
        query.operators.push({
            filter: (0, _filterBuilderImplJs.serializeExpression)(predicate((0, _filterBuilderImplJs.filterBuilderImpl)))
        });
        return new QueryImpl(query);
    }
    limit(n) {
        (0, _validateJs.validateArg)(n, 1, "limit", "n");
        const query = this.takeQuery();
        query.operators.push({
            limit: n
        });
        return new QueryImpl(query);
    }
    [Symbol.asyncIterator]() {
        this.startQuery();
        return this;
    }
    async next() {
        if (this.state.type === "closed" || this.state.type === "consumed") throwClosedError(this.state.type);
        const queryId = this.state.type === "preparing" ? this.startQuery() : this.state.queryId;
        const { value, done } = await (0, _syscallJs.performAsyncSyscall)("1.0/queryStreamNext", {
            queryId
        });
        if (done) this.closeQuery();
        const convexValue = (0, _indexJs.jsonToConvex)(value);
        return {
            value: convexValue,
            done
        };
    }
    return() {
        this.closeQuery();
        return Promise.resolve({
            done: true,
            value: void 0
        });
    }
    async paginate(paginationOpts) {
        (0, _validateJs.validateArg)(paginationOpts, 1, "paginate", "options");
        if (typeof paginationOpts?.numItems !== "number" || paginationOpts.numItems < 0) throw new Error(`\`options.numItems\` must be a positive number. Received \`${paginationOpts?.numItems}\`.`);
        const query = this.takeQuery();
        const pageSize = paginationOpts.numItems;
        const cursor = paginationOpts.cursor;
        const endCursor = paginationOpts?.endCursor ?? null;
        const maximumRowsRead = paginationOpts.maximumRowsRead ?? null;
        const { page, isDone, continueCursor, splitCursor, pageStatus } = await (0, _syscallJs.performAsyncSyscall)("1.0/queryPage", {
            query,
            cursor,
            endCursor,
            pageSize,
            maximumRowsRead,
            maximumBytesRead: paginationOpts.maximumBytesRead,
            version: (0, _indexJs1.version)
        });
        return {
            page: page.map((json)=>(0, _indexJs.jsonToConvex)(json)),
            isDone,
            continueCursor,
            splitCursor,
            pageStatus
        };
    }
    async collect() {
        const out = [];
        for await (const item of this)out.push(item);
        return out;
    }
    async take(n) {
        (0, _validateJs.validateArg)(n, 1, "take", "n");
        (0, _validateJs.validateArgIsNonNegativeInteger)(n, 1, "take", "n");
        return this.limit(n).collect();
    }
    async first() {
        const first_array = await this.take(1);
        return first_array.length === 0 ? null : first_array[0];
    }
    async unique() {
        const first_two_array = await this.take(2);
        if (first_two_array.length === 0) return null;
        if (first_two_array.length === 2) throw new Error(`unique() query returned more than one result from table ${this.tableNameForErrorMessages}:
 [${first_two_array[0]._id}, ${first_two_array[1]._id}, ...]`);
        return first_two_array[0];
    }
}

},{"../../values/index.js":"atHbO","./syscall.js":"4FNDy","./filter_builder_impl.js":"l9Nj0","./index_range_builder_impl.js":"5uydK","./search_filter_builder_impl.js":"2WUBa","./validate.js":"4awhk","../../index.js":"76BIQ","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"l9Nj0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ExpressionImpl", ()=>ExpressionImpl);
parcelHelpers.export(exports, "serializeExpression", ()=>serializeExpression);
parcelHelpers.export(exports, "filterBuilderImpl", ()=>filterBuilderImpl);
var _valueJs = require("../../values/value.js");
var _filterBuilderJs = require("../filter_builder.js");
"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
class ExpressionImpl extends (0, _filterBuilderJs.Expression) {
    constructor(inner){
        super();
        __publicField(this, "inner");
        this.inner = inner;
    }
    serialize() {
        return this.inner;
    }
}
function serializeExpression(expr) {
    if (expr instanceof ExpressionImpl) return expr.serialize();
    else return {
        $literal: (0, _valueJs.convexOrUndefinedToJson)(expr)
    };
}
const filterBuilderImpl = {
    //  Comparisons  /////////////////////////////////////////////////////////////
    eq (l, r) {
        return new ExpressionImpl({
            $eq: [
                serializeExpression(l),
                serializeExpression(r)
            ]
        });
    },
    neq (l, r) {
        return new ExpressionImpl({
            $neq: [
                serializeExpression(l),
                serializeExpression(r)
            ]
        });
    },
    lt (l, r) {
        return new ExpressionImpl({
            $lt: [
                serializeExpression(l),
                serializeExpression(r)
            ]
        });
    },
    lte (l, r) {
        return new ExpressionImpl({
            $lte: [
                serializeExpression(l),
                serializeExpression(r)
            ]
        });
    },
    gt (l, r) {
        return new ExpressionImpl({
            $gt: [
                serializeExpression(l),
                serializeExpression(r)
            ]
        });
    },
    gte (l, r) {
        return new ExpressionImpl({
            $gte: [
                serializeExpression(l),
                serializeExpression(r)
            ]
        });
    },
    //  Arithmetic  //////////////////////////////////////////////////////////////
    add (l, r) {
        return new ExpressionImpl({
            $add: [
                serializeExpression(l),
                serializeExpression(r)
            ]
        });
    },
    sub (l, r) {
        return new ExpressionImpl({
            $sub: [
                serializeExpression(l),
                serializeExpression(r)
            ]
        });
    },
    mul (l, r) {
        return new ExpressionImpl({
            $mul: [
                serializeExpression(l),
                serializeExpression(r)
            ]
        });
    },
    div (l, r) {
        return new ExpressionImpl({
            $div: [
                serializeExpression(l),
                serializeExpression(r)
            ]
        });
    },
    mod (l, r) {
        return new ExpressionImpl({
            $mod: [
                serializeExpression(l),
                serializeExpression(r)
            ]
        });
    },
    neg (x) {
        return new ExpressionImpl({
            $neg: serializeExpression(x)
        });
    },
    //  Logic  ///////////////////////////////////////////////////////////////////
    and (...exprs) {
        return new ExpressionImpl({
            $and: exprs.map(serializeExpression)
        });
    },
    or (...exprs) {
        return new ExpressionImpl({
            $or: exprs.map(serializeExpression)
        });
    },
    not (x) {
        return new ExpressionImpl({
            $not: serializeExpression(x)
        });
    },
    //  Other  ///////////////////////////////////////////////////////////////////
    field (fieldPath) {
        return new ExpressionImpl({
            $field: fieldPath
        });
    }
};

},{"../../values/value.js":"3LQpF","../filter_builder.js":"dmP5O","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"dmP5O":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Expression", ()=>Expression);
"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
class Expression {
    /**
   * @internal
   */ constructor(){
        // Property for nominal type support.
        __publicField(this, "_isExpression");
        // Property to distinguish expressions by the type they resolve to.
        __publicField(this, "_value");
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"5uydK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "IndexRangeBuilderImpl", ()=>IndexRangeBuilderImpl);
var _valueJs = require("../../values/value.js");
var _indexRangeBuilderJs = require("../index_range_builder.js");
"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
class IndexRangeBuilderImpl extends (0, _indexRangeBuilderJs.IndexRange) {
    constructor(rangeExpressions){
        super();
        __publicField(this, "rangeExpressions");
        __publicField(this, "isConsumed");
        this.rangeExpressions = rangeExpressions;
        this.isConsumed = false;
    }
    static new() {
        return new IndexRangeBuilderImpl([]);
    }
    consume() {
        if (this.isConsumed) throw new Error("IndexRangeBuilder has already been used! Chain your method calls like `q => q.eq(...).eq(...)`. See https://docs.convex.dev/using/indexes");
        this.isConsumed = true;
    }
    eq(fieldName, value) {
        this.consume();
        return new IndexRangeBuilderImpl(this.rangeExpressions.concat({
            type: "Eq",
            fieldPath: fieldName,
            value: (0, _valueJs.convexOrUndefinedToJson)(value)
        }));
    }
    gt(fieldName, value) {
        this.consume();
        return new IndexRangeBuilderImpl(this.rangeExpressions.concat({
            type: "Gt",
            fieldPath: fieldName,
            value: (0, _valueJs.convexOrUndefinedToJson)(value)
        }));
    }
    gte(fieldName, value) {
        this.consume();
        return new IndexRangeBuilderImpl(this.rangeExpressions.concat({
            type: "Gte",
            fieldPath: fieldName,
            value: (0, _valueJs.convexOrUndefinedToJson)(value)
        }));
    }
    lt(fieldName, value) {
        this.consume();
        return new IndexRangeBuilderImpl(this.rangeExpressions.concat({
            type: "Lt",
            fieldPath: fieldName,
            value: (0, _valueJs.convexOrUndefinedToJson)(value)
        }));
    }
    lte(fieldName, value) {
        this.consume();
        return new IndexRangeBuilderImpl(this.rangeExpressions.concat({
            type: "Lte",
            fieldPath: fieldName,
            value: (0, _valueJs.convexOrUndefinedToJson)(value)
        }));
    }
    export() {
        this.consume();
        return this.rangeExpressions;
    }
}

},{"../../values/value.js":"3LQpF","../index_range_builder.js":"fq75B","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"fq75B":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "IndexRange", ()=>IndexRange);
"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
class IndexRange {
    /**
   * @internal
   */ constructor(){
        // Property for nominal type support.
        __publicField(this, "_isIndexRange");
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"2WUBa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SearchFilterBuilderImpl", ()=>SearchFilterBuilderImpl);
var _valueJs = require("../../values/value.js");
var _searchFilterBuilderJs = require("../search_filter_builder.js");
var _validateJs = require("./validate.js");
"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
class SearchFilterBuilderImpl extends (0, _searchFilterBuilderJs.SearchFilter) {
    constructor(filters){
        super();
        __publicField(this, "filters");
        __publicField(this, "isConsumed");
        this.filters = filters;
        this.isConsumed = false;
    }
    static new() {
        return new SearchFilterBuilderImpl([]);
    }
    consume() {
        if (this.isConsumed) throw new Error("SearchFilterBuilder has already been used! Chain your method calls like `q => q.search(...).eq(...)`.");
        this.isConsumed = true;
    }
    search(fieldName, query) {
        (0, _validateJs.validateArg)(fieldName, 1, "search", "fieldName");
        (0, _validateJs.validateArg)(query, 2, "search", "query");
        this.consume();
        return new SearchFilterBuilderImpl(this.filters.concat({
            type: "Search",
            fieldPath: fieldName,
            value: query
        }));
    }
    eq(fieldName, value) {
        (0, _validateJs.validateArg)(fieldName, 1, "eq", "fieldName");
        if (arguments.length !== 2) (0, _validateJs.validateArg)(value, 2, "search", "value");
        this.consume();
        return new SearchFilterBuilderImpl(this.filters.concat({
            type: "Eq",
            fieldPath: fieldName,
            value: (0, _valueJs.convexOrUndefinedToJson)(value)
        }));
    }
    export() {
        this.consume();
        return this.filters;
    }
}

},{"../../values/value.js":"3LQpF","../search_filter_builder.js":"f5Cbq","./validate.js":"4awhk","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"f5Cbq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SearchFilter", ()=>SearchFilter);
"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
class SearchFilter {
    /**
   * @internal
   */ constructor(){
        // Property for nominal type support.
        __publicField(this, "_isSearchFilter");
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"4nyCw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setupMutationScheduler", ()=>setupMutationScheduler);
parcelHelpers.export(exports, "setupActionScheduler", ()=>setupActionScheduler);
var _indexJs = require("../../values/index.js");
var _indexJs1 = require("../../index.js");
var _syscallJs = require("./syscall.js");
var _indexJs2 = require("../../common/index.js");
var _validateJs = require("./validate.js");
var _pathsJs = require("../components/paths.js");
"use strict";
function setupMutationScheduler() {
    return {
        runAfter: async (delayMs, functionReference, args)=>{
            const syscallArgs = runAfterSyscallArgs(delayMs, functionReference, args);
            return await (0, _syscallJs.performAsyncSyscall)("1.0/schedule", syscallArgs);
        },
        runAt: async (ms_since_epoch_or_date, functionReference, args)=>{
            const syscallArgs = runAtSyscallArgs(ms_since_epoch_or_date, functionReference, args);
            return await (0, _syscallJs.performAsyncSyscall)("1.0/schedule", syscallArgs);
        },
        cancel: async (id)=>{
            (0, _validateJs.validateArg)(id, 1, "cancel", "id");
            const args = {
                id: (0, _indexJs.convexToJson)(id)
            };
            await (0, _syscallJs.performAsyncSyscall)("1.0/cancel_job", args);
        }
    };
}
function setupActionScheduler(requestId) {
    return {
        runAfter: async (delayMs, functionReference, args)=>{
            const syscallArgs = {
                requestId,
                ...runAfterSyscallArgs(delayMs, functionReference, args)
            };
            return await (0, _syscallJs.performAsyncSyscall)("1.0/actions/schedule", syscallArgs);
        },
        runAt: async (ms_since_epoch_or_date, functionReference, args)=>{
            const syscallArgs = {
                requestId,
                ...runAtSyscallArgs(ms_since_epoch_or_date, functionReference, args)
            };
            return await (0, _syscallJs.performAsyncSyscall)("1.0/actions/schedule", syscallArgs);
        },
        cancel: async (id)=>{
            (0, _validateJs.validateArg)(id, 1, "cancel", "id");
            const syscallArgs = {
                id: (0, _indexJs.convexToJson)(id)
            };
            return await (0, _syscallJs.performAsyncSyscall)("1.0/actions/cancel_job", syscallArgs);
        }
    };
}
function runAfterSyscallArgs(delayMs, functionReference, args) {
    if (typeof delayMs !== "number") throw new Error("`delayMs` must be a number");
    if (!isFinite(delayMs)) throw new Error("`delayMs` must be a finite number");
    if (delayMs < 0) throw new Error("`delayMs` must be non-negative");
    const functionArgs = (0, _indexJs2.parseArgs)(args);
    const address = (0, _pathsJs.getFunctionAddress)(functionReference);
    const ts = (Date.now() + delayMs) / 1e3;
    return {
        ...address,
        ts,
        args: (0, _indexJs.convexToJson)(functionArgs),
        version: (0, _indexJs1.version)
    };
}
function runAtSyscallArgs(ms_since_epoch_or_date, functionReference, args) {
    let ts;
    if (ms_since_epoch_or_date instanceof Date) ts = ms_since_epoch_or_date.valueOf() / 1e3;
    else if (typeof ms_since_epoch_or_date === "number") ts = ms_since_epoch_or_date / 1e3;
    else throw new Error("The invoke time must a Date or a timestamp");
    const address = (0, _pathsJs.getFunctionAddress)(functionReference);
    const functionArgs = (0, _indexJs2.parseArgs)(args);
    return {
        ...address,
        ts,
        args: (0, _indexJs.convexToJson)(functionArgs),
        version: (0, _indexJs1.version)
    };
}

},{"../../values/index.js":"atHbO","../../index.js":"76BIQ","./syscall.js":"4FNDy","../../common/index.js":"jSbKo","./validate.js":"4awhk","../components/paths.js":"alov9","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"k4feZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setupStorageReader", ()=>setupStorageReader);
parcelHelpers.export(exports, "setupStorageWriter", ()=>setupStorageWriter);
parcelHelpers.export(exports, "setupStorageActionWriter", ()=>setupStorageActionWriter);
var _indexJs = require("../../index.js");
var _syscallJs = require("./syscall.js");
var _validateJs = require("./validate.js");
"use strict";
function setupStorageReader(requestId) {
    return {
        getUrl: async (storageId)=>{
            (0, _validateJs.validateArg)(storageId, 1, "getUrl", "storageId");
            return await (0, _syscallJs.performAsyncSyscall)("1.0/storageGetUrl", {
                requestId,
                version: (0, _indexJs.version),
                storageId
            });
        },
        getMetadata: async (storageId)=>{
            return await (0, _syscallJs.performAsyncSyscall)("1.0/storageGetMetadata", {
                requestId,
                version: (0, _indexJs.version),
                storageId
            });
        }
    };
}
function setupStorageWriter(requestId) {
    const reader = setupStorageReader(requestId);
    return {
        generateUploadUrl: async ()=>{
            return await (0, _syscallJs.performAsyncSyscall)("1.0/storageGenerateUploadUrl", {
                requestId,
                version: (0, _indexJs.version)
            });
        },
        delete: async (storageId)=>{
            await (0, _syscallJs.performAsyncSyscall)("1.0/storageDelete", {
                requestId,
                version: (0, _indexJs.version),
                storageId
            });
        },
        getUrl: reader.getUrl,
        getMetadata: reader.getMetadata
    };
}
function setupStorageActionWriter(requestId) {
    const writer = setupStorageWriter(requestId);
    return {
        ...writer,
        store: async (blob, options)=>{
            return await (0, _syscallJs.performJsSyscall)("storage/storeBlob", {
                requestId,
                version: (0, _indexJs.version),
                blob,
                options
            });
        },
        get: async (storageId)=>{
            return await (0, _syscallJs.performJsSyscall)("storage/getBlob", {
                requestId,
                version: (0, _indexJs.version),
                storageId
            });
        }
    };
}

},{"../../index.js":"76BIQ","./syscall.js":"4FNDy","./validate.js":"4awhk","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"l2LyC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "paginationOptsValidator", ()=>paginationOptsValidator);
parcelHelpers.export(exports, "paginationResultValidator", ()=>paginationResultValidator);
var _validatorJs = require("../values/validator.js");
"use strict";
const paginationOptsValidator = (0, _validatorJs.v).object({
    numItems: (0, _validatorJs.v).number(),
    cursor: (0, _validatorJs.v).union((0, _validatorJs.v).string(), (0, _validatorJs.v).null()),
    endCursor: (0, _validatorJs.v).optional((0, _validatorJs.v).union((0, _validatorJs.v).string(), (0, _validatorJs.v).null())),
    id: (0, _validatorJs.v).optional((0, _validatorJs.v).number()),
    maximumRowsRead: (0, _validatorJs.v).optional((0, _validatorJs.v).number()),
    maximumBytesRead: (0, _validatorJs.v).optional((0, _validatorJs.v).number())
});
function paginationResultValidator(itemValidator) {
    return (0, _validatorJs.v).object({
        page: (0, _validatorJs.v).array(itemValidator),
        continueCursor: (0, _validatorJs.v).string(),
        isDone: (0, _validatorJs.v).boolean(),
        splitCursor: (0, _validatorJs.v).optional((0, _validatorJs.v).union((0, _validatorJs.v).string(), (0, _validatorJs.v).null())),
        pageStatus: (0, _validatorJs.v).optional((0, _validatorJs.v).union((0, _validatorJs.v).literal("SplitRecommended"), (0, _validatorJs.v).literal("SplitRequired"), (0, _validatorJs.v).null()))
    });
}

},{"../values/validator.js":"7gq7W","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"dI7vT":[function(require,module,exports) {
"use strict";

},{}],"4G5Pl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "cronJobs", ()=>cronJobs);
parcelHelpers.export(exports, "Crons", ()=>Crons);
var _apiJs = require("../server/api.js");
var _indexJs = require("../common/index.js");
var _indexJs1 = require("../values/index.js");
"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
const DAYS_OF_WEEK = [
    "sunday",
    "monday",
    "tuesday",
    "wednesday",
    "thursday",
    "friday",
    "saturday"
];
const cronJobs = ()=>new Crons();
function validateIntervalNumber(n) {
    if (!Number.isInteger(n) || n <= 0) throw new Error("Interval must be an integer greater than 0");
}
function validatedDayOfMonth(n) {
    if (!Number.isInteger(n) || n < 1 || n > 31) throw new Error("Day of month must be an integer from 1 to 31");
    return n;
}
function validatedDayOfWeek(s) {
    if (!DAYS_OF_WEEK.includes(s)) throw new Error('Day of week must be a string like "monday".');
    return s;
}
function validatedHourOfDay(n) {
    if (!Number.isInteger(n) || n < 0 || n > 23) throw new Error("Hour of day must be an integer from 0 to 23");
    return n;
}
function validatedMinuteOfHour(n) {
    if (!Number.isInteger(n) || n < 0 || n > 59) throw new Error("Minute of hour must be an integer from 0 to 59");
    return n;
}
function validatedCronString(s) {
    return s;
}
function validatedCronIdentifier(s) {
    if (!s.match(/^[ -~]*$/)) throw new Error(`Invalid cron identifier ${s}: use ASCII letters that are not control characters`);
    return s;
}
class Crons {
    constructor(){
        __publicField(this, "crons");
        __publicField(this, "isCrons");
        this.isCrons = true;
        this.crons = {};
    }
    /** @internal */ schedule(cronIdentifier, schedule, functionReference, args) {
        const cronArgs = (0, _indexJs.parseArgs)(args);
        validatedCronIdentifier(cronIdentifier);
        if (cronIdentifier in this.crons) throw new Error(`Cron identifier registered twice: ${cronIdentifier}`);
        this.crons[cronIdentifier] = {
            name: (0, _apiJs.getFunctionName)(functionReference),
            args: [
                (0, _indexJs1.convexToJson)(cronArgs)
            ],
            schedule
        };
    }
    /**
   * Schedule a mutation or action to run at some interval.
   *
   * ```js
   * crons.interval("Clear presence data", {seconds: 30}, api.presence.clear);
   * ```
   *
   * @param identifier - A unique name for this scheduled job.
   * @param schedule - The time between runs for this scheduled job.
   * @param functionReference - A {@link FunctionReference} for the function
   * to schedule.
   * @param args - The arguments to the function.
   */ interval(cronIdentifier, schedule, functionReference, ...args) {
        const s = schedule;
        const hasSeconds = +("seconds" in s && s.seconds !== void 0);
        const hasMinutes = +("minutes" in s && s.minutes !== void 0);
        const hasHours = +("hours" in s && s.hours !== void 0);
        const total = hasSeconds + hasMinutes + hasHours;
        if (total !== 1) throw new Error("Must specify one of seconds, minutes, or hours");
        if (hasSeconds) validateIntervalNumber(schedule.seconds);
        else if (hasMinutes) validateIntervalNumber(schedule.minutes);
        else if (hasHours) validateIntervalNumber(schedule.hours);
        this.schedule(cronIdentifier, {
            ...schedule,
            type: "interval"
        }, functionReference, ...args);
    }
    /**
   * Schedule a mutation or action to run on an hourly basis.
   *
   * ```js
   * crons.hourly(
   *   "Reset high scores",
   *   {
   *     minuteUTC: 30,
   *   },
   *   api.scores.reset
   * )
   * ```
   *
   * @param cronIdentifier - A unique name for this scheduled job.
   * @param schedule - What time (UTC) each day to run this function.
   * @param functionReference - A {@link FunctionReference} for the function
   * to schedule.
   * @param args - The arguments to the function.
   */ hourly(cronIdentifier, schedule, functionReference, ...args) {
        const minuteUTC = validatedMinuteOfHour(schedule.minuteUTC);
        this.schedule(cronIdentifier, {
            minuteUTC,
            type: "hourly"
        }, functionReference, ...args);
    }
    /**
   * Schedule a mutation or action to run on a daily basis.
   *
   * ```js
   * crons.daily(
   *   "Reset high scores",
   *   {
   *     hourUTC: 17, // (9:30am Pacific/10:30am Daylight Savings Pacific)
   *     minuteUTC: 30,
   *   },
   *   api.scores.reset
   * )
   * ```
   *
   * @param cronIdentifier - A unique name for this scheduled job.
   * @param schedule - What time (UTC) each day to run this function.
   * @param functionReference - A {@link FunctionReference} for the function
   * to schedule.
   * @param args - The arguments to the function.
   */ daily(cronIdentifier, schedule, functionReference, ...args) {
        const hourUTC = validatedHourOfDay(schedule.hourUTC);
        const minuteUTC = validatedMinuteOfHour(schedule.minuteUTC);
        this.schedule(cronIdentifier, {
            hourUTC,
            minuteUTC,
            type: "daily"
        }, functionReference, ...args);
    }
    /**
   * Schedule a mutation or action to run on a weekly basis.
   *
   * ```js
   * crons.weekly(
   *   "Weekly re-engagement email",
   *   {
   *     dayOfWeek: "Tuesday",
   *     hourUTC: 17, // (9:30am Pacific/10:30am Daylight Savings Pacific)
   *     minuteUTC: 30,
   *   },
   *   api.emails.send
   * )
   * ```
   *
   * @param cronIdentifier - A unique name for this scheduled job.
   * @param schedule - What day and time (UTC) each week to run this function.
   * @param functionReference - A {@link FunctionReference} for the function
   * to schedule.
   */ weekly(cronIdentifier, schedule, functionReference, ...args) {
        const dayOfWeek = validatedDayOfWeek(schedule.dayOfWeek);
        const hourUTC = validatedHourOfDay(schedule.hourUTC);
        const minuteUTC = validatedMinuteOfHour(schedule.minuteUTC);
        this.schedule(cronIdentifier, {
            dayOfWeek,
            hourUTC,
            minuteUTC,
            type: "weekly"
        }, functionReference, ...args);
    }
    /**
   * Schedule a mutation or action to run on a monthly basis.
   *
   * Note that some months have fewer days than others, so e.g. a function
   * scheduled to run on the 30th will not run in February.
   *
   * ```js
   * crons.monthly(
   *   "Bill customers at ",
   *   {
   *     hourUTC: 17, // (9:30am Pacific/10:30am Daylight Savings Pacific)
   *     minuteUTC: 30,
   *     day: 1,
   *   },
   *   api.billing.billCustomers
   * )
   * ```
   *
   * @param cronIdentifier - A unique name for this scheduled job.
   * @param schedule - What day and time (UTC) each month to run this function.
   * @param functionReference - A {@link FunctionReference} for the function
   * to schedule.
   * @param args - The arguments to the function.
   */ monthly(cronIdentifier, schedule, functionReference, ...args) {
        const day = validatedDayOfMonth(schedule.day);
        const hourUTC = validatedHourOfDay(schedule.hourUTC);
        const minuteUTC = validatedMinuteOfHour(schedule.minuteUTC);
        this.schedule(cronIdentifier, {
            day,
            hourUTC,
            minuteUTC,
            type: "monthly"
        }, functionReference, ...args);
    }
    /**
   * Schedule a mutation or action to run on a recurring basis.
   *
   * Like the unix command `cron`, Sunday is 0, Monday is 1, etc.
   *
   * ```
   *  \u250c\u2500 minute (0 - 59)
   *  \u2502 \u250c\u2500 hour (0 - 23)
   *  \u2502 \u2502 \u250c\u2500 day of the month (1 - 31)
   *  \u2502 \u2502 \u2502 \u250c\u2500 month (1 - 12)
   *  \u2502 \u2502 \u2502 \u2502 \u250c\u2500 day of the week (0 - 6) (Sunday to Saturday)
   * "* * * * *"
   * ```
   *
   * @param cronIdentifier - A unique name for this scheduled job.
   * @param cron - Cron string like `"15 7 * * *"` (Every day at 7:15 UTC)
   * @param functionReference - A {@link FunctionReference} for the function
   * to schedule.
   * @param args - The arguments to the function.
   */ cron(cronIdentifier, cron, functionReference, ...args) {
        const c = validatedCronString(cron);
        this.schedule(cronIdentifier, {
            cron: c,
            type: "cron"
        }, functionReference, ...args);
    }
    /** @internal */ export() {
        return JSON.stringify(this.crons);
    }
}

},{"../server/api.js":"9nMwO","../common/index.js":"jSbKo","../values/index.js":"atHbO","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"kNXNC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ROUTABLE_HTTP_METHODS", ()=>ROUTABLE_HTTP_METHODS);
parcelHelpers.export(exports, "normalizeMethod", ()=>normalizeMethod);
parcelHelpers.export(exports, "httpRouter", ()=>httpRouter);
parcelHelpers.export(exports, "HttpRouter", ()=>HttpRouter);
var _syscallJs = require("./impl/syscall.js");
"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
const ROUTABLE_HTTP_METHODS = [
    "GET",
    "POST",
    "PUT",
    "DELETE",
    "OPTIONS",
    "PATCH"
];
function normalizeMethod(method) {
    if (method === "HEAD") return "GET";
    return method;
}
const httpRouter = ()=>new HttpRouter();
class HttpRouter {
    constructor(){
        __publicField(this, "exactRoutes", /* @__PURE__ */ new Map());
        __publicField(this, "prefixRoutes", /* @__PURE__ */ new Map());
        __publicField(this, "isRouter", true);
        /**
     * Specify an HttpAction to be used to respond to requests
     * for an HTTP method (e.g. "GET") and a path or pathPrefix.
     *
     * Paths must begin with a slash. Path prefixes must also end in a slash.
     *
     * ```js
     * // matches `/profile` (but not `/profile/`)
     * http.route({ path: "/profile", method: "GET", handler: getProfile})
     *
     * // matches `/profiles/`, `/profiles/abc`, and `/profiles/a/c/b` (but not `/profile`)
     * http.route({ pathPrefix: "/profile/", method: "GET", handler: getProfile})
     * ```
     */ __publicField(this, "route", (spec)=>{
            if (!spec.handler) throw new Error(`route requires handler`);
            if (!spec.method) throw new Error(`route requires method`);
            const { method, handler } = spec;
            if (!ROUTABLE_HTTP_METHODS.includes(method)) throw new Error(`'${method}' is not an allowed HTTP method (like GET, POST, PUT etc.)`);
            if ("path" in spec) {
                if ("pathPrefix" in spec) throw new Error(`Invalid httpRouter route: cannot contain both 'path' and 'pathPrefix'`);
                if (!spec.path.startsWith("/")) throw new Error(`path '${spec.path}' does not start with a /`);
                if (spec.path.startsWith("/.files/") || spec.path === "/.files") throw new Error(`path '${spec.path}' is reserved`);
                const methods = this.exactRoutes.has(spec.path) ? this.exactRoutes.get(spec.path) : /* @__PURE__ */ new Map();
                if (methods.has(method)) throw new Error(`Path '${spec.path}' for method ${method} already in use`);
                methods.set(method, handler);
                this.exactRoutes.set(spec.path, methods);
            } else if ("pathPrefix" in spec) {
                if (!spec.pathPrefix.startsWith("/")) throw new Error(`pathPrefix '${spec.pathPrefix}' does not start with a /`);
                if (!spec.pathPrefix.endsWith("/")) throw new Error(`pathPrefix ${spec.pathPrefix} must end with a /`);
                if (spec.pathPrefix.startsWith("/.files/")) throw new Error(`pathPrefix '${spec.pathPrefix}' is reserved`);
                const prefixes = this.prefixRoutes.get(method) || /* @__PURE__ */ new Map();
                if (prefixes.has(spec.pathPrefix)) throw new Error(`${spec.method} pathPrefix ${spec.pathPrefix} is already defined`);
                prefixes.set(spec.pathPrefix, handler);
                this.prefixRoutes.set(method, prefixes);
            } else throw new Error(`Invalid httpRouter route entry: must contain either field 'path' or 'pathPrefix'`);
        });
        /**
     * Returns a list of routed HTTP actions.
     *
     * These are used to populate the list of routes shown in the Functions page of the Convex dashboard.
     *
     * @returns - an array of [path, method, endpoint] tuples.
     */ __publicField(this, "getRoutes", ()=>{
            const exactPaths = [
                ...this.exactRoutes.keys()
            ].sort();
            const exact = exactPaths.flatMap((path)=>[
                    ...this.exactRoutes.get(path).keys()
                ].sort().map((method)=>[
                        path,
                        method,
                        this.exactRoutes.get(path).get(method)
                    ]));
            const prefixPathMethods = [
                ...this.prefixRoutes.keys()
            ].sort();
            const prefixes = prefixPathMethods.flatMap((method)=>[
                    ...this.prefixRoutes.get(method).keys()
                ].sort().map((pathPrefix)=>[
                        `${pathPrefix}*`,
                        method,
                        this.prefixRoutes.get(method).get(pathPrefix)
                    ]));
            return [
                ...exact,
                ...prefixes
            ];
        });
        /**
     * Returns the appropriate HTTP action and its routed request path and method.
     *
     * The path and method returned are used for logging and metrics, and should
     * match up with one of the routes returned by `getRoutes`.
     *
     * For example,
     *
     * ```js
     * http.route({ pathPrefix: "/profile/", method: "GET", handler: getProfile});
     *
     * http.lookup("/profile/abc", "GET") // returns [getProfile, "GET", "/profile/*"]
     *```
     *
     * @returns - a tuple [{@link PublicHttpAction}, method, path] or null.
     */ __publicField(this, "lookup", (path, method)=>{
            method = normalizeMethod(method);
            const exactMatch = this.exactRoutes.get(path)?.get(method);
            if (exactMatch) return [
                exactMatch,
                method,
                path
            ];
            const prefixes = this.prefixRoutes.get(method) || /* @__PURE__ */ new Map();
            const prefixesSorted = [
                ...prefixes.entries()
            ].sort(([prefixA, _a], [prefixB, _b])=>prefixB.length - prefixA.length);
            for (const [pathPrefix, endpoint] of prefixesSorted){
                if (path.startsWith(pathPrefix)) return [
                    endpoint,
                    method,
                    `${pathPrefix}*`
                ];
            }
            return null;
        });
        /**
     * Given a JSON string representation of a Request object, return a Response
     * by routing the request and running the appropriate endpoint or returning
     * a 404 Response.
     *
     * @param argsStr - a JSON string representing a Request object.
     *
     * @returns - a Response object.
     */ __publicField(this, "runRequest", async (argsStr, requestRoute)=>{
            const request = (0, _syscallJs.performJsSyscall)("requestFromConvexJson", {
                convexJson: JSON.parse(argsStr)
            });
            let pathname = requestRoute;
            if (!pathname || typeof pathname !== "string") pathname = new URL(request.url).pathname;
            const method = request.method;
            const match = this.lookup(pathname, method);
            if (!match) {
                const response2 = new Response(`No HttpAction routed for ${pathname}`, {
                    status: 404
                });
                return JSON.stringify((0, _syscallJs.performJsSyscall)("convexJsonFromResponse", {
                    response: response2
                }));
            }
            const [endpoint, _method, _path] = match;
            const response = await endpoint.invokeHttpAction(request);
            return JSON.stringify((0, _syscallJs.performJsSyscall)("convexJsonFromResponse", {
                response
            }));
        });
    }
}

},{"./impl/syscall.js":"4FNDy","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"fIWeD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getFunctionAddress", ()=>(0, _pathsJs.getFunctionAddress));
parcelHelpers.export(exports, "createFunctionHandle", ()=>createFunctionHandle);
parcelHelpers.export(exports, "defineComponent", ()=>defineComponent);
parcelHelpers.export(exports, "defineApp", ()=>defineApp);
parcelHelpers.export(exports, "currentSystemUdfInComponent", ()=>currentSystemUdfInComponent);
parcelHelpers.export(exports, "componentsGeneric", ()=>componentsGeneric);
var _indexJs = require("../../values/index.js");
var _indexJs1 = require("../../index.js");
var _syscallJs = require("../impl/syscall.js");
var _pathsJs = require("./paths.js");
"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
async function createFunctionHandle(functionReference) {
    const address = (0, _pathsJs.getFunctionAddress)(functionReference);
    return await (0, _syscallJs.performAsyncSyscall)("1.0/createFunctionHandle", {
        ...address,
        version: (0, _indexJs1.version)
    });
}
class InstalledComponent {
    constructor(definition, name){
        /**
     * @internal
     */ __publicField(this, "_definition");
        /**
     * @internal
     */ __publicField(this, "_name");
        this._definition = definition;
        this._name = name;
        (0, _pathsJs.setReferencePath)(this, `_reference/childComponent/${name}`);
    }
    get exports() {
        return createExports(this._name, []);
    }
}
function createExports(name, pathParts) {
    const handler = {
        get (_, prop) {
            if (typeof prop === "string") {
                const newParts = [
                    ...pathParts,
                    prop
                ];
                return createExports(name, newParts);
            } else if (prop === (0, _pathsJs.toReferencePath)) {
                let reference = `_reference/childComponent/${name}`;
                for (const part of pathParts)reference += `/${part}`;
                return reference;
            } else return void 0;
        }
    };
    return new Proxy({}, handler);
}
function use(definition, options) {
    const importedComponentDefinition = definition;
    if (typeof importedComponentDefinition.componentDefinitionPath !== "string") throw new Error("Component definition does not have the required componentDefinitionPath property. This code only works in Convex runtime.");
    const name = options?.name || // added recently
    importedComponentDefinition.defaultName || // can be removed once backend is out
    importedComponentDefinition.componentDefinitionPath.split("/").pop();
    this._childComponents.push([
        name,
        importedComponentDefinition,
        {}
    ]);
    return new InstalledComponent(definition, name);
}
function exportAppForAnalysis() {
    const definitionType = {
        type: "app"
    };
    const childComponents = serializeChildComponents(this._childComponents);
    return {
        definitionType,
        childComponents,
        httpMounts: {},
        exports: serializeExportTree(this._exportTree)
    };
}
function serializeExportTree(tree) {
    const branch = [];
    for (const [key, child] of Object.entries(tree)){
        let node;
        if (typeof child === "string") node = {
            type: "leaf",
            leaf: child
        };
        else node = serializeExportTree(child);
        branch.push([
            key,
            node
        ]);
    }
    return {
        type: "branch",
        branch
    };
}
function serializeChildComponents(childComponents) {
    return childComponents.map(([name, definition, p])=>{
        let args = null;
        if (p !== null) {
            args = [];
            for (const [name2, value] of Object.entries(p))if (value !== void 0) args.push([
                name2,
                {
                    type: "value",
                    value: JSON.stringify((0, _indexJs.convexToJson)(value))
                }
            ]);
        }
        const path = definition.componentDefinitionPath;
        if (!path) throw new Error("no .componentPath for component definition " + JSON.stringify(definition, null, 2));
        return {
            name,
            path,
            args
        };
    });
}
function exportComponentForAnalysis() {
    const args = Object.entries(this._args).map(([name, validator])=>[
            name,
            {
                type: "value",
                value: JSON.stringify(validator.json)
            }
        ]);
    const definitionType = {
        type: "childComponent",
        name: this._name,
        args
    };
    const childComponents = serializeChildComponents(this._childComponents);
    return {
        name: this._name,
        definitionType,
        childComponents,
        httpMounts: {},
        exports: serializeExportTree(this._exportTree)
    };
}
function defineComponent(name) {
    const ret = {
        _isRoot: false,
        _name: name,
        _args: {},
        _childComponents: [],
        _exportTree: {},
        _onInitCallbacks: {},
        export: exportComponentForAnalysis,
        use
    };
    return ret;
}
function defineApp() {
    const ret = {
        _isRoot: true,
        _childComponents: [],
        _exportTree: {},
        export: exportAppForAnalysis,
        use
    };
    return ret;
}
function currentSystemUdfInComponent(componentId) {
    return {
        [(0, _pathsJs.toReferencePath)]: `_reference/currentSystemUdfInComponent/${componentId}`
    };
}
function createChildComponents(root, pathParts) {
    const handler = {
        get (_, prop) {
            if (typeof prop === "string") {
                const newParts = [
                    ...pathParts,
                    prop
                ];
                return createChildComponents(root, newParts);
            } else if (prop === (0, _pathsJs.toReferencePath)) {
                if (pathParts.length < 1) {
                    const found = [
                        root,
                        ...pathParts
                    ].join(".");
                    throw new Error(`API path is expected to be of the form \`${root}.childComponent.functionName\`. Found: \`${found}\``);
                }
                return `_reference/childComponent/` + pathParts.join("/");
            } else return void 0;
        }
    };
    return new Proxy({}, handler);
}
const componentsGeneric = ()=>createChildComponents("components", []);

},{"../../values/index.js":"atHbO","../../index.js":"76BIQ","../impl/syscall.js":"4FNDy","./paths.js":"alov9","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}],"7S7L3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TableDefinition", ()=>TableDefinition);
parcelHelpers.export(exports, "defineTable", ()=>defineTable);
parcelHelpers.export(exports, "SchemaDefinition", ()=>SchemaDefinition);
parcelHelpers.export(exports, "defineSchema", ()=>defineSchema);
var _validatorJs = require("../values/validator.js");
"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
class TableDefinition {
    /**
   * @internal
   */ constructor(documentType){
        __publicField(this, "indexes");
        __publicField(this, "stagedDbIndexes");
        __publicField(this, "searchIndexes");
        __publicField(this, "stagedSearchIndexes");
        __publicField(this, "vectorIndexes");
        __publicField(this, "stagedVectorIndexes");
        // The type of documents stored in this table.
        __publicField(this, "validator");
        this.indexes = [];
        this.stagedDbIndexes = [];
        this.searchIndexes = [];
        this.stagedSearchIndexes = [];
        this.vectorIndexes = [];
        this.stagedVectorIndexes = [];
        this.validator = documentType;
    }
    /**
   * This API is experimental: it may change or disappear.
   *
   * Returns indexes defined on this table.
   * Intended for the advanced use cases of dynamically deciding which index to use for a query.
   * If you think you need this, please chime in on ths issue in the Convex JS GitHub repo.
   * https://github.com/get-convex/convex-js/issues/49
   */ " indexes"() {
        return this.indexes;
    }
    index(name, indexConfig) {
        if (Array.isArray(indexConfig)) this.indexes.push({
            indexDescriptor: name,
            fields: indexConfig
        });
        else if (indexConfig.staged) this.stagedDbIndexes.push({
            indexDescriptor: name,
            fields: indexConfig.fields
        });
        else this.indexes.push({
            indexDescriptor: name,
            fields: indexConfig.fields
        });
        return this;
    }
    searchIndex(name, indexConfig) {
        if (indexConfig.staged) this.stagedSearchIndexes.push({
            indexDescriptor: name,
            searchField: indexConfig.searchField,
            filterFields: indexConfig.filterFields || []
        });
        else this.searchIndexes.push({
            indexDescriptor: name,
            searchField: indexConfig.searchField,
            filterFields: indexConfig.filterFields || []
        });
        return this;
    }
    vectorIndex(name, indexConfig) {
        if (indexConfig.staged) this.stagedVectorIndexes.push({
            indexDescriptor: name,
            vectorField: indexConfig.vectorField,
            dimensions: indexConfig.dimensions,
            filterFields: indexConfig.filterFields || []
        });
        else this.vectorIndexes.push({
            indexDescriptor: name,
            vectorField: indexConfig.vectorField,
            dimensions: indexConfig.dimensions,
            filterFields: indexConfig.filterFields || []
        });
        return this;
    }
    /**
   * Work around for https://github.com/microsoft/TypeScript/issues/57035
   */ self() {
        return this;
    }
    /**
   * Export the contents of this definition.
   *
   * This is called internally by the Convex framework.
   * @internal
   */ export() {
        const documentType = this.validator.json;
        if (typeof documentType !== "object") throw new Error("Invalid validator: please make sure that the parameter of `defineTable` is valid (see https://docs.convex.dev/database/schemas)");
        return {
            indexes: this.indexes,
            stagedDbIndexes: this.stagedDbIndexes,
            searchIndexes: this.searchIndexes,
            stagedSearchIndexes: this.stagedSearchIndexes,
            vectorIndexes: this.vectorIndexes,
            stagedVectorIndexes: this.stagedVectorIndexes,
            documentType
        };
    }
}
function defineTable(documentSchema) {
    if ((0, _validatorJs.isValidator)(documentSchema)) return new TableDefinition(documentSchema);
    else return new TableDefinition((0, _validatorJs.v).object(documentSchema));
}
class SchemaDefinition {
    /**
   * @internal
   */ constructor(tables, options){
        __publicField(this, "tables");
        __publicField(this, "strictTableNameTypes");
        __publicField(this, "schemaValidation");
        this.tables = tables;
        this.schemaValidation = options?.schemaValidation === void 0 ? true : options.schemaValidation;
    }
    /**
   * Export the contents of this definition.
   *
   * This is called internally by the Convex framework.
   * @internal
   */ export() {
        return JSON.stringify({
            tables: Object.entries(this.tables).map(([tableName, definition])=>{
                const { indexes, stagedDbIndexes, searchIndexes, stagedSearchIndexes, vectorIndexes, stagedVectorIndexes, documentType } = definition.export();
                return {
                    tableName,
                    indexes,
                    stagedDbIndexes,
                    searchIndexes,
                    stagedSearchIndexes,
                    vectorIndexes,
                    stagedVectorIndexes,
                    documentType
                };
            }),
            schemaValidation: this.schemaValidation
        });
    }
}
function defineSchema(schema, options) {
    return new SchemaDefinition(schema, options);
}
const _systemSchema = defineSchema({
    _scheduled_functions: defineTable({
        name: (0, _validatorJs.v).string(),
        args: (0, _validatorJs.v).array((0, _validatorJs.v).any()),
        scheduledTime: (0, _validatorJs.v).float64(),
        completedTime: (0, _validatorJs.v).optional((0, _validatorJs.v).float64()),
        state: (0, _validatorJs.v).union((0, _validatorJs.v).object({
            kind: (0, _validatorJs.v).literal("pending")
        }), (0, _validatorJs.v).object({
            kind: (0, _validatorJs.v).literal("inProgress")
        }), (0, _validatorJs.v).object({
            kind: (0, _validatorJs.v).literal("success")
        }), (0, _validatorJs.v).object({
            kind: (0, _validatorJs.v).literal("failed"),
            error: (0, _validatorJs.v).string()
        }), (0, _validatorJs.v).object({
            kind: (0, _validatorJs.v).literal("canceled")
        }))
    }),
    _storage: defineTable({
        sha256: (0, _validatorJs.v).string(),
        size: (0, _validatorJs.v).float64(),
        contentType: (0, _validatorJs.v).optional((0, _validatorJs.v).string())
    })
});

},{"../values/validator.js":"7gq7W","@parcel/transformer-js/src/esmodule-helpers.js":"iIXqM"}]},["bU1QP","8oeFb"], "8oeFb", "parcelRequire1e2a")

//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TyxLQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFHO0lBQUMsRUFBRTtJQUFBLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFBRSxJQUFJLElBQUksS0FBSyxFQUFFO1lBQUMsSUFBSSxJQUFFLElBQUksQ0FBQyxpQkFBaUIsSUFBRyxJQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUMsSUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSTtZQUFHLEtBQUksQ0FBQSxFQUFFLFlBQVksT0FBTyxJQUFHLEVBQUUsWUFBWSxTQUFPLEtBQUksQ0FBQSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxJQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLGVBQWUsRUFBRSxTQUFRLENBQUM7UUFBRTtJQUFDO0lBQUMsYUFBVyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRztJQUFBLENBQUMsQ0FBQztRQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsRUFBQyxVQUFTLENBQUMsRUFBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLGVBQWUsS0FBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFBTztJQUFDLE1BQU0sUUFBUSxDQUFDLEVBQUM7UUFBQyxPQUFPLElBQUksQ0FBQyxJQUFJO0lBQUU7SUFBQyxNQUFNLFNBQVMsQ0FBQyxFQUFDO1FBQUMsT0FBTyxNQUFNLElBQUksQ0FBQyxRQUFRO0lBQUU7SUFBQyxNQUFNLFFBQVEsQ0FBQyxFQUFDLENBQUMsRUFBQztRQUFDLE1BQU0sSUFBSSxDQUFDLElBQUksR0FBRTtJQUFFO0lBQUMsTUFBTSxTQUFTLENBQUMsRUFBQztRQUFDLE1BQU0sTUFBTSxJQUFJLENBQUMsUUFBUTtJQUFFO0lBQUMsTUFBTSxXQUFXLENBQUMsRUFBQztRQUFDLE9BQU8sSUFBSSxDQUFDLE9BQU87SUFBRTtJQUFDLE1BQU0sWUFBWSxDQUFDLEVBQUM7UUFBQyxPQUFPLE1BQU0sSUFBSSxDQUFDLFdBQVc7SUFBRTtB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QSxHQUFBLGNBQUEsRUFBRTtRQUFTLElBQ3hELENBQUEsR0FBQSxjQUFBLEVBQUUsT0FBTztZQUFFLE1BQU0sQ0FBQSxHQUFBLGNBQUEsRUFBRSxRQUFRO1FBQVk7SUFFM0M7SUFDQSxVQUFVLFlBQVk7UUFDcEIsUUFBUSxDQUFBLEdBQUEsY0FBQSxFQUFFO1FBQ1YsTUFBTSxDQUFBLEdBQUEsY0FBQSxFQUFFO1FBQ1IsYUFBYSxDQUFBLEdBQUEsY0FBQSxFQUFFLFNBQVMsQ0FBQSxHQUFBLGNBQUEsRUFBRTtJQUM1QjtBQUNGIiwic291cmNlcyI6WyJub2RlX21vZHVsZXMvQHBsYXNtb2hxL3BhcmNlbC1ydW50aW1lL2Rpc3QvcnVudGltZS05OGFhZjE2YTllMWY4ODNmLmpzIiwiLnBsYXNtby9zdGF0aWMvYmFja2dyb3VuZC9pbmRleC50cyIsInNyYy9iYWNrZ3JvdW5kLnRzIiwibm9kZV9tb2R1bGVzL0BwbGFzbW9ocS9zdG9yYWdlL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AcGFyY2VsL3RyYW5zZm9ybWVyLWpzL3NyYy9lc21vZHVsZS1oZWxwZXJzLmpzIiwibm9kZV9tb2R1bGVzL2NvbnZleC9kaXN0L2VzbS9icm93c2VyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbnZleC9zcmMvYnJvd3Nlci9pbmRleC50cyIsIm5vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vYnJvd3Nlci9zeW5jL2NsaWVudC5qcyIsIm5vZGVfbW9kdWxlcy9jb252ZXgvc3JjL2Jyb3dzZXIvc3luYy9jbGllbnQudHMiLCJub2RlX21vZHVsZXMvY29udmV4L2Rpc3QvZXNtL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbnZleC9zcmMvaW5kZXgudHMiLCJub2RlX21vZHVsZXMvY29udmV4L2Rpc3QvZXNtL3ZhbHVlcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb252ZXgvc3JjL3ZhbHVlcy9pbmRleC50cyIsIm5vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vdmFsdWVzL3ZhbHVlLmpzIiwibm9kZV9tb2R1bGVzL2NvbnZleC9zcmMvdmFsdWVzL3ZhbHVlLnRzIiwibm9kZV9tb2R1bGVzL2NvbnZleC9kaXN0L2VzbS92YWx1ZXMvYmFzZTY0LmpzIiwibm9kZV9tb2R1bGVzL2NvbnZleC9zcmMvdmFsdWVzL2Jhc2U2NC50cyIsIm5vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vY29tbW9uL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbnZleC9zcmMvY29tbW9uL2luZGV4LnRzIiwibm9kZV9tb2R1bGVzL2NvbnZleC9kaXN0L2VzbS92YWx1ZXMvdmFsaWRhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvbnZleC9zcmMvdmFsdWVzL3ZhbGlkYXRvci50cyIsIm5vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vdmFsdWVzL3ZhbGlkYXRvcnMuanMiLCJub2RlX21vZHVsZXMvY29udmV4L3NyYy92YWx1ZXMvdmFsaWRhdG9ycy50cyIsIm5vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vdmFsdWVzL2Vycm9ycy5qcyIsIm5vZGVfbW9kdWxlcy9jb252ZXgvc3JjL3ZhbHVlcy9lcnJvcnMudHMiLCJub2RlX21vZHVsZXMvY29udmV4L2Rpc3QvZXNtL3ZhbHVlcy9jb21wYXJlLmpzIiwibm9kZV9tb2R1bGVzL2NvbnZleC9zcmMvdmFsdWVzL2NvbXBhcmUudHMiLCJub2RlX21vZHVsZXMvY29udmV4L2Rpc3QvZXNtL3ZhbHVlcy9jb21wYXJlX3V0ZjguanMiLCJub2RlX21vZHVsZXMvY29udmV4L3NyYy92YWx1ZXMvY29tcGFyZV91dGY4LnRzIiwibm9kZV9tb2R1bGVzL2NvbnZleC9kaXN0L2VzbS9icm93c2VyL2xvZ2dpbmcuanMiLCJub2RlX21vZHVsZXMvY29udmV4L3NyYy9icm93c2VyL2xvZ2dpbmcudHMiLCJub2RlX21vZHVsZXMvY29udmV4L2Rpc3QvZXNtL2Jyb3dzZXIvc3luYy9sb2NhbF9zdGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb252ZXgvc3JjL2Jyb3dzZXIvc3luYy9sb2NhbF9zdGF0ZS50cyIsIm5vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vYnJvd3Nlci9zeW5jL3VkZl9wYXRoX3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2NvbnZleC9zcmMvYnJvd3Nlci9zeW5jL3VkZl9wYXRoX3V0aWxzLnRzIiwibm9kZV9tb2R1bGVzL2NvbnZleC9kaXN0L2VzbS9icm93c2VyL3N5bmMvcmVxdWVzdF9tYW5hZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvbnZleC9zcmMvYnJvd3Nlci9zeW5jL3JlcXVlc3RfbWFuYWdlci50cyIsIm5vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vYnJvd3Nlci9zeW5jL29wdGltaXN0aWNfdXBkYXRlc19pbXBsLmpzIiwibm9kZV9tb2R1bGVzL2NvbnZleC9zcmMvYnJvd3Nlci9zeW5jL29wdGltaXN0aWNfdXBkYXRlc19pbXBsLnRzIiwibm9kZV9tb2R1bGVzL2NvbnZleC9kaXN0L2VzbS9zZXJ2ZXIvYXBpLmpzIiwibm9kZV9tb2R1bGVzL2NvbnZleC9zcmMvc2VydmVyL2FwaS50cyIsIm5vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vc2VydmVyL2Z1bmN0aW9uTmFtZS5qcyIsIm5vZGVfbW9kdWxlcy9jb252ZXgvc3JjL3NlcnZlci9mdW5jdGlvbk5hbWUudHMiLCJub2RlX21vZHVsZXMvY29udmV4L2Rpc3QvZXNtL3NlcnZlci9jb21wb25lbnRzL3BhdGhzLmpzIiwibm9kZV9tb2R1bGVzL2NvbnZleC9zcmMvc2VydmVyL2NvbXBvbmVudHMvcGF0aHMudHMiLCJub2RlX21vZHVsZXMvY29udmV4L2Rpc3QvZXNtL2Jyb3dzZXIvc3luYy9yZW1vdGVfcXVlcnlfc2V0LmpzIiwibm9kZV9tb2R1bGVzL2NvbnZleC9zcmMvYnJvd3Nlci9zeW5jL3JlbW90ZV9xdWVyeV9zZXQudHMiLCJub2RlX21vZHVsZXMvY29udmV4L2Rpc3QvZXNtL3ZlbmRvci9sb25nLmpzIiwibm9kZV9tb2R1bGVzL2NvbnZleC9zcmMvdmVuZG9yL2xvbmcudHMiLCJub2RlX21vZHVsZXMvY29udmV4L2Rpc3QvZXNtL2Jyb3dzZXIvc3luYy93ZWJfc29ja2V0X21hbmFnZXIuanMiLCJub2RlX21vZHVsZXMvY29udmV4L3NyYy9icm93c2VyL3N5bmMvd2ViX3NvY2tldF9tYW5hZ2VyLnRzIiwibm9kZV9tb2R1bGVzL2NvbnZleC9kaXN0L2VzbS9icm93c2VyL3N5bmMvcHJvdG9jb2wuanMiLCJub2RlX21vZHVsZXMvY29udmV4L3NyYy9icm93c2VyL3N5bmMvcHJvdG9jb2wudHMiLCJub2RlX21vZHVsZXMvY29udmV4L2Rpc3QvZXNtL2Jyb3dzZXIvc3luYy9zZXNzaW9uLmpzIiwibm9kZV9tb2R1bGVzL2NvbnZleC9zcmMvYnJvd3Nlci9zeW5jL3Nlc3Npb24udHMiLCJub2RlX21vZHVsZXMvY29udmV4L2Rpc3QvZXNtL2Jyb3dzZXIvc3luYy9hdXRoZW50aWNhdGlvbl9tYW5hZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvbnZleC9zcmMvYnJvd3Nlci9zeW5jL2F1dGhlbnRpY2F0aW9uX21hbmFnZXIudHMiLCJub2RlX21vZHVsZXMvY29udmV4L2Rpc3QvZXNtL3ZlbmRvci9qd3QtZGVjb2RlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbnZleC9zcmMvdmVuZG9yL2p3dC1kZWNvZGUvaW5kZXgudHMiLCJub2RlX21vZHVsZXMvY29udmV4L2Rpc3QvZXNtL2Jyb3dzZXIvc3luYy9tZXRyaWNzLmpzIiwibm9kZV9tb2R1bGVzL2NvbnZleC9zcmMvYnJvd3Nlci9zeW5jL21ldHJpY3MudHMiLCJub2RlX21vZHVsZXMvY29udmV4L2Rpc3QvZXNtL2Jyb3dzZXIvc2ltcGxlX2NsaWVudC5qcyIsIm5vZGVfbW9kdWxlcy9jb252ZXgvc3JjL2Jyb3dzZXIvc2ltcGxlX2NsaWVudC50cyIsIm5vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vYnJvd3Nlci9zeW5jL3BhZ2luYXRlZF9xdWVyeV9jbGllbnQuanMiLCJub2RlX21vZHVsZXMvY29udmV4L3NyYy9icm93c2VyL3N5bmMvcGFnaW5hdGVkX3F1ZXJ5X2NsaWVudC50cyIsIm5vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vYnJvd3Nlci9zeW5jL3BhZ2luYXRpb24uanMiLCJub2RlX21vZHVsZXMvY29udmV4L3NyYy9icm93c2VyL3N5bmMvcGFnaW5hdGlvbi50cyIsIm5vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vYnJvd3Nlci9odHRwX2NsaWVudC5qcyIsIm5vZGVfbW9kdWxlcy9jb252ZXgvc3JjL2Jyb3dzZXIvaHR0cF9jbGllbnQudHMiLCJjb252ZXgvX2dlbmVyYXRlZC9hcGkuanMiLCJub2RlX21vZHVsZXMvY29udmV4L2Rpc3QvZXNtL3NlcnZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb252ZXgvc3JjL3NlcnZlci9pbmRleC50cyIsIm5vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vc2VydmVyL2RhdGFiYXNlLmpzIiwibm9kZV9tb2R1bGVzL2NvbnZleC9kaXN0L2VzbS9zZXJ2ZXIvaW1wbC9yZWdpc3RyYXRpb25faW1wbC5qcyIsIm5vZGVfbW9kdWxlcy9jb252ZXgvc3JjL3NlcnZlci9pbXBsL3JlZ2lzdHJhdGlvbl9pbXBsLnRzIiwibm9kZV9tb2R1bGVzL2NvbnZleC9kaXN0L2VzbS9zZXJ2ZXIvaW1wbC9hY3Rpb25zX2ltcGwuanMiLCJub2RlX21vZHVsZXMvY29udmV4L3NyYy9zZXJ2ZXIvaW1wbC9hY3Rpb25zX2ltcGwudHMiLCJub2RlX21vZHVsZXMvY29udmV4L2Rpc3QvZXNtL3NlcnZlci9pbXBsL3N5c2NhbGwuanMiLCJub2RlX21vZHVsZXMvY29udmV4L3NyYy9zZXJ2ZXIvaW1wbC9zeXNjYWxsLnRzIiwibm9kZV9tb2R1bGVzL2NvbnZleC9kaXN0L2VzbS9zZXJ2ZXIvaW1wbC92ZWN0b3Jfc2VhcmNoX2ltcGwuanMiLCJub2RlX21vZHVsZXMvY29udmV4L3NyYy9zZXJ2ZXIvaW1wbC92ZWN0b3Jfc2VhcmNoX2ltcGwudHMiLCJub2RlX21vZHVsZXMvY29udmV4L2Rpc3QvZXNtL3NlcnZlci92ZWN0b3Jfc2VhcmNoLmpzIiwibm9kZV9tb2R1bGVzL2NvbnZleC9zcmMvc2VydmVyL3ZlY3Rvcl9zZWFyY2gudHMiLCJub2RlX21vZHVsZXMvY29udmV4L2Rpc3QvZXNtL3NlcnZlci9pbXBsL3ZhbGlkYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvbnZleC9zcmMvc2VydmVyL2ltcGwvdmFsaWRhdGUudHMiLCJub2RlX21vZHVsZXMvY29udmV4L2Rpc3QvZXNtL3NlcnZlci9pbXBsL2F1dGhlbnRpY2F0aW9uX2ltcGwuanMiLCJub2RlX21vZHVsZXMvY29udmV4L3NyYy9zZXJ2ZXIvaW1wbC9hdXRoZW50aWNhdGlvbl9pbXBsLnRzIiwibm9kZV9tb2R1bGVzL2NvbnZleC9kaXN0L2VzbS9zZXJ2ZXIvaW1wbC9kYXRhYmFzZV9pbXBsLmpzIiwibm9kZV9tb2R1bGVzL2NvbnZleC9zcmMvc2VydmVyL2ltcGwvZGF0YWJhc2VfaW1wbC50cyIsIm5vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vc2VydmVyL2ltcGwvcXVlcnlfaW1wbC5qcyIsIm5vZGVfbW9kdWxlcy9jb252ZXgvc3JjL3NlcnZlci9pbXBsL3F1ZXJ5X2ltcGwudHMiLCJub2RlX21vZHVsZXMvY29udmV4L2Rpc3QvZXNtL3NlcnZlci9pbXBsL2ZpbHRlcl9idWlsZGVyX2ltcGwuanMiLCJub2RlX21vZHVsZXMvY29udmV4L3NyYy9zZXJ2ZXIvaW1wbC9maWx0ZXJfYnVpbGRlcl9pbXBsLnRzIiwibm9kZV9tb2R1bGVzL2NvbnZleC9kaXN0L2VzbS9zZXJ2ZXIvZmlsdGVyX2J1aWxkZXIuanMiLCJub2RlX21vZHVsZXMvY29udmV4L3NyYy9zZXJ2ZXIvZmlsdGVyX2J1aWxkZXIudHMiLCJub2RlX21vZHVsZXMvY29udmV4L2Rpc3QvZXNtL3NlcnZlci9pbXBsL2luZGV4X3JhbmdlX2J1aWxkZXJfaW1wbC5qcyIsIm5vZGVfbW9kdWxlcy9jb252ZXgvc3JjL3NlcnZlci9pbXBsL2luZGV4X3JhbmdlX2J1aWxkZXJfaW1wbC50cyIsIm5vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vc2VydmVyL2luZGV4X3JhbmdlX2J1aWxkZXIuanMiLCJub2RlX21vZHVsZXMvY29udmV4L3NyYy9zZXJ2ZXIvaW5kZXhfcmFuZ2VfYnVpbGRlci50cyIsIm5vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vc2VydmVyL2ltcGwvc2VhcmNoX2ZpbHRlcl9idWlsZGVyX2ltcGwuanMiLCJub2RlX21vZHVsZXMvY29udmV4L3NyYy9zZXJ2ZXIvaW1wbC9zZWFyY2hfZmlsdGVyX2J1aWxkZXJfaW1wbC50cyIsIm5vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vc2VydmVyL3NlYXJjaF9maWx0ZXJfYnVpbGRlci5qcyIsIm5vZGVfbW9kdWxlcy9jb252ZXgvc3JjL3NlcnZlci9zZWFyY2hfZmlsdGVyX2J1aWxkZXIudHMiLCJub2RlX21vZHVsZXMvY29udmV4L2Rpc3QvZXNtL3NlcnZlci9pbXBsL3NjaGVkdWxlcl9pbXBsLmpzIiwibm9kZV9tb2R1bGVzL2NvbnZleC9zcmMvc2VydmVyL2ltcGwvc2NoZWR1bGVyX2ltcGwudHMiLCJub2RlX21vZHVsZXMvY29udmV4L2Rpc3QvZXNtL3NlcnZlci9pbXBsL3N0b3JhZ2VfaW1wbC5qcyIsIm5vZGVfbW9kdWxlcy9jb252ZXgvc3JjL3NlcnZlci9pbXBsL3N0b3JhZ2VfaW1wbC50cyIsIm5vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vc2VydmVyL3BhZ2luYXRpb24uanMiLCJub2RlX21vZHVsZXMvY29udmV4L3NyYy9zZXJ2ZXIvcGFnaW5hdGlvbi50cyIsIm5vZGVfbW9kdWxlcy9jb252ZXgvZGlzdC9lc20vc2VydmVyL3N0b3JhZ2UuanMiLCJub2RlX21vZHVsZXMvY29udmV4L2Rpc3QvZXNtL3NlcnZlci9jcm9uLmpzIiwibm9kZV9tb2R1bGVzL2NvbnZleC9zcmMvc2VydmVyL2Nyb24udHMiLCJub2RlX21vZHVsZXMvY29udmV4L2Rpc3QvZXNtL3NlcnZlci9yb3V0ZXIuanMiLCJub2RlX21vZHVsZXMvY29udmV4L3NyYy9zZXJ2ZXIvcm91dGVyLnRzIiwibm9kZV9tb2R1bGVzL2NvbnZleC9kaXN0L2VzbS9zZXJ2ZXIvY29tcG9uZW50cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb252ZXgvc3JjL3NlcnZlci9jb21wb25lbnRzL2luZGV4LnRzIiwibm9kZV9tb2R1bGVzL2NvbnZleC9kaXN0L2VzbS9zZXJ2ZXIvc2NoZW1hLmpzIiwibm9kZV9tb2R1bGVzL2NvbnZleC9zcmMvc2VydmVyL3NjaGVtYS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdT1nbG9iYWxUaGlzLnByb2Nlc3M/LmFyZ3Z8fFtdO3ZhciBoPSgpPT5nbG9iYWxUaGlzLnByb2Nlc3M/LmVudnx8e307dmFyIEI9bmV3IFNldCh1KSxfPWU9PkIuaGFzKGUpLEc9dS5maWx0ZXIoZT0+ZS5zdGFydHNXaXRoKFwiLS1cIikmJmUuaW5jbHVkZXMoXCI9XCIpKS5tYXAoZT0+ZS5zcGxpdChcIj1cIikpLnJlZHVjZSgoZSxbdCxvXSk9PihlW3RdPW8sZSkse30pO3ZhciBVPV8oXCItLWRyeS1ydW5cIiksZz0oKT0+XyhcIi0tdmVyYm9zZVwiKXx8aCgpLlZFUkJPU0U9PT1cInRydWVcIixOPWcoKTt2YXIgbT0oZT1cIlwiLC4uLnQpPT5jb25zb2xlLmxvZyhlLnBhZEVuZCg5KSxcInxcIiwuLi50KTt2YXIgeT0oLi4uZSk9PmNvbnNvbGUuZXJyb3IoXCJcXHV7MUY1MzR9IEVSUk9SXCIucGFkRW5kKDkpLFwifFwiLC4uLmUpLHY9KC4uLmUpPT5tKFwiXFx1ezFGNTM1fSBJTkZPXCIsLi4uZSksZj0oLi4uZSk9Pm0oXCJcXHV7MUY3RTB9IFdBUk5cIiwuLi5lKSxNPTAsaT0oLi4uZSk9PmcoKSYmbShgXFx1ezFGN0UxfSAke00rK31gLC4uLmUpO3ZhciBiPSgpPT57bGV0IGU9Z2xvYmFsVGhpcy5icm93c2VyPy5ydW50aW1lfHxnbG9iYWxUaGlzLmNocm9tZT8ucnVudGltZSx0PSgpPT5zZXRJbnRlcnZhbChlLmdldFBsYXRmb3JtSW5mbywyNGUzKTtlLm9uU3RhcnR1cC5hZGRMaXN0ZW5lcih0KSx0KCl9O3ZhciBuPXtcImlzQ29udGVudFNjcmlwdFwiOmZhbHNlLFwiaXNCYWNrZ3JvdW5kXCI6dHJ1ZSxcImlzUmVhY3RcIjpmYWxzZSxcInJ1bnRpbWVzXCI6W1wiYmFja2dyb3VuZC1zZXJ2aWNlLXJ1bnRpbWVcIl0sXCJob3N0XCI6XCJsb2NhbGhvc3RcIixcInBvcnRcIjoxODE1LFwiZW50cnlGaWxlUGF0aFwiOlwiL0FwcGxpY2F0aW9ucy9HaXRodWIvaW5zdGFncmFtLWFpLWF1dG8taW1hZ2UtLXRodW1ibmFpbC1yZXBsYWNlci8ucGxhc21vL3N0YXRpYy9iYWNrZ3JvdW5kL2luZGV4LnRzXCIsXCJidW5kbGVJZFwiOlwiYzMzODkwOGU3MDRjOTFmMVwiLFwiZW52SGFzaFwiOlwiZDk5YTVmZmE1N2FjZDYzOFwiLFwidmVyYm9zZVwiOlwiZmFsc2VcIixcInNlY3VyZVwiOmZhbHNlLFwic2VydmVyUG9ydFwiOjQ5ODM2fTttb2R1bGUuYnVuZGxlLkhNUl9CVU5ETEVfSUQ9bi5idW5kbGVJZDtnbG9iYWxUaGlzLnByb2Nlc3M9e2FyZ3Y6W10sZW52OntWRVJCT1NFOm4udmVyYm9zZX19O3ZhciBEPW1vZHVsZS5idW5kbGUuTW9kdWxlO2Z1bmN0aW9uIEgoZSl7RC5jYWxsKHRoaXMsZSksdGhpcy5ob3Q9e2RhdGE6bW9kdWxlLmJ1bmRsZS5ob3REYXRhW2VdLF9hY2NlcHRDYWxsYmFja3M6W10sX2Rpc3Bvc2VDYWxsYmFja3M6W10sYWNjZXB0OmZ1bmN0aW9uKHQpe3RoaXMuX2FjY2VwdENhbGxiYWNrcy5wdXNoKHR8fGZ1bmN0aW9uKCl7fSl9LGRpc3Bvc2U6ZnVuY3Rpb24odCl7dGhpcy5fZGlzcG9zZUNhbGxiYWNrcy5wdXNoKHQpfX0sbW9kdWxlLmJ1bmRsZS5ob3REYXRhW2VdPXZvaWQgMH1tb2R1bGUuYnVuZGxlLk1vZHVsZT1IO21vZHVsZS5idW5kbGUuaG90RGF0YT17fTt2YXIgYz1nbG9iYWxUaGlzLmJyb3dzZXJ8fGdsb2JhbFRoaXMuY2hyb21lfHxudWxsO2Z1bmN0aW9uIFIoKXtyZXR1cm4hbi5ob3N0fHxuLmhvc3Q9PT1cIjAuMC4wLjBcIj9sb2NhdGlvbi5wcm90b2NvbC5pbmRleE9mKFwiaHR0cFwiKT09PTA/bG9jYXRpb24uaG9zdG5hbWU6XCJsb2NhbGhvc3RcIjpuLmhvc3R9ZnVuY3Rpb24geCgpe3JldHVybiFuLmhvc3R8fG4uaG9zdD09PVwiMC4wLjAuMFwiP1wibG9jYWxob3N0XCI6bi5ob3N0fWZ1bmN0aW9uIGQoKXtyZXR1cm4gbi5wb3J0fHxsb2NhdGlvbi5wb3J0fXZhciBQPVwiX19wbGFzbW9fcnVudGltZV9wYWdlX1wiLFM9XCJfX3BsYXNtb19ydW50aW1lX3NjcmlwdF9cIjt2YXIgTz1gJHtuLnNlY3VyZT9cImh0dHBzXCI6XCJodHRwXCJ9Oi8vJHtSKCl9OiR7ZCgpfS9gO2FzeW5jIGZ1bmN0aW9uIGsoZT0xNDcwKXtmb3IoOzspdHJ5e2F3YWl0IGZldGNoKE8pO2JyZWFrfWNhdGNoe2F3YWl0IG5ldyBQcm9taXNlKG89PnNldFRpbWVvdXQobyxlKSl9fWlmKGMucnVudGltZS5nZXRNYW5pZmVzdCgpLm1hbmlmZXN0X3ZlcnNpb249PT0zKXtsZXQgZT1jLnJ1bnRpbWUuZ2V0VVJMKFwiL19fcGxhc21vX2htcl9wcm94eV9fP3VybD1cIik7Z2xvYmFsVGhpcy5hZGRFdmVudExpc3RlbmVyKFwiZmV0Y2hcIixmdW5jdGlvbih0KXtsZXQgbz10LnJlcXVlc3QudXJsO2lmKG8uc3RhcnRzV2l0aChlKSl7bGV0IHM9bmV3IFVSTChkZWNvZGVVUklDb21wb25lbnQoby5zbGljZShlLmxlbmd0aCkpKTtzLmhvc3RuYW1lPT09bi5ob3N0JiZzLnBvcnQ9PT1gJHtuLnBvcnR9YD8ocy5zZWFyY2hQYXJhbXMuc2V0KFwidFwiLERhdGUubm93KCkudG9TdHJpbmcoKSksdC5yZXNwb25kV2l0aChmZXRjaChzKS50aGVuKHI9Pm5ldyBSZXNwb25zZShyLmJvZHkse2hlYWRlcnM6e1wiQ29udGVudC1UeXBlXCI6ci5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKT8/XCJ0ZXh0L2phdmFzY3JpcHRcIn19KSkpKTp0LnJlc3BvbmRXaXRoKG5ldyBSZXNwb25zZShcIlBsYXNtbyBITVJcIix7c3RhdHVzOjIwMCxzdGF0dXNUZXh0OlwiVGVzdGluZ1wifSkpfX0pfWZ1bmN0aW9uIEUoZSx0KXtsZXR7bW9kdWxlczpvfT1lO3JldHVybiBvPyEhb1t0XTohMX1mdW5jdGlvbiBDKGU9ZCgpKXtsZXQgdD14KCk7cmV0dXJuYCR7bi5zZWN1cmV8fGxvY2F0aW9uLnByb3RvY29sPT09XCJodHRwczpcIiYmIS9sb2NhbGhvc3R8MTI3LjAuMC4xfDAuMC4wLjAvLnRlc3QodCk/XCJ3c3NcIjpcIndzXCJ9Oi8vJHt0fToke2V9L2B9ZnVuY3Rpb24gTChlKXt0eXBlb2YgZS5tZXNzYWdlPT1cInN0cmluZ1wiJiZ5KFwiW3BsYXNtby9wYXJjZWwtcnVudGltZV06IFwiK2UubWVzc2FnZSl9ZnVuY3Rpb24gVChlKXtpZih0eXBlb2YgZ2xvYmFsVGhpcy5XZWJTb2NrZXQ+XCJ1XCIpcmV0dXJuO2xldCB0PW5ldyBXZWJTb2NrZXQoQyhOdW1iZXIoZCgpKSsxKSk7cmV0dXJuIHQuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIixhc3luYyBmdW5jdGlvbihvKXtsZXQgcz1KU09OLnBhcnNlKG8uZGF0YSk7YXdhaXQgZShzKX0pLHQuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsTCksdH1mdW5jdGlvbiBBKGUpe2lmKHR5cGVvZiBnbG9iYWxUaGlzLldlYlNvY2tldD5cInVcIilyZXR1cm47bGV0IHQ9bmV3IFdlYlNvY2tldChDKCkpO3JldHVybiB0LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsYXN5bmMgZnVuY3Rpb24obyl7bGV0IHM9SlNPTi5wYXJzZShvLmRhdGEpO2lmKHMudHlwZT09PVwidXBkYXRlXCImJmF3YWl0IGUocy5hc3NldHMpLHMudHlwZT09PVwiZXJyb3JcIilmb3IobGV0IHIgb2Ygcy5kaWFnbm9zdGljcy5hbnNpKXtsZXQgbD1yLmNvZGVmcmFtZXx8ci5zdGFjaztmKFwiW3BsYXNtby9wYXJjZWwtcnVudGltZV06IFwiK3IubWVzc2FnZStgXG5gK2wrYFxuXG5gK3IuaGludHMuam9pbihgXG5gKSl9fSksdC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIixMKSx0LmFkZEV2ZW50TGlzdGVuZXIoXCJvcGVuXCIsKCk9Pnt2KGBbcGxhc21vL3BhcmNlbC1ydW50aW1lXTogQ29ubmVjdGVkIHRvIEhNUiBzZXJ2ZXIgZm9yICR7bi5lbnRyeUZpbGVQYXRofWApfSksdC5hZGRFdmVudExpc3RlbmVyKFwiY2xvc2VcIiwoKT0+e2YoYFtwbGFzbW8vcGFyY2VsLXJ1bnRpbWVdOiBDb25uZWN0aW9uIHRvIHRoZSBITVIgc2VydmVyIGlzIGNsb3NlZCBmb3IgJHtuLmVudHJ5RmlsZVBhdGh9YCl9KSx0fXZhciB3PW1vZHVsZS5idW5kbGUucGFyZW50LGE9e2J1aWxkUmVhZHk6ITEsYmdDaGFuZ2VkOiExLGNzQ2hhbmdlZDohMSxwYWdlQ2hhbmdlZDohMSxzY3JpcHRQb3J0czpuZXcgU2V0LHBhZ2VQb3J0czpuZXcgU2V0fTthc3luYyBmdW5jdGlvbiBwKGU9ITEpe2lmKGV8fGEuYnVpbGRSZWFkeSYmYS5wYWdlQ2hhbmdlZCl7aShcIkJHU1cgUnVudGltZSAtIHJlbG9hZGluZyBQYWdlXCIpO2ZvcihsZXQgdCBvZiBhLnBhZ2VQb3J0cyl0LnBvc3RNZXNzYWdlKG51bGwpfWlmKGV8fGEuYnVpbGRSZWFkeSYmKGEuYmdDaGFuZ2VkfHxhLmNzQ2hhbmdlZCkpe2koXCJCR1NXIFJ1bnRpbWUgLSByZWxvYWRpbmcgQ1NcIik7bGV0IHQ9YXdhaXQgYz8udGFicy5xdWVyeSh7YWN0aXZlOiEwfSk7Zm9yKGxldCBvIG9mIGEuc2NyaXB0UG9ydHMpe2xldCBzPXQuc29tZShyPT5yLmlkPT09by5zZW5kZXIudGFiPy5pZCk7by5wb3N0TWVzc2FnZSh7X19wbGFzbW9fY3NfYWN0aXZlX3RhYl9fOnN9KX1jLnJ1bnRpbWUucmVsb2FkKCl9fWlmKCF3fHwhdy5pc1BhcmNlbFJlcXVpcmUpe2IoKTtsZXQgZT1BKGFzeW5jIHQ9PntpKFwiQkdTVyBSdW50aW1lIC0gT24gSE1SIFVwZGF0ZVwiKSxhLmJnQ2hhbmdlZHx8PXQuZmlsdGVyKHM9PnMuZW52SGFzaD09PW4uZW52SGFzaCkuc29tZShzPT5FKG1vZHVsZS5idW5kbGUscy5pZCkpO2xldCBvPXQuZmluZChzPT5zLnR5cGU9PT1cImpzb25cIik7aWYobyl7bGV0IHM9bmV3IFNldCh0Lm1hcChsPT5sLmlkKSkscj1PYmplY3QudmFsdWVzKG8uZGVwc0J5QnVuZGxlKS5tYXAobD0+T2JqZWN0LnZhbHVlcyhsKSkuZmxhdCgpO2EuYmdDaGFuZ2VkfHw9ci5ldmVyeShsPT5zLmhhcyhsKSl9cCgpfSk7ZS5hZGRFdmVudExpc3RlbmVyKFwib3BlblwiLCgpPT57bGV0IHQ9c2V0SW50ZXJ2YWwoKCk9PmUuc2VuZChcInBpbmdcIiksMjRlMyk7ZS5hZGRFdmVudExpc3RlbmVyKFwiY2xvc2VcIiwoKT0+Y2xlYXJJbnRlcnZhbCh0KSl9KSxlLmFkZEV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLGFzeW5jKCk9Pnthd2FpdCBrKCkscCghMCl9KX1UKGFzeW5jIGU9Pntzd2l0Y2goaShcIkJHU1cgUnVudGltZSAtIE9uIEJ1aWxkIFJlcGFja2FnZWRcIiksZS50eXBlKXtjYXNlXCJidWlsZF9yZWFkeVwiOnthLmJ1aWxkUmVhZHl8fD0hMCxwKCk7YnJlYWt9Y2FzZVwiY3NfY2hhbmdlZFwiOnthLmNzQ2hhbmdlZHx8PSEwLHAoKTticmVha319fSk7Yy5ydW50aW1lLm9uQ29ubmVjdC5hZGRMaXN0ZW5lcihmdW5jdGlvbihlKXtsZXQgdD1lLm5hbWUuc3RhcnRzV2l0aChQKSxvPWUubmFtZS5zdGFydHNXaXRoKFMpO2lmKHR8fG8pe2xldCBzPXQ/YS5wYWdlUG9ydHM6YS5zY3JpcHRQb3J0cztzLmFkZChlKSxlLm9uRGlzY29ubmVjdC5hZGRMaXN0ZW5lcigoKT0+e3MuZGVsZXRlKGUpfSksZS5vbk1lc3NhZ2UuYWRkTGlzdGVuZXIoZnVuY3Rpb24ocil7aShcIkJHU1cgUnVudGltZSAtIE9uIHNvdXJjZSBjaGFuZ2VkXCIsciksci5fX3BsYXNtb19jc19jaGFuZ2VkX18mJihhLmNzQ2hhbmdlZHx8PSEwKSxyLl9fcGxhc21vX3BhZ2VfY2hhbmdlZF9fJiYoYS5wYWdlQ2hhbmdlZHx8PSEwKSxwKCl9KX19KTtjLnJ1bnRpbWUub25NZXNzYWdlLmFkZExpc3RlbmVyKGZ1bmN0aW9uKHQpe3JldHVybiB0Ll9fcGxhc21vX2Z1bGxfcmVsb2FkX18mJihpKFwiQkdTVyBSdW50aW1lIC0gT24gdG9wLWxldmVsIGNvZGUgY2hhbmdlZFwiKSxwKCkpLCEwfSk7XG4iLCJpbXBvcnQgXCIuLi8uLi8uLi9zcmMvYmFja2dyb3VuZFwiIiwiaW1wb3J0IHsgU3RvcmFnZSB9IGZyb20gXCJAcGxhc21vaHEvc3RvcmFnZVwiXG5pbXBvcnQgeyBDb252ZXhIdHRwQ2xpZW50IH0gZnJvbSBcImNvbnZleC9icm93c2VyXCJcbmltcG9ydCB7IGFwaSB9IGZyb20gXCIuLi9jb252ZXgvX2dlbmVyYXRlZC9hcGlcIlxuXG5jb25zdCBzdG9yYWdlID0gbmV3IFN0b3JhZ2UoKVxuXG5jb25zdCBDT05WRVhfVVJMID0gcHJvY2Vzcy5lbnYuUExBU01PX1BVQkxJQ19DT05WRVhfVVJMIHx8IFwiXCJcbmNvbnN0IFNUUklQRV9QUklDRV9JRCA9IHByb2Nlc3MuZW52LlBMQVNNT19QVUJMSUNfU1RSSVBFX1BSSUNFX0lEIHx8IFwiXCJcblxuY29uc3QgY29udmV4ID0gbmV3IENvbnZleEh0dHBDbGllbnQoQ09OVkVYX1VSTClcblxuY2hyb21lLnJ1bnRpbWUub25JbnN0YWxsZWQuYWRkTGlzdGVuZXIoYXN5bmMgKGRldGFpbHMpID0+IHtcbiAgaWYgKGRldGFpbHMucmVhc29uID09PSBcImluc3RhbGxcIikge1xuICAgIGF3YWl0IHN0b3JhZ2Uuc2V0KFwiY3JlZGl0c1wiLCAxKVxuICAgIGF3YWl0IHN0b3JhZ2Uuc2V0KFwiaXNQcmVtaXVtXCIsIGZhbHNlKVxuICAgIGF3YWl0IHN0b3JhZ2Uuc2V0KFwiaXNBdXRoZW50aWNhdGVkXCIsIGZhbHNlKVxuICAgIGNvbnNvbGUubG9nKFwiW0luc3RhZ3JhbSBBSSBPcHRpbWl6ZXJdIEV4dGVuc2lvbiBpbnN0YWxsZWRcIilcbiAgfVxufSlcblxuY2hyb21lLmFjdGlvbi5vbkNsaWNrZWQuYWRkTGlzdGVuZXIoKHRhYikgPT4ge1xuICBpZiAodGFiLnVybD8uaW5jbHVkZXMoXCJpbnN0YWdyYW0uY29tXCIpKSB7XG4gICAgY2hyb21lLnRhYnMuc2VuZE1lc3NhZ2UodGFiLmlkISwgeyB0eXBlOiBcIlRPR0dMRV9QQU5FTFwiIH0pXG4gIH1cbn0pXG5cbnR5cGUgTWVzc2FnZVR5cGUgPVxuICB8IHsgdHlwZTogXCJHRVRfQVVUSF9TVEFURVwiIH1cbiAgfCB7IHR5cGU6IFwiU0VUX0FVVEhfU1RBVEVcIjsgcGF5bG9hZDogeyBpc0F1dGhlbnRpY2F0ZWQ6IGJvb2xlYW47IG9kY2gxMjM/OiBzdHJpbmc7IGVtYWlsPzogc3RyaW5nIH0gfVxuICB8IHsgdHlwZTogXCJHRVRfQ1JFRElUU1wiIH1cbiAgfCB7IHR5cGU6IFwiU0VUX0NSRURJVFNcIjsgcGF5bG9hZDogbnVtYmVyIH1cbiAgfCB7IHR5cGU6IFwiREVDUkVNRU5UX0NSRURJVFNcIiB9XG4gIHwgeyB0eXBlOiBcIlNFVF9QUkVNSVVNXCI7IHBheWxvYWQ6IGJvb2xlYW4gfVxuICB8IHsgdHlwZTogXCJHRVRfVVNFUl9TVEFURVwiIH1cbiAgfCB7IHR5cGU6IFwiT1BUSU1JWkVfSU1BR0VcIjsgcGF5bG9hZDogeyBpbWFnZVVybDogc3RyaW5nOyBzdHlsZVByZXNldD86IHN0cmluZyB9IH1cbiAgfCB7IHR5cGU6IFwiQ1JFQVRFX0NIRUNLT1VUXCIgfVxuXG5jaHJvbWUucnVudGltZS5vbk1lc3NhZ2UuYWRkTGlzdGVuZXIoKG1lc3NhZ2U6IE1lc3NhZ2VUeXBlLCBzZW5kZXIsIHNlbmRSZXNwb25zZSkgPT4ge1xuICBoYW5kbGVNZXNzYWdlKG1lc3NhZ2UsIHNlbmRlciwgc2VuZFJlc3BvbnNlKVxuICByZXR1cm4gdHJ1ZVxufSlcblxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShcbiAgbWVzc2FnZTogTWVzc2FnZVR5cGUsXG4gIF9zZW5kZXI6IGNocm9tZS5ydW50aW1lLk1lc3NhZ2VTZW5kZXIsXG4gIHNlbmRSZXNwb25zZTogKHJlc3BvbnNlOiB1bmtub3duKSA9PiB2b2lkXG4pIHtcbiAgdHJ5IHtcbiAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgY2FzZSBcIkdFVF9BVVRIX1NUQVRFXCI6IHtcbiAgICAgICAgY29uc3QgaXNBdXRoZW50aWNhdGVkID0gYXdhaXQgc3RvcmFnZS5nZXQ8Ym9vbGVhbj4oXCJpc0F1dGhlbnRpY2F0ZWRcIilcbiAgICAgICAgY29uc3Qgb2RjaDEyMyA9IGF3YWl0IHN0b3JhZ2UuZ2V0PHN0cmluZz4oXCJvZGNoMTIzXCIpXG4gICAgICAgIHNlbmRSZXNwb25zZSh7IGlzQXV0aGVudGljYXRlZDogaXNBdXRoZW50aWNhdGVkID8/IGZhbHNlLCBvZGNoMTIzIH0pXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIGNhc2UgXCJTRVRfQVVUSF9TVEFURVwiOiB7XG4gICAgICAgIGF3YWl0IHN0b3JhZ2Uuc2V0KFwiaXNBdXRoZW50aWNhdGVkXCIsIG1lc3NhZ2UucGF5bG9hZC5pc0F1dGhlbnRpY2F0ZWQpXG4gICAgICAgIGlmIChtZXNzYWdlLnBheWxvYWQub2RjaDEyMykge1xuICAgICAgICAgIGF3YWl0IHN0b3JhZ2Uuc2V0KFwib2RjaDEyM1wiLCBtZXNzYWdlLnBheWxvYWQub2RjaDEyMylcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5wYXlsb2FkLmlzQXV0aGVudGljYXRlZCAmJiBtZXNzYWdlLnBheWxvYWQub2RjaDEyMyAmJiBtZXNzYWdlLnBheWxvYWQuZW1haWwpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgY29udmV4Lm11dGF0aW9uKGFwaS5wcm9maWxlcy5jcmVhdGUsIHtcbiAgICAgICAgICAgICAgb2RjaDEyMzogbWVzc2FnZS5wYXlsb2FkLm9kY2gxMjMsXG4gICAgICAgICAgICAgIGVtYWlsOiBtZXNzYWdlLnBheWxvYWQuZW1haWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW0luc3RhZ3JhbSBBSSBPcHRpbWl6ZXJdIFByb2ZpbGUgbWF5IGFscmVhZHkgZXhpc3RcIilcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2VuZFJlc3BvbnNlKHsgc3VjY2VzczogdHJ1ZSB9KVxuICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICBjYXNlIFwiR0VUX0NSRURJVFNcIjoge1xuICAgICAgICBjb25zdCBvZGNoMTIzID0gYXdhaXQgc3RvcmFnZS5nZXQ8c3RyaW5nPihcIm9kY2gxMjNcIilcbiAgICAgICAgaWYgKG9kY2gxMjMgJiYgQ09OVkVYX1VSTCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwcm9maWxlID0gYXdhaXQgY29udmV4LnF1ZXJ5KGFwaS5wcm9maWxlcy5nZXRCeVVzZXJJZCwgeyBvZGNoMTIzIH0pXG4gICAgICAgICAgICBpZiAocHJvZmlsZSkge1xuICAgICAgICAgICAgICBhd2FpdCBzdG9yYWdlLnNldChcImNyZWRpdHNcIiwgcHJvZmlsZS5jcmVkaXRzKVxuICAgICAgICAgICAgICBhd2FpdCBzdG9yYWdlLnNldChcImlzUHJlbWl1bVwiLCBwcm9maWxlLmlzUHJlbWl1bSlcbiAgICAgICAgICAgICAgc2VuZFJlc3BvbnNlKHsgY3JlZGl0czogcHJvZmlsZS5pc1ByZW1pdW0gPyAtMSA6IHByb2ZpbGUuY3JlZGl0cyB9KVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJbSW5zdGFncmFtIEFJIE9wdGltaXplcl0gRmFpbGVkIHRvIGZldGNoIHByb2ZpbGU6XCIsIGUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNyZWRpdHMgPSBhd2FpdCBzdG9yYWdlLmdldDxudW1iZXI+KFwiY3JlZGl0c1wiKVxuICAgICAgICBzZW5kUmVzcG9uc2UoeyBjcmVkaXRzOiBjcmVkaXRzID8/IDEgfSlcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgY2FzZSBcIlNFVF9DUkVESVRTXCI6IHtcbiAgICAgICAgYXdhaXQgc3RvcmFnZS5zZXQoXCJjcmVkaXRzXCIsIG1lc3NhZ2UucGF5bG9hZClcbiAgICAgICAgc2VuZFJlc3BvbnNlKHsgc3VjY2VzczogdHJ1ZSB9KVxuICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICBjYXNlIFwiREVDUkVNRU5UX0NSRURJVFNcIjoge1xuICAgICAgICBjb25zdCBvZGNoMTIzID0gYXdhaXQgc3RvcmFnZS5nZXQ8c3RyaW5nPihcIm9kY2gxMjNcIilcbiAgICAgICAgaWYgKG9kY2gxMjMgJiYgQ09OVkVYX1VSTCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb252ZXgubXV0YXRpb24oYXBpLnByb2ZpbGVzLmRlY3JlbWVudENyZWRpdHMsIHsgb2RjaDEyMyB9KVxuICAgICAgICAgICAgYXdhaXQgc3RvcmFnZS5zZXQoXCJjcmVkaXRzXCIsIHJlc3VsdC5jcmVkaXRzKVxuICAgICAgICAgICAgc2VuZFJlc3BvbnNlKHJlc3VsdClcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIltJbnN0YWdyYW0gQUkgT3B0aW1pemVyXSBGYWlsZWQgdG8gZGVjcmVtZW50IGNyZWRpdHM6XCIsIGUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDcmVkaXRzID0gKGF3YWl0IHN0b3JhZ2UuZ2V0PG51bWJlcj4oXCJjcmVkaXRzXCIpKSA/PyAxXG4gICAgICAgIGNvbnN0IGlzUHJlbWl1bSA9IGF3YWl0IHN0b3JhZ2UuZ2V0PGJvb2xlYW4+KFwiaXNQcmVtaXVtXCIpXG4gICAgICAgIGlmIChpc1ByZW1pdW0pIHtcbiAgICAgICAgICBzZW5kUmVzcG9uc2UoeyBjcmVkaXRzOiAtMSB9KVxuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRDcmVkaXRzID4gMCkge1xuICAgICAgICAgIGNvbnN0IG5ld0NyZWRpdHMgPSBjdXJyZW50Q3JlZGl0cyAtIDFcbiAgICAgICAgICBhd2FpdCBzdG9yYWdlLnNldChcImNyZWRpdHNcIiwgbmV3Q3JlZGl0cylcbiAgICAgICAgICBzZW5kUmVzcG9uc2UoeyBjcmVkaXRzOiBuZXdDcmVkaXRzIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VuZFJlc3BvbnNlKHsgY3JlZGl0czogMCwgZXJyb3I6IFwiTm8gY3JlZGl0cyByZW1haW5pbmdcIiB9KVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIGNhc2UgXCJTRVRfUFJFTUlVTVwiOiB7XG4gICAgICAgIGNvbnN0IG9kY2gxMjMgPSBhd2FpdCBzdG9yYWdlLmdldDxzdHJpbmc+KFwib2RjaDEyM1wiKVxuICAgICAgICBpZiAob2RjaDEyMyAmJiBDT05WRVhfVVJMKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGNvbnZleC5tdXRhdGlvbihhcGkucHJvZmlsZXMuc2V0UHJlbWl1bSwge1xuICAgICAgICAgICAgICBvZGNoMTIzLFxuICAgICAgICAgICAgICBpc1ByZW1pdW06IG1lc3NhZ2UucGF5bG9hZCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIltJbnN0YWdyYW0gQUkgT3B0aW1pemVyXSBGYWlsZWQgdG8gc2V0IHByZW1pdW06XCIsIGUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHN0b3JhZ2Uuc2V0KFwiaXNQcmVtaXVtXCIsIG1lc3NhZ2UucGF5bG9hZClcbiAgICAgICAgaWYgKG1lc3NhZ2UucGF5bG9hZCkge1xuICAgICAgICAgIGF3YWl0IHN0b3JhZ2Uuc2V0KFwiY3JlZGl0c1wiLCAtMSlcbiAgICAgICAgfVxuICAgICAgICBzZW5kUmVzcG9uc2UoeyBzdWNjZXNzOiB0cnVlIH0pXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIGNhc2UgXCJHRVRfVVNFUl9TVEFURVwiOiB7XG4gICAgICAgIGNvbnN0IG9kY2gxMjMgPSBhd2FpdCBzdG9yYWdlLmdldDxzdHJpbmc+KFwib2RjaDEyM1wiKVxuICAgICAgICBpZiAob2RjaDEyMyAmJiBDT05WRVhfVVJMKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHByb2ZpbGUgPSBhd2FpdCBjb252ZXgucXVlcnkoYXBpLnByb2ZpbGVzLmdldEJ5VXNlcklkLCB7IG9kY2gxMjMgfSlcbiAgICAgICAgICAgIGlmIChwcm9maWxlKSB7XG4gICAgICAgICAgICAgIGF3YWl0IHN0b3JhZ2Uuc2V0KFwiY3JlZGl0c1wiLCBwcm9maWxlLmNyZWRpdHMpXG4gICAgICAgICAgICAgIGF3YWl0IHN0b3JhZ2Uuc2V0KFwiaXNQcmVtaXVtXCIsIHByb2ZpbGUuaXNQcmVtaXVtKVxuICAgICAgICAgICAgICBzZW5kUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICAgIGlzQXV0aGVudGljYXRlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpc1ByZW1pdW06IHByb2ZpbGUuaXNQcmVtaXVtLFxuICAgICAgICAgICAgICAgIGNyZWRpdHM6IHByb2ZpbGUuaXNQcmVtaXVtID8gLTEgOiBwcm9maWxlLmNyZWRpdHMsXG4gICAgICAgICAgICAgICAgb2RjaDEyMyxcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiW0luc3RhZ3JhbSBBSSBPcHRpbWl6ZXJdIEZhaWxlZCB0byBmZXRjaCB1c2VyIHN0YXRlOlwiLCBlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbaXNBdXRoZW50aWNhdGVkLCBpc1ByZW1pdW0sIGNyZWRpdHNdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgIHN0b3JhZ2UuZ2V0PGJvb2xlYW4+KFwiaXNBdXRoZW50aWNhdGVkXCIpLFxuICAgICAgICAgIHN0b3JhZ2UuZ2V0PGJvb2xlYW4+KFwiaXNQcmVtaXVtXCIpLFxuICAgICAgICAgIHN0b3JhZ2UuZ2V0PG51bWJlcj4oXCJjcmVkaXRzXCIpLFxuICAgICAgICBdKVxuICAgICAgICBzZW5kUmVzcG9uc2Uoe1xuICAgICAgICAgIGlzQXV0aGVudGljYXRlZDogaXNBdXRoZW50aWNhdGVkID8/IGZhbHNlLFxuICAgICAgICAgIGlzUHJlbWl1bTogaXNQcmVtaXVtID8/IGZhbHNlLFxuICAgICAgICAgIGNyZWRpdHM6IGlzUHJlbWl1bSA/IC0xIDogKGNyZWRpdHMgPz8gMSksXG4gICAgICAgICAgb2RjaDEyMyxcbiAgICAgICAgfSlcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgY2FzZSBcIk9QVElNSVpFX0lNQUdFXCI6IHtcbiAgICAgICAgaWYgKENPTlZFWF9VUkwpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29udmV4LmFjdGlvbihhcGkuYWkuZW5oYW5jZS5lbmhhbmNlSW1hZ2UsIHtcbiAgICAgICAgICAgICAgaW1hZ2VVcmw6IG1lc3NhZ2UucGF5bG9hZC5pbWFnZVVybCxcbiAgICAgICAgICAgICAgc3R5bGVQcmVzZXQ6IG1lc3NhZ2UucGF5bG9hZC5zdHlsZVByZXNldCxcbiAgICAgICAgICAgICAgZW5oYW5jZW1lbnRMZXZlbDogXCJtb2RlcmF0ZVwiLFxuICAgICAgICAgICAgICB1c2VGdWxsUGlwZWxpbmU6IGZhbHNlLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHNlbmRSZXNwb25zZSh7XG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IHJlc3VsdC5zdWNjZXNzLFxuICAgICAgICAgICAgICBhaUltYWdlVXJsOiByZXN1bHQuZW5oYW5jZWRVcmwgfHwgbWVzc2FnZS5wYXlsb2FkLmltYWdlVXJsLFxuICAgICAgICAgICAgICBlcnJvcjogcmVzdWx0LmVycm9yLFxuICAgICAgICAgICAgICBwcm9jZXNzaW5nVGltZU1zOiByZXN1bHQucHJvY2Vzc2luZ1RpbWVNcyxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJbSW5zdGFncmFtIEFJIE9wdGltaXplcl0gQUkgZW5oYW5jZW1lbnQgZmFpbGVkOlwiLCBlKVxuICAgICAgICAgICAgc2VuZFJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgIGFpSW1hZ2VVcmw6IG1lc3NhZ2UucGF5bG9hZC5pbWFnZVVybCxcbiAgICAgICAgICAgICAgZXJyb3I6IFN0cmluZyhlKSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZW5kUmVzcG9uc2Uoe1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGFpSW1hZ2VVcmw6IG1lc3NhZ2UucGF5bG9hZC5pbWFnZVVybCxcbiAgICAgICAgICBlcnJvcjogXCJDb252ZXggbm90IGNvbmZpZ3VyZWRcIixcbiAgICAgICAgfSlcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgY2FzZSBcIkNSRUFURV9DSEVDS09VVFwiOiB7XG4gICAgICAgIGNvbnN0IG9kY2gxMjMgPSBhd2FpdCBzdG9yYWdlLmdldDxzdHJpbmc+KFwib2RjaDEyM1wiKVxuICAgICAgICBpZiAoIW9kY2gxMjMpIHtcbiAgICAgICAgICBzZW5kUmVzcG9uc2UoeyBlcnJvcjogXCJOb3QgYXV0aGVudGljYXRlZFwiIH0pXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQ09OVkVYX1VSTCAmJiBTVFJJUEVfUFJJQ0VfSUQpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29udmV4LmFjdGlvbihhcGkuc3RyaXBlLmNyZWF0ZUNoZWNrb3V0U2Vzc2lvbiwge1xuICAgICAgICAgICAgICBvZGNoMTIzLFxuICAgICAgICAgICAgICBwcmljZUlkOiBTVFJJUEVfUFJJQ0VfSUQsXG4gICAgICAgICAgICAgIHN1Y2Nlc3NVcmw6IFwiaHR0cHM6Ly93d3cuaW5zdGFncmFtLmNvbS8/cGF5bWVudD1zdWNjZXNzXCIsXG4gICAgICAgICAgICAgIGNhbmNlbFVybDogXCJodHRwczovL3d3dy5pbnN0YWdyYW0uY29tLz9wYXltZW50PWNhbmNlbGxlZFwiLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHNlbmRSZXNwb25zZShyZXN1bHQpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJbSW5zdGFncmFtIEFJIE9wdGltaXplcl0gRmFpbGVkIHRvIGNyZWF0ZSBjaGVja291dDpcIiwgZSlcbiAgICAgICAgICAgIHNlbmRSZXNwb25zZSh7IGVycm9yOiBTdHJpbmcoZSkgfSlcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNlbmRSZXNwb25zZSh7IGVycm9yOiBcIlN0cmlwZSBub3QgY29uZmlndXJlZFwiIH0pXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHNlbmRSZXNwb25zZSh7IGVycm9yOiBcIlVua25vd24gbWVzc2FnZSB0eXBlXCIgfSlcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIltJbnN0YWdyYW0gQUkgT3B0aW1pemVyXSBNZXNzYWdlIGhhbmRsaW5nIGVycm9yOlwiLCBlcnJvcilcbiAgICBzZW5kUmVzcG9uc2UoeyBlcnJvcjogU3RyaW5nKGVycm9yKSB9KVxuICB9XG59XG5cbmNocm9tZS50YWJzLm9uVXBkYXRlZC5hZGRMaXN0ZW5lcigodGFiSWQsIGNoYW5nZUluZm8sIHRhYikgPT4ge1xuICBpZiAoY2hhbmdlSW5mby5zdGF0dXMgPT09IFwiY29tcGxldGVcIiAmJiB0YWIudXJsPy5pbmNsdWRlcyhcImluc3RhZ3JhbS5jb21cIikpIHtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHRhYi51cmwpXG4gICAgaWYgKHVybC5zZWFyY2hQYXJhbXMuZ2V0KFwicGF5bWVudFwiKSA9PT0gXCJzdWNjZXNzXCIpIHtcbiAgICAgIHN0b3JhZ2Uuc2V0KFwiaXNQcmVtaXVtXCIsIHRydWUpXG4gICAgICBzdG9yYWdlLnNldChcImNyZWRpdHNcIiwgLTEpXG4gICAgICBjaHJvbWUudGFicy5zZW5kTWVzc2FnZSh0YWJJZCwgeyB0eXBlOiBcIlBBWU1FTlRfU1VDQ0VTU1wiIH0pLmNhdGNoKCgpID0+IHt9KVxuICAgIH1cbiAgICBjaHJvbWUudGFicy5zZW5kTWVzc2FnZSh0YWJJZCwgeyB0eXBlOiBcIlBBR0VfTE9BREVEXCIgfSkuY2F0Y2goKCkgPT4ge30pXG4gIH1cbn0pXG4iLCJpbXBvcnQgbSBmcm9tXCJwaWZ5XCI7dmFyIGw9KCk9Pnt0cnl7bGV0IGU9KGdsb2JhbFRoaXMubmF2aWdhdG9yPy51c2VyQWdlbnQpLm1hdGNoKC8ob3BlcmF8Y2hyb21lfHNhZmFyaXxmaXJlZm94fG1zaWV8dHJpZGVudCg/PVxcLykpXFwvP1xccyooXFxkKykvaSl8fFtdO2lmKGVbMV09PT1cIkNocm9tZVwiKXJldHVybiBwYXJzZUludChlWzJdKTwxMDB8fGdsb2JhbFRoaXMuY2hyb21lLnJ1bnRpbWU/LmdldE1hbmlmZXN0KCk/Lm1hbmlmZXN0X3ZlcnNpb249PT0yfWNhdGNoe3JldHVybiExfXJldHVybiExfTt2YXIgbz1jbGFzc3sjcjsjdDtnZXQgcHJpbWFyeUNsaWVudCgpe3JldHVybiB0aGlzLiN0fSNlO2dldCBzZWNvbmRhcnlDbGllbnQoKXtyZXR1cm4gdGhpcy4jZX0jYTtnZXQgYXJlYSgpe3JldHVybiB0aGlzLiNhfWdldCBoYXNXZWJBcGkoKXt0cnl7cmV0dXJuIHR5cGVvZiB3aW5kb3c8XCJ1XCImJiEhd2luZG93LmxvY2FsU3RvcmFnZX1jYXRjaChlKXtyZXR1cm4gY29uc29sZS5lcnJvcihlKSwhMX19I3M9bmV3IE1hcDsjaTtnZXQgY29waWVkS2V5U2V0KCl7cmV0dXJuIHRoaXMuI2l9aXNDb3BpZWQ9ZT0+dGhpcy5oYXNXZWJBcGkmJih0aGlzLmFsbENvcGllZHx8dGhpcy5jb3BpZWRLZXlTZXQuaGFzKGUpKTsjbj0hMTtnZXQgYWxsQ29waWVkKCl7cmV0dXJuIHRoaXMuI259Z2V0RXh0U3RvcmFnZUFwaT0oKT0+Z2xvYmFsVGhpcy5icm93c2VyPy5zdG9yYWdlfHxnbG9iYWxUaGlzLmNocm9tZT8uc3RvcmFnZTtnZXQgaGFzRXh0ZW5zaW9uQXBpKCl7dHJ5e3JldHVybiEhdGhpcy5nZXRFeHRTdG9yYWdlQXBpKCl9Y2F0Y2goZSl7cmV0dXJuIGNvbnNvbGUuZXJyb3IoZSksITF9fWlzV2F0Y2hTdXBwb3J0ZWQ9KCk9PnRoaXMuaGFzRXh0ZW5zaW9uQXBpO2tleU5hbWVzcGFjZT1cIlwiO2lzVmFsaWRLZXk9ZT0+ZS5zdGFydHNXaXRoKHRoaXMua2V5TmFtZXNwYWNlKTtnZXROYW1lc3BhY2VkS2V5PWU9PmAke3RoaXMua2V5TmFtZXNwYWNlfSR7ZX1gO2dldFVubmFtZXNwYWNlZEtleT1lPT5lLnNsaWNlKHRoaXMua2V5TmFtZXNwYWNlLmxlbmd0aCk7c2VyZGU9e3NlcmlhbGl6ZXI6SlNPTi5zdHJpbmdpZnksZGVzZXJpYWxpemVyOkpTT04ucGFyc2V9O2NvbnN0cnVjdG9yKHthcmVhOmU9XCJzeW5jXCIsYWxsQ29waWVkOnQ9ITEsY29waWVkS2V5TGlzdDpzPVtdLHNlcmRlOnI9e319PXt9KXt0aGlzLnNldENvcGllZEtleVNldChzKSx0aGlzLiNhPWUsdGhpcy4jbj10LHRoaXMuc2VyZGU9ey4uLnRoaXMuc2VyZGUsLi4ucn07dHJ5e3RoaXMuaGFzV2ViQXBpJiYodHx8cy5sZW5ndGg+MCkmJih0aGlzLiNlPXdpbmRvdy5sb2NhbFN0b3JhZ2UpfWNhdGNoe310cnl7dGhpcy5oYXNFeHRlbnNpb25BcGkmJih0aGlzLiNyPXRoaXMuZ2V0RXh0U3RvcmFnZUFwaSgpLGwoKT90aGlzLiN0PW0odGhpcy4jclt0aGlzLmFyZWFdLHtleGNsdWRlOltcImdldEJ5dGVzSW5Vc2VcIl0sZXJyb3JGaXJzdDohMX0pOnRoaXMuI3Q9dGhpcy4jclt0aGlzLmFyZWFdKX1jYXRjaHt9fXNldENvcGllZEtleVNldChlKXt0aGlzLiNpPW5ldyBTZXQoZSl9cmF3R2V0QWxsPSgpPT50aGlzLiN0Py5nZXQoKTtnZXRBbGw9YXN5bmMoKT0+e2xldCBlPWF3YWl0IHRoaXMucmF3R2V0QWxsKCk7cmV0dXJuIE9iamVjdC5lbnRyaWVzKGUpLmZpbHRlcigoW3RdKT0+dGhpcy5pc1ZhbGlkS2V5KHQpKS5yZWR1Y2UoKHQsW3Mscl0pPT4odFt0aGlzLmdldFVubmFtZXNwYWNlZEtleShzKV09cix0KSx7fSl9O2NvcHk9YXN5bmMgZT0+e2xldCB0PWU9PT12b2lkIDA7aWYoIXQmJiF0aGlzLmNvcGllZEtleVNldC5oYXMoZSl8fCF0aGlzLmFsbENvcGllZHx8IXRoaXMuaGFzRXh0ZW5zaW9uQXBpKXJldHVybiExO2xldCBzPXRoaXMuYWxsQ29waWVkP2F3YWl0IHRoaXMucmF3R2V0QWxsKCk6YXdhaXQgdGhpcy4jdC5nZXQoKHQ/Wy4uLnRoaXMuY29waWVkS2V5U2V0XTpbZV0pLm1hcCh0aGlzLmdldE5hbWVzcGFjZWRLZXkpKTtpZighcylyZXR1cm4hMTtsZXQgcj0hMTtmb3IobGV0IGEgaW4gcyl7bGV0IGk9c1thXSxuPXRoaXMuI2U/LmdldEl0ZW0oYSk7dGhpcy4jZT8uc2V0SXRlbShhLGkpLHJ8fD1pIT09bn1yZXR1cm4gcn07cmF3R2V0PWFzeW5jIGU9Pihhd2FpdCB0aGlzLnJhd0dldE1hbnkoW2VdKSlbZV07cmF3R2V0TWFueT1hc3luYyBlPT50aGlzLmhhc0V4dGVuc2lvbkFwaT9hd2FpdCB0aGlzLiN0LmdldChlKTplLmZpbHRlcih0aGlzLmlzQ29waWVkKS5yZWR1Y2UoKHQscyk9Pih0W3NdPXRoaXMuI2U/LmdldEl0ZW0ocyksdCkse30pO3Jhd1NldD1hc3luYyhlLHQpPT5hd2FpdCB0aGlzLnJhd1NldE1hbnkoe1tlXTp0fSk7cmF3U2V0TWFueT1hc3luYyBlPT4odGhpcy4jZSYmT2JqZWN0LmVudHJpZXMoZSkuZmlsdGVyKChbdF0pPT50aGlzLmlzQ29waWVkKHQpKS5mb3JFYWNoKChbdCxzXSk9PnRoaXMuI2Uuc2V0SXRlbSh0LHMpKSx0aGlzLmhhc0V4dGVuc2lvbkFwaSYmYXdhaXQgdGhpcy4jdC5zZXQoZSksbnVsbCk7Y2xlYXI9YXN5bmMoZT0hMSk9PntlJiZ0aGlzLiNlPy5jbGVhcigpLGF3YWl0IHRoaXMuI3QuY2xlYXIoKX07cmF3UmVtb3ZlPWFzeW5jIGU9Pnthd2FpdCB0aGlzLnJhd1JlbW92ZU1hbnkoW2VdKX07cmF3UmVtb3ZlTWFueT1hc3luYyBlPT57dGhpcy4jZSYmZS5maWx0ZXIodGhpcy5pc0NvcGllZCkuZm9yRWFjaCh0PT50aGlzLiNlLnJlbW92ZUl0ZW0odCkpLHRoaXMuaGFzRXh0ZW5zaW9uQXBpJiZhd2FpdCB0aGlzLiN0LnJlbW92ZShlKX07cmVtb3ZlQWxsPWFzeW5jKCk9PntsZXQgZT1hd2FpdCB0aGlzLmdldEFsbCgpLHQ9T2JqZWN0LmtleXMoZSk7YXdhaXQgdGhpcy5yZW1vdmVNYW55KHQpfTt3YXRjaD1lPT57bGV0IHQ9dGhpcy5pc1dhdGNoU3VwcG9ydGVkKCk7cmV0dXJuIHQmJnRoaXMuI28oZSksdH07I289ZT0+e2ZvcihsZXQgdCBpbiBlKXtsZXQgcz10aGlzLmdldE5hbWVzcGFjZWRLZXkodCkscj10aGlzLiNzLmdldChzKT8uY2FsbGJhY2tTZXR8fG5ldyBTZXQ7aWYoci5hZGQoZVt0XSksci5zaXplPjEpY29udGludWU7bGV0IGE9KGksbik9PntpZihuIT09dGhpcy5hcmVhfHwhaVtzXSlyZXR1cm47bGV0IGg9dGhpcy4jcy5nZXQocyk7aWYoIWgpdGhyb3cgbmV3IEVycm9yKGBTdG9yYWdlIGNvbW1zIGRvZXMgbm90IGV4aXN0IGZvciBuc0tleTogJHtzfWApO1Byb21pc2UuYWxsKFt0aGlzLnBhcnNlVmFsdWUoaVtzXS5uZXdWYWx1ZSksdGhpcy5wYXJzZVZhbHVlKGlbc10ub2xkVmFsdWUpXSkudGhlbigoW3ksZF0pPT57Zm9yKGxldCBwIG9mIGguY2FsbGJhY2tTZXQpcCh7bmV3VmFsdWU6eSxvbGRWYWx1ZTpkfSxuKX0pfTt0aGlzLiNyLm9uQ2hhbmdlZC5hZGRMaXN0ZW5lcihhKSx0aGlzLiNzLnNldChzLHtjYWxsYmFja1NldDpyLGxpc3RlbmVyOmF9KX19O3Vud2F0Y2g9ZT0+e2xldCB0PXRoaXMuaXNXYXRjaFN1cHBvcnRlZCgpO3JldHVybiB0JiZ0aGlzLiNjKGUpLHR9OyNjKGUpe2ZvcihsZXQgdCBpbiBlKXtsZXQgcz10aGlzLmdldE5hbWVzcGFjZWRLZXkodCkscj1lW3RdLGE9dGhpcy4jcy5nZXQocyk7YSYmKGEuY2FsbGJhY2tTZXQuZGVsZXRlKHIpLGEuY2FsbGJhY2tTZXQuc2l6ZT09PTAmJih0aGlzLiNzLmRlbGV0ZShzKSx0aGlzLiNyLm9uQ2hhbmdlZC5yZW1vdmVMaXN0ZW5lcihhLmxpc3RlbmVyKSkpfX11bndhdGNoQWxsPSgpPT50aGlzLiNoKCk7I2goKXt0aGlzLiNzLmZvckVhY2goKHtsaXN0ZW5lcjplfSk9PnRoaXMuI3Iub25DaGFuZ2VkLnJlbW92ZUxpc3RlbmVyKGUpKSx0aGlzLiNzLmNsZWFyKCl9YXN5bmMgZ2V0SXRlbShlKXtyZXR1cm4gdGhpcy5nZXQoZSl9YXN5bmMgZ2V0SXRlbXMoZSl7cmV0dXJuIGF3YWl0IHRoaXMuZ2V0TWFueShlKX1hc3luYyBzZXRJdGVtKGUsdCl7YXdhaXQgdGhpcy5zZXQoZSx0KX1hc3luYyBzZXRJdGVtcyhlKXthd2FpdCBhd2FpdCB0aGlzLnNldE1hbnkoZSl9YXN5bmMgcmVtb3ZlSXRlbShlKXtyZXR1cm4gdGhpcy5yZW1vdmUoZSl9YXN5bmMgcmVtb3ZlSXRlbXMoZSl7cmV0dXJuIGF3YWl0IHRoaXMucmVtb3ZlTWFueShlKX19LGc9Y2xhc3MgZXh0ZW5kcyBve2dldD1hc3luYyBlPT57bGV0IHQ9dGhpcy5nZXROYW1lc3BhY2VkS2V5KGUpLHM9YXdhaXQgdGhpcy5yYXdHZXQodCk7cmV0dXJuIHRoaXMucGFyc2VWYWx1ZShzKX07Z2V0TWFueT1hc3luYyBlPT57bGV0IHQ9ZS5tYXAodGhpcy5nZXROYW1lc3BhY2VkS2V5KSxzPWF3YWl0IHRoaXMucmF3R2V0TWFueSh0KSxyPWF3YWl0IFByb21pc2UuYWxsKE9iamVjdC52YWx1ZXMocykubWFwKHRoaXMucGFyc2VWYWx1ZSkpO3JldHVybiBPYmplY3Qua2V5cyhzKS5yZWR1Y2UoKGEsaSxuKT0+KGFbdGhpcy5nZXRVbm5hbWVzcGFjZWRLZXkoaSldPXJbbl0sYSkse30pfTtzZXQ9YXN5bmMoZSx0KT0+e2xldCBzPXRoaXMuZ2V0TmFtZXNwYWNlZEtleShlKSxyPXRoaXMuc2VyZGUuc2VyaWFsaXplcih0KTtyZXR1cm4gdGhpcy5yYXdTZXQocyxyKX07c2V0TWFueT1hc3luYyBlPT57bGV0IHQ9T2JqZWN0LmVudHJpZXMoZSkucmVkdWNlKChzLFtyLGFdKT0+KHNbdGhpcy5nZXROYW1lc3BhY2VkS2V5KHIpXT10aGlzLnNlcmRlLnNlcmlhbGl6ZXIoYSkscykse30pO3JldHVybiBhd2FpdCB0aGlzLnJhd1NldE1hbnkodCl9O3JlbW92ZT1hc3luYyBlPT57bGV0IHQ9dGhpcy5nZXROYW1lc3BhY2VkS2V5KGUpO3JldHVybiB0aGlzLnJhd1JlbW92ZSh0KX07cmVtb3ZlTWFueT1hc3luYyBlPT57bGV0IHQ9ZS5tYXAodGhpcy5nZXROYW1lc3BhY2VkS2V5KTtyZXR1cm4gYXdhaXQgdGhpcy5yYXdSZW1vdmVNYW55KHQpfTtzZXROYW1lc3BhY2U9ZT0+e3RoaXMua2V5TmFtZXNwYWNlPWV9O3BhcnNlVmFsdWU9YXN5bmMgZT0+e3RyeXtpZihlIT09dm9pZCAwKXJldHVybiB0aGlzLnNlcmRlLmRlc2VyaWFsaXplcihlKX1jYXRjaCh0KXtjb25zb2xlLmVycm9yKHQpfX19O2V4cG9ydHtvIGFzIEJhc2VTdG9yYWdlLGcgYXMgU3RvcmFnZX07XG4iLCJjb25zdCBwcm9jZXNzRnVuY3Rpb24gPSAoZnVuY3Rpb25fLCBvcHRpb25zLCBwcm94eSwgdW53cmFwcGVkKSA9PiBmdW5jdGlvbiAoLi4uYXJndW1lbnRzXykge1xuXHRjb25zdCBQID0gb3B0aW9ucy5wcm9taXNlTW9kdWxlO1xuXG5cdHJldHVybiBuZXcgUCgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0aWYgKG9wdGlvbnMubXVsdGlBcmdzKSB7XG5cdFx0XHRhcmd1bWVudHNfLnB1c2goKC4uLnJlc3VsdCkgPT4ge1xuXHRcdFx0XHRpZiAob3B0aW9ucy5lcnJvckZpcnN0KSB7XG5cdFx0XHRcdFx0aWYgKHJlc3VsdFswXSkge1xuXHRcdFx0XHRcdFx0cmVqZWN0KHJlc3VsdCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJlc3VsdC5zaGlmdCgpO1xuXHRcdFx0XHRcdFx0cmVzb2x2ZShyZXN1bHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXNvbHZlKHJlc3VsdCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAob3B0aW9ucy5lcnJvckZpcnN0KSB7XG5cdFx0XHRhcmd1bWVudHNfLnB1c2goKGVycm9yLCByZXN1bHQpID0+IHtcblx0XHRcdFx0aWYgKGVycm9yKSB7XG5cdFx0XHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXNvbHZlKHJlc3VsdCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhcmd1bWVudHNfLnB1c2gocmVzb2x2ZSk7XG5cdFx0fVxuXG5cdFx0Y29uc3Qgc2VsZiA9IHRoaXMgPT09IHByb3h5ID8gdW53cmFwcGVkIDogdGhpcztcblx0XHRSZWZsZWN0LmFwcGx5KGZ1bmN0aW9uXywgc2VsZiwgYXJndW1lbnRzXyk7XG5cdH0pO1xufTtcblxuY29uc3QgZmlsdGVyQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwaWZ5KGlucHV0LCBvcHRpb25zKSB7XG5cdG9wdGlvbnMgPSB7XG5cdFx0ZXhjbHVkZTogWy8uKyg/OlN5bmN8U3RyZWFtKSQvXSxcblx0XHRlcnJvckZpcnN0OiB0cnVlLFxuXHRcdHByb21pc2VNb2R1bGU6IFByb21pc2UsXG5cdFx0Li4ub3B0aW9ucyxcblx0fTtcblxuXHRjb25zdCBvYmplY3RUeXBlID0gdHlwZW9mIGlucHV0O1xuXHRpZiAoIShpbnB1dCAhPT0gbnVsbCAmJiAob2JqZWN0VHlwZSA9PT0gJ29iamVjdCcgfHwgb2JqZWN0VHlwZSA9PT0gJ2Z1bmN0aW9uJykpKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgXFxgaW5wdXRcXGAgdG8gYmUgYSBcXGBGdW5jdGlvblxcYCBvciBcXGBPYmplY3RcXGAsIGdvdCBcXGAke2lucHV0ID09PSBudWxsID8gJ251bGwnIDogb2JqZWN0VHlwZX1cXGBgKTtcblx0fVxuXG5cdGNvbnN0IGZpbHRlciA9ICh0YXJnZXQsIGtleSkgPT4ge1xuXHRcdGxldCBjYWNoZWQgPSBmaWx0ZXJDYWNoZS5nZXQodGFyZ2V0KTtcblxuXHRcdGlmICghY2FjaGVkKSB7XG5cdFx0XHRjYWNoZWQgPSB7fTtcblx0XHRcdGZpbHRlckNhY2hlLnNldCh0YXJnZXQsIGNhY2hlZCk7XG5cdFx0fVxuXG5cdFx0aWYgKGtleSBpbiBjYWNoZWQpIHtcblx0XHRcdHJldHVybiBjYWNoZWRba2V5XTtcblx0XHR9XG5cblx0XHRjb25zdCBtYXRjaCA9IHBhdHRlcm4gPT4gKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJyB8fCB0eXBlb2Yga2V5ID09PSAnc3ltYm9sJykgPyBrZXkgPT09IHBhdHRlcm4gOiBwYXR0ZXJuLnRlc3Qoa2V5KTtcblx0XHRjb25zdCBkZXNjcmlwdG9yID0gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpO1xuXHRcdGNvbnN0IHdyaXRhYmxlT3JDb25maWd1cmFibGVPd24gPSAoZGVzY3JpcHRvciA9PT0gdW5kZWZpbmVkIHx8IGRlc2NyaXB0b3Iud3JpdGFibGUgfHwgZGVzY3JpcHRvci5jb25maWd1cmFibGUpO1xuXHRcdGNvbnN0IGluY2x1ZGVkID0gb3B0aW9ucy5pbmNsdWRlID8gb3B0aW9ucy5pbmNsdWRlLnNvbWUoZWxlbWVudCA9PiBtYXRjaChlbGVtZW50KSkgOiAhb3B0aW9ucy5leGNsdWRlLnNvbWUoZWxlbWVudCA9PiBtYXRjaChlbGVtZW50KSk7XG5cdFx0Y29uc3Qgc2hvdWxkRmlsdGVyID0gaW5jbHVkZWQgJiYgd3JpdGFibGVPckNvbmZpZ3VyYWJsZU93bjtcblx0XHRjYWNoZWRba2V5XSA9IHNob3VsZEZpbHRlcjtcblx0XHRyZXR1cm4gc2hvdWxkRmlsdGVyO1xuXHR9O1xuXG5cdGNvbnN0IGNhY2hlID0gbmV3IFdlYWtNYXAoKTtcblxuXHRjb25zdCBwcm94eSA9IG5ldyBQcm94eShpbnB1dCwge1xuXHRcdGFwcGx5KHRhcmdldCwgdGhpc0FyZywgYXJncykge1xuXHRcdFx0Y29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KHRhcmdldCk7XG5cblx0XHRcdGlmIChjYWNoZWQpIHtcblx0XHRcdFx0cmV0dXJuIFJlZmxlY3QuYXBwbHkoY2FjaGVkLCB0aGlzQXJnLCBhcmdzKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgcGlmaWVkID0gb3B0aW9ucy5leGNsdWRlTWFpbiA/IHRhcmdldCA6IHByb2Nlc3NGdW5jdGlvbih0YXJnZXQsIG9wdGlvbnMsIHByb3h5LCB0YXJnZXQpO1xuXHRcdFx0Y2FjaGUuc2V0KHRhcmdldCwgcGlmaWVkKTtcblx0XHRcdHJldHVybiBSZWZsZWN0LmFwcGx5KHBpZmllZCwgdGhpc0FyZywgYXJncyk7XG5cdFx0fSxcblxuXHRcdGdldCh0YXJnZXQsIGtleSkge1xuXHRcdFx0Y29uc3QgcHJvcGVydHkgPSB0YXJnZXRba2V5XTtcblxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZS1leHRlbmQtbmF0aXZlL25vLXVzZS1leHRlbmQtbmF0aXZlXG5cdFx0XHRpZiAoIWZpbHRlcih0YXJnZXQsIGtleSkgfHwgcHJvcGVydHkgPT09IEZ1bmN0aW9uLnByb3RvdHlwZVtrZXldKSB7XG5cdFx0XHRcdHJldHVybiBwcm9wZXJ0eTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KHByb3BlcnR5KTtcblxuXHRcdFx0aWYgKGNhY2hlZCkge1xuXHRcdFx0XHRyZXR1cm4gY2FjaGVkO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodHlwZW9mIHByb3BlcnR5ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGNvbnN0IHBpZmllZCA9IHByb2Nlc3NGdW5jdGlvbihwcm9wZXJ0eSwgb3B0aW9ucywgcHJveHksIHRhcmdldCk7XG5cdFx0XHRcdGNhY2hlLnNldChwcm9wZXJ0eSwgcGlmaWVkKTtcblx0XHRcdFx0cmV0dXJuIHBpZmllZDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHByb3BlcnR5O1xuXHRcdH0sXG5cdH0pO1xuXG5cdHJldHVybiBwcm94eTtcbn1cbiIsImV4cG9ydHMuaW50ZXJvcERlZmF1bHQgPSBmdW5jdGlvbiAoYSkge1xuICByZXR1cm4gYSAmJiBhLl9fZXNNb2R1bGUgPyBhIDoge2RlZmF1bHQ6IGF9O1xufTtcblxuZXhwb3J0cy5kZWZpbmVJbnRlcm9wRmxhZyA9IGZ1bmN0aW9uIChhKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLCAnX19lc01vZHVsZScsIHt2YWx1ZTogdHJ1ZX0pO1xufTtcblxuZXhwb3J0cy5leHBvcnRBbGwgPSBmdW5jdGlvbiAoc291cmNlLCBkZXN0KSB7XG4gIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKGtleSA9PT0gJ2RlZmF1bHQnIHx8IGtleSA9PT0gJ19fZXNNb2R1bGUnIHx8IGRlc3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZXN0LCBrZXksIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZVtrZXldO1xuICAgICAgfSxcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5leHBvcnRzLmV4cG9ydCA9IGZ1bmN0aW9uIChkZXN0LCBkZXN0TmFtZSwgZ2V0KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZXN0LCBkZXN0TmFtZSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBnZXQsXG4gIH0pO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0IHsgQmFzZUNvbnZleENsaWVudCB9IGZyb20gXCIuL3N5bmMvY2xpZW50LmpzXCI7XG5leHBvcnQgeyBDb252ZXhDbGllbnQgfSBmcm9tIFwiLi9zaW1wbGVfY2xpZW50LmpzXCI7XG5leHBvcnQgeyBDb252ZXhIdHRwQ2xpZW50IH0gZnJvbSBcIi4vaHR0cF9jbGllbnQuanNcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiLyoqXG4gKiBUb29scyBmb3IgYWNjZXNzaW5nIENvbnZleCBpbiB0aGUgYnJvd3Nlci5cbiAqXG4gKiAqKklmIHlvdSBhcmUgdXNpbmcgUmVhY3QsIHVzZSB0aGUge0BsaW5rIHJlYWN0fSBtb2R1bGUgaW5zdGVhZC4qKlxuICpcbiAqICMjIFVzYWdlXG4gKlxuICogQ3JlYXRlIGEge0BsaW5rIENvbnZleEh0dHBDbGllbnR9IHRvIGNvbm5lY3QgdG8gdGhlIENvbnZleCBDbG91ZC5cbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBDb252ZXhIdHRwQ2xpZW50IH0gZnJvbSBcImNvbnZleC9icm93c2VyXCI7XG4gKiAvLyB0eXBpY2FsbHkgbG9hZGVkIGZyb20gYW4gZW52aXJvbm1lbnQgdmFyaWFibGVcbiAqIGNvbnN0IGFkZHJlc3MgPSBcImh0dHBzOi8vc21hbGwtbW91c2UtMTIzLmNvbnZleC5jbG91ZFwiO1xuICogY29uc3QgY29udmV4ID0gbmV3IENvbnZleEh0dHBDbGllbnQoYWRkcmVzcyk7XG4gKiBgYGBcbiAqXG4gKiBAbW9kdWxlXG4gKi9cbmV4cG9ydCB7IEJhc2VDb252ZXhDbGllbnQgfSBmcm9tIFwiLi9zeW5jL2NsaWVudC5qc1wiO1xuZXhwb3J0IHR5cGUge1xuICBCYXNlQ29udmV4Q2xpZW50T3B0aW9ucyxcbiAgTXV0YXRpb25PcHRpb25zLFxuICBTdWJzY3JpYmVPcHRpb25zLFxuICBDb25uZWN0aW9uU3RhdGUsXG4gIEF1dGhUb2tlbkZldGNoZXIsXG59IGZyb20gXCIuL3N5bmMvY2xpZW50LmpzXCI7XG5leHBvcnQgdHlwZSB7IFBhZ2luYXRpb25TdGF0dXMgfSBmcm9tIFwiLi9zeW5jL3BhZ2luYXRpb24uanNcIjtcbmV4cG9ydCB0eXBlIHsgQ29udmV4Q2xpZW50T3B0aW9ucyB9IGZyb20gXCIuL3NpbXBsZV9jbGllbnQuanNcIjtcbmV4cG9ydCB7IENvbnZleENsaWVudCB9IGZyb20gXCIuL3NpbXBsZV9jbGllbnQuanNcIjtcbmV4cG9ydCB0eXBlIHtcbiAgT3B0aW1pc3RpY1VwZGF0ZSxcbiAgT3B0aW1pc3RpY0xvY2FsU3RvcmUsXG59IGZyb20gXCIuL3N5bmMvb3B0aW1pc3RpY191cGRhdGVzLmpzXCI7XG5leHBvcnQgdHlwZSB7IFF1ZXJ5VG9rZW4gfSBmcm9tIFwiLi9zeW5jL3VkZl9wYXRoX3V0aWxzLmpzXCI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgdHlwZSB7IFBhZ2luYXRlZFF1ZXJ5VG9rZW4gfSBmcm9tIFwiLi9zeW5jL3VkZl9wYXRoX3V0aWxzLmpzXCI7XG5leHBvcnQgeyBDb252ZXhIdHRwQ2xpZW50IH0gZnJvbSBcIi4vaHR0cF9jbGllbnQuanNcIjtcbmV4cG9ydCB0eXBlIHsgSHR0cE11dGF0aW9uT3B0aW9ucyB9IGZyb20gXCIuL2h0dHBfY2xpZW50LmpzXCI7XG5leHBvcnQgdHlwZSB7IFF1ZXJ5Sm91cm5hbCB9IGZyb20gXCIuL3N5bmMvcHJvdG9jb2wuanNcIjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCB0eXBlIHsgVXNlcklkZW50aXR5QXR0cmlidXRlcyB9IGZyb20gXCIuL3N5bmMvcHJvdG9jb2wuanNcIjtcbmV4cG9ydCB0eXBlIHsgRnVuY3Rpb25SZXN1bHQgfSBmcm9tIFwiLi9zeW5jL2Z1bmN0aW9uX3Jlc3VsdC5qc1wiO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuLi8uLi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgY29udmV4VG9Kc29uIH0gZnJvbSBcIi4uLy4uL3ZhbHVlcy9pbmRleC5qc1wiO1xuaW1wb3J0IHtcbiAgY3JlYXRlSHlicmlkRXJyb3JTdGFja3RyYWNlLFxuICBmb3J3YXJkRGF0YSxcbiAgaW5zdGFudGlhdGVEZWZhdWx0TG9nZ2VyLFxuICBpbnN0YW50aWF0ZU5vb3BMb2dnZXIsXG4gIGxvZ0ZhdGFsRXJyb3Jcbn0gZnJvbSBcIi4uL2xvZ2dpbmcuanNcIjtcbmltcG9ydCB7IExvY2FsU3luY1N0YXRlIH0gZnJvbSBcIi4vbG9jYWxfc3RhdGUuanNcIjtcbmltcG9ydCB7IFJlcXVlc3RNYW5hZ2VyIH0gZnJvbSBcIi4vcmVxdWVzdF9tYW5hZ2VyLmpzXCI7XG5pbXBvcnQge1xuICBPcHRpbWlzdGljUXVlcnlSZXN1bHRzXG59IGZyb20gXCIuL29wdGltaXN0aWNfdXBkYXRlc19pbXBsLmpzXCI7XG5pbXBvcnQgeyBSZW1vdGVRdWVyeVNldCB9IGZyb20gXCIuL3JlbW90ZV9xdWVyeV9zZXQuanNcIjtcbmltcG9ydCB7IHNlcmlhbGl6ZVBhdGhBbmRBcmdzIH0gZnJvbSBcIi4vdWRmX3BhdGhfdXRpbHMuanNcIjtcbmltcG9ydCB7IFdlYlNvY2tldE1hbmFnZXIgfSBmcm9tIFwiLi93ZWJfc29ja2V0X21hbmFnZXIuanNcIjtcbmltcG9ydCB7IG5ld1Nlc3Npb25JZCB9IGZyb20gXCIuL3Nlc3Npb24uanNcIjtcbmltcG9ydCB7XG4gIEF1dGhlbnRpY2F0aW9uTWFuYWdlclxufSBmcm9tIFwiLi9hdXRoZW50aWNhdGlvbl9tYW5hZ2VyLmpzXCI7XG5pbXBvcnQgeyBnZXRNYXJrc1JlcG9ydCwgbWFyayB9IGZyb20gXCIuL21ldHJpY3MuanNcIjtcbmltcG9ydCB7IHBhcnNlQXJncywgdmFsaWRhdGVEZXBsb3ltZW50VXJsIH0gZnJvbSBcIi4uLy4uL2NvbW1vbi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgQ29udmV4RXJyb3IgfSBmcm9tIFwiLi4vLi4vdmFsdWVzL2Vycm9ycy5qc1wiO1xuaW1wb3J0IHsgand0RGVjb2RlIH0gZnJvbSBcIi4uLy4uL3ZlbmRvci9qd3QtZGVjb2RlL2luZGV4LmpzXCI7XG5leHBvcnQgY2xhc3MgQmFzZUNvbnZleENsaWVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0gYWRkcmVzcyAtIFRoZSB1cmwgb2YgeW91ciBDb252ZXggZGVwbG95bWVudCwgb2Z0ZW4gcHJvdmlkZWRcbiAgICogYnkgYW4gZW52aXJvbm1lbnQgdmFyaWFibGUuIEUuZy4gYGh0dHBzOi8vc21hbGwtbW91c2UtMTIzLmNvbnZleC5jbG91ZGAuXG4gICAqIEBwYXJhbSBvblRyYW5zaXRpb24gLSBBIGNhbGxiYWNrIHJlY2VpdmluZyBhbiBhcnJheSBvZiBxdWVyeSB0b2tlbnNcbiAgICogY29ycmVzcG9uZGluZyB0byBxdWVyeSByZXN1bHRzIHRoYXQgaGF2ZSBjaGFuZ2VkIC0tIGFkZGl0aW9uYWwgaGFuZGxlcnNcbiAgICogY2FuIGJlIGFkZGVkIHZpYSBgYWRkT25UcmFuc2l0aW9uSGFuZGxlcmAuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gU2VlIHtAbGluayBCYXNlQ29udmV4Q2xpZW50T3B0aW9uc30gZm9yIGEgZnVsbCBkZXNjcmlwdGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkZHJlc3MsIG9uVHJhbnNpdGlvbiwgb3B0aW9ucykge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJhZGRyZXNzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzdGF0ZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVxdWVzdE1hbmFnZXJcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIndlYlNvY2tldE1hbmFnZXJcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImF1dGhlbnRpY2F0aW9uTWFuYWdlclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVtb3RlUXVlcnlTZXRcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm9wdGltaXN0aWNRdWVyeVJlc3VsdHNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl90cmFuc2l0aW9uSGFuZGxlckNvdW50ZXJcIiwgMCk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9uZXh0UmVxdWVzdElkXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfb25UcmFuc2l0aW9uRm5zXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfc2Vzc2lvbklkXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJmaXJzdE1lc3NhZ2VSZWNlaXZlZFwiLCBmYWxzZSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImRlYnVnXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJsb2dnZXJcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1heE9ic2VydmVkVGltZXN0YW1wXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjb25uZWN0aW9uU3RhdGVTdWJzY3JpYmVyc1wiLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibmV4dENvbm5lY3Rpb25TdGF0ZVN1YnNjcmliZXJJZFwiLCAwKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2xhc3RQdWJsaXNoZWRDb25uZWN0aW9uU3RhdGVcIik7XG4gICAgLyoqXG4gICAgICogQ2FsbCB0aGlzIHdoZW5ldmVyIHRoZSBjb25uZWN0aW9uIHN0YXRlIG1heSBoYXZlIGNoYW5nZWQgaW4gYSB3YXkgdGhhdCBjb3VsZFxuICAgICAqIHJlcXVpcmUgcHVibGlzaGluZyBpdC4gU2NoZWR1bGVzIGEgcG9zc2libHkgdXBkYXRlLlxuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtYXJrQ29ubmVjdGlvblN0YXRlRGlydHlcIiwgKCkgPT4ge1xuICAgICAgdm9pZCBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgY29uc3QgY3VyQ29ubmVjdGlvblN0YXRlID0gdGhpcy5jb25uZWN0aW9uU3RhdGUoKTtcbiAgICAgICAgaWYgKEpTT04uc3RyaW5naWZ5KGN1ckNvbm5lY3Rpb25TdGF0ZSkgIT09IEpTT04uc3RyaW5naWZ5KHRoaXMuX2xhc3RQdWJsaXNoZWRDb25uZWN0aW9uU3RhdGUpKSB7XG4gICAgICAgICAgdGhpcy5fbGFzdFB1Ymxpc2hlZENvbm5lY3Rpb25TdGF0ZSA9IGN1ckNvbm5lY3Rpb25TdGF0ZTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGNiIG9mIHRoaXMuY29ubmVjdGlvblN0YXRlU3Vic2NyaWJlcnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGNiKGN1ckNvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICAvLyBJbnN0YW5jZSBwcm9wZXJ0eSBzbyB0aGF0IGBtYXJrKClgIGRvZXNuJ3QgbmVlZCB0byBiZSBjYWxsZWQgYXMgYSBtZXRob2QuXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1hcmtcIiwgKG5hbWUpID0+IHtcbiAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgIG1hcmsobmFtZSwgdGhpcy5zZXNzaW9uSWQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgYWRkcmVzcyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIlBhc3NpbmcgYSBDbGllbnRDb25maWcgb2JqZWN0IGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuIFBhc3MgdGhlIFVSTCBvZiB0aGUgQ29udmV4IGRlcGxveW1lbnQgYXMgYSBzdHJpbmcgZGlyZWN0bHkuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zPy5za2lwQ29udmV4RGVwbG95bWVudFVybENoZWNrICE9PSB0cnVlKSB7XG4gICAgICB2YWxpZGF0ZURlcGxveW1lbnRVcmwoYWRkcmVzcyk7XG4gICAgfVxuICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMgfTtcbiAgICBjb25zdCBhdXRoUmVmcmVzaFRva2VuTGVld2F5U2Vjb25kcyA9IG9wdGlvbnMuYXV0aFJlZnJlc2hUb2tlbkxlZXdheVNlY29uZHMgPz8gMjtcbiAgICBsZXQgd2ViU29ja2V0Q29uc3RydWN0b3IgPSBvcHRpb25zLndlYlNvY2tldENvbnN0cnVjdG9yO1xuICAgIGlmICghd2ViU29ja2V0Q29uc3RydWN0b3IgJiYgdHlwZW9mIFdlYlNvY2tldCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIk5vIFdlYlNvY2tldCBnbG9iYWwgdmFyaWFibGUgZGVmaW5lZCEgVG8gdXNlIENvbnZleCBpbiBhbiBlbnZpcm9ubWVudCB3aXRob3V0IFdlYlNvY2tldCB0cnkgdGhlIEhUVFAgY2xpZW50OiBodHRwczovL2RvY3MuY29udmV4LmRldi9hcGkvY2xhc3Nlcy9icm93c2VyLkNvbnZleEh0dHBDbGllbnRcIlxuICAgICAgKTtcbiAgICB9XG4gICAgd2ViU29ja2V0Q29uc3RydWN0b3IgPSB3ZWJTb2NrZXRDb25zdHJ1Y3RvciB8fCBXZWJTb2NrZXQ7XG4gICAgdGhpcy5kZWJ1ZyA9IG9wdGlvbnMucmVwb3J0RGVidWdJbmZvVG9Db252ZXggPz8gZmFsc2U7XG4gICAgdGhpcy5hZGRyZXNzID0gYWRkcmVzcztcbiAgICB0aGlzLmxvZ2dlciA9IG9wdGlvbnMubG9nZ2VyID09PSBmYWxzZSA/IGluc3RhbnRpYXRlTm9vcExvZ2dlcih7IHZlcmJvc2U6IG9wdGlvbnMudmVyYm9zZSA/PyBmYWxzZSB9KSA6IG9wdGlvbnMubG9nZ2VyICE9PSB0cnVlICYmIG9wdGlvbnMubG9nZ2VyID8gb3B0aW9ucy5sb2dnZXIgOiBpbnN0YW50aWF0ZURlZmF1bHRMb2dnZXIoeyB2ZXJib3NlOiBvcHRpb25zLnZlcmJvc2UgPz8gZmFsc2UgfSk7XG4gICAgY29uc3QgaSA9IGFkZHJlc3Muc2VhcmNoKFwiOi8vXCIpO1xuICAgIGlmIChpID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvdmlkZWQgYWRkcmVzcyB3YXMgbm90IGFuIGFic29sdXRlIFVSTC5cIik7XG4gICAgfVxuICAgIGNvbnN0IG9yaWdpbiA9IGFkZHJlc3Muc3Vic3RyaW5nKGkgKyAzKTtcbiAgICBjb25zdCBwcm90b2NvbCA9IGFkZHJlc3Muc3Vic3RyaW5nKDAsIGkpO1xuICAgIGxldCB3c1Byb3RvY29sO1xuICAgIGlmIChwcm90b2NvbCA9PT0gXCJodHRwXCIpIHtcbiAgICAgIHdzUHJvdG9jb2wgPSBcIndzXCI7XG4gICAgfSBlbHNlIGlmIChwcm90b2NvbCA9PT0gXCJodHRwc1wiKSB7XG4gICAgICB3c1Byb3RvY29sID0gXCJ3c3NcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHBhcmVudCBwcm90b2NvbCAke3Byb3RvY29sfWApO1xuICAgIH1cbiAgICBjb25zdCB3c1VyaSA9IGAke3dzUHJvdG9jb2x9Oi8vJHtvcmlnaW59L2FwaS8ke3ZlcnNpb259L3N5bmNgO1xuICAgIHRoaXMuc3RhdGUgPSBuZXcgTG9jYWxTeW5jU3RhdGUoKTtcbiAgICB0aGlzLnJlbW90ZVF1ZXJ5U2V0ID0gbmV3IFJlbW90ZVF1ZXJ5U2V0KFxuICAgICAgKHF1ZXJ5SWQpID0+IHRoaXMuc3RhdGUucXVlcnlQYXRoKHF1ZXJ5SWQpLFxuICAgICAgdGhpcy5sb2dnZXJcbiAgICApO1xuICAgIHRoaXMucmVxdWVzdE1hbmFnZXIgPSBuZXcgUmVxdWVzdE1hbmFnZXIoXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIHRoaXMubWFya0Nvbm5lY3Rpb25TdGF0ZURpcnR5XG4gICAgKTtcbiAgICBjb25zdCBwYXVzZVNvY2tldCA9ICgpID0+IHtcbiAgICAgIHRoaXMud2ViU29ja2V0TWFuYWdlci5wYXVzZSgpO1xuICAgICAgdGhpcy5zdGF0ZS5wYXVzZSgpO1xuICAgIH07XG4gICAgdGhpcy5hdXRoZW50aWNhdGlvbk1hbmFnZXIgPSBuZXcgQXV0aGVudGljYXRpb25NYW5hZ2VyKFxuICAgICAgdGhpcy5zdGF0ZSxcbiAgICAgIHtcbiAgICAgICAgYXV0aGVudGljYXRlOiAodG9rZW4pID0+IHtcbiAgICAgICAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5zdGF0ZS5zZXRBdXRoKHRva2VuKTtcbiAgICAgICAgICB0aGlzLndlYlNvY2tldE1hbmFnZXIuc2VuZE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2UuYmFzZVZlcnNpb247XG4gICAgICAgIH0sXG4gICAgICAgIHN0b3BTb2NrZXQ6ICgpID0+IHRoaXMud2ViU29ja2V0TWFuYWdlci5zdG9wKCksXG4gICAgICAgIHRyeVJlc3RhcnRTb2NrZXQ6ICgpID0+IHRoaXMud2ViU29ja2V0TWFuYWdlci50cnlSZXN0YXJ0KCksXG4gICAgICAgIHBhdXNlU29ja2V0LFxuICAgICAgICByZXN1bWVTb2NrZXQ6ICgpID0+IHRoaXMud2ViU29ja2V0TWFuYWdlci5yZXN1bWUoKSxcbiAgICAgICAgY2xlYXJBdXRoOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5jbGVhckF1dGgoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbG9nZ2VyOiB0aGlzLmxvZ2dlcixcbiAgICAgICAgcmVmcmVzaFRva2VuTGVld2F5U2Vjb25kczogYXV0aFJlZnJlc2hUb2tlbkxlZXdheVNlY29uZHNcbiAgICAgIH1cbiAgICApO1xuICAgIHRoaXMub3B0aW1pc3RpY1F1ZXJ5UmVzdWx0cyA9IG5ldyBPcHRpbWlzdGljUXVlcnlSZXN1bHRzKCk7XG4gICAgdGhpcy5hZGRPblRyYW5zaXRpb25IYW5kbGVyKCh0cmFuc2l0aW9uKSA9PiB7XG4gICAgICBvblRyYW5zaXRpb24odHJhbnNpdGlvbi5xdWVyaWVzLm1hcCgocSkgPT4gcS50b2tlbikpO1xuICAgIH0pO1xuICAgIHRoaXMuX25leHRSZXF1ZXN0SWQgPSAwO1xuICAgIHRoaXMuX3Nlc3Npb25JZCA9IG5ld1Nlc3Npb25JZCgpO1xuICAgIGNvbnN0IHsgdW5zYXZlZENoYW5nZXNXYXJuaW5nIH0gPSBvcHRpb25zO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaWYgKHVuc2F2ZWRDaGFuZ2VzV2FybmluZyA9PT0gdHJ1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJ1bnNhdmVkQ2hhbmdlc1dhcm5pbmcgcmVxdWVzdGVkLCBidXQgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgbm90IGZvdW5kISBSZW1vdmUge3Vuc2F2ZWRDaGFuZ2VzV2FybmluZzogdHJ1ZX0gZnJvbSBDb252ZXggY2xpZW50IG9wdGlvbnMuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHVuc2F2ZWRDaGFuZ2VzV2FybmluZyAhPT0gZmFsc2UpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsIChlKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnJlcXVlc3RNYW5hZ2VyLmhhc0luY29tcGxldGVSZXF1ZXN0cygpKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGNvbnN0IGNvbmZpcm1hdGlvbk1lc3NhZ2UgPSBcIkFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBsZWF2ZT8gWW91ciBjaGFuZ2VzIG1heSBub3QgYmUgc2F2ZWQuXCI7XG4gICAgICAgICAgKGUgfHwgd2luZG93LmV2ZW50KS5yZXR1cm5WYWx1ZSA9IGNvbmZpcm1hdGlvbk1lc3NhZ2U7XG4gICAgICAgICAgcmV0dXJuIGNvbmZpcm1hdGlvbk1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLndlYlNvY2tldE1hbmFnZXIgPSBuZXcgV2ViU29ja2V0TWFuYWdlcihcbiAgICAgIHdzVXJpLFxuICAgICAge1xuICAgICAgICBvbk9wZW46IChyZWNvbm5lY3RNZXRhZGF0YSkgPT4ge1xuICAgICAgICAgIHRoaXMubWFyayhcImNvbnZleFdlYlNvY2tldE9wZW5cIik7XG4gICAgICAgICAgdGhpcy53ZWJTb2NrZXRNYW5hZ2VyLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgIC4uLnJlY29ubmVjdE1ldGFkYXRhLFxuICAgICAgICAgICAgdHlwZTogXCJDb25uZWN0XCIsXG4gICAgICAgICAgICBzZXNzaW9uSWQ6IHRoaXMuX3Nlc3Npb25JZCxcbiAgICAgICAgICAgIG1heE9ic2VydmVkVGltZXN0YW1wOiB0aGlzLm1heE9ic2VydmVkVGltZXN0YW1wXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3Qgb2xkUmVtb3RlUXVlcnlSZXN1bHRzID0gbmV3IFNldChcbiAgICAgICAgICAgIHRoaXMucmVtb3RlUXVlcnlTZXQucmVtb3RlUXVlcnlSZXN1bHRzKCkua2V5cygpXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLnJlbW90ZVF1ZXJ5U2V0ID0gbmV3IFJlbW90ZVF1ZXJ5U2V0KFxuICAgICAgICAgICAgKHF1ZXJ5SWQpID0+IHRoaXMuc3RhdGUucXVlcnlQYXRoKHF1ZXJ5SWQpLFxuICAgICAgICAgICAgdGhpcy5sb2dnZXJcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IFtxdWVyeVNldE1vZGlmaWNhdGlvbiwgYXV0aE1vZGlmaWNhdGlvbl0gPSB0aGlzLnN0YXRlLnJlc3RhcnQoXG4gICAgICAgICAgICBvbGRSZW1vdGVRdWVyeVJlc3VsdHNcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChhdXRoTW9kaWZpY2F0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLndlYlNvY2tldE1hbmFnZXIuc2VuZE1lc3NhZ2UoYXV0aE1vZGlmaWNhdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMud2ViU29ja2V0TWFuYWdlci5zZW5kTWVzc2FnZShxdWVyeVNldE1vZGlmaWNhdGlvbik7XG4gICAgICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIHRoaXMucmVxdWVzdE1hbmFnZXIucmVzdGFydCgpKSB7XG4gICAgICAgICAgICB0aGlzLndlYlNvY2tldE1hbmFnZXIuc2VuZE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvblJlc3VtZTogKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IFtxdWVyeVNldE1vZGlmaWNhdGlvbiwgYXV0aE1vZGlmaWNhdGlvbl0gPSB0aGlzLnN0YXRlLnJlc3VtZSgpO1xuICAgICAgICAgIGlmIChhdXRoTW9kaWZpY2F0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLndlYlNvY2tldE1hbmFnZXIuc2VuZE1lc3NhZ2UoYXV0aE1vZGlmaWNhdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChxdWVyeVNldE1vZGlmaWNhdGlvbikge1xuICAgICAgICAgICAgdGhpcy53ZWJTb2NrZXRNYW5hZ2VyLnNlbmRNZXNzYWdlKHF1ZXJ5U2V0TW9kaWZpY2F0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIHRoaXMucmVxdWVzdE1hbmFnZXIucmVzdW1lKCkpIHtcbiAgICAgICAgICAgIHRoaXMud2ViU29ja2V0TWFuYWdlci5zZW5kTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uTWVzc2FnZTogKHNlcnZlck1lc3NhZ2UpID0+IHtcbiAgICAgICAgICBpZiAoIXRoaXMuZmlyc3RNZXNzYWdlUmVjZWl2ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyc3RNZXNzYWdlUmVjZWl2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5tYXJrKFwiY29udmV4Rmlyc3RNZXNzYWdlUmVjZWl2ZWRcIik7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydE1hcmtzKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN3aXRjaCAoc2VydmVyTWVzc2FnZS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiVHJhbnNpdGlvblwiOiB7XG4gICAgICAgICAgICAgIHRoaXMub2JzZXJ2ZWRUaW1lc3RhbXAoc2VydmVyTWVzc2FnZS5lbmRWZXJzaW9uLnRzKTtcbiAgICAgICAgICAgICAgdGhpcy5hdXRoZW50aWNhdGlvbk1hbmFnZXIub25UcmFuc2l0aW9uKHNlcnZlck1lc3NhZ2UpO1xuICAgICAgICAgICAgICB0aGlzLnJlbW90ZVF1ZXJ5U2V0LnRyYW5zaXRpb24oc2VydmVyTWVzc2FnZSk7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUudHJhbnNpdGlvbihzZXJ2ZXJNZXNzYWdlKTtcbiAgICAgICAgICAgICAgY29uc3QgY29tcGxldGVkUmVxdWVzdHMgPSB0aGlzLnJlcXVlc3RNYW5hZ2VyLnJlbW92ZUNvbXBsZXRlZChcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW90ZVF1ZXJ5U2V0LnRpbWVzdGFtcCgpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHRoaXMubm90aWZ5T25RdWVyeVJlc3VsdENoYW5nZXMoY29tcGxldGVkUmVxdWVzdHMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJNdXRhdGlvblJlc3BvbnNlXCI6IHtcbiAgICAgICAgICAgICAgaWYgKHNlcnZlck1lc3NhZ2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIHRoaXMub2JzZXJ2ZWRUaW1lc3RhbXAoc2VydmVyTWVzc2FnZS50cyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgY29tcGxldGVkTXV0YXRpb25JbmZvID0gdGhpcy5yZXF1ZXN0TWFuYWdlci5vblJlc3BvbnNlKHNlcnZlck1lc3NhZ2UpO1xuICAgICAgICAgICAgICBpZiAoY29tcGxldGVkTXV0YXRpb25JbmZvICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlPblF1ZXJ5UmVzdWx0Q2hhbmdlcyhcbiAgICAgICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZE11dGF0aW9uSW5mby5yZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVkTXV0YXRpb25JbmZvLnJlc3VsdFxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiQWN0aW9uUmVzcG9uc2VcIjoge1xuICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RNYW5hZ2VyLm9uUmVzcG9uc2Uoc2VydmVyTWVzc2FnZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIkF1dGhFcnJvclwiOiB7XG4gICAgICAgICAgICAgIHRoaXMuYXV0aGVudGljYXRpb25NYW5hZ2VyLm9uQXV0aEVycm9yKHNlcnZlck1lc3NhZ2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJGYXRhbEVycm9yXCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBsb2dGYXRhbEVycm9yKHRoaXMubG9nZ2VyLCBzZXJ2ZXJNZXNzYWdlLmVycm9yKTtcbiAgICAgICAgICAgICAgdm9pZCB0aGlzLndlYlNvY2tldE1hbmFnZXIudGVybWluYXRlKCk7XG4gICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICBzZXJ2ZXJNZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGFzU3luY2VkUGFzdExhc3RSZWNvbm5lY3Q6IHRoaXMuaGFzU3luY2VkUGFzdExhc3RSZWNvbm5lY3QoKVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIG9uU2VydmVyRGlzY29ubmVjdEVycm9yOiBvcHRpb25zLm9uU2VydmVyRGlzY29ubmVjdEVycm9yXG4gICAgICB9LFxuICAgICAgd2ViU29ja2V0Q29uc3RydWN0b3IsXG4gICAgICB0aGlzLmxvZ2dlcixcbiAgICAgIHRoaXMubWFya0Nvbm5lY3Rpb25TdGF0ZURpcnR5LFxuICAgICAgdGhpcy5kZWJ1Z1xuICAgICk7XG4gICAgdGhpcy5tYXJrKFwiY29udmV4Q2xpZW50Q29uc3RydWN0ZWRcIik7XG4gICAgaWYgKG9wdGlvbnMuZXhwZWN0QXV0aCkge1xuICAgICAgcGF1c2VTb2NrZXQoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZXJlIGlzIG91dHN0YW5kaW5nIHdvcmsgZnJvbSBwcmlvciB0byB0aGUgdGltZSBvZiB0aGUgbW9zdCByZWNlbnQgcmVzdGFydC5cbiAgICogVGhpcyBpbmRpY2F0ZXMgdGhhdCB0aGUgY2xpZW50IGhhcyBub3QgcHJvdmVuIGl0c2VsZiB0byBoYXZlIGdvdHRlbiBwYXN0IHRoZSBpc3N1ZSB0aGF0XG4gICAqIHBvdGVudGlhbGx5IGxlZCB0byB0aGUgcmVzdGFydC4gVXNlIHRoaXMgdG8gaW5mbHVlbmNlIHdoZW4gdG8gcmVzZXQgYmFja29mZiBhZnRlciBhIGZhaWx1cmUuXG4gICAqL1xuICBoYXNTeW5jZWRQYXN0TGFzdFJlY29ubmVjdCgpIHtcbiAgICBjb25zdCBoYXNTeW5jZWRQYXN0TGFzdFJlY29ubmVjdCA9IHRoaXMucmVxdWVzdE1hbmFnZXIuaGFzU3luY2VkUGFzdExhc3RSZWNvbm5lY3QoKSB8fCB0aGlzLnN0YXRlLmhhc1N5bmNlZFBhc3RMYXN0UmVjb25uZWN0KCk7XG4gICAgcmV0dXJuIGhhc1N5bmNlZFBhc3RMYXN0UmVjb25uZWN0O1xuICB9XG4gIG9ic2VydmVkVGltZXN0YW1wKG9ic2VydmVkVHMpIHtcbiAgICBpZiAodGhpcy5tYXhPYnNlcnZlZFRpbWVzdGFtcCA9PT0gdm9pZCAwIHx8IHRoaXMubWF4T2JzZXJ2ZWRUaW1lc3RhbXAubGVzc1RoYW5PckVxdWFsKG9ic2VydmVkVHMpKSB7XG4gICAgICB0aGlzLm1heE9ic2VydmVkVGltZXN0YW1wID0gb2JzZXJ2ZWRUcztcbiAgICB9XG4gIH1cbiAgZ2V0TWF4T2JzZXJ2ZWRUaW1lc3RhbXAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF4T2JzZXJ2ZWRUaW1lc3RhbXA7XG4gIH1cbiAgLyoqXG4gICAqIENvbXB1dGUgdGhlIGN1cnJlbnQgcXVlcnkgcmVzdWx0cyBiYXNlZCBvbiB0aGUgcmVtb3RlUXVlcnlTZXQgYW5kIHRoZVxuICAgKiBjdXJyZW50IG9wdGltaXN0aWMgdXBkYXRlcyBhbmQgY2FsbCBgb25UcmFuc2l0aW9uYCBmb3IgYWxsIHRoZSBjaGFuZ2VkXG4gICAqIHF1ZXJpZXMuXG4gICAqXG4gICAqIEBwYXJhbSBjb21wbGV0ZWRNdXRhdGlvbnMgLSBBIHNldCBvZiBtdXRhdGlvbiBJRHMgd2hvc2Ugb3B0aW1pc3RpYyB1cGRhdGVzXG4gICAqIGFyZSBubyBsb25nZXIgbmVlZGVkLlxuICAgKi9cbiAgbm90aWZ5T25RdWVyeVJlc3VsdENoYW5nZXMoY29tcGxldGVkUmVxdWVzdHMpIHtcbiAgICBjb25zdCByZW1vdGVRdWVyeVJlc3VsdHMgPSB0aGlzLnJlbW90ZVF1ZXJ5U2V0LnJlbW90ZVF1ZXJ5UmVzdWx0cygpO1xuICAgIGNvbnN0IHF1ZXJ5VG9rZW5Ub1ZhbHVlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IFtxdWVyeUlkLCByZXN1bHRdIG9mIHJlbW90ZVF1ZXJ5UmVzdWx0cykge1xuICAgICAgY29uc3QgcXVlcnlUb2tlbiA9IHRoaXMuc3RhdGUucXVlcnlUb2tlbihxdWVyeUlkKTtcbiAgICAgIGlmIChxdWVyeVRva2VuICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0ge1xuICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICB1ZGZQYXRoOiB0aGlzLnN0YXRlLnF1ZXJ5UGF0aChxdWVyeUlkKSxcbiAgICAgICAgICBhcmdzOiB0aGlzLnN0YXRlLnF1ZXJ5QXJncyhxdWVyeUlkKVxuICAgICAgICB9O1xuICAgICAgICBxdWVyeVRva2VuVG9WYWx1ZS5zZXQocXVlcnlUb2tlbiwgcXVlcnkpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjaGFuZ2VkUXVlcnlUb2tlbnMgPSB0aGlzLm9wdGltaXN0aWNRdWVyeVJlc3VsdHMuaW5nZXN0UXVlcnlSZXN1bHRzRnJvbVNlcnZlcihcbiAgICAgIHF1ZXJ5VG9rZW5Ub1ZhbHVlLFxuICAgICAgbmV3IFNldChjb21wbGV0ZWRSZXF1ZXN0cy5rZXlzKCkpXG4gICAgKTtcbiAgICB0aGlzLmhhbmRsZVRyYW5zaXRpb24oe1xuICAgICAgcXVlcmllczogY2hhbmdlZFF1ZXJ5VG9rZW5zLm1hcCgodG9rZW4pID0+IHtcbiAgICAgICAgY29uc3Qgb3B0aW1pc3RpY1Jlc3VsdCA9IHRoaXMub3B0aW1pc3RpY1F1ZXJ5UmVzdWx0cy5yYXdRdWVyeVJlc3VsdCh0b2tlbik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgbW9kaWZpY2F0aW9uOiB7XG4gICAgICAgICAgICBraW5kOiBcIlVwZGF0ZWRcIixcbiAgICAgICAgICAgIHJlc3VsdDogb3B0aW1pc3RpY1Jlc3VsdFxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pLFxuICAgICAgcmVmbGVjdGVkTXV0YXRpb25zOiBBcnJheS5mcm9tKGNvbXBsZXRlZFJlcXVlc3RzKS5tYXAoXG4gICAgICAgIChbcmVxdWVzdElkLCByZXN1bHRdKSA9PiAoe1xuICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICByZXN1bHRcbiAgICAgICAgfSlcbiAgICAgICksXG4gICAgICB0aW1lc3RhbXA6IHRoaXMucmVtb3RlUXVlcnlTZXQudGltZXN0YW1wKClcbiAgICB9KTtcbiAgfVxuICBoYW5kbGVUcmFuc2l0aW9uKHRyYW5zaXRpb24pIHtcbiAgICBmb3IgKGNvbnN0IGZuIG9mIHRoaXMuX29uVHJhbnNpdGlvbkZucy52YWx1ZXMoKSkge1xuICAgICAgZm4odHJhbnNpdGlvbik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBBZGQgYSBoYW5kbGVyIHRoYXQgd2lsbCBiZSBjYWxsZWQgb24gYSB0cmFuc2l0aW9uLlxuICAgKlxuICAgKiBBbnkgZXh0ZXJuYWwgc2lkZSBlZmZlY3RzIChlLmcuIHNldHRpbmcgUmVhY3Qgc3RhdGUpIHNob3VsZCBiZSBoYW5kbGVkIGhlcmUuXG4gICAqXG4gICAqIEBwYXJhbSBmblxuICAgKlxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgYWRkT25UcmFuc2l0aW9uSGFuZGxlcihmbikge1xuICAgIGNvbnN0IGlkID0gdGhpcy5fdHJhbnNpdGlvbkhhbmRsZXJDb3VudGVyKys7XG4gICAgdGhpcy5fb25UcmFuc2l0aW9uRm5zLnNldChpZCwgZm4pO1xuICAgIHJldHVybiAoKSA9PiB0aGlzLl9vblRyYW5zaXRpb25GbnMuZGVsZXRlKGlkKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IEpXVCBhdXRoIHRva2VuIGFuZCBkZWNvZGVkIGNsYWltcy5cbiAgICovXG4gIGdldEN1cnJlbnRBdXRoQ2xhaW1zKCkge1xuICAgIGNvbnN0IGF1dGhUb2tlbiA9IHRoaXMuc3RhdGUuZ2V0QXV0aCgpO1xuICAgIGxldCBkZWNvZGVkID0ge307XG4gICAgaWYgKGF1dGhUb2tlbiAmJiBhdXRoVG9rZW4udG9rZW5UeXBlID09PSBcIlVzZXJcIikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGVjb2RlZCA9IGF1dGhUb2tlbiA/IGp3dERlY29kZShhdXRoVG9rZW4udmFsdWUpIDoge307XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgZGVjb2RlZCA9IHt9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4geyB0b2tlbjogYXV0aFRva2VuLnZhbHVlLCBkZWNvZGVkIH07XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgYXV0aGVudGljYXRpb24gdG9rZW4gdG8gYmUgdXNlZCBmb3Igc3Vic2VxdWVudCBxdWVyaWVzIGFuZCBtdXRhdGlvbnMuXG4gICAqIGBmZXRjaFRva2VuYCB3aWxsIGJlIGNhbGxlZCBhdXRvbWF0aWNhbGx5IGFnYWluIGlmIGEgdG9rZW4gZXhwaXJlcy5cbiAgICogYGZldGNoVG9rZW5gIHNob3VsZCByZXR1cm4gYG51bGxgIGlmIHRoZSB0b2tlbiBjYW5ub3QgYmUgcmV0cmlldmVkLCBmb3IgZXhhbXBsZVxuICAgKiB3aGVuIHRoZSB1c2VyJ3MgcmlnaHRzIHdlcmUgcGVybWFuZW50bHkgcmV2b2tlZC5cbiAgICogQHBhcmFtIGZldGNoVG9rZW4gLSBhbiBhc3luYyBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIEpXVC1lbmNvZGVkIE9wZW5JRCBDb25uZWN0IElkZW50aXR5IFRva2VuXG4gICAqIEBwYXJhbSBvbkNoYW5nZSAtIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBhdXRoZW50aWNhdGlvbiBzdGF0dXMgY2hhbmdlc1xuICAgKi9cbiAgc2V0QXV0aChmZXRjaFRva2VuLCBvbkNoYW5nZSkge1xuICAgIHZvaWQgdGhpcy5hdXRoZW50aWNhdGlvbk1hbmFnZXIuc2V0Q29uZmlnKGZldGNoVG9rZW4sIG9uQ2hhbmdlKTtcbiAgfVxuICBoYXNBdXRoKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmhhc0F1dGgoKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHNldEFkbWluQXV0aCh2YWx1ZSwgZmFrZVVzZXJJZGVudGl0eSkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLnN0YXRlLnNldEFkbWluQXV0aCh2YWx1ZSwgZmFrZVVzZXJJZGVudGl0eSk7XG4gICAgdGhpcy53ZWJTb2NrZXRNYW5hZ2VyLnNlbmRNZXNzYWdlKG1lc3NhZ2UpO1xuICB9XG4gIGNsZWFyQXV0aCgpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5zdGF0ZS5jbGVhckF1dGgoKTtcbiAgICB0aGlzLndlYlNvY2tldE1hbmFnZXIuc2VuZE1lc3NhZ2UobWVzc2FnZSk7XG4gIH1cbiAgLyoqXG4gICAgICogU3Vic2NyaWJlIHRvIGEgcXVlcnkgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBXaGVuZXZlciB0aGlzIHF1ZXJ5J3MgcmVzdWx0IGNoYW5nZXMsIHRoZSBgb25UcmFuc2l0aW9uYCBjYWxsYmFja1xuICAgICAqIHBhc3NlZCBpbnRvIHRoZSBjb25zdHJ1Y3RvciB3aWxsIGJlIGNhbGxlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSBhcmdzIC0gQW4gYXJndW1lbnRzIG9iamVjdCBmb3IgdGhlIHF1ZXJ5LiBJZiB0aGlzIGlzIG9taXR0ZWQsIHRoZVxuICAgICAqIGFyZ3VtZW50cyB3aWxsIGJlIGB7fWAuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBIHtAbGluayBTdWJzY3JpYmVPcHRpb25zfSBvcHRpb25zIG9iamVjdCBmb3IgdGhpcyBxdWVyeS5cbiAgXG4gICAgICogQHJldHVybnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgYSB7QGxpbmsgUXVlcnlUb2tlbn0gY29ycmVzcG9uZGluZyB0byB0aGlzXG4gICAgICogcXVlcnkgYW5kIGFuIGB1bnN1YnNjcmliZWAgY2FsbGJhY2suXG4gICAgICovXG4gIHN1YnNjcmliZShuYW1lLCBhcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgYXJnc09iamVjdCA9IHBhcnNlQXJncyhhcmdzKTtcbiAgICBjb25zdCB7IG1vZGlmaWNhdGlvbiwgcXVlcnlUb2tlbiwgdW5zdWJzY3JpYmUgfSA9IHRoaXMuc3RhdGUuc3Vic2NyaWJlKFxuICAgICAgbmFtZSxcbiAgICAgIGFyZ3NPYmplY3QsXG4gICAgICBvcHRpb25zPy5qb3VybmFsLFxuICAgICAgb3B0aW9ucz8uY29tcG9uZW50UGF0aFxuICAgICk7XG4gICAgaWYgKG1vZGlmaWNhdGlvbiAhPT0gbnVsbCkge1xuICAgICAgdGhpcy53ZWJTb2NrZXRNYW5hZ2VyLnNlbmRNZXNzYWdlKG1vZGlmaWNhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBxdWVyeVRva2VuLFxuICAgICAgdW5zdWJzY3JpYmU6ICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9kaWZpY2F0aW9uMiA9IHVuc3Vic2NyaWJlKCk7XG4gICAgICAgIGlmIChtb2RpZmljYXRpb24yKSB7XG4gICAgICAgICAgdGhpcy53ZWJTb2NrZXRNYW5hZ2VyLnNlbmRNZXNzYWdlKG1vZGlmaWNhdGlvbjIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQSBxdWVyeSByZXN1bHQgYmFzZWQgb25seSBvbiB0aGUgY3VycmVudCwgbG9jYWwgc3RhdGUuXG4gICAqXG4gICAqIFRoZSBvbmx5IHdheSB0aGlzIHdpbGwgcmV0dXJuIGEgdmFsdWUgaXMgaWYgd2UncmUgYWxyZWFkeSBzdWJzY3JpYmVkIHRvIHRoZVxuICAgKiBxdWVyeSBvciBpdHMgdmFsdWUgaGFzIGJlZW4gc2V0IG9wdGltaXN0aWNhbGx5LlxuICAgKi9cbiAgbG9jYWxRdWVyeVJlc3VsdCh1ZGZQYXRoLCBhcmdzKSB7XG4gICAgY29uc3QgYXJnc09iamVjdCA9IHBhcnNlQXJncyhhcmdzKTtcbiAgICBjb25zdCBxdWVyeVRva2VuID0gc2VyaWFsaXplUGF0aEFuZEFyZ3ModWRmUGF0aCwgYXJnc09iamVjdCk7XG4gICAgcmV0dXJuIHRoaXMub3B0aW1pc3RpY1F1ZXJ5UmVzdWx0cy5xdWVyeVJlc3VsdChxdWVyeVRva2VuKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHF1ZXJ5IHJlc3VsdCBieSBxdWVyeSB0b2tlbiBiYXNlZCBvbiBjdXJyZW50LCBsb2NhbCBzdGF0ZVxuICAgKlxuICAgKiBUaGUgb25seSB3YXkgdGhpcyB3aWxsIHJldHVybiBhIHZhbHVlIGlzIGlmIHdlJ3JlIGFscmVhZHkgc3Vic2NyaWJlZCB0byB0aGVcbiAgICogcXVlcnkgb3IgaXRzIHZhbHVlIGhhcyBiZWVuIHNldCBvcHRpbWlzdGljYWxseS5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBsb2NhbFF1ZXJ5UmVzdWx0QnlUb2tlbihxdWVyeVRva2VuKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW1pc3RpY1F1ZXJ5UmVzdWx0cy5xdWVyeVJlc3VsdChxdWVyeVRva2VuKTtcbiAgfVxuICAvKipcbiAgICogV2hldGhlciBsb2NhbCBxdWVyeSByZXN1bHQgaXMgYXZhaWxhYmxlIGZvciBhIHRva2VuLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCB0aHJvdyBpZiB0aGUgcmVzdWx0IGlzIGFuIGVycm9yLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGhhc0xvY2FsUXVlcnlSZXN1bHRCeVRva2VuKHF1ZXJ5VG9rZW4pIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpbWlzdGljUXVlcnlSZXN1bHRzLmhhc1F1ZXJ5UmVzdWx0KHF1ZXJ5VG9rZW4pO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGxvY2FsUXVlcnlMb2dzKHVkZlBhdGgsIGFyZ3MpIHtcbiAgICBjb25zdCBhcmdzT2JqZWN0ID0gcGFyc2VBcmdzKGFyZ3MpO1xuICAgIGNvbnN0IHF1ZXJ5VG9rZW4gPSBzZXJpYWxpemVQYXRoQW5kQXJncyh1ZGZQYXRoLCBhcmdzT2JqZWN0KTtcbiAgICByZXR1cm4gdGhpcy5vcHRpbWlzdGljUXVlcnlSZXN1bHRzLnF1ZXJ5TG9ncyhxdWVyeVRva2VuKTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmUgdGhlIGN1cnJlbnQge0BsaW5rIFF1ZXJ5Sm91cm5hbH0gZm9yIHRoaXMgcXVlcnkgZnVuY3Rpb24uXG4gICAqXG4gICAqIElmIHdlIGhhdmUgbm90IHlldCByZWNlaXZlZCBhIHJlc3VsdCBmb3IgdGhpcyBxdWVyeSwgdGhpcyB3aWxsIGJlIGB1bmRlZmluZWRgLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBxdWVyeS5cbiAgICogQHBhcmFtIGFyZ3MgLSBUaGUgYXJndW1lbnRzIG9iamVjdCBmb3IgdGhpcyBxdWVyeS5cbiAgICogQHJldHVybnMgVGhlIHF1ZXJ5J3Mge0BsaW5rIFF1ZXJ5Sm91cm5hbH0gb3IgYHVuZGVmaW5lZGAuXG4gICAqL1xuICBxdWVyeUpvdXJuYWwobmFtZSwgYXJncykge1xuICAgIGNvbnN0IGFyZ3NPYmplY3QgPSBwYXJzZUFyZ3MoYXJncyk7XG4gICAgY29uc3QgcXVlcnlUb2tlbiA9IHNlcmlhbGl6ZVBhdGhBbmRBcmdzKG5hbWUsIGFyZ3NPYmplY3QpO1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnF1ZXJ5Sm91cm5hbChxdWVyeVRva2VuKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IHtAbGluayBDb25uZWN0aW9uU3RhdGV9IGJldHdlZW4gdGhlIGNsaWVudCBhbmQgdGhlIENvbnZleFxuICAgKiBiYWNrZW5kLlxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUge0BsaW5rIENvbm5lY3Rpb25TdGF0ZX0gd2l0aCB0aGUgQ29udmV4IGJhY2tlbmQuXG4gICAqL1xuICBjb25uZWN0aW9uU3RhdGUoKSB7XG4gICAgY29uc3Qgd3NDb25uZWN0aW9uU3RhdGUgPSB0aGlzLndlYlNvY2tldE1hbmFnZXIuY29ubmVjdGlvblN0YXRlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhhc0luZmxpZ2h0UmVxdWVzdHM6IHRoaXMucmVxdWVzdE1hbmFnZXIuaGFzSW5mbGlnaHRSZXF1ZXN0cygpLFxuICAgICAgaXNXZWJTb2NrZXRDb25uZWN0ZWQ6IHdzQ29ubmVjdGlvblN0YXRlLmlzQ29ubmVjdGVkLFxuICAgICAgaGFzRXZlckNvbm5lY3RlZDogd3NDb25uZWN0aW9uU3RhdGUuaGFzRXZlckNvbm5lY3RlZCxcbiAgICAgIGNvbm5lY3Rpb25Db3VudDogd3NDb25uZWN0aW9uU3RhdGUuY29ubmVjdGlvbkNvdW50LFxuICAgICAgY29ubmVjdGlvblJldHJpZXM6IHdzQ29ubmVjdGlvblN0YXRlLmNvbm5lY3Rpb25SZXRyaWVzLFxuICAgICAgdGltZU9mT2xkZXN0SW5mbGlnaHRSZXF1ZXN0OiB0aGlzLnJlcXVlc3RNYW5hZ2VyLnRpbWVPZk9sZGVzdEluZmxpZ2h0UmVxdWVzdCgpLFxuICAgICAgaW5mbGlnaHRNdXRhdGlvbnM6IHRoaXMucmVxdWVzdE1hbmFnZXIuaW5mbGlnaHRNdXRhdGlvbnMoKSxcbiAgICAgIGluZmxpZ2h0QWN0aW9uczogdGhpcy5yZXF1ZXN0TWFuYWdlci5pbmZsaWdodEFjdGlvbnMoKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFN1YnNjcmliZSB0byB0aGUge0BsaW5rIENvbm5lY3Rpb25TdGF0ZX0gYmV0d2VlbiB0aGUgY2xpZW50IGFuZCB0aGUgQ29udmV4XG4gICAqIGJhY2tlbmQsIGNhbGxpbmcgYSBjYWxsYmFjayBlYWNoIHRpbWUgaXQgY2hhbmdlcy5cbiAgICpcbiAgICogU3Vic2NyaWJlZCBjYWxsYmFja3Mgd2lsbCBiZSBjYWxsZWQgd2hlbiBhbnkgcGFydCBvZiBDb25uZWN0aW9uU3RhdGUgY2hhbmdlcy5cbiAgICogQ29ubmVjdGlvblN0YXRlIG1heSBncm93IGluIGZ1dHVyZSB2ZXJzaW9ucyAoZS5nLiB0byBwcm92aWRlIGEgYXJyYXkgb2ZcbiAgICogaW5mbGlnaHQgcmVxdWVzdHMpIGluIHdoaWNoIGNhc2UgY2FsbGJhY2tzIHdvdWxkIGJlIGNhbGxlZCBtb3JlIGZyZXF1ZW50bHkuXG4gICAqXG4gICAqIEByZXR1cm5zIEFuIHVuc3Vic2NyaWJlIGZ1bmN0aW9uIHRvIHN0b3AgbGlzdGVuaW5nLlxuICAgKi9cbiAgc3Vic2NyaWJlVG9Db25uZWN0aW9uU3RhdGUoY2IpIHtcbiAgICBjb25zdCBpZCA9IHRoaXMubmV4dENvbm5lY3Rpb25TdGF0ZVN1YnNjcmliZXJJZCsrO1xuICAgIHRoaXMuY29ubmVjdGlvblN0YXRlU3Vic2NyaWJlcnMuc2V0KGlkLCBjYik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRoaXMuY29ubmVjdGlvblN0YXRlU3Vic2NyaWJlcnMuZGVsZXRlKGlkKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgICAqIEV4ZWN1dGUgYSBtdXRhdGlvbiBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIG11dGF0aW9uLlxuICAgICAqIEBwYXJhbSBhcmdzIC0gQW4gYXJndW1lbnRzIG9iamVjdCBmb3IgdGhlIG11dGF0aW9uLiBJZiB0aGlzIGlzIG9taXR0ZWQsXG4gICAgICogdGhlIGFyZ3VtZW50cyB3aWxsIGJlIGB7fWAuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBIHtAbGluayBNdXRhdGlvbk9wdGlvbnN9IG9wdGlvbnMgb2JqZWN0IGZvciB0aGlzIG11dGF0aW9uLlxuICBcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSBvZiB0aGUgbXV0YXRpb24ncyByZXN1bHQuXG4gICAgICovXG4gIGFzeW5jIG11dGF0aW9uKG5hbWUsIGFyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLm11dGF0aW9uSW50ZXJuYWwobmFtZSwgYXJncywgb3B0aW9ucyk7XG4gICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgaWYgKHJlc3VsdC5lcnJvckRhdGEgIT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBmb3J3YXJkRGF0YShcbiAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgbmV3IENvbnZleEVycm9yKFxuICAgICAgICAgICAgY3JlYXRlSHlicmlkRXJyb3JTdGFja3RyYWNlKFwibXV0YXRpb25cIiwgbmFtZSwgcmVzdWx0KVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihjcmVhdGVIeWJyaWRFcnJvclN0YWNrdHJhY2UoXCJtdXRhdGlvblwiLCBuYW1lLCByZXN1bHQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhc3luYyBtdXRhdGlvbkludGVybmFsKHVkZlBhdGgsIGFyZ3MsIG9wdGlvbnMsIGNvbXBvbmVudFBhdGgpIHtcbiAgICBjb25zdCB7IG11dGF0aW9uUHJvbWlzZSB9ID0gdGhpcy5lbnF1ZXVlTXV0YXRpb24oXG4gICAgICB1ZGZQYXRoLFxuICAgICAgYXJncyxcbiAgICAgIG9wdGlvbnMsXG4gICAgICBjb21wb25lbnRQYXRoXG4gICAgKTtcbiAgICByZXR1cm4gbXV0YXRpb25Qcm9taXNlO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVNdXRhdGlvbih1ZGZQYXRoLCBhcmdzLCBvcHRpb25zLCBjb21wb25lbnRQYXRoKSB7XG4gICAgY29uc3QgbXV0YXRpb25BcmdzID0gcGFyc2VBcmdzKGFyZ3MpO1xuICAgIHRoaXMudHJ5UmVwb3J0TG9uZ0Rpc2Nvbm5lY3QoKTtcbiAgICBjb25zdCByZXF1ZXN0SWQgPSB0aGlzLm5leHRSZXF1ZXN0SWQ7XG4gICAgdGhpcy5fbmV4dFJlcXVlc3RJZCsrO1xuICAgIGlmIChvcHRpb25zICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IG9wdGltaXN0aWNVcGRhdGUgPSBvcHRpb25zLm9wdGltaXN0aWNVcGRhdGU7XG4gICAgICBpZiAob3B0aW1pc3RpY1VwZGF0ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IHdyYXBwZWRVcGRhdGUgPSAobG9jYWxRdWVyeVN0b3JlKSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gb3B0aW1pc3RpY1VwZGF0ZShcbiAgICAgICAgICAgIGxvY2FsUXVlcnlTdG9yZSxcbiAgICAgICAgICAgIG11dGF0aW9uQXJnc1xuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXG4gICAgICAgICAgICAgIFwiT3B0aW1pc3RpYyB1cGRhdGUgaGFuZGxlciByZXR1cm5lZCBhIFByb21pc2UuIE9wdGltaXN0aWMgdXBkYXRlcyBzaG91bGQgYmUgc3luY2hyb25vdXMuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjaGFuZ2VkUXVlcnlUb2tlbnMgPSB0aGlzLm9wdGltaXN0aWNRdWVyeVJlc3VsdHMuYXBwbHlPcHRpbWlzdGljVXBkYXRlKFxuICAgICAgICAgIHdyYXBwZWRVcGRhdGUsXG4gICAgICAgICAgcmVxdWVzdElkXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGNoYW5nZWRRdWVyaWVzID0gY2hhbmdlZFF1ZXJ5VG9rZW5zLm1hcCgodG9rZW4pID0+IHtcbiAgICAgICAgICBjb25zdCBsb2NhbFJlc3VsdCA9IHRoaXMubG9jYWxRdWVyeVJlc3VsdEJ5VG9rZW4odG9rZW4pO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b2tlbixcbiAgICAgICAgICAgIG1vZGlmaWNhdGlvbjoge1xuICAgICAgICAgICAgICBraW5kOiBcIlVwZGF0ZWRcIixcbiAgICAgICAgICAgICAgcmVzdWx0OiBsb2NhbFJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDoge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGxvY2FsUmVzdWx0LFxuICAgICAgICAgICAgICAgIGxvZ0xpbmVzOiBbXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGFuZGxlVHJhbnNpdGlvbih7XG4gICAgICAgICAgcXVlcmllczogY2hhbmdlZFF1ZXJpZXMsXG4gICAgICAgICAgcmVmbGVjdGVkTXV0YXRpb25zOiBbXSxcbiAgICAgICAgICB0aW1lc3RhbXA6IHRoaXMucmVtb3RlUXVlcnlTZXQudGltZXN0YW1wKClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICB0eXBlOiBcIk11dGF0aW9uXCIsXG4gICAgICByZXF1ZXN0SWQsXG4gICAgICB1ZGZQYXRoLFxuICAgICAgY29tcG9uZW50UGF0aCxcbiAgICAgIGFyZ3M6IFtjb252ZXhUb0pzb24obXV0YXRpb25BcmdzKV1cbiAgICB9O1xuICAgIGNvbnN0IG1pZ2h0QmVTZW50ID0gdGhpcy53ZWJTb2NrZXRNYW5hZ2VyLnNlbmRNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIGNvbnN0IG11dGF0aW9uUHJvbWlzZSA9IHRoaXMucmVxdWVzdE1hbmFnZXIucmVxdWVzdChtZXNzYWdlLCBtaWdodEJlU2VudCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlcXVlc3RJZCxcbiAgICAgIG11dGF0aW9uUHJvbWlzZVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYW4gYWN0aW9uIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBhY3Rpb24uXG4gICAqIEBwYXJhbSBhcmdzIC0gQW4gYXJndW1lbnRzIG9iamVjdCBmb3IgdGhlIGFjdGlvbi4gSWYgdGhpcyBpcyBvbWl0dGVkLFxuICAgKiB0aGUgYXJndW1lbnRzIHdpbGwgYmUgYHt9YC5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIG9mIHRoZSBhY3Rpb24ncyByZXN1bHQuXG4gICAqL1xuICBhc3luYyBhY3Rpb24obmFtZSwgYXJncykge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuYWN0aW9uSW50ZXJuYWwobmFtZSwgYXJncyk7XG4gICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgaWYgKHJlc3VsdC5lcnJvckRhdGEgIT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBmb3J3YXJkRGF0YShcbiAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgbmV3IENvbnZleEVycm9yKGNyZWF0ZUh5YnJpZEVycm9yU3RhY2t0cmFjZShcImFjdGlvblwiLCBuYW1lLCByZXN1bHQpKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGNyZWF0ZUh5YnJpZEVycm9yU3RhY2t0cmFjZShcImFjdGlvblwiLCBuYW1lLCByZXN1bHQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhc3luYyBhY3Rpb25JbnRlcm5hbCh1ZGZQYXRoLCBhcmdzLCBjb21wb25lbnRQYXRoKSB7XG4gICAgY29uc3QgYWN0aW9uQXJncyA9IHBhcnNlQXJncyhhcmdzKTtcbiAgICBjb25zdCByZXF1ZXN0SWQgPSB0aGlzLm5leHRSZXF1ZXN0SWQ7XG4gICAgdGhpcy5fbmV4dFJlcXVlc3RJZCsrO1xuICAgIHRoaXMudHJ5UmVwb3J0TG9uZ0Rpc2Nvbm5lY3QoKTtcbiAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgdHlwZTogXCJBY3Rpb25cIixcbiAgICAgIHJlcXVlc3RJZCxcbiAgICAgIHVkZlBhdGgsXG4gICAgICBjb21wb25lbnRQYXRoLFxuICAgICAgYXJnczogW2NvbnZleFRvSnNvbihhY3Rpb25BcmdzKV1cbiAgICB9O1xuICAgIGNvbnN0IG1pZ2h0QmVTZW50ID0gdGhpcy53ZWJTb2NrZXRNYW5hZ2VyLnNlbmRNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3RNYW5hZ2VyLnJlcXVlc3QobWVzc2FnZSwgbWlnaHRCZVNlbnQpO1xuICB9XG4gIC8qKlxuICAgKiBDbG9zZSBhbnkgbmV0d29yayBoYW5kbGVzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNsaWVudCBhbmQgc3RvcCBhbGwgc3Vic2NyaXB0aW9ucy5cbiAgICpcbiAgICogQ2FsbCB0aGlzIG1ldGhvZCB3aGVuIHlvdSdyZSBkb25lIHdpdGggYW4ge0BsaW5rIEJhc2VDb252ZXhDbGllbnR9IHRvXG4gICAqIGRpc3Bvc2Ugb2YgaXRzIHNvY2tldHMgYW5kIHJlc291cmNlcy5cbiAgICpcbiAgICogQHJldHVybnMgQSBgUHJvbWlzZWAgZnVsZmlsbGVkIHdoZW4gdGhlIGNvbm5lY3Rpb24gaGFzIGJlZW4gY29tcGxldGVseSBjbG9zZWQuXG4gICAqL1xuICBhc3luYyBjbG9zZSgpIHtcbiAgICB0aGlzLmF1dGhlbnRpY2F0aW9uTWFuYWdlci5zdG9wKCk7XG4gICAgcmV0dXJuIHRoaXMud2ViU29ja2V0TWFuYWdlci50ZXJtaW5hdGUoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHRoZSBhZGRyZXNzIGZvciB0aGlzIGNsaWVudCwgdXNlZnVsIGZvciBjcmVhdGluZyBhIG5ldyBjbGllbnQuXG4gICAqXG4gICAqIE5vdCBndWFyYW50ZWVkIHRvIG1hdGNoIHRoZSBhZGRyZXNzIHdpdGggd2hpY2ggdGhpcyBjbGllbnQgd2FzIGNvbnN0cnVjdGVkOlxuICAgKiBpdCBtYXkgYmUgY2Fub25pY2FsaXplZC5cbiAgICovXG4gIGdldCB1cmwoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkcmVzcztcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXQgbmV4dFJlcXVlc3RJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbmV4dFJlcXVlc3RJZDtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXQgc2Vzc2lvbklkKCkge1xuICAgIHJldHVybiB0aGlzLl9zZXNzaW9uSWQ7XG4gIH1cbiAgLyoqXG4gICAqIFJlcG9ydHMgcGVyZm9ybWFuY2UgbWFya3MgdG8gdGhlIHNlcnZlci4gVGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgd2hlblxuICAgKiB3ZSBoYXZlIGEgZnVuY3Rpb25hbCB3ZWJzb2NrZXQuXG4gICAqL1xuICByZXBvcnRNYXJrcygpIHtcbiAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgY29uc3QgcmVwb3J0ID0gZ2V0TWFya3NSZXBvcnQodGhpcy5zZXNzaW9uSWQpO1xuICAgICAgdGhpcy53ZWJTb2NrZXRNYW5hZ2VyLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgdHlwZTogXCJFdmVudFwiLFxuICAgICAgICBldmVudFR5cGU6IFwiQ2xpZW50Q29ubmVjdFwiLFxuICAgICAgICBldmVudDogcmVwb3J0XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgdHJ5UmVwb3J0TG9uZ0Rpc2Nvbm5lY3QoKSB7XG4gICAgaWYgKCF0aGlzLmRlYnVnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRpbWVPZk9sZGVzdFJlcXVlc3QgPSB0aGlzLmNvbm5lY3Rpb25TdGF0ZSgpLnRpbWVPZk9sZGVzdEluZmxpZ2h0UmVxdWVzdDtcbiAgICBpZiAodGltZU9mT2xkZXN0UmVxdWVzdCA9PT0gbnVsbCB8fCBEYXRlLm5vdygpIC0gdGltZU9mT2xkZXN0UmVxdWVzdC5nZXRUaW1lKCkgPD0gNjAgKiAxZTMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZW5kcG9pbnQgPSBgJHt0aGlzLmFkZHJlc3N9L2FwaS9kZWJ1Z19ldmVudGA7XG4gICAgZmV0Y2goZW5kcG9pbnQsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICBcIkNvbnZleC1DbGllbnRcIjogYG5wbS0ke3ZlcnNpb259YFxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgZXZlbnQ6IFwiTG9uZ1dlYnNvY2tldERpc2Nvbm5lY3RcIiB9KVxuICAgIH0pLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXG4gICAgICAgICAgXCJBbmFseXRpY3MgcmVxdWVzdCBmYWlsZWQgd2l0aCByZXNwb25zZTpcIixcbiAgICAgICAgICByZXNwb25zZS5ib2R5XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKFwiQW5hbHl0aWNzIHJlc3BvbnNlIGZhaWxlZCB3aXRoIGVycm9yOlwiLCBlcnJvcik7XG4gICAgfSk7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsaWVudC5qcy5tYXBcbiIsIi8qKlxuICogQmFzZUNvbnZleENsaWVudCBzaG91bGQgbm90IGJlIHVzZWQgZGlyZWN0bHkgYW5kIGRvZXMgbm90IHByb3ZpZGUgYSBzdGFibGVcbiAqIGludGVyZmFjZS4gSXQgaXMgYSBcIkJhc2VcIiBjbGllbnQgbm90IGJlY2F1c2UgaXQgZXhwZWN0cyB0byBiZSBpbmhlcml0ZWQgZnJvbVxuICogYnV0IGJlY2F1c2Ugb3RoZXIgY2xpZW50cyBhcmUgYnVpbHQgYXJvdW5kIGl0LlxuICpcbiAqIEJhc2VDb252ZXhDbGllbnQgaXMgbm90IENvbnZleCBGdW5jdGlvbiB0eXBlLWF3YXJlOiBpdCBkZWFsc1xuICogd2l0aCBxdWVyaWVzIGFzIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBWYWx1ZSwgbm90IHRoZSBzcGVjaWZpYyB2YWx1ZS5cbiAqIFVzZSBhIGhpZ2hlci1sZXZlbCBsaWJyYXJ5IHRvIGdldCB0eXBlcy5cbiAqL1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuLi8uLi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgY29udmV4VG9Kc29uLCBWYWx1ZSB9IGZyb20gXCIuLi8uLi92YWx1ZXMvaW5kZXguanNcIjtcbmltcG9ydCB7XG4gIGNyZWF0ZUh5YnJpZEVycm9yU3RhY2t0cmFjZSxcbiAgZm9yd2FyZERhdGEsXG4gIGluc3RhbnRpYXRlRGVmYXVsdExvZ2dlcixcbiAgaW5zdGFudGlhdGVOb29wTG9nZ2VyLFxuICBsb2dGYXRhbEVycm9yLFxuICBMb2dnZXIsXG59IGZyb20gXCIuLi9sb2dnaW5nLmpzXCI7XG5pbXBvcnQgeyBMb2NhbFN5bmNTdGF0ZSB9IGZyb20gXCIuL2xvY2FsX3N0YXRlLmpzXCI7XG5pbXBvcnQgeyBSZXF1ZXN0TWFuYWdlciB9IGZyb20gXCIuL3JlcXVlc3RfbWFuYWdlci5qc1wiO1xuaW1wb3J0IHtcbiAgT3B0aW1pc3RpY0xvY2FsU3RvcmUsXG4gIE9wdGltaXN0aWNVcGRhdGUsXG59IGZyb20gXCIuL29wdGltaXN0aWNfdXBkYXRlcy5qc1wiO1xuaW1wb3J0IHtcbiAgT3B0aW1pc3RpY1F1ZXJ5UmVzdWx0cyxcbiAgUXVlcnlSZXN1bHRzTWFwLFxufSBmcm9tIFwiLi9vcHRpbWlzdGljX3VwZGF0ZXNfaW1wbC5qc1wiO1xuaW1wb3J0IHtcbiAgQWN0aW9uUmVxdWVzdCxcbiAgTXV0YXRpb25SZXF1ZXN0LFxuICBRdWVyeUlkLFxuICBRdWVyeUpvdXJuYWwsXG4gIFNlcnZlck1lc3NhZ2UsXG4gIFJlcXVlc3RJZCxcbiAgVFMsXG4gIFVzZXJJZGVudGl0eUF0dHJpYnV0ZXMsXG59IGZyb20gXCIuL3Byb3RvY29sLmpzXCI7XG5pbXBvcnQgeyBSZW1vdGVRdWVyeVNldCB9IGZyb20gXCIuL3JlbW90ZV9xdWVyeV9zZXQuanNcIjtcbmltcG9ydCB7IFF1ZXJ5VG9rZW4sIHNlcmlhbGl6ZVBhdGhBbmRBcmdzIH0gZnJvbSBcIi4vdWRmX3BhdGhfdXRpbHMuanNcIjtcbmltcG9ydCB7IFJlY29ubmVjdE1ldGFkYXRhLCBXZWJTb2NrZXRNYW5hZ2VyIH0gZnJvbSBcIi4vd2ViX3NvY2tldF9tYW5hZ2VyLmpzXCI7XG5pbXBvcnQgeyBuZXdTZXNzaW9uSWQgfSBmcm9tIFwiLi9zZXNzaW9uLmpzXCI7XG5pbXBvcnQgeyBGdW5jdGlvblJlc3VsdCB9IGZyb20gXCIuL2Z1bmN0aW9uX3Jlc3VsdC5qc1wiO1xuaW1wb3J0IHtcbiAgQXV0aGVudGljYXRpb25NYW5hZ2VyLFxuICBBdXRoVG9rZW5GZXRjaGVyLFxufSBmcm9tIFwiLi9hdXRoZW50aWNhdGlvbl9tYW5hZ2VyLmpzXCI7XG5leHBvcnQgeyB0eXBlIEF1dGhUb2tlbkZldGNoZXIgfSBmcm9tIFwiLi9hdXRoZW50aWNhdGlvbl9tYW5hZ2VyLmpzXCI7XG5pbXBvcnQgeyBnZXRNYXJrc1JlcG9ydCwgbWFyaywgTWFya05hbWUgfSBmcm9tIFwiLi9tZXRyaWNzLmpzXCI7XG5pbXBvcnQgeyBwYXJzZUFyZ3MsIHZhbGlkYXRlRGVwbG95bWVudFVybCB9IGZyb20gXCIuLi8uLi9jb21tb24vaW5kZXguanNcIjtcbmltcG9ydCB7IENvbnZleEVycm9yIH0gZnJvbSBcIi4uLy4uL3ZhbHVlcy9lcnJvcnMuanNcIjtcbmltcG9ydCB7IGp3dERlY29kZSB9IGZyb20gXCIuLi8uLi92ZW5kb3Ivand0LWRlY29kZS9pbmRleC5qc1wiO1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIHtAbGluayBCYXNlQ29udmV4Q2xpZW50fS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQmFzZUNvbnZleENsaWVudE9wdGlvbnMge1xuICAvKipcbiAgICogV2hldGhlciB0byBwcm9tcHQgdGhlIHVzZXIgaWYgdGhleSBoYXZlIHVuc2F2ZWQgY2hhbmdlcyBwZW5kaW5nXG4gICAqIHdoZW4gbmF2aWdhdGluZyBhd2F5IG9yIGNsb3NpbmcgYSB3ZWIgcGFnZS5cbiAgICpcbiAgICogVGhpcyBpcyBvbmx5IHBvc3NpYmxlIHdoZW4gdGhlIGB3aW5kb3dgIG9iamVjdCBleGlzdHMsIGkuZS4gaW4gYSBicm93c2VyLlxuICAgKlxuICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBgdHJ1ZWAgaW4gYnJvd3NlcnMuXG4gICAqL1xuICB1bnNhdmVkQ2hhbmdlc1dhcm5pbmc/OiBib29sZWFuO1xuICAvKipcbiAgICogU3BlY2lmaWVzIGFuIGFsdGVybmF0ZVxuICAgKiBbV2ViU29ja2V0XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2ViU29ja2V0KVxuICAgKiBjb25zdHJ1Y3RvciB0byB1c2UgZm9yIGNsaWVudCBjb21tdW5pY2F0aW9uIHdpdGggdGhlIENvbnZleCBjbG91ZC5cbiAgICogVGhlIGRlZmF1bHQgYmVoYXZpb3IgaXMgdG8gdXNlIGBXZWJTb2NrZXRgIGZyb20gdGhlIGdsb2JhbCBlbnZpcm9ubWVudC5cbiAgICovXG4gIHdlYlNvY2tldENvbnN0cnVjdG9yPzogdHlwZW9mIFdlYlNvY2tldDtcbiAgLyoqXG4gICAqIEFkZHMgYWRkaXRpb25hbCBsb2dnaW5nIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuXG4gICAqXG4gICAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGBmYWxzZWAuXG4gICAqL1xuICB2ZXJib3NlPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIEEgbG9nZ2VyLCBgdHJ1ZWAsIG9yIGBmYWxzZWAuIElmIG5vdCBwcm92aWRlZCBvciBgdHJ1ZWAsIGxvZ3MgdG8gdGhlIGNvbnNvbGUuXG4gICAqIElmIGBmYWxzZWAsIGxvZ3MgYXJlIG5vdCBwcmludGVkIGFueXdoZXJlLlxuICAgKlxuICAgKiBZb3UgY2FuIGNvbnN0cnVjdCB5b3VyIG93biBsb2dnZXIgdG8gY3VzdG9taXplIGxvZ2dpbmcgdG8gbG9nIGVsc2V3aGVyZS5cbiAgICogQSBsb2dnZXIgaXMgYW4gb2JqZWN0IHdpdGggNCBtZXRob2RzOiBsb2coKSwgd2FybigpLCBlcnJvcigpLCBhbmQgbG9nVmVyYm9zZSgpLlxuICAgKiBUaGVzZSBtZXRob2RzIGNhbiByZWNlaXZlIG11bHRpcGxlIGFyZ3VtZW50cyBvZiBhbnkgdHlwZXMsIGxpa2UgY29uc29sZS5sb2coKS5cbiAgICovXG4gIGxvZ2dlcj86IExvZ2dlciB8IGJvb2xlYW47XG4gIC8qKlxuICAgKiBTZW5kcyBhZGRpdGlvbmFsIG1ldHJpY3MgdG8gQ29udmV4IGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuXG4gICAqXG4gICAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGBmYWxzZWAuXG4gICAqL1xuICByZXBvcnREZWJ1Z0luZm9Ub0NvbnZleD86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWw6IGl0IG1heSBjaGFuZ2Ugb3IgZGlzYXBwZWFyLlxuICAgKlxuICAgKiBBIGZ1bmN0aW9uIHRvIGNhbGwgb24gcmVjZWl2aW5nIGFibm9ybWFsIFdlYlNvY2tldCBjbG9zZSBtZXNzYWdlcyBmcm9tIHRoZVxuICAgKiBjb25uZWN0ZWQgQ29udmV4IGRlcGxveW1lbnQuIFRoZSBjb250ZW50IG9mIHRoZXNlIG1lc3NhZ2VzIGlzIG5vdCBzdGFibGUsXG4gICAqIGl0IGlzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCB0aGF0IG1heSBjaGFuZ2UuXG4gICAqXG4gICAqIENvbnNpZGVyIHRoaXMgQVBJIGFuIG9ic2VydmFiaWxpdHkgc3RvcGdhcCB1bnRpbCBoaWdoZXIgbGV2ZWwgY29kZXMgd2l0aFxuICAgKiByZWNvbW1lbmRhdGlvbnMgb24gd2hhdCB0byBkbyBhcmUgYXZhaWxhYmxlLCB3aGljaCBjb3VsZCBiZSBhIG1vcmUgc3RhYmxlXG4gICAqIGludGVyZmFjZSBpbnN0ZWFkIG9mIGBzdHJpbmdgLlxuICAgKlxuICAgKiBDaGVjayBgY29ubmVjdGlvblN0YXRlYCBmb3IgbW9yZSBxdWFudGl0YXRpdmUgbWV0cmljcyBhYm91dCBjb25uZWN0aW9uIHN0YXR1cy5cbiAgICovXG4gIG9uU2VydmVyRGlzY29ubmVjdEVycm9yPzogKG1lc3NhZ2U6IHN0cmluZykgPT4gdm9pZDtcbiAgLyoqXG4gICAqIFNraXAgdmFsaWRhdGluZyB0aGF0IHRoZSBDb252ZXggZGVwbG95bWVudCBVUkwgbG9va3MgbGlrZVxuICAgKiBgaHR0cHM6Ly9oYXBweS1hbmltYWwtMTIzLmNvbnZleC5jbG91ZGAgb3IgbG9jYWxob3N0LlxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VmdWwgaWYgcnVubmluZyBhIHNlbGYtaG9zdGVkIENvbnZleCBiYWNrZW5kIHRoYXQgdXNlcyBhIGRpZmZlcmVudFxuICAgKiBVUkwuXG4gICAqXG4gICAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGBmYWxzZWBcbiAgICovXG4gIHNraXBDb252ZXhEZXBsb3ltZW50VXJsQ2hlY2s/OiBib29sZWFuO1xuICAvKipcbiAgICogSWYgdXNpbmcgYXV0aCwgdGhlIG51bWJlciBvZiBzZWNvbmRzIGJlZm9yZSBhIHRva2VuIGV4cGlyZXMgdGhhdCB3ZSBzaG91bGQgcmVmcmVzaCBpdC5cbiAgICpcbiAgICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgYDJgLlxuICAgKi9cbiAgYXV0aFJlZnJlc2hUb2tlbkxlZXdheVNlY29uZHM/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWw6IGl0IG1heSBjaGFuZ2Ugb3IgZGlzYXBwZWFyLlxuICAgKlxuICAgKiBXaGV0aGVyIHF1ZXJ5LCBtdXRhdGlvbiwgYW5kIGFjdGlvbiByZXF1ZXN0cyBzaG91bGQgYmUgaGVsZCBiYWNrXG4gICAqIHVudGlsIHRoZSBmaXJzdCBhdXRoIHRva2VuIGNhbiBiZSBzZW50LlxuICAgKlxuICAgKiBPcHRpbmcgaW50byB0aGlzIGJlaGF2aW9yIHdvcmtzIHdlbGwgZm9yIHBhZ2VzIHRoYXQgc2hvdWxkXG4gICAqIG9ubHkgYmUgdmlld2VkIGJ5IGF1dGhlbnRpY2F0ZWQgY2xpZW50cy5cbiAgICpcbiAgICogRGVmYXVsdHMgdG8gZmFsc2UsIG5vdCB3YWl0aW5nIGZvciBhbiBhdXRoIHRva2VuLlxuICAgKi9cbiAgZXhwZWN0QXV0aD86IGJvb2xlYW47XG59XG5cbi8qKlxuICogU3RhdGUgZGVzY3JpYmluZyB0aGUgY2xpZW50J3MgY29ubmVjdGlvbiB3aXRoIHRoZSBDb252ZXggYmFja2VuZC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCB0eXBlIENvbm5lY3Rpb25TdGF0ZSA9IHtcbiAgaGFzSW5mbGlnaHRSZXF1ZXN0czogYm9vbGVhbjtcbiAgaXNXZWJTb2NrZXRDb25uZWN0ZWQ6IGJvb2xlYW47XG4gIHRpbWVPZk9sZGVzdEluZmxpZ2h0UmVxdWVzdDogRGF0ZSB8IG51bGw7XG4gIC8qKlxuICAgKiBUcnVlIGlmIHRoZSBjbGllbnQgaGFzIGV2ZXIgb3BlbmVkIGEgV2ViU29ja2V0IHRvIHRoZSBcInJlYWR5XCIgc3RhdGUuXG4gICAqL1xuICBoYXNFdmVyQ29ubmVjdGVkOiBib29sZWFuO1xuICAvKipcbiAgICogVGhlIG51bWJlciBvZiB0aW1lcyB0aGlzIGNsaWVudCBoYXMgY29ubmVjdGVkIHRvIHRoZSBDb252ZXggYmFja2VuZC5cbiAgICpcbiAgICogQSBudW1iZXIgb2YgdGhpbmdzIGNhbiBjYXVzZSB0aGUgY2xpZW50IHRvIHJlY29ubmVjdCAtLSBzZXJ2ZXIgZXJyb3JzLFxuICAgKiBiYWQgaW50ZXJuZXQsIGF1dGggZXhwaXJpbmcuIEJ1dCB0aGlzIG51bWJlciBiZWluZyBoaWdoIGlzIGFuIGluZGljYXRpb25cbiAgICogdGhhdCB0aGUgY2xpZW50IGlzIGhhdmluZyB0cm91YmxlIGtlZXBpbmcgYSBzdGFibGUgY29ubmVjdGlvbi5cbiAgICovXG4gIGNvbm5lY3Rpb25Db3VudDogbnVtYmVyO1xuICAvKipcbiAgICogVGhlIG51bWJlciBvZiB0aW1lcyB0aGlzIGNsaWVudCBoYXMgdHJpZWQgKGFuZCBmYWlsZWQpIHRvIGNvbm5lY3QgdG8gdGhlIENvbnZleCBiYWNrZW5kLlxuICAgKi9cbiAgY29ubmVjdGlvblJldHJpZXM6IG51bWJlcjtcbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgbXV0YXRpb25zIGN1cnJlbnRseSBpbiBmbGlnaHQuXG4gICAqL1xuICBpbmZsaWdodE11dGF0aW9uczogbnVtYmVyO1xuICAvKipcbiAgICogVGhlIG51bWJlciBvZiBhY3Rpb25zIGN1cnJlbnRseSBpbiBmbGlnaHQuXG4gICAqL1xuICBpbmZsaWdodEFjdGlvbnM6IG51bWJlcjtcbn07XG5cbi8qKlxuICogT3B0aW9ucyBmb3Ige0BsaW5rIEJhc2VDb252ZXhDbGllbnQuc3Vic2NyaWJlfS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU3Vic2NyaWJlT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBBbiAob3B0aW9uYWwpIGpvdXJuYWwgcHJvZHVjZWQgZnJvbSBhIHByZXZpb3VzIGV4ZWN1dGlvbiBvZiB0aGlzIHF1ZXJ5XG4gICAqIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBJZiB0aGVyZSBpcyBhbiBleGlzdGluZyBzdWJzY3JpcHRpb24gdG8gYSBxdWVyeSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lXG4gICAqIG5hbWUgYW5kIGFyZ3VtZW50cywgdGhpcyBqb3VybmFsIHdpbGwgaGF2ZSBubyBlZmZlY3QuXG4gICAqL1xuICBqb3VybmFsPzogUXVlcnlKb3VybmFsO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbXBvbmVudFBhdGg/OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogT3B0aW9ucyBmb3Ige0BsaW5rIEJhc2VDb252ZXhDbGllbnQubXV0YXRpb259LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNdXRhdGlvbk9wdGlvbnMge1xuICAvKipcbiAgICogQW4gb3B0aW1pc3RpYyB1cGRhdGUgdG8gYXBwbHkgYWxvbmcgd2l0aCB0aGlzIG11dGF0aW9uLlxuICAgKlxuICAgKiBBbiBvcHRpbWlzdGljIHVwZGF0ZSBsb2NhbGx5IHVwZGF0ZXMgcXVlcmllcyB3aGlsZSBhIG11dGF0aW9uIGlzIHBlbmRpbmcuXG4gICAqIE9uY2UgdGhlIG11dGF0aW9uIGNvbXBsZXRlcywgdGhlIHVwZGF0ZSB3aWxsIGJlIHJvbGxlZCBiYWNrLlxuICAgKi9cbiAgb3B0aW1pc3RpY1VwZGF0ZT86IE9wdGltaXN0aWNVcGRhdGU8YW55PiB8IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBUeXBlIGRlc2NyaWJpbmcgdXBkYXRlcyB0byBhIHF1ZXJ5IHdpdGhpbiBhIGBUcmFuc2l0aW9uYC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCB0eXBlIFF1ZXJ5TW9kaWZpY2F0aW9uID1cbiAgLy8gYHVuZGVmaW5lZGAgZ2VuZXJhbGx5IGNvbWVzIGZyb20gYW4gb3B0aW1pc3RpYyB1cGRhdGUgc2V0dGluZyB0aGUgcXVlcnkgdG8gYmUgbG9hZGluZ1xuICB7IGtpbmQ6IFwiVXBkYXRlZFwiOyByZXN1bHQ6IEZ1bmN0aW9uUmVzdWx0IHwgdW5kZWZpbmVkIH0gfCB7IGtpbmQ6IFwiUmVtb3ZlZFwiIH07XG5cbi8qKlxuICogT2JqZWN0IGRlc2NyaWJpbmcgYSB0cmFuc2l0aW9uIHBhc3NlZCBpbnRvIHRoZSBgb25UcmFuc2l0aW9uYCBoYW5kbGVyLlxuICpcbiAqIFRoZXNlIGNhbiBiZSBmcm9tIHJlY2VpdmluZyBhIHRyYW5zaXRpb24gZnJvbSB0aGUgc2VydmVyLCBvciBmcm9tIGFwcGx5aW5nIGFuXG4gKiBvcHRpbWlzdGljIHVwZGF0ZSBsb2NhbGx5LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IHR5cGUgVHJhbnNpdGlvbiA9IHtcbiAgcXVlcmllczogQXJyYXk8eyB0b2tlbjogUXVlcnlUb2tlbjsgbW9kaWZpY2F0aW9uOiBRdWVyeU1vZGlmaWNhdGlvbiB9PjtcbiAgcmVmbGVjdGVkTXV0YXRpb25zOiBBcnJheTx7IHJlcXVlc3RJZDogUmVxdWVzdElkOyByZXN1bHQ6IEZ1bmN0aW9uUmVzdWx0IH0+O1xuICB0aW1lc3RhbXA6IFRTO1xufTtcblxuLyoqXG4gKiBMb3ctbGV2ZWwgY2xpZW50IGZvciBkaXJlY3RseSBpbnRlZ3JhdGluZyBzdGF0ZSBtYW5hZ2VtZW50IGxpYnJhcmllc1xuICogd2l0aCBDb252ZXguXG4gKlxuICogTW9zdCBkZXZlbG9wZXJzIHNob3VsZCB1c2UgaGlnaGVyIGxldmVsIGNsaWVudHMsIGxpa2VcbiAqIHRoZSB7QGxpbmsgQ29udmV4SHR0cENsaWVudH0gb3IgdGhlIFJlYWN0IGhvb2sgYmFzZWQge0BsaW5rIHJlYWN0LkNvbnZleFJlYWN0Q2xpZW50fS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNlQ29udmV4Q2xpZW50IHtcbiAgcHJpdmF0ZSByZWFkb25seSBhZGRyZXNzOiBzdHJpbmc7XG4gIHByaXZhdGUgcmVhZG9ubHkgc3RhdGU6IExvY2FsU3luY1N0YXRlO1xuICBwcml2YXRlIHJlYWRvbmx5IHJlcXVlc3RNYW5hZ2VyOiBSZXF1ZXN0TWFuYWdlcjtcbiAgcHJpdmF0ZSByZWFkb25seSB3ZWJTb2NrZXRNYW5hZ2VyOiBXZWJTb2NrZXRNYW5hZ2VyO1xuICBwcml2YXRlIHJlYWRvbmx5IGF1dGhlbnRpY2F0aW9uTWFuYWdlcjogQXV0aGVudGljYXRpb25NYW5hZ2VyO1xuICBwcml2YXRlIHJlbW90ZVF1ZXJ5U2V0OiBSZW1vdGVRdWVyeVNldDtcbiAgcHJpdmF0ZSByZWFkb25seSBvcHRpbWlzdGljUXVlcnlSZXN1bHRzOiBPcHRpbWlzdGljUXVlcnlSZXN1bHRzO1xuICBwcml2YXRlIF90cmFuc2l0aW9uSGFuZGxlckNvdW50ZXIgPSAwO1xuICBwcml2YXRlIF9uZXh0UmVxdWVzdElkOiBSZXF1ZXN0SWQ7XG4gIHByaXZhdGUgX29uVHJhbnNpdGlvbkZuczogTWFwPG51bWJlciwgKHRyYW5zaXRpb246IFRyYW5zaXRpb24pID0+IHZvaWQ+ID1cbiAgICBuZXcgTWFwKCk7XG4gIHByaXZhdGUgcmVhZG9ubHkgX3Nlc3Npb25JZDogc3RyaW5nO1xuICBwcml2YXRlIGZpcnN0TWVzc2FnZVJlY2VpdmVkID0gZmFsc2U7XG4gIHByaXZhdGUgcmVhZG9ubHkgZGVidWc6IGJvb2xlYW47XG4gIHByaXZhdGUgcmVhZG9ubHkgbG9nZ2VyOiBMb2dnZXI7XG4gIHByaXZhdGUgbWF4T2JzZXJ2ZWRUaW1lc3RhbXA6IFRTIHwgdW5kZWZpbmVkO1xuICBwcml2YXRlIGNvbm5lY3Rpb25TdGF0ZVN1YnNjcmliZXJzID0gbmV3IE1hcDxcbiAgICBudW1iZXIsXG4gICAgKGNvbm5lY3Rpb25TdGF0ZTogQ29ubmVjdGlvblN0YXRlKSA9PiB2b2lkXG4gID4oKTtcbiAgcHJpdmF0ZSBuZXh0Q29ubmVjdGlvblN0YXRlU3Vic2NyaWJlcklkOiBudW1iZXIgPSAwO1xuICBwcml2YXRlIF9sYXN0UHVibGlzaGVkQ29ubmVjdGlvblN0YXRlOiBDb25uZWN0aW9uU3RhdGUgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBhZGRyZXNzIC0gVGhlIHVybCBvZiB5b3VyIENvbnZleCBkZXBsb3ltZW50LCBvZnRlbiBwcm92aWRlZFxuICAgKiBieSBhbiBlbnZpcm9ubWVudCB2YXJpYWJsZS4gRS5nLiBgaHR0cHM6Ly9zbWFsbC1tb3VzZS0xMjMuY29udmV4LmNsb3VkYC5cbiAgICogQHBhcmFtIG9uVHJhbnNpdGlvbiAtIEEgY2FsbGJhY2sgcmVjZWl2aW5nIGFuIGFycmF5IG9mIHF1ZXJ5IHRva2Vuc1xuICAgKiBjb3JyZXNwb25kaW5nIHRvIHF1ZXJ5IHJlc3VsdHMgdGhhdCBoYXZlIGNoYW5nZWQgLS0gYWRkaXRpb25hbCBoYW5kbGVyc1xuICAgKiBjYW4gYmUgYWRkZWQgdmlhIGBhZGRPblRyYW5zaXRpb25IYW5kbGVyYC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBTZWUge0BsaW5rIEJhc2VDb252ZXhDbGllbnRPcHRpb25zfSBmb3IgYSBmdWxsIGRlc2NyaXB0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgYWRkcmVzczogc3RyaW5nLFxuICAgIG9uVHJhbnNpdGlvbjogKHVwZGF0ZWRRdWVyaWVzOiBRdWVyeVRva2VuW10pID0+IHZvaWQsXG4gICAgb3B0aW9ucz86IEJhc2VDb252ZXhDbGllbnRPcHRpb25zLFxuICApIHtcbiAgICBpZiAodHlwZW9mIGFkZHJlc3MgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJQYXNzaW5nIGEgQ2xpZW50Q29uZmlnIG9iamVjdCBpcyBubyBsb25nZXIgc3VwcG9ydGVkLiBQYXNzIHRoZSBVUkwgb2YgdGhlIENvbnZleCBkZXBsb3ltZW50IGFzIGEgc3RyaW5nIGRpcmVjdGx5LlwiLFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnM/LnNraXBDb252ZXhEZXBsb3ltZW50VXJsQ2hlY2sgIT09IHRydWUpIHtcbiAgICAgIHZhbGlkYXRlRGVwbG95bWVudFVybChhZGRyZXNzKTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9O1xuICAgIGNvbnN0IGF1dGhSZWZyZXNoVG9rZW5MZWV3YXlTZWNvbmRzID1cbiAgICAgIG9wdGlvbnMuYXV0aFJlZnJlc2hUb2tlbkxlZXdheVNlY29uZHMgPz8gMjtcbiAgICBsZXQgd2ViU29ja2V0Q29uc3RydWN0b3IgPSBvcHRpb25zLndlYlNvY2tldENvbnN0cnVjdG9yO1xuICAgIGlmICghd2ViU29ja2V0Q29uc3RydWN0b3IgJiYgdHlwZW9mIFdlYlNvY2tldCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIk5vIFdlYlNvY2tldCBnbG9iYWwgdmFyaWFibGUgZGVmaW5lZCEgVG8gdXNlIENvbnZleCBpbiBhbiBlbnZpcm9ubWVudCB3aXRob3V0IFdlYlNvY2tldCB0cnkgdGhlIEhUVFAgY2xpZW50OiBodHRwczovL2RvY3MuY29udmV4LmRldi9hcGkvY2xhc3Nlcy9icm93c2VyLkNvbnZleEh0dHBDbGllbnRcIixcbiAgICAgICk7XG4gICAgfVxuICAgIHdlYlNvY2tldENvbnN0cnVjdG9yID0gd2ViU29ja2V0Q29uc3RydWN0b3IgfHwgV2ViU29ja2V0O1xuICAgIHRoaXMuZGVidWcgPSBvcHRpb25zLnJlcG9ydERlYnVnSW5mb1RvQ29udmV4ID8/IGZhbHNlO1xuICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgdGhpcy5sb2dnZXIgPVxuICAgICAgb3B0aW9ucy5sb2dnZXIgPT09IGZhbHNlXG4gICAgICAgID8gaW5zdGFudGlhdGVOb29wTG9nZ2VyKHsgdmVyYm9zZTogb3B0aW9ucy52ZXJib3NlID8/IGZhbHNlIH0pXG4gICAgICAgIDogb3B0aW9ucy5sb2dnZXIgIT09IHRydWUgJiYgb3B0aW9ucy5sb2dnZXJcbiAgICAgICAgICA/IG9wdGlvbnMubG9nZ2VyXG4gICAgICAgICAgOiBpbnN0YW50aWF0ZURlZmF1bHRMb2dnZXIoeyB2ZXJib3NlOiBvcHRpb25zLnZlcmJvc2UgPz8gZmFsc2UgfSk7XG4gICAgLy8gU3Vic3RpdHV0ZSBodHRwKHMpIHdpdGggd3MocylcbiAgICBjb25zdCBpID0gYWRkcmVzcy5zZWFyY2goXCI6Ly9cIik7XG4gICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm92aWRlZCBhZGRyZXNzIHdhcyBub3QgYW4gYWJzb2x1dGUgVVJMLlwiKTtcbiAgICB9XG4gICAgY29uc3Qgb3JpZ2luID0gYWRkcmVzcy5zdWJzdHJpbmcoaSArIDMpOyAvLyBtb3ZlIHBhc3QgdGhlIGRvdWJsZSBzbGFzaFxuICAgIGNvbnN0IHByb3RvY29sID0gYWRkcmVzcy5zdWJzdHJpbmcoMCwgaSk7XG4gICAgbGV0IHdzUHJvdG9jb2w7XG4gICAgaWYgKHByb3RvY29sID09PSBcImh0dHBcIikge1xuICAgICAgd3NQcm90b2NvbCA9IFwid3NcIjtcbiAgICB9IGVsc2UgaWYgKHByb3RvY29sID09PSBcImh0dHBzXCIpIHtcbiAgICAgIHdzUHJvdG9jb2wgPSBcIndzc1wiO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gcGFyZW50IHByb3RvY29sICR7cHJvdG9jb2x9YCk7XG4gICAgfVxuICAgIGNvbnN0IHdzVXJpID0gYCR7d3NQcm90b2NvbH06Ly8ke29yaWdpbn0vYXBpLyR7dmVyc2lvbn0vc3luY2A7XG5cbiAgICB0aGlzLnN0YXRlID0gbmV3IExvY2FsU3luY1N0YXRlKCk7XG4gICAgdGhpcy5yZW1vdGVRdWVyeVNldCA9IG5ldyBSZW1vdGVRdWVyeVNldChcbiAgICAgIChxdWVyeUlkKSA9PiB0aGlzLnN0YXRlLnF1ZXJ5UGF0aChxdWVyeUlkKSxcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICk7XG4gICAgdGhpcy5yZXF1ZXN0TWFuYWdlciA9IG5ldyBSZXF1ZXN0TWFuYWdlcihcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgdGhpcy5tYXJrQ29ubmVjdGlvblN0YXRlRGlydHksXG4gICAgKTtcblxuICAgIC8vIFRoaXMgaXMgYSBjYWxsYmFjayBmb3IgQXV0aGVudGljYXRpb25NYW5hZ2VyICh3aGljaCBjYW4ndCBjYWxsXG4gICAgLy8gdGhpcyBzeW5jaHJvbm91c2x5LCB0aGUgY2FsbGJhY2sgd291bGRuJ3Qgd29yaykgc28gdGhlIGluaXRpYWxcbiAgICAvLyBwYXVzZSBmb3IgZXhwZWN0QXV0aCB3ZSBjYWxsIGl0IGF0IHRoZSBlbmQgb2YgdGhpcyBjb25zdHJ1Y3Rvci5cbiAgICBjb25zdCBwYXVzZVNvY2tldCA9ICgpID0+IHtcbiAgICAgIHRoaXMud2ViU29ja2V0TWFuYWdlci5wYXVzZSgpO1xuICAgICAgdGhpcy5zdGF0ZS5wYXVzZSgpO1xuICAgIH07XG4gICAgdGhpcy5hdXRoZW50aWNhdGlvbk1hbmFnZXIgPSBuZXcgQXV0aGVudGljYXRpb25NYW5hZ2VyKFxuICAgICAgdGhpcy5zdGF0ZSxcbiAgICAgIHtcbiAgICAgICAgYXV0aGVudGljYXRlOiAodG9rZW4pID0+IHtcbiAgICAgICAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5zdGF0ZS5zZXRBdXRoKHRva2VuKTtcbiAgICAgICAgICB0aGlzLndlYlNvY2tldE1hbmFnZXIuc2VuZE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2UuYmFzZVZlcnNpb247XG4gICAgICAgIH0sXG4gICAgICAgIHN0b3BTb2NrZXQ6ICgpID0+IHRoaXMud2ViU29ja2V0TWFuYWdlci5zdG9wKCksXG4gICAgICAgIHRyeVJlc3RhcnRTb2NrZXQ6ICgpID0+IHRoaXMud2ViU29ja2V0TWFuYWdlci50cnlSZXN0YXJ0KCksXG4gICAgICAgIHBhdXNlU29ja2V0LFxuICAgICAgICByZXN1bWVTb2NrZXQ6ICgpID0+IHRoaXMud2ViU29ja2V0TWFuYWdlci5yZXN1bWUoKSxcbiAgICAgICAgY2xlYXJBdXRoOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5jbGVhckF1dGgoKTtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGxvZ2dlcjogdGhpcy5sb2dnZXIsXG4gICAgICAgIHJlZnJlc2hUb2tlbkxlZXdheVNlY29uZHM6IGF1dGhSZWZyZXNoVG9rZW5MZWV3YXlTZWNvbmRzLFxuICAgICAgfSxcbiAgICApO1xuICAgIHRoaXMub3B0aW1pc3RpY1F1ZXJ5UmVzdWx0cyA9IG5ldyBPcHRpbWlzdGljUXVlcnlSZXN1bHRzKCk7XG4gICAgdGhpcy5hZGRPblRyYW5zaXRpb25IYW5kbGVyKCh0cmFuc2l0aW9uKSA9PiB7XG4gICAgICBvblRyYW5zaXRpb24odHJhbnNpdGlvbi5xdWVyaWVzLm1hcCgocSkgPT4gcS50b2tlbikpO1xuICAgIH0pO1xuICAgIHRoaXMuX25leHRSZXF1ZXN0SWQgPSAwO1xuICAgIHRoaXMuX3Nlc3Npb25JZCA9IG5ld1Nlc3Npb25JZCgpO1xuXG4gICAgY29uc3QgeyB1bnNhdmVkQ2hhbmdlc1dhcm5pbmcgfSA9IG9wdGlvbnM7XG4gICAgaWYgKFxuICAgICAgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiB8fFxuICAgICAgdHlwZW9mIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyID09PSBcInVuZGVmaW5lZFwiXG4gICAgKSB7XG4gICAgICBpZiAodW5zYXZlZENoYW5nZXNXYXJuaW5nID09PSB0cnVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcInVuc2F2ZWRDaGFuZ2VzV2FybmluZyByZXF1ZXN0ZWQsIGJ1dCB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciBub3QgZm91bmQhIFJlbW92ZSB7dW5zYXZlZENoYW5nZXNXYXJuaW5nOiB0cnVlfSBmcm9tIENvbnZleCBjbGllbnQgb3B0aW9ucy5cIixcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHVuc2F2ZWRDaGFuZ2VzV2FybmluZyAhPT0gZmFsc2UpIHtcbiAgICAgIC8vIExpc3RlbiBmb3IgdGFiIGNsb3NlIGV2ZW50cyBhbmQgbm90aWZ5IHRoZSB1c2VyIG9uIHVuc2F2ZWQgY2hhbmdlcy5cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsIChlKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnJlcXVlc3RNYW5hZ2VyLmhhc0luY29tcGxldGVSZXF1ZXN0cygpKSB7XG4gICAgICAgICAgLy8gVGhlcmUgYXJlIDMgZGlmZmVyZW50IHdheXMgdG8gdHJpZ2dlciB0aGlzIHBvcCB1cCBzbyBqdXN0IHRyeSBhbGwgb2ZcbiAgICAgICAgICAvLyB0aGVtLlxuXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIC8vIFRoaXMgY29uZmlybWF0aW9uIG1lc3NhZ2UgZG9lc24ndCBhY3R1YWxseSBhcHBlYXIgaW4gbW9zdCBtb2Rlcm5cbiAgICAgICAgICAvLyBicm93c2VycyBidXQgd2UgdHJpZWQuXG4gICAgICAgICAgY29uc3QgY29uZmlybWF0aW9uTWVzc2FnZSA9XG4gICAgICAgICAgICBcIkFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBsZWF2ZT8gWW91ciBjaGFuZ2VzIG1heSBub3QgYmUgc2F2ZWQuXCI7XG4gICAgICAgICAgLy8gUmVjb21tZW5kZWQgbWV0aG9kIGZvciBsZWdhY3kgKElFKSBicm93c2Vycy5cbiAgICAgICAgICAvLyBjYXN0cyB0byBhdm9pZCBkZXByZWNhdGlvbiBub3RpY2VzXG4gICAgICAgICAgKChlIHx8ICh3aW5kb3cgYXMgYW55KS5ldmVudCkgYXMgYW55KS5yZXR1cm5WYWx1ZSA9XG4gICAgICAgICAgICBjb25maXJtYXRpb25NZXNzYWdlO1xuICAgICAgICAgIHJldHVybiBjb25maXJtYXRpb25NZXNzYWdlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLndlYlNvY2tldE1hbmFnZXIgPSBuZXcgV2ViU29ja2V0TWFuYWdlcihcbiAgICAgIHdzVXJpLFxuICAgICAge1xuICAgICAgICBvbk9wZW46IChyZWNvbm5lY3RNZXRhZGF0YTogUmVjb25uZWN0TWV0YWRhdGEpID0+IHtcbiAgICAgICAgICAvLyBXZSBoYXZlIGEgbmV3IFdlYlNvY2tldCFcbiAgICAgICAgICB0aGlzLm1hcmsoXCJjb252ZXhXZWJTb2NrZXRPcGVuXCIpO1xuICAgICAgICAgIHRoaXMud2ViU29ja2V0TWFuYWdlci5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAuLi5yZWNvbm5lY3RNZXRhZGF0YSxcbiAgICAgICAgICAgIHR5cGU6IFwiQ29ubmVjdFwiLFxuICAgICAgICAgICAgc2Vzc2lvbklkOiB0aGlzLl9zZXNzaW9uSWQsXG4gICAgICAgICAgICBtYXhPYnNlcnZlZFRpbWVzdGFtcDogdGhpcy5tYXhPYnNlcnZlZFRpbWVzdGFtcCxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIFRocm93IG91dCBvdXIgcmVtb3RlIHF1ZXJ5LCByZWlzc3VlIHF1ZXJpZXNcbiAgICAgICAgICAvLyBhbmQgb3V0c3RhbmRpbmcgbXV0YXRpb25zLCBhbmQgcmVhdXRoZW50aWNhdGUuXG4gICAgICAgICAgY29uc3Qgb2xkUmVtb3RlUXVlcnlSZXN1bHRzID0gbmV3IFNldChcbiAgICAgICAgICAgIHRoaXMucmVtb3RlUXVlcnlTZXQucmVtb3RlUXVlcnlSZXN1bHRzKCkua2V5cygpLFxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5yZW1vdGVRdWVyeVNldCA9IG5ldyBSZW1vdGVRdWVyeVNldChcbiAgICAgICAgICAgIChxdWVyeUlkKSA9PiB0aGlzLnN0YXRlLnF1ZXJ5UGF0aChxdWVyeUlkKSxcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3QgW3F1ZXJ5U2V0TW9kaWZpY2F0aW9uLCBhdXRoTW9kaWZpY2F0aW9uXSA9IHRoaXMuc3RhdGUucmVzdGFydChcbiAgICAgICAgICAgIG9sZFJlbW90ZVF1ZXJ5UmVzdWx0cyxcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChhdXRoTW9kaWZpY2F0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLndlYlNvY2tldE1hbmFnZXIuc2VuZE1lc3NhZ2UoYXV0aE1vZGlmaWNhdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMud2ViU29ja2V0TWFuYWdlci5zZW5kTWVzc2FnZShxdWVyeVNldE1vZGlmaWNhdGlvbik7XG4gICAgICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIHRoaXMucmVxdWVzdE1hbmFnZXIucmVzdGFydCgpKSB7XG4gICAgICAgICAgICB0aGlzLndlYlNvY2tldE1hbmFnZXIuc2VuZE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvblJlc3VtZTogKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IFtxdWVyeVNldE1vZGlmaWNhdGlvbiwgYXV0aE1vZGlmaWNhdGlvbl0gPSB0aGlzLnN0YXRlLnJlc3VtZSgpO1xuICAgICAgICAgIGlmIChhdXRoTW9kaWZpY2F0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLndlYlNvY2tldE1hbmFnZXIuc2VuZE1lc3NhZ2UoYXV0aE1vZGlmaWNhdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChxdWVyeVNldE1vZGlmaWNhdGlvbikge1xuICAgICAgICAgICAgdGhpcy53ZWJTb2NrZXRNYW5hZ2VyLnNlbmRNZXNzYWdlKHF1ZXJ5U2V0TW9kaWZpY2F0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIHRoaXMucmVxdWVzdE1hbmFnZXIucmVzdW1lKCkpIHtcbiAgICAgICAgICAgIHRoaXMud2ViU29ja2V0TWFuYWdlci5zZW5kTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uTWVzc2FnZTogKHNlcnZlck1lc3NhZ2U6IFNlcnZlck1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAvLyBNZXRyaWNzIGV2ZW50cyBncm93IGxpbmVhcmx5IHdpdGggcmVjb25uZWN0aW9uIGF0dGVtcHRzIHNvIHRoaXNcbiAgICAgICAgICAvLyBjb25kaXRpb25hbCBwcmV2ZW50cyBuXjIgbWV0cmljcyByZXBvcnRpbmcuXG4gICAgICAgICAgaWYgKCF0aGlzLmZpcnN0TWVzc2FnZVJlY2VpdmVkKSB7XG4gICAgICAgICAgICB0aGlzLmZpcnN0TWVzc2FnZVJlY2VpdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubWFyayhcImNvbnZleEZpcnN0TWVzc2FnZVJlY2VpdmVkXCIpO1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRNYXJrcygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzd2l0Y2ggKHNlcnZlck1lc3NhZ2UudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcIlRyYW5zaXRpb25cIjoge1xuICAgICAgICAgICAgICB0aGlzLm9ic2VydmVkVGltZXN0YW1wKHNlcnZlck1lc3NhZ2UuZW5kVmVyc2lvbi50cyk7XG4gICAgICAgICAgICAgIHRoaXMuYXV0aGVudGljYXRpb25NYW5hZ2VyLm9uVHJhbnNpdGlvbihzZXJ2ZXJNZXNzYWdlKTtcbiAgICAgICAgICAgICAgdGhpcy5yZW1vdGVRdWVyeVNldC50cmFuc2l0aW9uKHNlcnZlck1lc3NhZ2UpO1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlLnRyYW5zaXRpb24oc2VydmVyTWVzc2FnZSk7XG4gICAgICAgICAgICAgIGNvbnN0IGNvbXBsZXRlZFJlcXVlc3RzID0gdGhpcy5yZXF1ZXN0TWFuYWdlci5yZW1vdmVDb21wbGV0ZWQoXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdGVRdWVyeVNldC50aW1lc3RhbXAoKSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgdGhpcy5ub3RpZnlPblF1ZXJ5UmVzdWx0Q2hhbmdlcyhjb21wbGV0ZWRSZXF1ZXN0cyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIk11dGF0aW9uUmVzcG9uc2VcIjoge1xuICAgICAgICAgICAgICBpZiAoc2VydmVyTWVzc2FnZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vYnNlcnZlZFRpbWVzdGFtcChzZXJ2ZXJNZXNzYWdlLnRzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBjb21wbGV0ZWRNdXRhdGlvbkluZm8gPVxuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdE1hbmFnZXIub25SZXNwb25zZShzZXJ2ZXJNZXNzYWdlKTtcbiAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlZE11dGF0aW9uSW5mbyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5T25RdWVyeVJlc3VsdENoYW5nZXMoXG4gICAgICAgICAgICAgICAgICBuZXcgTWFwKFtcbiAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZE11dGF0aW9uSW5mby5yZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVkTXV0YXRpb25JbmZvLnJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiQWN0aW9uUmVzcG9uc2VcIjoge1xuICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RNYW5hZ2VyLm9uUmVzcG9uc2Uoc2VydmVyTWVzc2FnZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIkF1dGhFcnJvclwiOiB7XG4gICAgICAgICAgICAgIHRoaXMuYXV0aGVudGljYXRpb25NYW5hZ2VyLm9uQXV0aEVycm9yKHNlcnZlck1lc3NhZ2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJGYXRhbEVycm9yXCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBsb2dGYXRhbEVycm9yKHRoaXMubG9nZ2VyLCBzZXJ2ZXJNZXNzYWdlLmVycm9yKTtcbiAgICAgICAgICAgICAgdm9pZCB0aGlzLndlYlNvY2tldE1hbmFnZXIudGVybWluYXRlKCk7XG4gICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICBzZXJ2ZXJNZXNzYWdlIHNhdGlzZmllcyBuZXZlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGFzU3luY2VkUGFzdExhc3RSZWNvbm5lY3Q6IHRoaXMuaGFzU3luY2VkUGFzdExhc3RSZWNvbm5lY3QoKSxcbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBvblNlcnZlckRpc2Nvbm5lY3RFcnJvcjogb3B0aW9ucy5vblNlcnZlckRpc2Nvbm5lY3RFcnJvcixcbiAgICAgIH0sXG4gICAgICB3ZWJTb2NrZXRDb25zdHJ1Y3RvcixcbiAgICAgIHRoaXMubG9nZ2VyLFxuICAgICAgdGhpcy5tYXJrQ29ubmVjdGlvblN0YXRlRGlydHksXG4gICAgICB0aGlzLmRlYnVnLFxuICAgICk7XG4gICAgdGhpcy5tYXJrKFwiY29udmV4Q2xpZW50Q29uc3RydWN0ZWRcIik7XG5cbiAgICAvLyBCZWdpbiBjbGllbnQgaW4gYSBwYXVzZWQgc3RhdGUgd2FpdGluZyBmb3IgYW4gYXV0aCB0b2tlbi5cbiAgICBpZiAob3B0aW9ucy5leHBlY3RBdXRoKSB7XG4gICAgICBwYXVzZVNvY2tldCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGVyZSBpcyBvdXRzdGFuZGluZyB3b3JrIGZyb20gcHJpb3IgdG8gdGhlIHRpbWUgb2YgdGhlIG1vc3QgcmVjZW50IHJlc3RhcnQuXG4gICAqIFRoaXMgaW5kaWNhdGVzIHRoYXQgdGhlIGNsaWVudCBoYXMgbm90IHByb3ZlbiBpdHNlbGYgdG8gaGF2ZSBnb3R0ZW4gcGFzdCB0aGUgaXNzdWUgdGhhdFxuICAgKiBwb3RlbnRpYWxseSBsZWQgdG8gdGhlIHJlc3RhcnQuIFVzZSB0aGlzIHRvIGluZmx1ZW5jZSB3aGVuIHRvIHJlc2V0IGJhY2tvZmYgYWZ0ZXIgYSBmYWlsdXJlLlxuICAgKi9cbiAgcHJpdmF0ZSBoYXNTeW5jZWRQYXN0TGFzdFJlY29ubmVjdCgpIHtcbiAgICBjb25zdCBoYXNTeW5jZWRQYXN0TGFzdFJlY29ubmVjdCA9XG4gICAgICB0aGlzLnJlcXVlc3RNYW5hZ2VyLmhhc1N5bmNlZFBhc3RMYXN0UmVjb25uZWN0KCkgfHxcbiAgICAgIHRoaXMuc3RhdGUuaGFzU3luY2VkUGFzdExhc3RSZWNvbm5lY3QoKTtcbiAgICByZXR1cm4gaGFzU3luY2VkUGFzdExhc3RSZWNvbm5lY3Q7XG4gIH1cblxuICBwcml2YXRlIG9ic2VydmVkVGltZXN0YW1wKG9ic2VydmVkVHM6IFRTKSB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5tYXhPYnNlcnZlZFRpbWVzdGFtcCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLm1heE9ic2VydmVkVGltZXN0YW1wLmxlc3NUaGFuT3JFcXVhbChvYnNlcnZlZFRzKVxuICAgICkge1xuICAgICAgdGhpcy5tYXhPYnNlcnZlZFRpbWVzdGFtcCA9IG9ic2VydmVkVHM7XG4gICAgfVxuICB9XG5cbiAgZ2V0TWF4T2JzZXJ2ZWRUaW1lc3RhbXAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF4T2JzZXJ2ZWRUaW1lc3RhbXA7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZSB0aGUgY3VycmVudCBxdWVyeSByZXN1bHRzIGJhc2VkIG9uIHRoZSByZW1vdGVRdWVyeVNldCBhbmQgdGhlXG4gICAqIGN1cnJlbnQgb3B0aW1pc3RpYyB1cGRhdGVzIGFuZCBjYWxsIGBvblRyYW5zaXRpb25gIGZvciBhbGwgdGhlIGNoYW5nZWRcbiAgICogcXVlcmllcy5cbiAgICpcbiAgICogQHBhcmFtIGNvbXBsZXRlZE11dGF0aW9ucyAtIEEgc2V0IG9mIG11dGF0aW9uIElEcyB3aG9zZSBvcHRpbWlzdGljIHVwZGF0ZXNcbiAgICogYXJlIG5vIGxvbmdlciBuZWVkZWQuXG4gICAqL1xuICBwcml2YXRlIG5vdGlmeU9uUXVlcnlSZXN1bHRDaGFuZ2VzKFxuICAgIGNvbXBsZXRlZFJlcXVlc3RzOiBNYXA8UmVxdWVzdElkLCBGdW5jdGlvblJlc3VsdD4sXG4gICkge1xuICAgIGNvbnN0IHJlbW90ZVF1ZXJ5UmVzdWx0czogTWFwPFF1ZXJ5SWQsIEZ1bmN0aW9uUmVzdWx0PiA9XG4gICAgICB0aGlzLnJlbW90ZVF1ZXJ5U2V0LnJlbW90ZVF1ZXJ5UmVzdWx0cygpO1xuICAgIGNvbnN0IHF1ZXJ5VG9rZW5Ub1ZhbHVlOiBRdWVyeVJlc3VsdHNNYXAgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBbcXVlcnlJZCwgcmVzdWx0XSBvZiByZW1vdGVRdWVyeVJlc3VsdHMpIHtcbiAgICAgIGNvbnN0IHF1ZXJ5VG9rZW4gPSB0aGlzLnN0YXRlLnF1ZXJ5VG9rZW4ocXVlcnlJZCk7XG4gICAgICAvLyBJdCdzIHBvc3NpYmxlIHRoYXQgd2UndmUgYWxyZWFkeSB1bnN1YnNjcmliZWQgdG8gdGhpcyBxdWVyeSBidXRcbiAgICAgIC8vIHRoZSBzZXJ2ZXIgaGFzbid0IGxlYXJuZWQgYWJvdXQgdGhhdCB5ZXQuIElmIHNvLCBpZ25vcmUgdGhpcyBvbmUuXG5cbiAgICAgIGlmIChxdWVyeVRva2VuICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0ge1xuICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICB1ZGZQYXRoOiB0aGlzLnN0YXRlLnF1ZXJ5UGF0aChxdWVyeUlkKSEsXG4gICAgICAgICAgYXJnczogdGhpcy5zdGF0ZS5xdWVyeUFyZ3MocXVlcnlJZCkhLFxuICAgICAgICB9O1xuICAgICAgICBxdWVyeVRva2VuVG9WYWx1ZS5zZXQocXVlcnlUb2tlbiwgcXVlcnkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFF1ZXJ5IHRva2VucyB0aGF0IGFyZSBuZXcgKGJlY2F1c2Ugb2YgbmV3IHNlcnZlciByZXN1bHRzIG9yIG5ldyBsb2NhbCBvcHRpbWlzdGljIHVwZGF0ZXMpXG4gICAgLy8gb3IgZGlmZmVyIGZyb20gb2xkIHZhbHVlcyAoYmVjYXVzZSBvZiBjaGFuZ2VzIGZyb20gbG9jYWwgb3B0aW1pc3RpYyB1cGRhdGVzIG9yIG5ldyByZXN1bHRzXG4gICAgLy8gZnJvbSB0aGUgc2VydmVyKS5cbiAgICBjb25zdCBjaGFuZ2VkUXVlcnlUb2tlbnMgPVxuICAgICAgdGhpcy5vcHRpbWlzdGljUXVlcnlSZXN1bHRzLmluZ2VzdFF1ZXJ5UmVzdWx0c0Zyb21TZXJ2ZXIoXG4gICAgICAgIHF1ZXJ5VG9rZW5Ub1ZhbHVlLFxuICAgICAgICBuZXcgU2V0KGNvbXBsZXRlZFJlcXVlc3RzLmtleXMoKSksXG4gICAgICApO1xuXG4gICAgdGhpcy5oYW5kbGVUcmFuc2l0aW9uKHtcbiAgICAgIHF1ZXJpZXM6IGNoYW5nZWRRdWVyeVRva2Vucy5tYXAoKHRva2VuKSA9PiB7XG4gICAgICAgIGNvbnN0IG9wdGltaXN0aWNSZXN1bHQgPVxuICAgICAgICAgIHRoaXMub3B0aW1pc3RpY1F1ZXJ5UmVzdWx0cy5yYXdRdWVyeVJlc3VsdCh0b2tlbik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgbW9kaWZpY2F0aW9uOiB7XG4gICAgICAgICAgICBraW5kOiBcIlVwZGF0ZWRcIiBhcyBjb25zdCxcbiAgICAgICAgICAgIHJlc3VsdDogb3B0aW1pc3RpY1Jlc3VsdCxcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgfSksXG4gICAgICByZWZsZWN0ZWRNdXRhdGlvbnM6IEFycmF5LmZyb20oY29tcGxldGVkUmVxdWVzdHMpLm1hcChcbiAgICAgICAgKFtyZXF1ZXN0SWQsIHJlc3VsdF0pID0+ICh7XG4gICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgfSksXG4gICAgICApLFxuICAgICAgdGltZXN0YW1wOiB0aGlzLnJlbW90ZVF1ZXJ5U2V0LnRpbWVzdGFtcCgpLFxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVUcmFuc2l0aW9uKHRyYW5zaXRpb246IFRyYW5zaXRpb24pIHtcbiAgICBmb3IgKGNvbnN0IGZuIG9mIHRoaXMuX29uVHJhbnNpdGlvbkZucy52YWx1ZXMoKSkge1xuICAgICAgZm4odHJhbnNpdGlvbik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIGhhbmRsZXIgdGhhdCB3aWxsIGJlIGNhbGxlZCBvbiBhIHRyYW5zaXRpb24uXG4gICAqXG4gICAqIEFueSBleHRlcm5hbCBzaWRlIGVmZmVjdHMgKGUuZy4gc2V0dGluZyBSZWFjdCBzdGF0ZSkgc2hvdWxkIGJlIGhhbmRsZWQgaGVyZS5cbiAgICpcbiAgICogQHBhcmFtIGZuXG4gICAqXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBhZGRPblRyYW5zaXRpb25IYW5kbGVyKGZuOiAodHJhbnNpdGlvbjogVHJhbnNpdGlvbikgPT4gdm9pZCkge1xuICAgIGNvbnN0IGlkID0gdGhpcy5fdHJhbnNpdGlvbkhhbmRsZXJDb3VudGVyKys7XG4gICAgdGhpcy5fb25UcmFuc2l0aW9uRm5zLnNldChpZCwgZm4pO1xuICAgIHJldHVybiAoKSA9PiB0aGlzLl9vblRyYW5zaXRpb25GbnMuZGVsZXRlKGlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgSldUIGF1dGggdG9rZW4gYW5kIGRlY29kZWQgY2xhaW1zLlxuICAgKi9cbiAgZ2V0Q3VycmVudEF1dGhDbGFpbXMoKTpcbiAgICB8IHsgdG9rZW46IHN0cmluZzsgZGVjb2RlZDogUmVjb3JkPHN0cmluZywgYW55PiB9XG4gICAgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IGF1dGhUb2tlbiA9IHRoaXMuc3RhdGUuZ2V0QXV0aCgpO1xuICAgIGxldCBkZWNvZGVkOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge307XG4gICAgaWYgKGF1dGhUb2tlbiAmJiBhdXRoVG9rZW4udG9rZW5UeXBlID09PSBcIlVzZXJcIikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGVjb2RlZCA9IGF1dGhUb2tlbiA/IGp3dERlY29kZShhdXRoVG9rZW4udmFsdWUpIDoge307XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgZGVjb2RlZCA9IHt9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4geyB0b2tlbjogYXV0aFRva2VuLnZhbHVlLCBkZWNvZGVkIH07XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBhdXRoZW50aWNhdGlvbiB0b2tlbiB0byBiZSB1c2VkIGZvciBzdWJzZXF1ZW50IHF1ZXJpZXMgYW5kIG11dGF0aW9ucy5cbiAgICogYGZldGNoVG9rZW5gIHdpbGwgYmUgY2FsbGVkIGF1dG9tYXRpY2FsbHkgYWdhaW4gaWYgYSB0b2tlbiBleHBpcmVzLlxuICAgKiBgZmV0Y2hUb2tlbmAgc2hvdWxkIHJldHVybiBgbnVsbGAgaWYgdGhlIHRva2VuIGNhbm5vdCBiZSByZXRyaWV2ZWQsIGZvciBleGFtcGxlXG4gICAqIHdoZW4gdGhlIHVzZXIncyByaWdodHMgd2VyZSBwZXJtYW5lbnRseSByZXZva2VkLlxuICAgKiBAcGFyYW0gZmV0Y2hUb2tlbiAtIGFuIGFzeW5jIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgSldULWVuY29kZWQgT3BlbklEIENvbm5lY3QgSWRlbnRpdHkgVG9rZW5cbiAgICogQHBhcmFtIG9uQ2hhbmdlIC0gYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGF1dGhlbnRpY2F0aW9uIHN0YXR1cyBjaGFuZ2VzXG4gICAqL1xuICBzZXRBdXRoKFxuICAgIGZldGNoVG9rZW46IEF1dGhUb2tlbkZldGNoZXIsXG4gICAgb25DaGFuZ2U6IChpc0F1dGhlbnRpY2F0ZWQ6IGJvb2xlYW4pID0+IHZvaWQsXG4gICkge1xuICAgIHZvaWQgdGhpcy5hdXRoZW50aWNhdGlvbk1hbmFnZXIuc2V0Q29uZmlnKGZldGNoVG9rZW4sIG9uQ2hhbmdlKTtcbiAgfVxuXG4gIGhhc0F1dGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuaGFzQXV0aCgpO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRBZG1pbkF1dGgodmFsdWU6IHN0cmluZywgZmFrZVVzZXJJZGVudGl0eT86IFVzZXJJZGVudGl0eUF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5zdGF0ZS5zZXRBZG1pbkF1dGgodmFsdWUsIGZha2VVc2VySWRlbnRpdHkpO1xuICAgIHRoaXMud2ViU29ja2V0TWFuYWdlci5zZW5kTWVzc2FnZShtZXNzYWdlKTtcbiAgfVxuXG4gIGNsZWFyQXV0aCgpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5zdGF0ZS5jbGVhckF1dGgoKTtcbiAgICB0aGlzLndlYlNvY2tldE1hbmFnZXIuc2VuZE1lc3NhZ2UobWVzc2FnZSk7XG4gIH1cblxuICAvKipcbiAgICogU3Vic2NyaWJlIHRvIGEgcXVlcnkgZnVuY3Rpb24uXG4gICAqXG4gICAqIFdoZW5ldmVyIHRoaXMgcXVlcnkncyByZXN1bHQgY2hhbmdlcywgdGhlIGBvblRyYW5zaXRpb25gIGNhbGxiYWNrXG4gICAqIHBhc3NlZCBpbnRvIHRoZSBjb25zdHJ1Y3RvciB3aWxsIGJlIGNhbGxlZC5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcXVlcnkuXG4gICAqIEBwYXJhbSBhcmdzIC0gQW4gYXJndW1lbnRzIG9iamVjdCBmb3IgdGhlIHF1ZXJ5LiBJZiB0aGlzIGlzIG9taXR0ZWQsIHRoZVxuICAgKiBhcmd1bWVudHMgd2lsbCBiZSBge31gLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEEge0BsaW5rIFN1YnNjcmliZU9wdGlvbnN9IG9wdGlvbnMgb2JqZWN0IGZvciB0aGlzIHF1ZXJ5LlxuXG4gICAqIEByZXR1cm5zIEFuIG9iamVjdCBjb250YWluaW5nIGEge0BsaW5rIFF1ZXJ5VG9rZW59IGNvcnJlc3BvbmRpbmcgdG8gdGhpc1xuICAgKiBxdWVyeSBhbmQgYW4gYHVuc3Vic2NyaWJlYCBjYWxsYmFjay5cbiAgICovXG4gIHN1YnNjcmliZShcbiAgICBuYW1lOiBzdHJpbmcsXG4gICAgYXJncz86IFJlY29yZDxzdHJpbmcsIFZhbHVlPixcbiAgICBvcHRpb25zPzogU3Vic2NyaWJlT3B0aW9ucyxcbiAgKTogeyBxdWVyeVRva2VuOiBRdWVyeVRva2VuOyB1bnN1YnNjcmliZTogKCkgPT4gdm9pZCB9IHtcbiAgICBjb25zdCBhcmdzT2JqZWN0ID0gcGFyc2VBcmdzKGFyZ3MpO1xuXG4gICAgY29uc3QgeyBtb2RpZmljYXRpb24sIHF1ZXJ5VG9rZW4sIHVuc3Vic2NyaWJlIH0gPSB0aGlzLnN0YXRlLnN1YnNjcmliZShcbiAgICAgIG5hbWUsXG4gICAgICBhcmdzT2JqZWN0LFxuICAgICAgb3B0aW9ucz8uam91cm5hbCxcbiAgICAgIG9wdGlvbnM/LmNvbXBvbmVudFBhdGgsXG4gICAgKTtcbiAgICBpZiAobW9kaWZpY2F0aW9uICE9PSBudWxsKSB7XG4gICAgICB0aGlzLndlYlNvY2tldE1hbmFnZXIuc2VuZE1lc3NhZ2UobW9kaWZpY2F0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHF1ZXJ5VG9rZW4sXG4gICAgICB1bnN1YnNjcmliZTogKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2RpZmljYXRpb24gPSB1bnN1YnNjcmliZSgpO1xuICAgICAgICBpZiAobW9kaWZpY2F0aW9uKSB7XG4gICAgICAgICAgdGhpcy53ZWJTb2NrZXRNYW5hZ2VyLnNlbmRNZXNzYWdlKG1vZGlmaWNhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHF1ZXJ5IHJlc3VsdCBiYXNlZCBvbmx5IG9uIHRoZSBjdXJyZW50LCBsb2NhbCBzdGF0ZS5cbiAgICpcbiAgICogVGhlIG9ubHkgd2F5IHRoaXMgd2lsbCByZXR1cm4gYSB2YWx1ZSBpcyBpZiB3ZSdyZSBhbHJlYWR5IHN1YnNjcmliZWQgdG8gdGhlXG4gICAqIHF1ZXJ5IG9yIGl0cyB2YWx1ZSBoYXMgYmVlbiBzZXQgb3B0aW1pc3RpY2FsbHkuXG4gICAqL1xuICBsb2NhbFF1ZXJ5UmVzdWx0KFxuICAgIHVkZlBhdGg6IHN0cmluZyxcbiAgICBhcmdzPzogUmVjb3JkPHN0cmluZywgVmFsdWU+LFxuICApOiBWYWx1ZSB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgYXJnc09iamVjdCA9IHBhcnNlQXJncyhhcmdzKTtcbiAgICBjb25zdCBxdWVyeVRva2VuID0gc2VyaWFsaXplUGF0aEFuZEFyZ3ModWRmUGF0aCwgYXJnc09iamVjdCk7XG4gICAgcmV0dXJuIHRoaXMub3B0aW1pc3RpY1F1ZXJ5UmVzdWx0cy5xdWVyeVJlc3VsdChxdWVyeVRva2VuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgcXVlcnkgcmVzdWx0IGJ5IHF1ZXJ5IHRva2VuIGJhc2VkIG9uIGN1cnJlbnQsIGxvY2FsIHN0YXRlXG4gICAqXG4gICAqIFRoZSBvbmx5IHdheSB0aGlzIHdpbGwgcmV0dXJuIGEgdmFsdWUgaXMgaWYgd2UncmUgYWxyZWFkeSBzdWJzY3JpYmVkIHRvIHRoZVxuICAgKiBxdWVyeSBvciBpdHMgdmFsdWUgaGFzIGJlZW4gc2V0IG9wdGltaXN0aWNhbGx5LlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGxvY2FsUXVlcnlSZXN1bHRCeVRva2VuKHF1ZXJ5VG9rZW46IFF1ZXJ5VG9rZW4pOiBWYWx1ZSB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW1pc3RpY1F1ZXJ5UmVzdWx0cy5xdWVyeVJlc3VsdChxdWVyeVRva2VuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGxvY2FsIHF1ZXJ5IHJlc3VsdCBpcyBhdmFpbGFibGUgZm9yIGEgdG9rZW4uXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHRocm93IGlmIHRoZSByZXN1bHQgaXMgYW4gZXJyb3IuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgaGFzTG9jYWxRdWVyeVJlc3VsdEJ5VG9rZW4ocXVlcnlUb2tlbjogUXVlcnlUb2tlbik6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLm9wdGltaXN0aWNRdWVyeVJlc3VsdHMuaGFzUXVlcnlSZXN1bHQocXVlcnlUb2tlbik7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBsb2NhbFF1ZXJ5TG9ncyhcbiAgICB1ZGZQYXRoOiBzdHJpbmcsXG4gICAgYXJncz86IFJlY29yZDxzdHJpbmcsIFZhbHVlPixcbiAgKTogc3RyaW5nW10gfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IGFyZ3NPYmplY3QgPSBwYXJzZUFyZ3MoYXJncyk7XG4gICAgY29uc3QgcXVlcnlUb2tlbiA9IHNlcmlhbGl6ZVBhdGhBbmRBcmdzKHVkZlBhdGgsIGFyZ3NPYmplY3QpO1xuICAgIHJldHVybiB0aGlzLm9wdGltaXN0aWNRdWVyeVJlc3VsdHMucXVlcnlMb2dzKHF1ZXJ5VG9rZW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSBjdXJyZW50IHtAbGluayBRdWVyeUpvdXJuYWx9IGZvciB0aGlzIHF1ZXJ5IGZ1bmN0aW9uLlxuICAgKlxuICAgKiBJZiB3ZSBoYXZlIG5vdCB5ZXQgcmVjZWl2ZWQgYSByZXN1bHQgZm9yIHRoaXMgcXVlcnksIHRoaXMgd2lsbCBiZSBgdW5kZWZpbmVkYC5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcXVlcnkuXG4gICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyBvYmplY3QgZm9yIHRoaXMgcXVlcnkuXG4gICAqIEByZXR1cm5zIFRoZSBxdWVyeSdzIHtAbGluayBRdWVyeUpvdXJuYWx9IG9yIGB1bmRlZmluZWRgLlxuICAgKi9cbiAgcXVlcnlKb3VybmFsKFxuICAgIG5hbWU6IHN0cmluZyxcbiAgICBhcmdzPzogUmVjb3JkPHN0cmluZywgVmFsdWU+LFxuICApOiBRdWVyeUpvdXJuYWwgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IGFyZ3NPYmplY3QgPSBwYXJzZUFyZ3MoYXJncyk7XG4gICAgY29uc3QgcXVlcnlUb2tlbiA9IHNlcmlhbGl6ZVBhdGhBbmRBcmdzKG5hbWUsIGFyZ3NPYmplY3QpO1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnF1ZXJ5Sm91cm5hbChxdWVyeVRva2VuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQge0BsaW5rIENvbm5lY3Rpb25TdGF0ZX0gYmV0d2VlbiB0aGUgY2xpZW50IGFuZCB0aGUgQ29udmV4XG4gICAqIGJhY2tlbmQuXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSB7QGxpbmsgQ29ubmVjdGlvblN0YXRlfSB3aXRoIHRoZSBDb252ZXggYmFja2VuZC5cbiAgICovXG4gIGNvbm5lY3Rpb25TdGF0ZSgpOiBDb25uZWN0aW9uU3RhdGUge1xuICAgIGNvbnN0IHdzQ29ubmVjdGlvblN0YXRlID0gdGhpcy53ZWJTb2NrZXRNYW5hZ2VyLmNvbm5lY3Rpb25TdGF0ZSgpO1xuICAgIHJldHVybiB7XG4gICAgICBoYXNJbmZsaWdodFJlcXVlc3RzOiB0aGlzLnJlcXVlc3RNYW5hZ2VyLmhhc0luZmxpZ2h0UmVxdWVzdHMoKSxcbiAgICAgIGlzV2ViU29ja2V0Q29ubmVjdGVkOiB3c0Nvbm5lY3Rpb25TdGF0ZS5pc0Nvbm5lY3RlZCxcbiAgICAgIGhhc0V2ZXJDb25uZWN0ZWQ6IHdzQ29ubmVjdGlvblN0YXRlLmhhc0V2ZXJDb25uZWN0ZWQsXG4gICAgICBjb25uZWN0aW9uQ291bnQ6IHdzQ29ubmVjdGlvblN0YXRlLmNvbm5lY3Rpb25Db3VudCxcbiAgICAgIGNvbm5lY3Rpb25SZXRyaWVzOiB3c0Nvbm5lY3Rpb25TdGF0ZS5jb25uZWN0aW9uUmV0cmllcyxcbiAgICAgIHRpbWVPZk9sZGVzdEluZmxpZ2h0UmVxdWVzdDpcbiAgICAgICAgdGhpcy5yZXF1ZXN0TWFuYWdlci50aW1lT2ZPbGRlc3RJbmZsaWdodFJlcXVlc3QoKSxcbiAgICAgIGluZmxpZ2h0TXV0YXRpb25zOiB0aGlzLnJlcXVlc3RNYW5hZ2VyLmluZmxpZ2h0TXV0YXRpb25zKCksXG4gICAgICBpbmZsaWdodEFjdGlvbnM6IHRoaXMucmVxdWVzdE1hbmFnZXIuaW5mbGlnaHRBY3Rpb25zKCksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsIHRoaXMgd2hlbmV2ZXIgdGhlIGNvbm5lY3Rpb24gc3RhdGUgbWF5IGhhdmUgY2hhbmdlZCBpbiBhIHdheSB0aGF0IGNvdWxkXG4gICAqIHJlcXVpcmUgcHVibGlzaGluZyBpdC4gU2NoZWR1bGVzIGEgcG9zc2libHkgdXBkYXRlLlxuICAgKi9cbiAgcHJpdmF0ZSBtYXJrQ29ubmVjdGlvblN0YXRlRGlydHkgPSAoKSA9PiB7XG4gICAgdm9pZCBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgIGNvbnN0IGN1ckNvbm5lY3Rpb25TdGF0ZSA9IHRoaXMuY29ubmVjdGlvblN0YXRlKCk7XG4gICAgICBpZiAoXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KGN1ckNvbm5lY3Rpb25TdGF0ZSkgIT09XG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHRoaXMuX2xhc3RQdWJsaXNoZWRDb25uZWN0aW9uU3RhdGUpXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5fbGFzdFB1Ymxpc2hlZENvbm5lY3Rpb25TdGF0ZSA9IGN1ckNvbm5lY3Rpb25TdGF0ZTtcbiAgICAgICAgZm9yIChjb25zdCBjYiBvZiB0aGlzLmNvbm5lY3Rpb25TdGF0ZVN1YnNjcmliZXJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgLy8gT25lIG9mIHRoZXNlIGNhbGxiYWNrIHRocm93aW5nIHdpbGwgcHJldmVudCBvdGhlciBjYWxsYmFja3NcbiAgICAgICAgICAvLyBmcm9tIHJ1bm5pbmcgYnV0IHdpbGwgbm90IGxlYXZlIHRoZSBjbGllbnQgaW4gYSB1bmRlZmluZWQgc3RhdGUuXG4gICAgICAgICAgY2IoY3VyQ29ubmVjdGlvblN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgdG8gdGhlIHtAbGluayBDb25uZWN0aW9uU3RhdGV9IGJldHdlZW4gdGhlIGNsaWVudCBhbmQgdGhlIENvbnZleFxuICAgKiBiYWNrZW5kLCBjYWxsaW5nIGEgY2FsbGJhY2sgZWFjaCB0aW1lIGl0IGNoYW5nZXMuXG4gICAqXG4gICAqIFN1YnNjcmliZWQgY2FsbGJhY2tzIHdpbGwgYmUgY2FsbGVkIHdoZW4gYW55IHBhcnQgb2YgQ29ubmVjdGlvblN0YXRlIGNoYW5nZXMuXG4gICAqIENvbm5lY3Rpb25TdGF0ZSBtYXkgZ3JvdyBpbiBmdXR1cmUgdmVyc2lvbnMgKGUuZy4gdG8gcHJvdmlkZSBhIGFycmF5IG9mXG4gICAqIGluZmxpZ2h0IHJlcXVlc3RzKSBpbiB3aGljaCBjYXNlIGNhbGxiYWNrcyB3b3VsZCBiZSBjYWxsZWQgbW9yZSBmcmVxdWVudGx5LlxuICAgKlxuICAgKiBAcmV0dXJucyBBbiB1bnN1YnNjcmliZSBmdW5jdGlvbiB0byBzdG9wIGxpc3RlbmluZy5cbiAgICovXG4gIHN1YnNjcmliZVRvQ29ubmVjdGlvblN0YXRlKFxuICAgIGNiOiAoY29ubmVjdGlvblN0YXRlOiBDb25uZWN0aW9uU3RhdGUpID0+IHZvaWQsXG4gICk6ICgpID0+IHZvaWQge1xuICAgIGNvbnN0IGlkID0gdGhpcy5uZXh0Q29ubmVjdGlvblN0YXRlU3Vic2NyaWJlcklkKys7XG4gICAgdGhpcy5jb25uZWN0aW9uU3RhdGVTdWJzY3JpYmVycy5zZXQoaWQsIGNiKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdGhpcy5jb25uZWN0aW9uU3RhdGVTdWJzY3JpYmVycy5kZWxldGUoaWQpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZSBhIG11dGF0aW9uIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBtdXRhdGlvbi5cbiAgICogQHBhcmFtIGFyZ3MgLSBBbiBhcmd1bWVudHMgb2JqZWN0IGZvciB0aGUgbXV0YXRpb24uIElmIHRoaXMgaXMgb21pdHRlZCxcbiAgICogdGhlIGFyZ3VtZW50cyB3aWxsIGJlIGB7fWAuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQSB7QGxpbmsgTXV0YXRpb25PcHRpb25zfSBvcHRpb25zIG9iamVjdCBmb3IgdGhpcyBtdXRhdGlvbi5cblxuICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSBvZiB0aGUgbXV0YXRpb24ncyByZXN1bHQuXG4gICAqL1xuICBhc3luYyBtdXRhdGlvbihcbiAgICBuYW1lOiBzdHJpbmcsXG4gICAgYXJncz86IFJlY29yZDxzdHJpbmcsIFZhbHVlPixcbiAgICBvcHRpb25zPzogTXV0YXRpb25PcHRpb25zLFxuICApOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMubXV0YXRpb25JbnRlcm5hbChuYW1lLCBhcmdzLCBvcHRpb25zKTtcbiAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICBpZiAocmVzdWx0LmVycm9yRGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IGZvcndhcmREYXRhKFxuICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICBuZXcgQ29udmV4RXJyb3IoXG4gICAgICAgICAgICBjcmVhdGVIeWJyaWRFcnJvclN0YWNrdHJhY2UoXCJtdXRhdGlvblwiLCBuYW1lLCByZXN1bHQpLFxuICAgICAgICAgICksXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoY3JlYXRlSHlicmlkRXJyb3JTdGFja3RyYWNlKFwibXV0YXRpb25cIiwgbmFtZSwgcmVzdWx0KSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhc3luYyBtdXRhdGlvbkludGVybmFsKFxuICAgIHVkZlBhdGg6IHN0cmluZyxcbiAgICBhcmdzPzogUmVjb3JkPHN0cmluZywgVmFsdWU+LFxuICAgIG9wdGlvbnM/OiBNdXRhdGlvbk9wdGlvbnMsXG4gICAgY29tcG9uZW50UGF0aD86IHN0cmluZyxcbiAgKTogUHJvbWlzZTxGdW5jdGlvblJlc3VsdD4ge1xuICAgIGNvbnN0IHsgbXV0YXRpb25Qcm9taXNlIH0gPSB0aGlzLmVucXVldWVNdXRhdGlvbihcbiAgICAgIHVkZlBhdGgsXG4gICAgICBhcmdzLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGNvbXBvbmVudFBhdGgsXG4gICAgKTtcbiAgICByZXR1cm4gbXV0YXRpb25Qcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZU11dGF0aW9uKFxuICAgIHVkZlBhdGg6IHN0cmluZyxcbiAgICBhcmdzPzogUmVjb3JkPHN0cmluZywgVmFsdWU+LFxuICAgIG9wdGlvbnM/OiBNdXRhdGlvbk9wdGlvbnMsXG4gICAgY29tcG9uZW50UGF0aD86IHN0cmluZyxcbiAgKTogeyByZXF1ZXN0SWQ6IFJlcXVlc3RJZDsgbXV0YXRpb25Qcm9taXNlOiBQcm9taXNlPEZ1bmN0aW9uUmVzdWx0PiB9IHtcbiAgICBjb25zdCBtdXRhdGlvbkFyZ3MgPSBwYXJzZUFyZ3MoYXJncyk7XG4gICAgdGhpcy50cnlSZXBvcnRMb25nRGlzY29ubmVjdCgpO1xuICAgIGNvbnN0IHJlcXVlc3RJZCA9IHRoaXMubmV4dFJlcXVlc3RJZDtcbiAgICB0aGlzLl9uZXh0UmVxdWVzdElkKys7XG5cbiAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBvcHRpbWlzdGljVXBkYXRlID0gb3B0aW9ucy5vcHRpbWlzdGljVXBkYXRlO1xuICAgICAgaWYgKG9wdGltaXN0aWNVcGRhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB3cmFwcGVkVXBkYXRlID0gKGxvY2FsUXVlcnlTdG9yZTogT3B0aW1pc3RpY0xvY2FsU3RvcmUpID0+IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQ6IHVua25vd24gPSBvcHRpbWlzdGljVXBkYXRlKFxuICAgICAgICAgICAgbG9jYWxRdWVyeVN0b3JlLFxuICAgICAgICAgICAgbXV0YXRpb25BcmdzLFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXG4gICAgICAgICAgICAgIFwiT3B0aW1pc3RpYyB1cGRhdGUgaGFuZGxlciByZXR1cm5lZCBhIFByb21pc2UuIE9wdGltaXN0aWMgdXBkYXRlcyBzaG91bGQgYmUgc3luY2hyb25vdXMuXCIsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBjaGFuZ2VkUXVlcnlUb2tlbnMgPVxuICAgICAgICAgIHRoaXMub3B0aW1pc3RpY1F1ZXJ5UmVzdWx0cy5hcHBseU9wdGltaXN0aWNVcGRhdGUoXG4gICAgICAgICAgICB3cmFwcGVkVXBkYXRlLFxuICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgY2hhbmdlZFF1ZXJpZXMgPSBjaGFuZ2VkUXVlcnlUb2tlbnMubWFwKCh0b2tlbikgPT4ge1xuICAgICAgICAgIGNvbnN0IGxvY2FsUmVzdWx0ID0gdGhpcy5sb2NhbFF1ZXJ5UmVzdWx0QnlUb2tlbih0b2tlbik7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRva2VuLFxuICAgICAgICAgICAgbW9kaWZpY2F0aW9uOiB7XG4gICAgICAgICAgICAgIGtpbmQ6IFwiVXBkYXRlZFwiIGFzIGNvbnN0LFxuICAgICAgICAgICAgICByZXN1bHQ6XG4gICAgICAgICAgICAgICAgbG9jYWxSZXN1bHQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUgYXMgY29uc3QsXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGxvY2FsUmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICAgIGxvZ0xpbmVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGFuZGxlVHJhbnNpdGlvbih7XG4gICAgICAgICAgcXVlcmllczogY2hhbmdlZFF1ZXJpZXMsXG4gICAgICAgICAgcmVmbGVjdGVkTXV0YXRpb25zOiBbXSxcbiAgICAgICAgICB0aW1lc3RhbXA6IHRoaXMucmVtb3RlUXVlcnlTZXQudGltZXN0YW1wKCksXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG1lc3NhZ2U6IE11dGF0aW9uUmVxdWVzdCA9IHtcbiAgICAgIHR5cGU6IFwiTXV0YXRpb25cIixcbiAgICAgIHJlcXVlc3RJZCxcbiAgICAgIHVkZlBhdGgsXG4gICAgICBjb21wb25lbnRQYXRoLFxuICAgICAgYXJnczogW2NvbnZleFRvSnNvbihtdXRhdGlvbkFyZ3MpXSxcbiAgICB9O1xuICAgIGNvbnN0IG1pZ2h0QmVTZW50ID0gdGhpcy53ZWJTb2NrZXRNYW5hZ2VyLnNlbmRNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIGNvbnN0IG11dGF0aW9uUHJvbWlzZSA9IHRoaXMucmVxdWVzdE1hbmFnZXIucmVxdWVzdChtZXNzYWdlLCBtaWdodEJlU2VudCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlcXVlc3RJZCxcbiAgICAgIG11dGF0aW9uUHJvbWlzZSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYW4gYWN0aW9uIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBhY3Rpb24uXG4gICAqIEBwYXJhbSBhcmdzIC0gQW4gYXJndW1lbnRzIG9iamVjdCBmb3IgdGhlIGFjdGlvbi4gSWYgdGhpcyBpcyBvbWl0dGVkLFxuICAgKiB0aGUgYXJndW1lbnRzIHdpbGwgYmUgYHt9YC5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIG9mIHRoZSBhY3Rpb24ncyByZXN1bHQuXG4gICAqL1xuICBhc3luYyBhY3Rpb24obmFtZTogc3RyaW5nLCBhcmdzPzogUmVjb3JkPHN0cmluZywgVmFsdWU+KTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmFjdGlvbkludGVybmFsKG5hbWUsIGFyZ3MpO1xuICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIGlmIChyZXN1bHQuZXJyb3JEYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgZm9yd2FyZERhdGEoXG4gICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgIG5ldyBDb252ZXhFcnJvcihjcmVhdGVIeWJyaWRFcnJvclN0YWNrdHJhY2UoXCJhY3Rpb25cIiwgbmFtZSwgcmVzdWx0KSksXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoY3JlYXRlSHlicmlkRXJyb3JTdGFja3RyYWNlKFwiYWN0aW9uXCIsIG5hbWUsIHJlc3VsdCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgYXN5bmMgYWN0aW9uSW50ZXJuYWwoXG4gICAgdWRmUGF0aDogc3RyaW5nLFxuICAgIGFyZ3M/OiBSZWNvcmQ8c3RyaW5nLCBWYWx1ZT4sXG4gICAgY29tcG9uZW50UGF0aD86IHN0cmluZyxcbiAgKTogUHJvbWlzZTxGdW5jdGlvblJlc3VsdD4ge1xuICAgIGNvbnN0IGFjdGlvbkFyZ3MgPSBwYXJzZUFyZ3MoYXJncyk7XG4gICAgY29uc3QgcmVxdWVzdElkID0gdGhpcy5uZXh0UmVxdWVzdElkO1xuICAgIHRoaXMuX25leHRSZXF1ZXN0SWQrKztcbiAgICB0aGlzLnRyeVJlcG9ydExvbmdEaXNjb25uZWN0KCk7XG5cbiAgICBjb25zdCBtZXNzYWdlOiBBY3Rpb25SZXF1ZXN0ID0ge1xuICAgICAgdHlwZTogXCJBY3Rpb25cIixcbiAgICAgIHJlcXVlc3RJZCxcbiAgICAgIHVkZlBhdGgsXG4gICAgICBjb21wb25lbnRQYXRoLFxuICAgICAgYXJnczogW2NvbnZleFRvSnNvbihhY3Rpb25BcmdzKV0sXG4gICAgfTtcblxuICAgIGNvbnN0IG1pZ2h0QmVTZW50ID0gdGhpcy53ZWJTb2NrZXRNYW5hZ2VyLnNlbmRNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3RNYW5hZ2VyLnJlcXVlc3QobWVzc2FnZSwgbWlnaHRCZVNlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlIGFueSBuZXR3b3JrIGhhbmRsZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY2xpZW50IGFuZCBzdG9wIGFsbCBzdWJzY3JpcHRpb25zLlxuICAgKlxuICAgKiBDYWxsIHRoaXMgbWV0aG9kIHdoZW4geW91J3JlIGRvbmUgd2l0aCBhbiB7QGxpbmsgQmFzZUNvbnZleENsaWVudH0gdG9cbiAgICogZGlzcG9zZSBvZiBpdHMgc29ja2V0cyBhbmQgcmVzb3VyY2VzLlxuICAgKlxuICAgKiBAcmV0dXJucyBBIGBQcm9taXNlYCBmdWxmaWxsZWQgd2hlbiB0aGUgY29ubmVjdGlvbiBoYXMgYmVlbiBjb21wbGV0ZWx5IGNsb3NlZC5cbiAgICovXG4gIGFzeW5jIGNsb3NlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMuYXV0aGVudGljYXRpb25NYW5hZ2VyLnN0b3AoKTtcbiAgICByZXR1cm4gdGhpcy53ZWJTb2NrZXRNYW5hZ2VyLnRlcm1pbmF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgYWRkcmVzcyBmb3IgdGhpcyBjbGllbnQsIHVzZWZ1bCBmb3IgY3JlYXRpbmcgYSBuZXcgY2xpZW50LlxuICAgKlxuICAgKiBOb3QgZ3VhcmFudGVlZCB0byBtYXRjaCB0aGUgYWRkcmVzcyB3aXRoIHdoaWNoIHRoaXMgY2xpZW50IHdhcyBjb25zdHJ1Y3RlZDpcbiAgICogaXQgbWF5IGJlIGNhbm9uaWNhbGl6ZWQuXG4gICAqL1xuICBnZXQgdXJsKCkge1xuICAgIHJldHVybiB0aGlzLmFkZHJlc3M7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXQgbmV4dFJlcXVlc3RJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbmV4dFJlcXVlc3RJZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldCBzZXNzaW9uSWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Nlc3Npb25JZDtcbiAgfVxuXG4gIC8vIEluc3RhbmNlIHByb3BlcnR5IHNvIHRoYXQgYG1hcmsoKWAgZG9lc24ndCBuZWVkIHRvIGJlIGNhbGxlZCBhcyBhIG1ldGhvZC5cbiAgcHJpdmF0ZSBtYXJrID0gKG5hbWU6IE1hcmtOYW1lKSA9PiB7XG4gICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgIG1hcmsobmFtZSwgdGhpcy5zZXNzaW9uSWQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVwb3J0cyBwZXJmb3JtYW5jZSBtYXJrcyB0byB0aGUgc2VydmVyLiBUaGlzIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuXG4gICAqIHdlIGhhdmUgYSBmdW5jdGlvbmFsIHdlYnNvY2tldC5cbiAgICovXG4gIHByaXZhdGUgcmVwb3J0TWFya3MoKSB7XG4gICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgIGNvbnN0IHJlcG9ydCA9IGdldE1hcmtzUmVwb3J0KHRoaXMuc2Vzc2lvbklkKTtcbiAgICAgIHRoaXMud2ViU29ja2V0TWFuYWdlci5zZW5kTWVzc2FnZSh7XG4gICAgICAgIHR5cGU6IFwiRXZlbnRcIixcbiAgICAgICAgZXZlbnRUeXBlOiBcIkNsaWVudENvbm5lY3RcIixcbiAgICAgICAgZXZlbnQ6IHJlcG9ydCxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdHJ5UmVwb3J0TG9uZ0Rpc2Nvbm5lY3QoKSB7XG4gICAgaWYgKCF0aGlzLmRlYnVnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRpbWVPZk9sZGVzdFJlcXVlc3QgPVxuICAgICAgdGhpcy5jb25uZWN0aW9uU3RhdGUoKS50aW1lT2ZPbGRlc3RJbmZsaWdodFJlcXVlc3Q7XG4gICAgaWYgKFxuICAgICAgdGltZU9mT2xkZXN0UmVxdWVzdCA9PT0gbnVsbCB8fFxuICAgICAgRGF0ZS5ub3coKSAtIHRpbWVPZk9sZGVzdFJlcXVlc3QuZ2V0VGltZSgpIDw9IDYwICogMTAwMFxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlbmRwb2ludCA9IGAke3RoaXMuYWRkcmVzc30vYXBpL2RlYnVnX2V2ZW50YDtcbiAgICBmZXRjaChlbmRwb2ludCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIFwiQ29udmV4LUNsaWVudFwiOiBgbnBtLSR7dmVyc2lvbn1gLFxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgZXZlbnQ6IFwiTG9uZ1dlYnNvY2tldERpc2Nvbm5lY3RcIiB9KSxcbiAgICB9KVxuICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFxuICAgICAgICAgICAgXCJBbmFseXRpY3MgcmVxdWVzdCBmYWlsZWQgd2l0aCByZXNwb25zZTpcIixcbiAgICAgICAgICAgIHJlc3BvbnNlLmJvZHksXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIkFuYWx5dGljcyByZXNwb25zZSBmYWlsZWQgd2l0aCBlcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgfSk7XG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcIjEuMzEuMlwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwiMS4zMS4yXCI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydCB7IGNvbnZleFRvSnNvbiwganNvblRvQ29udmV4IH0gZnJvbSBcIi4vdmFsdWUuanNcIjtcbmV4cG9ydCB7IHYsIGFzT2JqZWN0VmFsaWRhdG9yIH0gZnJvbSBcIi4vdmFsaWRhdG9yLmpzXCI7XG5pbXBvcnQgKiBhcyBCYXNlNjQgZnJvbSBcIi4vYmFzZTY0LmpzXCI7XG5leHBvcnQgeyBCYXNlNjQgfTtcbmV4cG9ydCAqIGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuZXhwb3J0IHsgY29tcGFyZVZhbHVlcyB9IGZyb20gXCIuL2NvbXBhcmUuanNcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiLyoqXG4gKiBVdGlsaXRpZXMgZm9yIHdvcmtpbmcgd2l0aCB2YWx1ZXMgc3RvcmVkIGluIENvbnZleC5cbiAqXG4gKiBZb3UgY2FuIHNlZSB0aGUgZnVsbCBzZXQgb2Ygc3VwcG9ydGVkIHR5cGVzIGF0XG4gKiBbVHlwZXNdKGh0dHBzOi8vZG9jcy5jb252ZXguZGV2L3VzaW5nL3R5cGVzKS5cbiAqIEBtb2R1bGVcbiAqL1xuXG5leHBvcnQgeyBjb252ZXhUb0pzb24sIGpzb25Ub0NvbnZleCB9IGZyb20gXCIuL3ZhbHVlLmpzXCI7XG5leHBvcnQgdHlwZSB7XG4gIElkIGFzIEdlbmVyaWNJZCxcbiAgSlNPTlZhbHVlLFxuICBWYWx1ZSxcbiAgTnVtZXJpY1ZhbHVlLFxufSBmcm9tIFwiLi92YWx1ZS5qc1wiO1xuZXhwb3J0IHsgdiwgYXNPYmplY3RWYWxpZGF0b3IgfSBmcm9tIFwiLi92YWxpZGF0b3IuanNcIjtcbmV4cG9ydCB0eXBlIHtcbiAgQXNPYmplY3RWYWxpZGF0b3IsXG4gIEdlbmVyaWNWYWxpZGF0b3IsXG4gIE9iamVjdFR5cGUsXG4gIFByb3BlcnR5VmFsaWRhdG9ycyxcbn0gZnJvbSBcIi4vdmFsaWRhdG9yLmpzXCI7XG5leHBvcnQgdHlwZSB7XG4gIFZhbGlkYXRvckpTT04sXG4gIFJlY29yZEtleVZhbGlkYXRvckpTT04sXG4gIFJlY29yZFZhbHVlVmFsaWRhdG9ySlNPTixcbiAgT2JqZWN0RmllbGRUeXBlLFxuICBWYWxpZGF0b3IsXG4gIE9wdGlvbmFsUHJvcGVydHksXG4gIFZJZCxcbiAgVkZsb2F0NjQsXG4gIFZJbnQ2NCxcbiAgVkJvb2xlYW4sXG4gIFZCeXRlcyxcbiAgVlN0cmluZyxcbiAgVk51bGwsXG4gIFZBbnksXG4gIFZPYmplY3QsXG4gIFZMaXRlcmFsLFxuICBWQXJyYXksXG4gIFZSZWNvcmQsXG4gIFZVbmlvbixcbiAgVk9wdGlvbmFsLFxufSBmcm9tIFwiLi92YWxpZGF0b3JzLmpzXCI7XG5pbXBvcnQgKiBhcyBCYXNlNjQgZnJvbSBcIi4vYmFzZTY0LmpzXCI7XG5leHBvcnQgeyBCYXNlNjQgfTtcbmV4cG9ydCB0eXBlIHsgSW5mZXIgfSBmcm9tIFwiLi92YWxpZGF0b3IuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuZXhwb3J0IHsgY29tcGFyZVZhbHVlcyB9IGZyb20gXCIuL2NvbXBhcmUuanNcIjtcbiIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0ICogYXMgQmFzZTY0IGZyb20gXCIuL2Jhc2U2NC5qc1wiO1xuaW1wb3J0IHsgaXNTaW1wbGVPYmplY3QgfSBmcm9tIFwiLi4vY29tbW9uL2luZGV4LmpzXCI7XG5jb25zdCBMSVRUTEVfRU5ESUFOID0gdHJ1ZTtcbmNvbnN0IE1JTl9JTlQ2NCA9IEJpZ0ludChcIi05MjIzMzcyMDM2ODU0Nzc1ODA4XCIpO1xuY29uc3QgTUFYX0lOVDY0ID0gQmlnSW50KFwiOTIyMzM3MjAzNjg1NDc3NTgwN1wiKTtcbmNvbnN0IFpFUk8gPSBCaWdJbnQoXCIwXCIpO1xuY29uc3QgRUlHSFQgPSBCaWdJbnQoXCI4XCIpO1xuY29uc3QgVFdPRklGVFlTSVggPSBCaWdJbnQoXCIyNTZcIik7XG5mdW5jdGlvbiBpc1NwZWNpYWwobikge1xuICByZXR1cm4gTnVtYmVyLmlzTmFOKG4pIHx8ICFOdW1iZXIuaXNGaW5pdGUobikgfHwgT2JqZWN0LmlzKG4sIC0wKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzbG93QmlnSW50VG9CYXNlNjQodmFsdWUpIHtcbiAgaWYgKHZhbHVlIDwgWkVSTykge1xuICAgIHZhbHVlIC09IE1JTl9JTlQ2NCArIE1JTl9JTlQ2NDtcbiAgfVxuICBsZXQgaGV4ID0gdmFsdWUudG9TdHJpbmcoMTYpO1xuICBpZiAoaGV4Lmxlbmd0aCAlIDIgPT09IDEpIGhleCA9IFwiMFwiICsgaGV4O1xuICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KG5ldyBBcnJheUJ1ZmZlcig4KSk7XG4gIGxldCBpID0gMDtcbiAgZm9yIChjb25zdCBoZXhCeXRlIG9mIGhleC5tYXRjaCgvLnsyfS9nKS5yZXZlcnNlKCkpIHtcbiAgICBieXRlcy5zZXQoW3BhcnNlSW50KGhleEJ5dGUsIDE2KV0sIGkrKyk7XG4gICAgdmFsdWUgPj49IEVJR0hUO1xuICB9XG4gIHJldHVybiBCYXNlNjQuZnJvbUJ5dGVBcnJheShieXRlcyk7XG59XG5leHBvcnQgZnVuY3Rpb24gc2xvd0Jhc2U2NFRvQmlnSW50KGVuY29kZWQpIHtcbiAgY29uc3QgaW50ZWdlckJ5dGVzID0gQmFzZTY0LnRvQnl0ZUFycmF5KGVuY29kZWQpO1xuICBpZiAoaW50ZWdlckJ5dGVzLmJ5dGVMZW5ndGggIT09IDgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgUmVjZWl2ZWQgJHtpbnRlZ2VyQnl0ZXMuYnl0ZUxlbmd0aH0gYnl0ZXMsIGV4cGVjdGVkIDggZm9yICRpbnRlZ2VyYFxuICAgICk7XG4gIH1cbiAgbGV0IHZhbHVlID0gWkVSTztcbiAgbGV0IHBvd2VyID0gWkVSTztcbiAgZm9yIChjb25zdCBieXRlIG9mIGludGVnZXJCeXRlcykge1xuICAgIHZhbHVlICs9IEJpZ0ludChieXRlKSAqIFRXT0ZJRlRZU0lYICoqIHBvd2VyO1xuICAgIHBvd2VyKys7XG4gIH1cbiAgaWYgKHZhbHVlID4gTUFYX0lOVDY0KSB7XG4gICAgdmFsdWUgKz0gTUlOX0lOVDY0ICsgTUlOX0lOVDY0O1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBtb2Rlcm5CaWdJbnRUb0Jhc2U2NCh2YWx1ZSkge1xuICBpZiAodmFsdWUgPCBNSU5fSU5UNjQgfHwgTUFYX0lOVDY0IDwgdmFsdWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQmlnSW50ICR7dmFsdWV9IGRvZXMgbm90IGZpdCBpbnRvIGEgNjQtYml0IHNpZ25lZCBpbnRlZ2VyLmBcbiAgICApO1xuICB9XG4gIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcig4KTtcbiAgbmV3IERhdGFWaWV3KGJ1ZmZlcikuc2V0QmlnSW50NjQoMCwgdmFsdWUsIHRydWUpO1xuICByZXR1cm4gQmFzZTY0LmZyb21CeXRlQXJyYXkobmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbW9kZXJuQmFzZTY0VG9CaWdJbnQoZW5jb2RlZCkge1xuICBjb25zdCBpbnRlZ2VyQnl0ZXMgPSBCYXNlNjQudG9CeXRlQXJyYXkoZW5jb2RlZCk7XG4gIGlmIChpbnRlZ2VyQnl0ZXMuYnl0ZUxlbmd0aCAhPT0gOCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBSZWNlaXZlZCAke2ludGVnZXJCeXRlcy5ieXRlTGVuZ3RofSBieXRlcywgZXhwZWN0ZWQgOCBmb3IgJGludGVnZXJgXG4gICAgKTtcbiAgfVxuICBjb25zdCBpbnRCeXRlc1ZpZXcgPSBuZXcgRGF0YVZpZXcoaW50ZWdlckJ5dGVzLmJ1ZmZlcik7XG4gIHJldHVybiBpbnRCeXRlc1ZpZXcuZ2V0QmlnSW50NjQoMCwgdHJ1ZSk7XG59XG5leHBvcnQgY29uc3QgYmlnSW50VG9CYXNlNjQgPSBEYXRhVmlldy5wcm90b3R5cGUuc2V0QmlnSW50NjQgPyBtb2Rlcm5CaWdJbnRUb0Jhc2U2NCA6IHNsb3dCaWdJbnRUb0Jhc2U2NDtcbmV4cG9ydCBjb25zdCBiYXNlNjRUb0JpZ0ludCA9IERhdGFWaWV3LnByb3RvdHlwZS5nZXRCaWdJbnQ2NCA/IG1vZGVybkJhc2U2NFRvQmlnSW50IDogc2xvd0Jhc2U2NFRvQmlnSW50O1xuY29uc3QgTUFYX0lERU5USUZJRVJfTEVOID0gMTAyNDtcbmZ1bmN0aW9uIHZhbGlkYXRlT2JqZWN0RmllbGQoaykge1xuICBpZiAoay5sZW5ndGggPiBNQVhfSURFTlRJRklFUl9MRU4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgRmllbGQgbmFtZSAke2t9IGV4Y2VlZHMgbWF4aW11bSBmaWVsZCBuYW1lIGxlbmd0aCAke01BWF9JREVOVElGSUVSX0xFTn0uYFxuICAgICk7XG4gIH1cbiAgaWYgKGsuc3RhcnRzV2l0aChcIiRcIikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZpZWxkIG5hbWUgJHtrfSBzdGFydHMgd2l0aCBhICckJywgd2hpY2ggaXMgcmVzZXJ2ZWQuYCk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3QgY2hhckNvZGUgPSBrLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNoYXJDb2RlIDwgMzIgfHwgY2hhckNvZGUgPj0gMTI3KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBGaWVsZCBuYW1lICR7a30gaGFzIGludmFsaWQgY2hhcmFjdGVyICcke2tbaV19JzogRmllbGQgbmFtZXMgY2FuIG9ubHkgY29udGFpbiBub24tY29udHJvbCBBU0NJSSBjaGFyYWN0ZXJzYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBqc29uVG9Db252ZXgodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUubWFwKCh2YWx1ZTIpID0+IGpzb25Ub0NvbnZleCh2YWx1ZTIpKTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHR5cGUgb2YgJHt2YWx1ZX1gKTtcbiAgfVxuICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXModmFsdWUpO1xuICBpZiAoZW50cmllcy5sZW5ndGggPT09IDEpIHtcbiAgICBjb25zdCBrZXkgPSBlbnRyaWVzWzBdWzBdO1xuICAgIGlmIChrZXkgPT09IFwiJGJ5dGVzXCIpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUuJGJ5dGVzICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTWFsZm9ybWVkICRieXRlcyBmaWVsZCBvbiAke3ZhbHVlfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEJhc2U2NC50b0J5dGVBcnJheSh2YWx1ZS4kYnl0ZXMpLmJ1ZmZlcjtcbiAgICB9XG4gICAgaWYgKGtleSA9PT0gXCIkaW50ZWdlclwiKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlLiRpbnRlZ2VyICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTWFsZm9ybWVkICRpbnRlZ2VyIGZpZWxkIG9uICR7dmFsdWV9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZTY0VG9CaWdJbnQodmFsdWUuJGludGVnZXIpO1xuICAgIH1cbiAgICBpZiAoa2V5ID09PSBcIiRmbG9hdFwiKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlLiRmbG9hdCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1hbGZvcm1lZCAkZmxvYXQgZmllbGQgb24gJHt2YWx1ZX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZsb2F0Qnl0ZXMgPSBCYXNlNjQudG9CeXRlQXJyYXkodmFsdWUuJGZsb2F0KTtcbiAgICAgIGlmIChmbG9hdEJ5dGVzLmJ5dGVMZW5ndGggIT09IDgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBSZWNlaXZlZCAke2Zsb2F0Qnl0ZXMuYnl0ZUxlbmd0aH0gYnl0ZXMsIGV4cGVjdGVkIDggZm9yICRmbG9hdGBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZsb2F0Qnl0ZXNWaWV3ID0gbmV3IERhdGFWaWV3KGZsb2F0Qnl0ZXMuYnVmZmVyKTtcbiAgICAgIGNvbnN0IGZsb2F0ID0gZmxvYXRCeXRlc1ZpZXcuZ2V0RmxvYXQ2NCgwLCBMSVRUTEVfRU5ESUFOKTtcbiAgICAgIGlmICghaXNTcGVjaWFsKGZsb2F0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZsb2F0ICR7ZmxvYXR9IHNob3VsZCBiZSBlbmNvZGVkIGFzIGEgbnVtYmVyYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmxvYXQ7XG4gICAgfVxuICAgIGlmIChrZXkgPT09IFwiJHNldFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBSZWNlaXZlZCBhIFNldCB3aGljaCBpcyBubyBsb25nZXIgc3VwcG9ydGVkIGFzIGEgQ29udmV4IHR5cGUuYFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGtleSA9PT0gXCIkbWFwXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFJlY2VpdmVkIGEgTWFwIHdoaWNoIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgYXMgYSBDb252ZXggdHlwZS5gXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBjb25zdCBvdXQgPSB7fTtcbiAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgdmFsaWRhdGVPYmplY3RGaWVsZChrKTtcbiAgICBvdXRba10gPSBqc29uVG9Db252ZXgodik7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbmNvbnN0IE1BWF9WQUxVRV9GT1JfRVJST1JfTEVOID0gMTYzODQ7XG5leHBvcnQgZnVuY3Rpb24gc3RyaW5naWZ5VmFsdWVGb3JFcnJvcih2YWx1ZSkge1xuICBjb25zdCBzdHIgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgKF9rZXksIHZhbHVlMikgPT4ge1xuICAgIGlmICh2YWx1ZTIgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIFwidW5kZWZpbmVkXCI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUyID09PSBcImJpZ2ludFwiKSB7XG4gICAgICByZXR1cm4gYCR7dmFsdWUyLnRvU3RyaW5nKCl9bmA7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTI7XG4gIH0pO1xuICBpZiAoc3RyLmxlbmd0aCA+IE1BWF9WQUxVRV9GT1JfRVJST1JfTEVOKSB7XG4gICAgY29uc3QgcmVzdCA9IFwiWy4uLnRydW5jYXRlZF1cIjtcbiAgICBsZXQgdHJ1bmNhdGVBdCA9IE1BWF9WQUxVRV9GT1JfRVJST1JfTEVOIC0gcmVzdC5sZW5ndGg7XG4gICAgY29uc3QgY29kZVBvaW50ID0gc3RyLmNvZGVQb2ludEF0KHRydW5jYXRlQXQgLSAxKTtcbiAgICBpZiAoY29kZVBvaW50ICE9PSB2b2lkIDAgJiYgY29kZVBvaW50ID4gNjU1MzUpIHtcbiAgICAgIHRydW5jYXRlQXQgLT0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoMCwgdHJ1bmNhdGVBdCkgKyByZXN0O1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBjb252ZXhUb0pzb25JbnRlcm5hbCh2YWx1ZSwgb3JpZ2luYWxWYWx1ZSwgY29udGV4dCwgaW5jbHVkZVRvcExldmVsVW5kZWZpbmVkKSB7XG4gIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgY29uc3QgY29udGV4dFRleHQgPSBjb250ZXh0ICYmIGAgKHByZXNlbnQgYXQgcGF0aCAke2NvbnRleHR9IGluIG9yaWdpbmFsIG9iamVjdCAke3N0cmluZ2lmeVZhbHVlRm9yRXJyb3IoXG4gICAgICBvcmlnaW5hbFZhbHVlXG4gICAgKX0pYDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgdW5kZWZpbmVkIGlzIG5vdCBhIHZhbGlkIENvbnZleCB2YWx1ZSR7Y29udGV4dFRleHR9LiBUbyBsZWFybiBhYm91dCBDb252ZXgncyBzdXBwb3J0ZWQgdHlwZXMsIHNlZSBodHRwczovL2RvY3MuY29udmV4LmRldi91c2luZy90eXBlcy5gXG4gICAgKTtcbiAgfVxuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIikge1xuICAgIGlmICh2YWx1ZSA8IE1JTl9JTlQ2NCB8fCBNQVhfSU5UNjQgPCB2YWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQmlnSW50ICR7dmFsdWV9IGRvZXMgbm90IGZpdCBpbnRvIGEgNjQtYml0IHNpZ25lZCBpbnRlZ2VyLmBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7ICRpbnRlZ2VyOiBiaWdJbnRUb0Jhc2U2NCh2YWx1ZSkgfTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgaWYgKGlzU3BlY2lhbCh2YWx1ZSkpIHtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcig4KTtcbiAgICAgIG5ldyBEYXRhVmlldyhidWZmZXIpLnNldEZsb2F0NjQoMCwgdmFsdWUsIExJVFRMRV9FTkRJQU4pO1xuICAgICAgcmV0dXJuIHsgJGZsb2F0OiBCYXNlNjQuZnJvbUJ5dGVBcnJheShuZXcgVWludDhBcnJheShidWZmZXIpKSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4geyAkYnl0ZXM6IEJhc2U2NC5mcm9tQnl0ZUFycmF5KG5ldyBVaW50OEFycmF5KHZhbHVlKSkgfTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUubWFwKFxuICAgICAgKHZhbHVlMiwgaSkgPT4gY29udmV4VG9Kc29uSW50ZXJuYWwodmFsdWUyLCBvcmlnaW5hbFZhbHVlLCBjb250ZXh0ICsgYFske2l9XWAsIGZhbHNlKVxuICAgICk7XG4gIH1cbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgZXJyb3JNZXNzYWdlRm9yVW5zdXBwb3J0ZWRUeXBlKGNvbnRleHQsIFwiU2V0XCIsIFsuLi52YWx1ZV0sIG9yaWdpbmFsVmFsdWUpXG4gICAgKTtcbiAgfVxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBlcnJvck1lc3NhZ2VGb3JVbnN1cHBvcnRlZFR5cGUoY29udGV4dCwgXCJNYXBcIiwgWy4uLnZhbHVlXSwgb3JpZ2luYWxWYWx1ZSlcbiAgICApO1xuICB9XG4gIGlmICghaXNTaW1wbGVPYmplY3QodmFsdWUpKSB7XG4gICAgY29uc3QgdGhlVHlwZSA9IHZhbHVlPy5jb25zdHJ1Y3Rvcj8ubmFtZTtcbiAgICBjb25zdCB0eXBlTmFtZSA9IHRoZVR5cGUgPyBgJHt0aGVUeXBlfSBgIDogXCJcIjtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBlcnJvck1lc3NhZ2VGb3JVbnN1cHBvcnRlZFR5cGUoY29udGV4dCwgdHlwZU5hbWUsIHZhbHVlLCBvcmlnaW5hbFZhbHVlKVxuICAgICk7XG4gIH1cbiAgY29uc3Qgb3V0ID0ge307XG4gIGNvbnN0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyh2YWx1ZSk7XG4gIGVudHJpZXMuc29ydCgoW2sxLCBfdjFdLCBbazIsIF92Ml0pID0+IGsxID09PSBrMiA/IDAgOiBrMSA8IGsyID8gLTEgOiAxKTtcbiAgZm9yIChjb25zdCBbaywgdl0gb2YgZW50cmllcykge1xuICAgIGlmICh2ICE9PSB2b2lkIDApIHtcbiAgICAgIHZhbGlkYXRlT2JqZWN0RmllbGQoayk7XG4gICAgICBvdXRba10gPSBjb252ZXhUb0pzb25JbnRlcm5hbCh2LCBvcmlnaW5hbFZhbHVlLCBjb250ZXh0ICsgYC4ke2t9YCwgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAoaW5jbHVkZVRvcExldmVsVW5kZWZpbmVkKSB7XG4gICAgICB2YWxpZGF0ZU9iamVjdEZpZWxkKGspO1xuICAgICAgb3V0W2tdID0gY29udmV4T3JVbmRlZmluZWRUb0pzb25JbnRlcm5hbChcbiAgICAgICAgdixcbiAgICAgICAgb3JpZ2luYWxWYWx1ZSxcbiAgICAgICAgY29udGV4dCArIGAuJHtrfWBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59XG5mdW5jdGlvbiBlcnJvck1lc3NhZ2VGb3JVbnN1cHBvcnRlZFR5cGUoY29udGV4dCwgdHlwZU5hbWUsIHZhbHVlLCBvcmlnaW5hbFZhbHVlKSB7XG4gIGlmIChjb250ZXh0KSB7XG4gICAgcmV0dXJuIGAke3R5cGVOYW1lfSR7c3RyaW5naWZ5VmFsdWVGb3JFcnJvcihcbiAgICAgIHZhbHVlXG4gICAgKX0gaXMgbm90IGEgc3VwcG9ydGVkIENvbnZleCB0eXBlIChwcmVzZW50IGF0IHBhdGggJHtjb250ZXh0fSBpbiBvcmlnaW5hbCBvYmplY3QgJHtzdHJpbmdpZnlWYWx1ZUZvckVycm9yKFxuICAgICAgb3JpZ2luYWxWYWx1ZVxuICAgICl9KS4gVG8gbGVhcm4gYWJvdXQgQ29udmV4J3Mgc3VwcG9ydGVkIHR5cGVzLCBzZWUgaHR0cHM6Ly9kb2NzLmNvbnZleC5kZXYvdXNpbmcvdHlwZXMuYDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYCR7dHlwZU5hbWV9JHtzdHJpbmdpZnlWYWx1ZUZvckVycm9yKFxuICAgICAgdmFsdWVcbiAgICApfSBpcyBub3QgYSBzdXBwb3J0ZWQgQ29udmV4IHR5cGUuYDtcbiAgfVxufVxuZnVuY3Rpb24gY29udmV4T3JVbmRlZmluZWRUb0pzb25JbnRlcm5hbCh2YWx1ZSwgb3JpZ2luYWxWYWx1ZSwgY29udGV4dCkge1xuICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiB7ICR1bmRlZmluZWQ6IG51bGwgfTtcbiAgfSBlbHNlIHtcbiAgICBpZiAob3JpZ2luYWxWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBQcm9ncmFtbWluZyBlcnJvci4gQ3VycmVudCB2YWx1ZSBpcyAke3N0cmluZ2lmeVZhbHVlRm9yRXJyb3IoXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgKX0gYnV0IG9yaWdpbmFsIHZhbHVlIGlzIHVuZGVmaW5lZGBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBjb252ZXhUb0pzb25JbnRlcm5hbCh2YWx1ZSwgb3JpZ2luYWxWYWx1ZSwgY29udGV4dCwgZmFsc2UpO1xuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gY29udmV4VG9Kc29uKHZhbHVlKSB7XG4gIHJldHVybiBjb252ZXhUb0pzb25JbnRlcm5hbCh2YWx1ZSwgdmFsdWUsIFwiXCIsIGZhbHNlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXhPclVuZGVmaW5lZFRvSnNvbih2YWx1ZSkge1xuICByZXR1cm4gY29udmV4T3JVbmRlZmluZWRUb0pzb25JbnRlcm5hbCh2YWx1ZSwgdmFsdWUsIFwiXCIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhdGNoVmFsdWVUb0pzb24odmFsdWUpIHtcbiAgcmV0dXJuIGNvbnZleFRvSnNvbkludGVybmFsKHZhbHVlLCB2YWx1ZSwgXCJcIiwgdHJ1ZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWx1ZS5qcy5tYXBcbiIsIi8qKlxuICogVXRpbGl0aWVzIGZvciB3b3JraW5nIHdpdGggdmFsdWVzIHN0b3JlZCBpbiBDb252ZXguXG4gKlxuICogWW91IGNhbiBzZWUgdGhlIGZ1bGwgc2V0IG9mIHN1cHBvcnRlZCB0eXBlcyBhdFxuICogW1R5cGVzXShodHRwczovL2RvY3MuY29udmV4LmRldi91c2luZy90eXBlcykuXG4gKiBAbW9kdWxlXG4gKi9cbmltcG9ydCAqIGFzIEJhc2U2NCBmcm9tIFwiLi9iYXNlNjQuanNcIjtcbmltcG9ydCB7IGlzU2ltcGxlT2JqZWN0IH0gZnJvbSBcIi4uL2NvbW1vbi9pbmRleC5qc1wiO1xuXG5jb25zdCBMSVRUTEVfRU5ESUFOID0gdHJ1ZTtcbi8vIFRoaXMgY29kZSBpcyB1c2VkIGJ5IGNvZGUgdGhhdCBtYXkgbm90IGhhdmUgYmlnaW50IGxpdGVyYWxzLlxuY29uc3QgTUlOX0lOVDY0ID0gQmlnSW50KFwiLTkyMjMzNzIwMzY4NTQ3NzU4MDhcIik7XG5jb25zdCBNQVhfSU5UNjQgPSBCaWdJbnQoXCI5MjIzMzcyMDM2ODU0Nzc1ODA3XCIpO1xuY29uc3QgWkVSTyA9IEJpZ0ludChcIjBcIik7XG5jb25zdCBFSUdIVCA9IEJpZ0ludChcIjhcIik7XG5jb25zdCBUV09GSUZUWVNJWCA9IEJpZ0ludChcIjI1NlwiKTtcblxuLyoqXG4gKiBUaGUgdHlwZSBvZiBKYXZhU2NyaXB0IHZhbHVlcyBzZXJpYWxpemFibGUgdG8gSlNPTi5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCB0eXBlIEpTT05WYWx1ZSA9XG4gIHwgbnVsbFxuICB8IGJvb2xlYW5cbiAgfCBudW1iZXJcbiAgfCBzdHJpbmdcbiAgfCBKU09OVmFsdWVbXVxuICB8IHsgW2tleTogc3RyaW5nXTogSlNPTlZhbHVlIH07XG5cbi8qKlxuICogQW4gaWRlbnRpZmllciBmb3IgYSBkb2N1bWVudCBpbiBDb252ZXguXG4gKlxuICogQ29udmV4IGRvY3VtZW50cyBhcmUgdW5pcXVlbHkgaWRlbnRpZmllZCBieSB0aGVpciBgSWRgLCB3aGljaCBpcyBhY2Nlc3NpYmxlXG4gKiBvbiB0aGUgYF9pZGAgZmllbGQuIFRvIGxlYXJuIG1vcmUsIHNlZSBbRG9jdW1lbnQgSURzXShodHRwczovL2RvY3MuY29udmV4LmRldi9kYXRhYmFzZS9kb2N1bWVudC1pZHMpLlxuICpcbiAqIERvY3VtZW50cyBjYW4gYmUgbG9hZGVkIHVzaW5nIGBkYi5nZXQodGFibGVOYW1lLCBpZClgIGluIHF1ZXJ5IGFuZCBtdXRhdGlvbiBmdW5jdGlvbnMuXG4gKlxuICogSURzIGFyZSBiYXNlIDMyIGVuY29kZWQgc3RyaW5ncyB3aGljaCBhcmUgVVJMIHNhZmUuXG4gKlxuICogSURzIGFyZSBqdXN0IHN0cmluZ3MgYXQgcnVudGltZSwgYnV0IHRoaXMgdHlwZSBjYW4gYmUgdXNlZCB0byBkaXN0aW5ndWlzaCB0aGVtIGZyb20gb3RoZXJcbiAqIHN0cmluZ3MgYXQgY29tcGlsZSB0aW1lLlxuICpcbiAqIElmIHlvdSdyZSB1c2luZyBjb2RlIGdlbmVyYXRpb24sIHVzZSB0aGUgYElkYCB0eXBlIGdlbmVyYXRlZCBmb3IgeW91ciBkYXRhIG1vZGVsIGluXG4gKiBgY29udmV4L19nZW5lcmF0ZWQvZGF0YU1vZGVsLmQudHNgLlxuICpcbiAqIEB0eXBlUGFyYW0gVGFibGVOYW1lIC0gQSBzdHJpbmcgbGl0ZXJhbCB0eXBlIG9mIHRoZSB0YWJsZSBuYW1lIChsaWtlIFwidXNlcnNcIikuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgdHlwZSBJZDxUYWJsZU5hbWUgZXh0ZW5kcyBzdHJpbmc+ID0gc3RyaW5nICYgeyBfX3RhYmxlTmFtZTogVGFibGVOYW1lIH07XG5cbi8qKlxuICogQSB2YWx1ZSBzdXBwb3J0ZWQgYnkgQ29udmV4LlxuICpcbiAqIFZhbHVlcyBjYW4gYmU6XG4gKiAtIHN0b3JlZCBpbnNpZGUgb2YgZG9jdW1lbnRzLlxuICogLSB1c2VkIGFzIGFyZ3VtZW50cyBhbmQgcmV0dXJuIHR5cGVzIHRvIHF1ZXJpZXMgYW5kIG11dGF0aW9uIGZ1bmN0aW9ucy5cbiAqXG4gKiBZb3UgY2FuIHNlZSB0aGUgZnVsbCBzZXQgb2Ygc3VwcG9ydGVkIHR5cGVzIGF0XG4gKiBbVHlwZXNdKGh0dHBzOi8vZG9jcy5jb252ZXguZGV2L3VzaW5nL3R5cGVzKS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCB0eXBlIFZhbHVlID1cbiAgfCBudWxsXG4gIHwgYmlnaW50XG4gIHwgbnVtYmVyXG4gIHwgYm9vbGVhblxuICB8IHN0cmluZ1xuICB8IEFycmF5QnVmZmVyXG4gIHwgVmFsdWVbXVxuICB8IHsgW2tleTogc3RyaW5nXTogdW5kZWZpbmVkIHwgVmFsdWUgfTtcblxuLyoqXG4gKiBUaGUgdHlwZXMgb2Yge0BsaW5rIFZhbHVlfSB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlcHJlc2VudCBudW1iZXJzLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IHR5cGUgTnVtZXJpY1ZhbHVlID0gYmlnaW50IHwgbnVtYmVyO1xuXG5mdW5jdGlvbiBpc1NwZWNpYWwobjogbnVtYmVyKSB7XG4gIHJldHVybiBOdW1iZXIuaXNOYU4obikgfHwgIU51bWJlci5pc0Zpbml0ZShuKSB8fCBPYmplY3QuaXMobiwgLTApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2xvd0JpZ0ludFRvQmFzZTY0KHZhbHVlOiBiaWdpbnQpOiBzdHJpbmcge1xuICAvLyB0aGUgY29udmVyc2lvbiBpcyBlYXN5IGlmIHdlIHByZXRlbmQgaXQncyB1bnNpZ25lZFxuICBpZiAodmFsdWUgPCBaRVJPKSB7XG4gICAgdmFsdWUgLT0gTUlOX0lOVDY0ICsgTUlOX0lOVDY0O1xuICB9XG4gIGxldCBoZXggPSB2YWx1ZS50b1N0cmluZygxNik7XG4gIGlmIChoZXgubGVuZ3RoICUgMiA9PT0gMSkgaGV4ID0gXCIwXCIgKyBoZXg7XG5cbiAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShuZXcgQXJyYXlCdWZmZXIoOCkpO1xuICBsZXQgaSA9IDA7XG4gIGZvciAoY29uc3QgaGV4Qnl0ZSBvZiBoZXgubWF0Y2goLy57Mn0vZykhLnJldmVyc2UoKSkge1xuICAgIGJ5dGVzLnNldChbcGFyc2VJbnQoaGV4Qnl0ZSwgMTYpXSwgaSsrKTtcbiAgICB2YWx1ZSA+Pj0gRUlHSFQ7XG4gIH1cbiAgcmV0dXJuIEJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ5dGVzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNsb3dCYXNlNjRUb0JpZ0ludChlbmNvZGVkOiBzdHJpbmcpOiBiaWdpbnQge1xuICBjb25zdCBpbnRlZ2VyQnl0ZXMgPSBCYXNlNjQudG9CeXRlQXJyYXkoZW5jb2RlZCk7XG4gIGlmIChpbnRlZ2VyQnl0ZXMuYnl0ZUxlbmd0aCAhPT0gOCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBSZWNlaXZlZCAke2ludGVnZXJCeXRlcy5ieXRlTGVuZ3RofSBieXRlcywgZXhwZWN0ZWQgOCBmb3IgJGludGVnZXJgLFxuICAgICk7XG4gIH1cbiAgbGV0IHZhbHVlID0gWkVSTztcbiAgbGV0IHBvd2VyID0gWkVSTztcbiAgZm9yIChjb25zdCBieXRlIG9mIGludGVnZXJCeXRlcykge1xuICAgIHZhbHVlICs9IEJpZ0ludChieXRlKSAqIFRXT0ZJRlRZU0lYICoqIHBvd2VyO1xuICAgIHBvd2VyKys7XG4gIH1cbiAgaWYgKHZhbHVlID4gTUFYX0lOVDY0KSB7XG4gICAgdmFsdWUgKz0gTUlOX0lOVDY0ICsgTUlOX0lOVDY0O1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1vZGVybkJpZ0ludFRvQmFzZTY0KHZhbHVlOiBiaWdpbnQpOiBzdHJpbmcge1xuICBpZiAodmFsdWUgPCBNSU5fSU5UNjQgfHwgTUFYX0lOVDY0IDwgdmFsdWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQmlnSW50ICR7dmFsdWV9IGRvZXMgbm90IGZpdCBpbnRvIGEgNjQtYml0IHNpZ25lZCBpbnRlZ2VyLmAsXG4gICAgKTtcbiAgfVxuICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoOCk7XG4gIG5ldyBEYXRhVmlldyhidWZmZXIpLnNldEJpZ0ludDY0KDAsIHZhbHVlLCB0cnVlKTtcbiAgcmV0dXJuIEJhc2U2NC5mcm9tQnl0ZUFycmF5KG5ldyBVaW50OEFycmF5KGJ1ZmZlcikpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbW9kZXJuQmFzZTY0VG9CaWdJbnQoZW5jb2RlZDogc3RyaW5nKTogYmlnaW50IHtcbiAgY29uc3QgaW50ZWdlckJ5dGVzID0gQmFzZTY0LnRvQnl0ZUFycmF5KGVuY29kZWQpO1xuICBpZiAoaW50ZWdlckJ5dGVzLmJ5dGVMZW5ndGggIT09IDgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgUmVjZWl2ZWQgJHtpbnRlZ2VyQnl0ZXMuYnl0ZUxlbmd0aH0gYnl0ZXMsIGV4cGVjdGVkIDggZm9yICRpbnRlZ2VyYCxcbiAgICApO1xuICB9XG4gIGNvbnN0IGludEJ5dGVzVmlldyA9IG5ldyBEYXRhVmlldyhpbnRlZ2VyQnl0ZXMuYnVmZmVyKTtcbiAgcmV0dXJuIGludEJ5dGVzVmlldy5nZXRCaWdJbnQ2NCgwLCB0cnVlKTtcbn1cblxuLy8gRmFsbCBiYWNrIHRvIGEgc2xvd2VyIHZlcnNpb24gb24gU2FmYXJpIDE0IHdoaWNoIGxhY2tzIHRoZXNlIEFQSXMuXG5leHBvcnQgY29uc3QgYmlnSW50VG9CYXNlNjQgPSAoRGF0YVZpZXcucHJvdG90eXBlIGFzIGFueSkuc2V0QmlnSW50NjRcbiAgPyBtb2Rlcm5CaWdJbnRUb0Jhc2U2NFxuICA6IHNsb3dCaWdJbnRUb0Jhc2U2NDtcbmV4cG9ydCBjb25zdCBiYXNlNjRUb0JpZ0ludCA9IChEYXRhVmlldy5wcm90b3R5cGUgYXMgYW55KS5nZXRCaWdJbnQ2NFxuICA/IG1vZGVybkJhc2U2NFRvQmlnSW50XG4gIDogc2xvd0Jhc2U2NFRvQmlnSW50O1xuXG5jb25zdCBNQVhfSURFTlRJRklFUl9MRU4gPSAxMDI0O1xuXG5mdW5jdGlvbiB2YWxpZGF0ZU9iamVjdEZpZWxkKGs6IHN0cmluZykge1xuICBpZiAoay5sZW5ndGggPiBNQVhfSURFTlRJRklFUl9MRU4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgRmllbGQgbmFtZSAke2t9IGV4Y2VlZHMgbWF4aW11bSBmaWVsZCBuYW1lIGxlbmd0aCAke01BWF9JREVOVElGSUVSX0xFTn0uYCxcbiAgICApO1xuICB9XG4gIGlmIChrLnN0YXJ0c1dpdGgoXCIkXCIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGaWVsZCBuYW1lICR7a30gc3RhcnRzIHdpdGggYSAnJCcsIHdoaWNoIGlzIHJlc2VydmVkLmApO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgay5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IGNoYXJDb2RlID0gay5jaGFyQ29kZUF0KGkpO1xuICAgIC8vIE5vbi1jb250cm9sIEFTQ0lJIGNoYXJhY3RlcnNcbiAgICBpZiAoY2hhckNvZGUgPCAzMiB8fCBjaGFyQ29kZSA+PSAxMjcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEZpZWxkIG5hbWUgJHtrfSBoYXMgaW52YWxpZCBjaGFyYWN0ZXIgJyR7a1tpXX0nOiBGaWVsZCBuYW1lcyBjYW4gb25seSBjb250YWluIG5vbi1jb250cm9sIEFTQ0lJIGNoYXJhY3RlcnNgLFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhIENvbnZleCB2YWx1ZSBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBkZXNlcmlhbGl6ZSBzZXJpYWxpemVkIEludDY0cyB0byBgQmlnSW50YHMsIEJ5dGVzIHRvIGBBcnJheUJ1ZmZlcmBzIGV0Yy5cbiAqXG4gKiBUbyBsZWFybiBtb3JlIGFib3V0IENvbnZleCB2YWx1ZXMsIHNlZSBbVHlwZXNdKGh0dHBzOi8vZG9jcy5jb252ZXguZGV2L3VzaW5nL3R5cGVzKS5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhIENvbnZleCB2YWx1ZSBwcmV2aW91c2x5IGNyZWF0ZWQgd2l0aCB7QGxpbmsgY29udmV4VG9Kc29ufS5cbiAqIEByZXR1cm5zIFRoZSBKYXZhU2NyaXB0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBDb252ZXggdmFsdWUuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24ganNvblRvQ29udmV4KHZhbHVlOiBKU09OVmFsdWUpOiBWYWx1ZSB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLm1hcCgodmFsdWUpID0+IGpzb25Ub0NvbnZleCh2YWx1ZSkpO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgdHlwZSBvZiAke3ZhbHVlIGFzIGFueX1gKTtcbiAgfVxuICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXModmFsdWUpO1xuICBpZiAoZW50cmllcy5sZW5ndGggPT09IDEpIHtcbiAgICBjb25zdCBrZXkgPSBlbnRyaWVzWzBdWzBdO1xuICAgIGlmIChrZXkgPT09IFwiJGJ5dGVzXCIpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUuJGJ5dGVzICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTWFsZm9ybWVkICRieXRlcyBmaWVsZCBvbiAke3ZhbHVlIGFzIGFueX1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBCYXNlNjQudG9CeXRlQXJyYXkodmFsdWUuJGJ5dGVzKS5idWZmZXI7XG4gICAgfVxuICAgIGlmIChrZXkgPT09IFwiJGludGVnZXJcIikge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZS4kaW50ZWdlciAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1hbGZvcm1lZCAkaW50ZWdlciBmaWVsZCBvbiAke3ZhbHVlIGFzIGFueX1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlNjRUb0JpZ0ludCh2YWx1ZS4kaW50ZWdlcik7XG4gICAgfVxuICAgIGlmIChrZXkgPT09IFwiJGZsb2F0XCIpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUuJGZsb2F0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTWFsZm9ybWVkICRmbG9hdCBmaWVsZCBvbiAke3ZhbHVlIGFzIGFueX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZsb2F0Qnl0ZXMgPSBCYXNlNjQudG9CeXRlQXJyYXkodmFsdWUuJGZsb2F0KTtcbiAgICAgIGlmIChmbG9hdEJ5dGVzLmJ5dGVMZW5ndGggIT09IDgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBSZWNlaXZlZCAke2Zsb2F0Qnl0ZXMuYnl0ZUxlbmd0aH0gYnl0ZXMsIGV4cGVjdGVkIDggZm9yICRmbG9hdGAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCBmbG9hdEJ5dGVzVmlldyA9IG5ldyBEYXRhVmlldyhmbG9hdEJ5dGVzLmJ1ZmZlcik7XG4gICAgICBjb25zdCBmbG9hdCA9IGZsb2F0Qnl0ZXNWaWV3LmdldEZsb2F0NjQoMCwgTElUVExFX0VORElBTik7XG4gICAgICBpZiAoIWlzU3BlY2lhbChmbG9hdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGbG9hdCAke2Zsb2F0fSBzaG91bGQgYmUgZW5jb2RlZCBhcyBhIG51bWJlcmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZsb2F0O1xuICAgIH1cbiAgICBpZiAoa2V5ID09PSBcIiRzZXRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgUmVjZWl2ZWQgYSBTZXQgd2hpY2ggaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCBhcyBhIENvbnZleCB0eXBlLmAsXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoa2V5ID09PSBcIiRtYXBcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgUmVjZWl2ZWQgYSBNYXAgd2hpY2ggaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCBhcyBhIENvbnZleCB0eXBlLmAsXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBjb25zdCBvdXQ6IHsgW2tleTogc3RyaW5nXTogVmFsdWUgfSA9IHt9O1xuICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSkpIHtcbiAgICB2YWxpZGF0ZU9iamVjdEZpZWxkKGspO1xuICAgIG91dFtrXSA9IGpzb25Ub0NvbnZleCh2KTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG5jb25zdCBNQVhfVkFMVUVfRk9SX0VSUk9SX0xFTiA9IDE2Mzg0O1xuXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5naWZ5VmFsdWVGb3JFcnJvcih2YWx1ZTogYW55KSB7XG4gIGNvbnN0IHN0ciA9IEpTT04uc3RyaW5naWZ5KHZhbHVlLCAoX2tleSwgdmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQnkgZGVmYXVsdCBgSlNPTi5zdHJpbmdpZnlgIGNvbnZlcnRzIHVuZGVmaW5lZCwgZnVuY3Rpb25zLCBzeW1ib2xzLFxuICAgICAgLy8gSW5maW5pdHksIGFuZCBOYU4gdG8gbnVsbCB3aGljaCBwcm9kdWNlcyBhIGNvbmZ1c2luZyBlcnJvciBtZXNzYWdlLlxuICAgICAgLy8gV2UgZGVhbCB3aXRoIGB1bmRlZmluZWRgIHNwZWNpZmljYWxseSBiZWNhdXNlIGl0J3MgdGhlIG1vc3QgY29tbW9uLlxuICAgICAgLy8gSWRlYWxseSB3ZSdkIHVzZSBhIHByZXR0eS1wcmludGluZyBsaWJyYXJ5IHRoYXQgcHJpbnRzIGB1bmRlZmluZWRgXG4gICAgICAvLyAobm8gcXVvdGVzKSwgYnV0IGl0IG1pZ2h0IG5vdCBiZSB3b3J0aCB0aGUgYnVuZGxlIHNpemUgY29zdC5cbiAgICAgIHJldHVybiBcInVuZGVmaW5lZFwiO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAvLyBgSlNPTi5zdHJpbmdpZnlgIHRocm93cyBvbiBiaWdpbnRzIGJ5IGRlZmF1bHQuXG4gICAgICByZXR1cm4gYCR7dmFsdWUudG9TdHJpbmcoKX1uYDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9KTtcbiAgaWYgKHN0ci5sZW5ndGggPiBNQVhfVkFMVUVfRk9SX0VSUk9SX0xFTikge1xuICAgIGNvbnN0IHJlc3QgPSBcIlsuLi50cnVuY2F0ZWRdXCI7XG4gICAgbGV0IHRydW5jYXRlQXQgPSBNQVhfVkFMVUVfRk9SX0VSUk9SX0xFTiAtIHJlc3QubGVuZ3RoO1xuICAgIGNvbnN0IGNvZGVQb2ludCA9IHN0ci5jb2RlUG9pbnRBdCh0cnVuY2F0ZUF0IC0gMSk7XG4gICAgaWYgKGNvZGVQb2ludCAhPT0gdW5kZWZpbmVkICYmIGNvZGVQb2ludCA+IDB4ZmZmZikge1xuICAgICAgLy8gZG9uJ3Qgc3BsaXQgYSBzdXJyb2dhdGUgcGFpciBpbiBoYWxmXG4gICAgICB0cnVuY2F0ZUF0IC09IDE7XG4gICAgfVxuICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKDAsIHRydW5jYXRlQXQpICsgcmVzdDtcbiAgfVxuICByZXR1cm4gc3RyO1xufVxuXG5mdW5jdGlvbiBjb252ZXhUb0pzb25JbnRlcm5hbChcbiAgdmFsdWU6IFZhbHVlLFxuICBvcmlnaW5hbFZhbHVlOiBWYWx1ZSxcbiAgY29udGV4dDogc3RyaW5nLFxuICBpbmNsdWRlVG9wTGV2ZWxVbmRlZmluZWQ6IGJvb2xlYW4sXG4pOiBKU09OVmFsdWUge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IGNvbnRleHRUZXh0ID1cbiAgICAgIGNvbnRleHQgJiZcbiAgICAgIGAgKHByZXNlbnQgYXQgcGF0aCAke2NvbnRleHR9IGluIG9yaWdpbmFsIG9iamVjdCAke3N0cmluZ2lmeVZhbHVlRm9yRXJyb3IoXG4gICAgICAgIG9yaWdpbmFsVmFsdWUsXG4gICAgICApfSlgO1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGB1bmRlZmluZWQgaXMgbm90IGEgdmFsaWQgQ29udmV4IHZhbHVlJHtjb250ZXh0VGV4dH0uIFRvIGxlYXJuIGFib3V0IENvbnZleCdzIHN1cHBvcnRlZCB0eXBlcywgc2VlIGh0dHBzOi8vZG9jcy5jb252ZXguZGV2L3VzaW5nL3R5cGVzLmAsXG4gICAgKTtcbiAgfVxuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIikge1xuICAgIGlmICh2YWx1ZSA8IE1JTl9JTlQ2NCB8fCBNQVhfSU5UNjQgPCB2YWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQmlnSW50ICR7dmFsdWV9IGRvZXMgbm90IGZpdCBpbnRvIGEgNjQtYml0IHNpZ25lZCBpbnRlZ2VyLmAsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4geyAkaW50ZWdlcjogYmlnSW50VG9CYXNlNjQodmFsdWUpIH07XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgIGlmIChpc1NwZWNpYWwodmFsdWUpKSB7XG4gICAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoOCk7XG4gICAgICBuZXcgRGF0YVZpZXcoYnVmZmVyKS5zZXRGbG9hdDY0KDAsIHZhbHVlLCBMSVRUTEVfRU5ESUFOKTtcbiAgICAgIHJldHVybiB7ICRmbG9hdDogQmFzZTY0LmZyb21CeXRlQXJyYXkobmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSkgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIHsgJGJ5dGVzOiBCYXNlNjQuZnJvbUJ5dGVBcnJheShuZXcgVWludDhBcnJheSh2YWx1ZSkpIH07XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLm1hcCgodmFsdWUsIGkpID0+XG4gICAgICBjb252ZXhUb0pzb25JbnRlcm5hbCh2YWx1ZSwgb3JpZ2luYWxWYWx1ZSwgY29udGV4dCArIGBbJHtpfV1gLCBmYWxzZSksXG4gICAgKTtcbiAgfVxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBlcnJvck1lc3NhZ2VGb3JVbnN1cHBvcnRlZFR5cGUoY29udGV4dCwgXCJTZXRcIiwgWy4uLnZhbHVlXSwgb3JpZ2luYWxWYWx1ZSksXG4gICAgKTtcbiAgfVxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBlcnJvck1lc3NhZ2VGb3JVbnN1cHBvcnRlZFR5cGUoY29udGV4dCwgXCJNYXBcIiwgWy4uLnZhbHVlXSwgb3JpZ2luYWxWYWx1ZSksXG4gICAgKTtcbiAgfVxuXG4gIGlmICghaXNTaW1wbGVPYmplY3QodmFsdWUpKSB7XG4gICAgY29uc3QgdGhlVHlwZSA9IHZhbHVlPy5jb25zdHJ1Y3Rvcj8ubmFtZTtcbiAgICBjb25zdCB0eXBlTmFtZSA9IHRoZVR5cGUgPyBgJHt0aGVUeXBlfSBgIDogXCJcIjtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBlcnJvck1lc3NhZ2VGb3JVbnN1cHBvcnRlZFR5cGUoY29udGV4dCwgdHlwZU5hbWUsIHZhbHVlLCBvcmlnaW5hbFZhbHVlKSxcbiAgICApO1xuICB9XG5cbiAgY29uc3Qgb3V0OiB7IFtrZXk6IHN0cmluZ106IEpTT05WYWx1ZSB9ID0ge307XG4gIGNvbnN0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyh2YWx1ZSk7XG4gIGVudHJpZXMuc29ydCgoW2sxLCBfdjFdLCBbazIsIF92Ml0pID0+IChrMSA9PT0gazIgPyAwIDogazEgPCBrMiA/IC0xIDogMSkpO1xuICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBlbnRyaWVzKSB7XG4gICAgaWYgKHYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFsaWRhdGVPYmplY3RGaWVsZChrKTtcbiAgICAgIG91dFtrXSA9IGNvbnZleFRvSnNvbkludGVybmFsKHYsIG9yaWdpbmFsVmFsdWUsIGNvbnRleHQgKyBgLiR7a31gLCBmYWxzZSk7XG4gICAgfSBlbHNlIGlmIChpbmNsdWRlVG9wTGV2ZWxVbmRlZmluZWQpIHtcbiAgICAgIHZhbGlkYXRlT2JqZWN0RmllbGQoayk7XG4gICAgICBvdXRba10gPSBjb252ZXhPclVuZGVmaW5lZFRvSnNvbkludGVybmFsKFxuICAgICAgICB2LFxuICAgICAgICBvcmlnaW5hbFZhbHVlLFxuICAgICAgICBjb250ZXh0ICsgYC4ke2t9YCxcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIGVycm9yTWVzc2FnZUZvclVuc3VwcG9ydGVkVHlwZShcbiAgY29udGV4dDogc3RyaW5nLFxuICB0eXBlTmFtZTogc3RyaW5nLFxuICB2YWx1ZTogYW55LFxuICBvcmlnaW5hbFZhbHVlOiBhbnksXG4pIHtcbiAgaWYgKGNvbnRleHQpIHtcbiAgICByZXR1cm4gYCR7dHlwZU5hbWV9JHtzdHJpbmdpZnlWYWx1ZUZvckVycm9yKFxuICAgICAgdmFsdWUsXG4gICAgKX0gaXMgbm90IGEgc3VwcG9ydGVkIENvbnZleCB0eXBlIChwcmVzZW50IGF0IHBhdGggJHtjb250ZXh0fSBpbiBvcmlnaW5hbCBvYmplY3QgJHtzdHJpbmdpZnlWYWx1ZUZvckVycm9yKFxuICAgICAgb3JpZ2luYWxWYWx1ZSxcbiAgICApfSkuIFRvIGxlYXJuIGFib3V0IENvbnZleCdzIHN1cHBvcnRlZCB0eXBlcywgc2VlIGh0dHBzOi8vZG9jcy5jb252ZXguZGV2L3VzaW5nL3R5cGVzLmA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGAke3R5cGVOYW1lfSR7c3RyaW5naWZ5VmFsdWVGb3JFcnJvcihcbiAgICAgIHZhbHVlLFxuICAgICl9IGlzIG5vdCBhIHN1cHBvcnRlZCBDb252ZXggdHlwZS5gO1xuICB9XG59XG5cbi8vIGNvbnZleE9yVW5kZWZpbmVkVG9Kc29uSW50ZXJuYWwgd3JhcHBlciBleGlzdHMgc28gd2UgY2FuIHBpcGUgdGhyb3VnaCB0aGVcbi8vIGBvcmlnaW5hbFZhbHVlYCBhbmQgYGNvbnRleHRgIHRocm91Z2ggZm9yIGJldHRlciBlcnJvciBtZXNzYWdpbmcuXG5mdW5jdGlvbiBjb252ZXhPclVuZGVmaW5lZFRvSnNvbkludGVybmFsKFxuICB2YWx1ZTogVmFsdWUgfCB1bmRlZmluZWQsXG4gIG9yaWdpbmFsVmFsdWU6IFZhbHVlIHwgdW5kZWZpbmVkLFxuICBjb250ZXh0OiBzdHJpbmcsXG4pOiBKU09OVmFsdWUge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB7ICR1bmRlZmluZWQ6IG51bGwgfTtcbiAgfSBlbHNlIHtcbiAgICBpZiAob3JpZ2luYWxWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBUaGlzIHNob3VsZCBub3QgaGFwcGVuLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgUHJvZ3JhbW1pbmcgZXJyb3IuIEN1cnJlbnQgdmFsdWUgaXMgJHtzdHJpbmdpZnlWYWx1ZUZvckVycm9yKFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICApfSBidXQgb3JpZ2luYWwgdmFsdWUgaXMgdW5kZWZpbmVkYCxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBjb252ZXhUb0pzb25JbnRlcm5hbCh2YWx1ZSwgb3JpZ2luYWxWYWx1ZSwgY29udGV4dCwgZmFsc2UpO1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydCBhIENvbnZleCB2YWx1ZSB0byBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBVc2Uge0BsaW5rIGpzb25Ub0NvbnZleH0gdG8gcmVjcmVhdGUgdGhlIG9yaWdpbmFsIHZhbHVlLlxuICpcbiAqIFRvIGxlYXJuIG1vcmUgYWJvdXQgQ29udmV4IHZhbHVlcywgc2VlIFtUeXBlc10oaHR0cHM6Ly9kb2NzLmNvbnZleC5kZXYvdXNpbmcvdHlwZXMpLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIEEgQ29udmV4IHZhbHVlIHRvIGNvbnZlcnQgaW50byBKU09OLlxuICogQHJldHVybnMgVGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXhUb0pzb24odmFsdWU6IFZhbHVlKTogSlNPTlZhbHVlIHtcbiAgcmV0dXJuIGNvbnZleFRvSnNvbkludGVybmFsKHZhbHVlLCB2YWx1ZSwgXCJcIiwgZmFsc2UpO1xufVxuXG4vLyBDb252ZXJ0IGEgQ29udmV4IHZhbHVlIG9yIGB1bmRlZmluZWRgIGludG8gaXRzIEpTT04gcmVwcmVzZW50YXRpb24uXG4vLyBgdW5kZWZpbmVkYCBpcyB1c2VkIGluIGZpbHRlcnMgdG8gcmVwcmVzZW50IGEgbWlzc2luZyBvYmplY3QgZmllbGQuXG5leHBvcnQgZnVuY3Rpb24gY29udmV4T3JVbmRlZmluZWRUb0pzb24odmFsdWU6IFZhbHVlIHwgdW5kZWZpbmVkKTogSlNPTlZhbHVlIHtcbiAgcmV0dXJuIGNvbnZleE9yVW5kZWZpbmVkVG9Kc29uSW50ZXJuYWwodmFsdWUsIHZhbHVlLCBcIlwiKTtcbn1cblxuLyoqXG4gKiBTaW1pbGFyIHRvIGNvbnZleFRvSnNvbiBidXQgYWxzbyBzZXJpYWxpemVzIHRvcCBsZXZlbCB1bmRlZmluZWQgZmllbGRzXG4gKiB1c2luZyBjb252ZXhPclVuZGVmaW5lZFRvSnNvbigpLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIEEgQ29udmV4IHZhbHVlIHRvIGNvbnZlcnQgaW50byBKU09OLlxuICogQHJldHVybnMgVGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYHZhbHVlYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhdGNoVmFsdWVUb0pzb24odmFsdWU6IFZhbHVlKTogSlNPTlZhbHVlIHtcbiAgcmV0dXJuIGNvbnZleFRvSnNvbkludGVybmFsKHZhbHVlLCB2YWx1ZSwgXCJcIiwgdHJ1ZSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBsb29rdXAgPSBbXTtcbnZhciByZXZMb29rdXAgPSBbXTtcbnZhciBBcnIgPSBVaW50OEFycmF5O1xudmFyIGNvZGUgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIjtcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV07XG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaTtcbn1cbnJldkxvb2t1cFtcIi1cIi5jaGFyQ29kZUF0KDApXSA9IDYyO1xucmV2TG9va3VwW1wiX1wiLmNoYXJDb2RlQXQoMCldID0gNjM7XG5mdW5jdGlvbiBnZXRMZW5zKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aDtcbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNFwiKTtcbiAgfVxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZihcIj1cIik7XG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuO1xuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlbiA/IDAgOiA0IC0gdmFsaWRMZW4gJSA0O1xuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVMZW5ndGgoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpO1xuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdO1xuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXTtcbiAgcmV0dXJuICh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCAtIHBsYWNlSG9sZGVyc0xlbjtcbn1cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoKF9iNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCAtIHBsYWNlSG9sZGVyc0xlbjtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVBcnJheShiNjQpIHtcbiAgdmFyIHRtcDtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NCk7XG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF07XG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdO1xuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKTtcbiAgdmFyIGN1ckJ5dGUgPSAwO1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMCA/IHZhbGlkTGVuIC0gNCA6IHZhbGlkTGVuO1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID0gcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNiB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldO1xuICAgIGFycltjdXJCeXRlKytdID0gdG1wID4+IDE2ICYgMjU1O1xuICAgIGFycltjdXJCeXRlKytdID0gdG1wID4+IDggJiAyNTU7XG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAyNTU7XG4gIH1cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMiB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQ7XG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAyNTU7XG4gIH1cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTAgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0IHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMjtcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCA+PiA4ICYgMjU1O1xuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMjU1O1xuICB9XG4gIHJldHVybiBhcnI7XG59XG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgNjNdICsgbG9va3VwW251bSA+PiAxMiAmIDYzXSArIGxvb2t1cFtudW0gPj4gNiAmIDYzXSArIGxvb2t1cFtudW0gJiA2M107XG59XG5mdW5jdGlvbiBlbmNvZGVDaHVuayh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wO1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID0gKHVpbnQ4W2ldIDw8IDE2ICYgMTY3MTE2ODApICsgKHVpbnQ4W2kgKyAxXSA8PCA4ICYgNjUyODApICsgKHVpbnQ4W2kgKyAyXSAmIDI1NSk7XG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpO1xuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbihcIlwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQnl0ZUFycmF5KHVpbnQ4KSB7XG4gIHZhciB0bXA7XG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGg7XG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMztcbiAgdmFyIHBhcnRzID0gW107XG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzO1xuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChcbiAgICAgIGVuY29kZUNodW5rKFxuICAgICAgICB1aW50OCxcbiAgICAgICAgaSxcbiAgICAgICAgaSArIG1heENodW5rTGVuZ3RoID4gbGVuMiA/IGxlbjIgOiBpICsgbWF4Q2h1bmtMZW5ndGhcbiAgICAgIClcbiAgICApO1xuICB9XG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV07XG4gICAgcGFydHMucHVzaChsb29rdXBbdG1wID4+IDJdICsgbG9va3VwW3RtcCA8PCA0ICYgNjNdICsgXCI9PVwiKTtcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV07XG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICsgbG9va3VwW3RtcCA+PiA0ICYgNjNdICsgbG9va3VwW3RtcCA8PCAyICYgNjNdICsgXCI9XCJcbiAgICApO1xuICB9XG4gIHJldHVybiBwYXJ0cy5qb2luKFwiXCIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZyb21CeXRlQXJyYXlVcmxTYWZlTm9QYWRkaW5nKHVpbnQ4KSB7XG4gIHJldHVybiBmcm9tQnl0ZUFycmF5KHVpbnQ4KS5yZXBsYWNlKC9cXCsvZywgXCItXCIpLnJlcGxhY2UoL1xcLy9nLCBcIl9cIikucmVwbGFjZSgvPS9nLCBcIlwiKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2U2NC5qcy5tYXBcbiIsIi8qXG5odHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvYmxvYi84ODk1N2M5OTQzYzdlMmEwZjAzY2RmNzNlNzFkNTc5ZTQzMzYyN2QzL2luZGV4LmpzXG5Db3B5cmlnaHQgKGMpIDIwMTQgSmFtZXNvbiBMaXR0bGVcblRoZSBNSVQgTGljZW5zZSAoTUlUKVxuKi9cblxuLy8gVmVuZG9yZWQgYmVjYXVzZSB0aGlzIGxpYnJhcnkgaGFzIG5vIEVTTSBidWlsZCwgYW5kIHNvbWUgZW52aXJvbm1lbnRzXG4vLyAoU3ZlbHRlS2l0KSBhcmUgaGFwcGllc3Qgd2hlbiBhbGwgZGVwZW5kZW5jaWVzIGFyZSBFU00uXG5cbnZhciBsb29rdXA6IHN0cmluZ1tdID0gW107XG52YXIgcmV2TG9va3VwOiBudW1iZXJbXSA9IFtdO1xudmFyIEFyciA9IFVpbnQ4QXJyYXk7XG5cbnZhciBjb2RlID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7XG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldO1xuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGk7XG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFtcIi1cIi5jaGFyQ29kZUF0KDApXSA9IDYyO1xucmV2TG9va3VwW1wiX1wiLmNoYXJDb2RlQXQoMCldID0gNjM7XG5cbmZ1bmN0aW9uIGdldExlbnMoYjY0OiBzdHJpbmcpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGg7XG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNFwiKTtcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoXCI9XCIpO1xuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlbjtcblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlbiA/IDAgOiA0IC0gKHZhbGlkTGVuICUgNCk7XG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXTtcbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG4vKiogQHB1YmxpYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVMZW5ndGgoYjY0OiBzdHJpbmcpOiBudW1iZXIge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KTtcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXTtcbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV07XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMpIC8gNCAtIHBsYWNlSG9sZGVyc0xlbjtcbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGgoX2I2NDogc3RyaW5nLCB2YWxpZExlbjogbnVtYmVyLCBwbGFjZUhvbGRlcnNMZW46IG51bWJlcikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzKSAvIDQgLSBwbGFjZUhvbGRlcnNMZW47XG59XG5cbi8qKiBAcHVibGljICovXG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlQXJyYXkoYjY0OiBzdHJpbmcpOiBVaW50OEFycmF5IHtcbiAgdmFyIHRtcDtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NCk7XG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF07XG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdO1xuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpO1xuXG4gIHZhciBjdXJCeXRlID0gMDtcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwID8gdmFsaWRMZW4gLSA0IDogdmFsaWRMZW47XG5cbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV07XG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4ZmY7XG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhmZjtcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4ZmY7XG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KTtcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4ZmY7XG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpO1xuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4ZmY7XG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweGZmO1xuICB9XG5cbiAgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0KG51bTogbnVtYmVyKSB7XG4gIHJldHVybiAoXG4gICAgbG9va3VwWyhudW0gPj4gMTgpICYgMHgzZl0gK1xuICAgIGxvb2t1cFsobnVtID4+IDEyKSAmIDB4M2ZdICtcbiAgICBsb29rdXBbKG51bSA+PiA2KSAmIDB4M2ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzZl1cbiAgKTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsodWludDg6IFVpbnQ4QXJyYXksIHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyKSB7XG4gIHZhciB0bXA7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweGZmMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweGZmMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweGZmKTtcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSk7XG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKFwiXCIpO1xufVxuXG4vKiogQHB1YmxpYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21CeXRlQXJyYXkodWludDg6IFVpbnQ4QXJyYXkpOiBzdHJpbmcge1xuICB2YXIgdG1wO1xuICB2YXIgbGVuID0gdWludDgubGVuZ3RoO1xuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDM7IC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdO1xuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MzsgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChcbiAgICAgIGVuY29kZUNodW5rKFxuICAgICAgICB1aW50OCxcbiAgICAgICAgaSxcbiAgICAgICAgaSArIG1heENodW5rTGVuZ3RoID4gbGVuMiA/IGxlbjIgOiBpICsgbWF4Q2h1bmtMZW5ndGgsXG4gICAgICApLFxuICAgICk7XG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV07XG4gICAgcGFydHMucHVzaChsb29rdXBbdG1wID4+IDJdICsgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNmXSArIFwiPT1cIik7XG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdO1xuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzZl0gK1xuICAgICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M2ZdICtcbiAgICAgICAgXCI9XCIsXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKFwiXCIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZnJvbUJ5dGVBcnJheVVybFNhZmVOb1BhZGRpbmcodWludDg6IFVpbnQ4QXJyYXkpOiBzdHJpbmcge1xuICByZXR1cm4gZnJvbUJ5dGVBcnJheSh1aW50OClcbiAgICAucmVwbGFjZSgvXFwrL2csIFwiLVwiKVxuICAgIC5yZXBsYWNlKC9cXC8vZywgXCJfXCIpXG4gICAgLnJlcGxhY2UoLz0vZywgXCJcIik7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUFyZ3MoYXJncykge1xuICBpZiAoYXJncyA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIGlmICghaXNTaW1wbGVPYmplY3QoYXJncykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgVGhlIGFyZ3VtZW50cyB0byBhIENvbnZleCBmdW5jdGlvbiBtdXN0IGJlIGFuIG9iamVjdC4gUmVjZWl2ZWQ6ICR7YXJnc31gXG4gICAgKTtcbiAgfVxuICByZXR1cm4gYXJncztcbn1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZURlcGxveW1lbnRVcmwoZGVwbG95bWVudFVybCkge1xuICBpZiAodHlwZW9mIGRlcGxveW1lbnRVcmwgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQ2xpZW50IGNyZWF0ZWQgd2l0aCB1bmRlZmluZWQgZGVwbG95bWVudCBhZGRyZXNzLiBJZiB5b3UgdXNlZCBhbiBlbnZpcm9ubWVudCB2YXJpYWJsZSwgY2hlY2sgdGhhdCBpdCdzIHNldC5gXG4gICAgKTtcbiAgfVxuICBpZiAodHlwZW9mIGRlcGxveW1lbnRVcmwgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgSW52YWxpZCBkZXBsb3ltZW50IGFkZHJlc3M6IGZvdW5kICR7ZGVwbG95bWVudFVybH1cIi5gXG4gICAgKTtcbiAgfVxuICBpZiAoIShkZXBsb3ltZW50VXJsLnN0YXJ0c1dpdGgoXCJodHRwOlwiKSB8fCBkZXBsb3ltZW50VXJsLnN0YXJ0c1dpdGgoXCJodHRwczpcIikpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFsaWQgZGVwbG95bWVudCBhZGRyZXNzOiBNdXN0IHN0YXJ0IHdpdGggXCJodHRwczovL1wiIG9yIFwiaHR0cDovL1wiLiBGb3VuZCBcIiR7ZGVwbG95bWVudFVybH1cIi5gXG4gICAgKTtcbiAgfVxuICB0cnkge1xuICAgIG5ldyBVUkwoZGVwbG95bWVudFVybCk7XG4gIH0gY2F0Y2gge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbnZhbGlkIGRlcGxveW1lbnQgYWRkcmVzczogXCIke2RlcGxveW1lbnRVcmx9XCIgaXMgbm90IGEgdmFsaWQgVVJMLiBJZiB5b3UgYmVsaWV2ZSB0aGlzIFVSTCBpcyBjb3JyZWN0LCB1c2UgdGhlIFxcYHNraXBDb252ZXhEZXBsb3ltZW50VXJsQ2hlY2tcXGAgb3B0aW9uIHRvIGJ5cGFzcyB0aGlzLmBcbiAgICApO1xuICB9XG4gIGlmIChkZXBsb3ltZW50VXJsLmVuZHNXaXRoKFwiLmNvbnZleC5zaXRlXCIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFsaWQgZGVwbG95bWVudCBhZGRyZXNzOiBcIiR7ZGVwbG95bWVudFVybH1cIiBlbmRzIHdpdGggLmNvbnZleC5zaXRlLCB3aGljaCBpcyB1c2VkIGZvciBIVFRQIEFjdGlvbnMuIENvbnZleCBkZXBsb3ltZW50IFVSTHMgdHlwaWNhbGx5IGVuZCB3aXRoIC5jb252ZXguY2xvdWQ/IElmIHlvdSBiZWxpZXZlIHRoaXMgVVJMIGlzIGNvcnJlY3QsIHVzZSB0aGUgXFxgc2tpcENvbnZleERlcGxveW1lbnRVcmxDaGVja1xcYCBvcHRpb24gdG8gYnlwYXNzIHRoaXMuYFxuICAgICk7XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1NpbXBsZU9iamVjdCh2YWx1ZSkge1xuICBjb25zdCBpc09iamVjdCA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIjtcbiAgY29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcbiAgY29uc3QgaXNTaW1wbGUgPSBwcm90b3R5cGUgPT09IG51bGwgfHwgcHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlIHx8IC8vIE9iamVjdHMgZ2VuZXJhdGVkIGZyb20gb3RoZXIgY29udGV4dHMgKGUuZy4gYWNyb3NzIE5vZGUuanMgYHZtYCBtb2R1bGVzKSB3aWxsIG5vdCBzYXRpc2Z5IHRoZSBwcmV2aW91c1xuICAvLyBjb25kaXRpb25zIGJ1dCBhcmUgc3RpbGwgc2ltcGxlIG9iamVjdHMuXG4gIHByb3RvdHlwZT8uY29uc3RydWN0b3I/Lm5hbWUgPT09IFwiT2JqZWN0XCI7XG4gIHJldHVybiBpc09iamVjdCAmJiBpc1NpbXBsZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiaW1wb3J0IHR5cGUgeyBWYWx1ZSB9IGZyb20gXCIuLi92YWx1ZXMvdmFsdWUuanNcIjtcblxuLyoqXG4gKiBWYWxpZGF0ZSB0aGF0IHRoZSBhcmd1bWVudHMgdG8gYSBDb252ZXggZnVuY3Rpb24gYXJlIGFuIG9iamVjdCwgZGVmYXVsdGluZ1xuICogYHVuZGVmaW5lZGAgdG8gYHt9YC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQXJncyhcbiAgYXJnczogUmVjb3JkPHN0cmluZywgVmFsdWU+IHwgdW5kZWZpbmVkLFxuKTogUmVjb3JkPHN0cmluZywgVmFsdWU+IHtcbiAgaWYgKGFyZ3MgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBpZiAoIWlzU2ltcGxlT2JqZWN0KGFyZ3MpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFRoZSBhcmd1bWVudHMgdG8gYSBDb252ZXggZnVuY3Rpb24gbXVzdCBiZSBhbiBvYmplY3QuIFJlY2VpdmVkOiAke1xuICAgICAgICBhcmdzIGFzIGFueVxuICAgICAgfWAsXG4gICAgKTtcbiAgfVxuICByZXR1cm4gYXJncztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlRGVwbG95bWVudFVybChkZXBsb3ltZW50VXJsOiBzdHJpbmcpIHtcbiAgLy8gRG9uJ3QgdXNlIHRoaW5ncyBsaWtlIGBuZXcgVVJMKGRlcGxveW1lbnRVcmwpLmhvc3RuYW1lYCBzaW5jZSB0aGVzZSBhcmVuJ3RcbiAgLy8gc3VwcG9ydGVkIGJ5IFJlYWN0IE5hdGl2ZSdzIEpTIGVudmlyb25tZW50XG4gIGlmICh0eXBlb2YgZGVwbG95bWVudFVybCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBDbGllbnQgY3JlYXRlZCB3aXRoIHVuZGVmaW5lZCBkZXBsb3ltZW50IGFkZHJlc3MuIElmIHlvdSB1c2VkIGFuIGVudmlyb25tZW50IHZhcmlhYmxlLCBjaGVjayB0aGF0IGl0J3Mgc2V0LmAsXG4gICAgKTtcbiAgfVxuICBpZiAodHlwZW9mIGRlcGxveW1lbnRVcmwgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgSW52YWxpZCBkZXBsb3ltZW50IGFkZHJlc3M6IGZvdW5kICR7ZGVwbG95bWVudFVybCBhcyBhbnl9XCIuYCxcbiAgICApO1xuICB9XG4gIGlmIChcbiAgICAhKGRlcGxveW1lbnRVcmwuc3RhcnRzV2l0aChcImh0dHA6XCIpIHx8IGRlcGxveW1lbnRVcmwuc3RhcnRzV2l0aChcImh0dHBzOlwiKSlcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFsaWQgZGVwbG95bWVudCBhZGRyZXNzOiBNdXN0IHN0YXJ0IHdpdGggXCJodHRwczovL1wiIG9yIFwiaHR0cDovL1wiLiBGb3VuZCBcIiR7ZGVwbG95bWVudFVybH1cIi5gLFxuICAgICk7XG4gIH1cblxuICAvLyBNb3N0IGNsaWVudHMgc2hvdWxkIGNvbm5lY3QgdG8gXCIuY29udmV4LmNsb3VkXCIuIEJ1dCB3ZSBhbHNvIHN1cHBvcnQgbG9jYWxob3N0IGFuZFxuICAvLyBjdXN0b20gY3VzdG9tLiBXZSB2YWxpZGF0ZSB0aGUgZGVwbG95bWVudCB1cmwgaXMgYSB2YWxpZCB1cmwsIHdoaWNoIGlzIHRoZSBtb3N0XG4gIC8vIGNvbW1vbiBmYWlsdXJlIHBhdHRlcm4uXG4gIHRyeSB7XG4gICAgbmV3IFVSTChkZXBsb3ltZW50VXJsKTtcbiAgfSBjYXRjaCB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFsaWQgZGVwbG95bWVudCBhZGRyZXNzOiBcIiR7ZGVwbG95bWVudFVybH1cIiBpcyBub3QgYSB2YWxpZCBVUkwuIElmIHlvdSBiZWxpZXZlIHRoaXMgVVJMIGlzIGNvcnJlY3QsIHVzZSB0aGUgXFxgc2tpcENvbnZleERlcGxveW1lbnRVcmxDaGVja1xcYCBvcHRpb24gdG8gYnlwYXNzIHRoaXMuYCxcbiAgICApO1xuICB9XG5cbiAgLy8gSWYgYSB1c2VyIHVzZXMgLmNvbnZleC5zaXRlLCB0aGlzIGlzIHZlcnkgbGlrZWx5IGluY29ycmVjdC5cbiAgaWYgKGRlcGxveW1lbnRVcmwuZW5kc1dpdGgoXCIuY29udmV4LnNpdGVcIikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgSW52YWxpZCBkZXBsb3ltZW50IGFkZHJlc3M6IFwiJHtkZXBsb3ltZW50VXJsfVwiIGVuZHMgd2l0aCAuY29udmV4LnNpdGUsIHdoaWNoIGlzIHVzZWQgZm9yIEhUVFAgQWN0aW9ucy4gQ29udmV4IGRlcGxveW1lbnQgVVJMcyB0eXBpY2FsbHkgZW5kIHdpdGggLmNvbnZleC5jbG91ZD8gSWYgeW91IGJlbGlldmUgdGhpcyBVUkwgaXMgY29ycmVjdCwgdXNlIHRoZSBcXGBza2lwQ29udmV4RGVwbG95bWVudFVybENoZWNrXFxgIG9wdGlvbiB0byBieXBhc3MgdGhpcy5gLFxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGEgdmFsdWUgaXMgYSBwbGFpbiBvbGQgSmF2YVNjcmlwdCBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1NpbXBsZU9iamVjdCh2YWx1ZTogdW5rbm93bikge1xuICBjb25zdCBpc09iamVjdCA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIjtcbiAgY29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcbiAgY29uc3QgaXNTaW1wbGUgPVxuICAgIHByb3RvdHlwZSA9PT0gbnVsbCB8fFxuICAgIHByb3RvdHlwZSA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fFxuICAgIC8vIE9iamVjdHMgZ2VuZXJhdGVkIGZyb20gb3RoZXIgY29udGV4dHMgKGUuZy4gYWNyb3NzIE5vZGUuanMgYHZtYCBtb2R1bGVzKSB3aWxsIG5vdCBzYXRpc2Z5IHRoZSBwcmV2aW91c1xuICAgIC8vIGNvbmRpdGlvbnMgYnV0IGFyZSBzdGlsbCBzaW1wbGUgb2JqZWN0cy5cbiAgICBwcm90b3R5cGU/LmNvbnN0cnVjdG9yPy5uYW1lID09PSBcIk9iamVjdFwiO1xuICByZXR1cm4gaXNPYmplY3QgJiYgaXNTaW1wbGU7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7XG4gIFZBbnksXG4gIFZBcnJheSxcbiAgVkJvb2xlYW4sXG4gIFZCeXRlcyxcbiAgVkZsb2F0NjQsXG4gIFZJZCxcbiAgVkludDY0LFxuICBWTGl0ZXJhbCxcbiAgVk51bGwsXG4gIFZPYmplY3QsXG4gIFZSZWNvcmQsXG4gIFZTdHJpbmcsXG4gIFZVbmlvblxufSBmcm9tIFwiLi92YWxpZGF0b3JzLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZGF0b3IodjIpIHtcbiAgcmV0dXJuICEhdjIuaXNDb252ZXhWYWxpZGF0b3I7XG59XG5leHBvcnQgZnVuY3Rpb24gYXNPYmplY3RWYWxpZGF0b3Iob2JqKSB7XG4gIGlmIChpc1ZhbGlkYXRvcihvYmopKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdi5vYmplY3Qob2JqKTtcbiAgfVxufVxuZXhwb3J0IGNvbnN0IHYgPSB7XG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhhdCB0aGUgdmFsdWUgY29ycmVzcG9uZHMgdG8gYW4gSUQgb2YgYSBkb2N1bWVudCBpbiBnaXZlbiB0YWJsZS5cbiAgICogQHBhcmFtIHRhYmxlTmFtZSBUaGUgbmFtZSBvZiB0aGUgdGFibGUuXG4gICAqL1xuICBpZDogKHRhYmxlTmFtZSkgPT4ge1xuICAgIHJldHVybiBuZXcgVklkKHtcbiAgICAgIGlzT3B0aW9uYWw6IFwicmVxdWlyZWRcIixcbiAgICAgIHRhYmxlTmFtZVxuICAgIH0pO1xuICB9LFxuICAvKipcbiAgICogVmFsaWRhdGVzIHRoYXQgdGhlIHZhbHVlIGlzIG9mIHR5cGUgTnVsbC5cbiAgICovXG4gIG51bGw6ICgpID0+IHtcbiAgICByZXR1cm4gbmV3IFZOdWxsKHsgaXNPcHRpb25hbDogXCJyZXF1aXJlZFwiIH0pO1xuICB9LFxuICAvKipcbiAgICogVmFsaWRhdGVzIHRoYXQgdGhlIHZhbHVlIGlzIG9mIENvbnZleCB0eXBlIEZsb2F0NjQgKE51bWJlciBpbiBKUykuXG4gICAqXG4gICAqIEFsaWFzIGZvciBgdi5mbG9hdDY0KClgXG4gICAqL1xuICBudW1iZXI6ICgpID0+IHtcbiAgICByZXR1cm4gbmV3IFZGbG9hdDY0KHsgaXNPcHRpb25hbDogXCJyZXF1aXJlZFwiIH0pO1xuICB9LFxuICAvKipcbiAgICogVmFsaWRhdGVzIHRoYXQgdGhlIHZhbHVlIGlzIG9mIENvbnZleCB0eXBlIEZsb2F0NjQgKE51bWJlciBpbiBKUykuXG4gICAqL1xuICBmbG9hdDY0OiAoKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBWRmxvYXQ2NCh7IGlzT3B0aW9uYWw6IFwicmVxdWlyZWRcIiB9KTtcbiAgfSxcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgdi5pbnQ2NCgpYCBpbnN0ZWFkXG4gICAqL1xuICBiaWdpbnQ6ICgpID0+IHtcbiAgICByZXR1cm4gbmV3IFZJbnQ2NCh7IGlzT3B0aW9uYWw6IFwicmVxdWlyZWRcIiB9KTtcbiAgfSxcbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGF0IHRoZSB2YWx1ZSBpcyBvZiBDb252ZXggdHlwZSBJbnQ2NCAoQmlnSW50IGluIEpTKS5cbiAgICovXG4gIGludDY0OiAoKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBWSW50NjQoeyBpc09wdGlvbmFsOiBcInJlcXVpcmVkXCIgfSk7XG4gIH0sXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhhdCB0aGUgdmFsdWUgaXMgb2YgdHlwZSBCb29sZWFuLlxuICAgKi9cbiAgYm9vbGVhbjogKCkgPT4ge1xuICAgIHJldHVybiBuZXcgVkJvb2xlYW4oeyBpc09wdGlvbmFsOiBcInJlcXVpcmVkXCIgfSk7XG4gIH0sXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhhdCB0aGUgdmFsdWUgaXMgb2YgdHlwZSBTdHJpbmcuXG4gICAqL1xuICBzdHJpbmc6ICgpID0+IHtcbiAgICByZXR1cm4gbmV3IFZTdHJpbmcoeyBpc09wdGlvbmFsOiBcInJlcXVpcmVkXCIgfSk7XG4gIH0sXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhhdCB0aGUgdmFsdWUgaXMgb2YgQ29udmV4IHR5cGUgQnl0ZXMgKGNvbnN0cnVjdGVkIGluIEpTIHZpYSBgQXJyYXlCdWZmZXJgKS5cbiAgICovXG4gIGJ5dGVzOiAoKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBWQnl0ZXMoeyBpc09wdGlvbmFsOiBcInJlcXVpcmVkXCIgfSk7XG4gIH0sXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhhdCB0aGUgdmFsdWUgaXMgZXF1YWwgdG8gdGhlIGdpdmVuIGxpdGVyYWwgdmFsdWUuXG4gICAqIEBwYXJhbSBsaXRlcmFsIFRoZSBsaXRlcmFsIHZhbHVlIHRvIGNvbXBhcmUgYWdhaW5zdC5cbiAgICovXG4gIGxpdGVyYWw6IChsaXRlcmFsKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBWTGl0ZXJhbCh7IGlzT3B0aW9uYWw6IFwicmVxdWlyZWRcIiwgdmFsdWU6IGxpdGVyYWwgfSk7XG4gIH0sXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhhdCB0aGUgdmFsdWUgaXMgYW4gQXJyYXkgb2YgdGhlIGdpdmVuIGVsZW1lbnQgdHlwZS5cbiAgICogQHBhcmFtIGVsZW1lbnQgVGhlIHZhbGlkYXRvciBmb3IgdGhlIGVsZW1lbnRzIG9mIHRoZSBhcnJheS5cbiAgICovXG4gIGFycmF5OiAoZWxlbWVudCkgPT4ge1xuICAgIHJldHVybiBuZXcgVkFycmF5KHsgaXNPcHRpb25hbDogXCJyZXF1aXJlZFwiLCBlbGVtZW50IH0pO1xuICB9LFxuICAvKipcbiAgICogVmFsaWRhdGVzIHRoYXQgdGhlIHZhbHVlIGlzIGFuIE9iamVjdCB3aXRoIHRoZSBnaXZlbiBwcm9wZXJ0aWVzLlxuICAgKiBAcGFyYW0gZmllbGRzIEFuIG9iamVjdCBzcGVjaWZ5aW5nIHRoZSB2YWxpZGF0b3IgZm9yIGVhY2ggcHJvcGVydHkuXG4gICAqL1xuICBvYmplY3Q6IChmaWVsZHMpID0+IHtcbiAgICByZXR1cm4gbmV3IFZPYmplY3QoeyBpc09wdGlvbmFsOiBcInJlcXVpcmVkXCIsIGZpZWxkcyB9KTtcbiAgfSxcbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGF0IHRoZSB2YWx1ZSBpcyBhIFJlY29yZCB3aXRoIGtleXMgYW5kIHZhbHVlcyB0aGF0IG1hdGNoIHRoZSBnaXZlbiB0eXBlcy5cbiAgICogQHBhcmFtIGtleXMgVGhlIHZhbGlkYXRvciBmb3IgdGhlIGtleXMgb2YgdGhlIHJlY29yZC4gVGhpcyBjYW5ub3QgY29udGFpbiBzdHJpbmcgbGl0ZXJhbHMuXG4gICAqIEBwYXJhbSB2YWx1ZXMgVGhlIHZhbGlkYXRvciBmb3IgdGhlIHZhbHVlcyBvZiB0aGUgcmVjb3JkLlxuICAgKi9cbiAgcmVjb3JkOiAoa2V5cywgdmFsdWVzKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBWUmVjb3JkKHtcbiAgICAgIGlzT3B0aW9uYWw6IFwicmVxdWlyZWRcIixcbiAgICAgIGtleToga2V5cyxcbiAgICAgIHZhbHVlOiB2YWx1ZXNcbiAgICB9KTtcbiAgfSxcbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGF0IHRoZSB2YWx1ZSBtYXRjaGVzIG9uZSBvZiB0aGUgZ2l2ZW4gdmFsaWRhdG9ycy5cbiAgICogQHBhcmFtIG1lbWJlcnMgVGhlIHZhbGlkYXRvcnMgdG8gbWF0Y2ggYWdhaW5zdC5cbiAgICovXG4gIHVuaW9uOiAoLi4ubWVtYmVycykgPT4ge1xuICAgIHJldHVybiBuZXcgVlVuaW9uKHtcbiAgICAgIGlzT3B0aW9uYWw6IFwicmVxdWlyZWRcIixcbiAgICAgIG1lbWJlcnNcbiAgICB9KTtcbiAgfSxcbiAgLyoqXG4gICAqIERvZXMgbm90IHZhbGlkYXRlIHRoZSB2YWx1ZS5cbiAgICovXG4gIGFueTogKCkgPT4ge1xuICAgIHJldHVybiBuZXcgVkFueSh7IGlzT3B0aW9uYWw6IFwicmVxdWlyZWRcIiB9KTtcbiAgfSxcbiAgLyoqXG4gICAqIEFsbG93cyBub3Qgc3BlY2lmeWluZyBhIHZhbHVlIGZvciBhIHByb3BlcnR5IGluIGFuIE9iamVjdC5cbiAgICogQHBhcmFtIHZhbHVlIFRoZSBwcm9wZXJ0eSB2YWx1ZSB2YWxpZGF0b3IgdG8gbWFrZSBvcHRpb25hbC5cbiAgICpcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBvYmplY3RXaXRoT3B0aW9uYWxGaWVsZHMgPSB2Lm9iamVjdCh7XG4gICAqICAgcmVxdWlyZWRGaWVsZDogdi5zdHJpbmcoKSxcbiAgICogICBvcHRpb25hbEZpZWxkOiB2Lm9wdGlvbmFsKHYuc3RyaW5nKCkpLFxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqL1xuICBvcHRpb25hbDogKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIHZhbHVlLmFzT3B0aW9uYWwoKTtcbiAgfSxcbiAgLyoqXG4gICAqIEFsbG93cyBzcGVjaWZ5aW5nIGEgdmFsdWUgb3IgbnVsbC5cbiAgICovXG4gIG51bGxhYmxlOiAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gdi51bmlvbih2YWx1ZSwgdi5udWxsKCkpO1xuICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFsaWRhdG9yLmpzLm1hcFxuIiwiaW1wb3J0IHsgRXhwYW5kIH0gZnJvbSBcIi4uL3R5cGVfdXRpbHMuanNcIjtcbmltcG9ydCB7IEdlbmVyaWNJZCB9IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQge1xuICBPcHRpb25hbFByb3BlcnR5LFxuICBWQW55LFxuICBWQXJyYXksXG4gIFZCb29sZWFuLFxuICBWQnl0ZXMsXG4gIFZGbG9hdDY0LFxuICBWSWQsXG4gIFZJbnQ2NCxcbiAgVkxpdGVyYWwsXG4gIFZOdWxsLFxuICBWT2JqZWN0LFxuICBWT3B0aW9uYWwsXG4gIFZSZWNvcmQsXG4gIFZTdHJpbmcsXG4gIFZVbmlvbixcbiAgVmFsaWRhdG9yLFxufSBmcm9tIFwiLi92YWxpZGF0b3JzLmpzXCI7XG5cbi8qKlxuICogVGhlIHR5cGUgdGhhdCBhbGwgdmFsaWRhdG9ycyBtdXN0IGV4dGVuZC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCB0eXBlIEdlbmVyaWNWYWxpZGF0b3IgPSBWYWxpZGF0b3I8YW55LCBhbnksIGFueT47XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkYXRvcih2OiBhbnkpOiB2IGlzIEdlbmVyaWNWYWxpZGF0b3Ige1xuICByZXR1cm4gISF2LmlzQ29udmV4VmFsaWRhdG9yO1xufVxuXG4vKipcbiAqIENvZXJjZSBhbiBvYmplY3Qgd2l0aCB2YWxpZGF0b3JzIGFzIHByb3BlcnRpZXMgdG8gYSB2YWxpZGF0b3IuXG4gKiBJZiBhIHZhbGlkYXRvciBpcyBwYXNzZWQsIHJldHVybiBpdC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc09iamVjdFZhbGlkYXRvcjxcbiAgViBleHRlbmRzIFZhbGlkYXRvcjxhbnksIGFueSwgYW55PiB8IFByb3BlcnR5VmFsaWRhdG9ycyxcbj4oXG4gIG9iajogVixcbik6IFYgZXh0ZW5kcyBWYWxpZGF0b3I8YW55LCBhbnksIGFueT5cbiAgPyBWXG4gIDogViBleHRlbmRzIFByb3BlcnR5VmFsaWRhdG9yc1xuICAgID8gVmFsaWRhdG9yPE9iamVjdFR5cGU8Vj4+XG4gICAgOiBuZXZlciB7XG4gIGlmIChpc1ZhbGlkYXRvcihvYmopKSB7XG4gICAgcmV0dXJuIG9iaiBhcyBhbnk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHYub2JqZWN0KG9iaiBhcyBQcm9wZXJ0eVZhbGlkYXRvcnMpIGFzIGFueTtcbiAgfVxufVxuXG4vKipcbiAqIENvZXJjZSBhbiBvYmplY3Qgd2l0aCB2YWxpZGF0b3JzIGFzIHByb3BlcnRpZXMgdG8gYSB2YWxpZGF0b3IuXG4gKiBJZiBhIHZhbGlkYXRvciBpcyBwYXNzZWQsIHJldHVybiBpdC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCB0eXBlIEFzT2JqZWN0VmFsaWRhdG9yPFxuICBWIGV4dGVuZHMgVmFsaWRhdG9yPGFueSwgYW55LCBhbnk+IHwgUHJvcGVydHlWYWxpZGF0b3JzLFxuPiA9XG4gIFYgZXh0ZW5kcyBWYWxpZGF0b3I8YW55LCBhbnksIGFueT5cbiAgICA/IFZcbiAgICA6IFYgZXh0ZW5kcyBQcm9wZXJ0eVZhbGlkYXRvcnNcbiAgICAgID8gVmFsaWRhdG9yPE9iamVjdFR5cGU8Vj4+XG4gICAgICA6IG5ldmVyO1xuXG4vKipcbiAqIFRoZSB2YWxpZGF0b3IgYnVpbGRlci5cbiAqXG4gKiBUaGlzIGJ1aWxkZXIgYWxsb3dzIHlvdSB0byBidWlsZCB2YWxpZGF0b3JzIGZvciBDb252ZXggdmFsdWVzLlxuICpcbiAqIFZhbGlkYXRvcnMgY2FuIGJlIHVzZWQgaW4gW3NjaGVtYSBkZWZpbml0aW9uc10oaHR0cHM6Ly9kb2NzLmNvbnZleC5kZXYvZGF0YWJhc2Uvc2NoZW1hcylcbiAqIGFuZCBhcyBpbnB1dCB2YWxpZGF0b3JzIGZvciBDb252ZXggZnVuY3Rpb25zLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHYgPSB7XG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhhdCB0aGUgdmFsdWUgY29ycmVzcG9uZHMgdG8gYW4gSUQgb2YgYSBkb2N1bWVudCBpbiBnaXZlbiB0YWJsZS5cbiAgICogQHBhcmFtIHRhYmxlTmFtZSBUaGUgbmFtZSBvZiB0aGUgdGFibGUuXG4gICAqL1xuICBpZDogPFRhYmxlTmFtZSBleHRlbmRzIHN0cmluZz4odGFibGVOYW1lOiBUYWJsZU5hbWUpID0+IHtcbiAgICByZXR1cm4gbmV3IFZJZDxHZW5lcmljSWQ8VGFibGVOYW1lPj4oe1xuICAgICAgaXNPcHRpb25hbDogXCJyZXF1aXJlZFwiLFxuICAgICAgdGFibGVOYW1lLFxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhhdCB0aGUgdmFsdWUgaXMgb2YgdHlwZSBOdWxsLlxuICAgKi9cbiAgbnVsbDogKCkgPT4ge1xuICAgIHJldHVybiBuZXcgVk51bGwoeyBpc09wdGlvbmFsOiBcInJlcXVpcmVkXCIgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGF0IHRoZSB2YWx1ZSBpcyBvZiBDb252ZXggdHlwZSBGbG9hdDY0IChOdW1iZXIgaW4gSlMpLlxuICAgKlxuICAgKiBBbGlhcyBmb3IgYHYuZmxvYXQ2NCgpYFxuICAgKi9cbiAgbnVtYmVyOiAoKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBWRmxvYXQ2NCh7IGlzT3B0aW9uYWw6IFwicmVxdWlyZWRcIiB9KTtcbiAgfSxcblxuICAvKipcbiAgICogVmFsaWRhdGVzIHRoYXQgdGhlIHZhbHVlIGlzIG9mIENvbnZleCB0eXBlIEZsb2F0NjQgKE51bWJlciBpbiBKUykuXG4gICAqL1xuICBmbG9hdDY0OiAoKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBWRmxvYXQ2NCh7IGlzT3B0aW9uYWw6IFwicmVxdWlyZWRcIiB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGB2LmludDY0KClgIGluc3RlYWRcbiAgICovXG4gIGJpZ2ludDogKCkgPT4ge1xuICAgIHJldHVybiBuZXcgVkludDY0KHsgaXNPcHRpb25hbDogXCJyZXF1aXJlZFwiIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhhdCB0aGUgdmFsdWUgaXMgb2YgQ29udmV4IHR5cGUgSW50NjQgKEJpZ0ludCBpbiBKUykuXG4gICAqL1xuICBpbnQ2NDogKCkgPT4ge1xuICAgIHJldHVybiBuZXcgVkludDY0KHsgaXNPcHRpb25hbDogXCJyZXF1aXJlZFwiIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhhdCB0aGUgdmFsdWUgaXMgb2YgdHlwZSBCb29sZWFuLlxuICAgKi9cbiAgYm9vbGVhbjogKCkgPT4ge1xuICAgIHJldHVybiBuZXcgVkJvb2xlYW4oeyBpc09wdGlvbmFsOiBcInJlcXVpcmVkXCIgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGF0IHRoZSB2YWx1ZSBpcyBvZiB0eXBlIFN0cmluZy5cbiAgICovXG4gIHN0cmluZzogKCkgPT4ge1xuICAgIHJldHVybiBuZXcgVlN0cmluZyh7IGlzT3B0aW9uYWw6IFwicmVxdWlyZWRcIiB9KTtcbiAgfSxcblxuICAvKipcbiAgICogVmFsaWRhdGVzIHRoYXQgdGhlIHZhbHVlIGlzIG9mIENvbnZleCB0eXBlIEJ5dGVzIChjb25zdHJ1Y3RlZCBpbiBKUyB2aWEgYEFycmF5QnVmZmVyYCkuXG4gICAqL1xuICBieXRlczogKCkgPT4ge1xuICAgIHJldHVybiBuZXcgVkJ5dGVzKHsgaXNPcHRpb25hbDogXCJyZXF1aXJlZFwiIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhhdCB0aGUgdmFsdWUgaXMgZXF1YWwgdG8gdGhlIGdpdmVuIGxpdGVyYWwgdmFsdWUuXG4gICAqIEBwYXJhbSBsaXRlcmFsIFRoZSBsaXRlcmFsIHZhbHVlIHRvIGNvbXBhcmUgYWdhaW5zdC5cbiAgICovXG4gIGxpdGVyYWw6IDxUIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyIHwgYmlnaW50IHwgYm9vbGVhbj4obGl0ZXJhbDogVCkgPT4ge1xuICAgIHJldHVybiBuZXcgVkxpdGVyYWw8VD4oeyBpc09wdGlvbmFsOiBcInJlcXVpcmVkXCIsIHZhbHVlOiBsaXRlcmFsIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhhdCB0aGUgdmFsdWUgaXMgYW4gQXJyYXkgb2YgdGhlIGdpdmVuIGVsZW1lbnQgdHlwZS5cbiAgICogQHBhcmFtIGVsZW1lbnQgVGhlIHZhbGlkYXRvciBmb3IgdGhlIGVsZW1lbnRzIG9mIHRoZSBhcnJheS5cbiAgICovXG4gIGFycmF5OiA8VCBleHRlbmRzIFZhbGlkYXRvcjxhbnksIFwicmVxdWlyZWRcIiwgYW55Pj4oZWxlbWVudDogVCkgPT4ge1xuICAgIHJldHVybiBuZXcgVkFycmF5PFRbXCJ0eXBlXCJdW10sIFQ+KHsgaXNPcHRpb25hbDogXCJyZXF1aXJlZFwiLCBlbGVtZW50IH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhhdCB0aGUgdmFsdWUgaXMgYW4gT2JqZWN0IHdpdGggdGhlIGdpdmVuIHByb3BlcnRpZXMuXG4gICAqIEBwYXJhbSBmaWVsZHMgQW4gb2JqZWN0IHNwZWNpZnlpbmcgdGhlIHZhbGlkYXRvciBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAgICovXG4gIG9iamVjdDogPFQgZXh0ZW5kcyBQcm9wZXJ0eVZhbGlkYXRvcnM+KGZpZWxkczogVCkgPT4ge1xuICAgIHJldHVybiBuZXcgVk9iamVjdDxPYmplY3RUeXBlPFQ+LCBUPih7IGlzT3B0aW9uYWw6IFwicmVxdWlyZWRcIiwgZmllbGRzIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhhdCB0aGUgdmFsdWUgaXMgYSBSZWNvcmQgd2l0aCBrZXlzIGFuZCB2YWx1ZXMgdGhhdCBtYXRjaCB0aGUgZ2l2ZW4gdHlwZXMuXG4gICAqIEBwYXJhbSBrZXlzIFRoZSB2YWxpZGF0b3IgZm9yIHRoZSBrZXlzIG9mIHRoZSByZWNvcmQuIFRoaXMgY2Fubm90IGNvbnRhaW4gc3RyaW5nIGxpdGVyYWxzLlxuICAgKiBAcGFyYW0gdmFsdWVzIFRoZSB2YWxpZGF0b3IgZm9yIHRoZSB2YWx1ZXMgb2YgdGhlIHJlY29yZC5cbiAgICovXG4gIHJlY29yZDogPFxuICAgIEtleSBleHRlbmRzIFZhbGlkYXRvcjxzdHJpbmcsIFwicmVxdWlyZWRcIiwgYW55PixcbiAgICBWYWx1ZSBleHRlbmRzIFZhbGlkYXRvcjxhbnksIFwicmVxdWlyZWRcIiwgYW55PixcbiAgPihcbiAgICBrZXlzOiBLZXksXG4gICAgdmFsdWVzOiBWYWx1ZSxcbiAgKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBWUmVjb3JkPFJlY29yZDxJbmZlcjxLZXk+LCBWYWx1ZVtcInR5cGVcIl0+LCBLZXksIFZhbHVlPih7XG4gICAgICBpc09wdGlvbmFsOiBcInJlcXVpcmVkXCIsXG4gICAgICBrZXk6IGtleXMsXG4gICAgICB2YWx1ZTogdmFsdWVzLFxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhhdCB0aGUgdmFsdWUgbWF0Y2hlcyBvbmUgb2YgdGhlIGdpdmVuIHZhbGlkYXRvcnMuXG4gICAqIEBwYXJhbSBtZW1iZXJzIFRoZSB2YWxpZGF0b3JzIHRvIG1hdGNoIGFnYWluc3QuXG4gICAqL1xuICB1bmlvbjogPFQgZXh0ZW5kcyBWYWxpZGF0b3I8YW55LCBcInJlcXVpcmVkXCIsIGFueT5bXT4oLi4ubWVtYmVyczogVCkgPT4ge1xuICAgIHJldHVybiBuZXcgVlVuaW9uPFRbbnVtYmVyXVtcInR5cGVcIl0sIFQ+KHtcbiAgICAgIGlzT3B0aW9uYWw6IFwicmVxdWlyZWRcIixcbiAgICAgIG1lbWJlcnMsXG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERvZXMgbm90IHZhbGlkYXRlIHRoZSB2YWx1ZS5cbiAgICovXG4gIGFueTogKCkgPT4ge1xuICAgIHJldHVybiBuZXcgVkFueSh7IGlzT3B0aW9uYWw6IFwicmVxdWlyZWRcIiB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQWxsb3dzIG5vdCBzcGVjaWZ5aW5nIGEgdmFsdWUgZm9yIGEgcHJvcGVydHkgaW4gYW4gT2JqZWN0LlxuICAgKiBAcGFyYW0gdmFsdWUgVGhlIHByb3BlcnR5IHZhbHVlIHZhbGlkYXRvciB0byBtYWtlIG9wdGlvbmFsLlxuICAgKlxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IG9iamVjdFdpdGhPcHRpb25hbEZpZWxkcyA9IHYub2JqZWN0KHtcbiAgICogICByZXF1aXJlZEZpZWxkOiB2LnN0cmluZygpLFxuICAgKiAgIG9wdGlvbmFsRmllbGQ6IHYub3B0aW9uYWwodi5zdHJpbmcoKSksXG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICovXG4gIG9wdGlvbmFsOiA8VCBleHRlbmRzIEdlbmVyaWNWYWxpZGF0b3I+KHZhbHVlOiBUKSA9PiB7XG4gICAgcmV0dXJuIHZhbHVlLmFzT3B0aW9uYWwoKSBhcyBWT3B0aW9uYWw8VD47XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFsbG93cyBzcGVjaWZ5aW5nIGEgdmFsdWUgb3IgbnVsbC5cbiAgICovXG4gIG51bGxhYmxlOiA8VCBleHRlbmRzIFZhbGlkYXRvcjxhbnksIFwicmVxdWlyZWRcIiwgYW55Pj4odmFsdWU6IFQpID0+IHtcbiAgICByZXR1cm4gdi51bmlvbih2YWx1ZSwgdi5udWxsKCkpO1xuICB9LFxufTtcblxuLyoqXG4gKiBWYWxpZGF0b3JzIGZvciBlYWNoIHByb3BlcnR5IG9mIGFuIG9iamVjdC5cbiAqXG4gKiBUaGlzIGlzIHJlcHJlc2VudGVkIGFzIGFuIG9iamVjdCBtYXBwaW5nIHRoZSBwcm9wZXJ0eSBuYW1lIHRvIGl0c1xuICoge0BsaW5rIFZhbGlkYXRvcn0uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgdHlwZSBQcm9wZXJ0eVZhbGlkYXRvcnMgPSBSZWNvcmQ8XG4gIHN0cmluZyxcbiAgVmFsaWRhdG9yPGFueSwgT3B0aW9uYWxQcm9wZXJ0eSwgYW55PlxuPjtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSB0eXBlIG9mIGFuIG9iamVjdCBmcm9tIHtAbGluayBQcm9wZXJ0eVZhbGlkYXRvcnN9LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IHR5cGUgT2JqZWN0VHlwZTxGaWVsZHMgZXh0ZW5kcyBQcm9wZXJ0eVZhbGlkYXRvcnM+ID0gRXhwYW5kPFxuICAvLyBNYXAgZWFjaCBrZXkgdG8gdGhlIGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgdmFsaWRhdG9yJ3MgdHlwZSBtYWtpbmdcbiAgLy8gdGhlIG9wdGlvbmFsIG9uZXMgb3B0aW9uYWwuXG4gIHtcbiAgICAvLyBUaGlzIGBFeGNsdWRlPC4uLiwgdW5kZWZpbmVkPmAgZG9lcyBub3RoaW5nIHVubGVzc1xuICAgIC8vIHRoZSB0c2NvbmZpZy5qc29uIG9wdGlvbiBgXCJleGFjdE9wdGlvbmFsUHJvcGVydHlUeXBlc1wiOiB0cnVlLGBcbiAgICAvLyBpcyB1c2VkLiBXaGVuIGl0IGlzIGl0IHJlc3VsdHMgaW4gYSBtb3JlIGFjY3VyYXRlIHR5cGUuXG4gICAgLy8gV2hlbiBpdCBpcyBub3QgdGhlIGBFeGNsdWRlYCByZW1vdmVzIGB1bmRlZmluZWRgIGJ1dCBpdCBpc1xuICAgIC8vIGFkZGVkIGFnYWluIGJ5IHRoZSBvcHRpb25hbCBwcm9wZXJ0eS5cbiAgICBbUHJvcGVydHkgaW4gT3B0aW9uYWxLZXlzPEZpZWxkcz5dPzogRXhjbHVkZTxcbiAgICAgIEluZmVyPEZpZWxkc1tQcm9wZXJ0eV0+LFxuICAgICAgdW5kZWZpbmVkXG4gICAgPjtcbiAgfSAmIHtcbiAgICBbUHJvcGVydHkgaW4gUmVxdWlyZWRLZXlzPEZpZWxkcz5dOiBJbmZlcjxGaWVsZHNbUHJvcGVydHldPjtcbiAgfVxuPjtcblxudHlwZSBPcHRpb25hbEtleXM8UHJvcGVydHlWYWxpZGF0b3JzIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgR2VuZXJpY1ZhbGlkYXRvcj4+ID1cbiAge1xuICAgIFtQcm9wZXJ0eSBpbiBrZXlvZiBQcm9wZXJ0eVZhbGlkYXRvcnNdOiBQcm9wZXJ0eVZhbGlkYXRvcnNbUHJvcGVydHldW1wiaXNPcHRpb25hbFwiXSBleHRlbmRzIFwib3B0aW9uYWxcIlxuICAgICAgPyBQcm9wZXJ0eVxuICAgICAgOiBuZXZlcjtcbiAgfVtrZXlvZiBQcm9wZXJ0eVZhbGlkYXRvcnNdO1xuXG50eXBlIFJlcXVpcmVkS2V5czxQcm9wZXJ0eVZhbGlkYXRvcnMgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBHZW5lcmljVmFsaWRhdG9yPj4gPVxuICBFeGNsdWRlPGtleW9mIFByb3BlcnR5VmFsaWRhdG9ycywgT3B0aW9uYWxLZXlzPFByb3BlcnR5VmFsaWRhdG9ycz4+O1xuXG4vKipcbiAqIEV4dHJhY3QgYSBUeXBlU2NyaXB0IHR5cGUgZnJvbSBhIHZhbGlkYXRvci5cbiAqXG4gKiBFeGFtcGxlIHVzYWdlOlxuICogYGBgdHNcbiAqIGNvbnN0IG9iamVjdFNjaGVtYSA9IHYub2JqZWN0KHtcbiAqICAgcHJvcGVydHk6IHYuc3RyaW5nKCksXG4gKiB9KTtcbiAqIHR5cGUgTXlPYmplY3QgPSBJbmZlcjx0eXBlb2Ygb2JqZWN0U2NoZW1hPjsgLy8geyBwcm9wZXJ0eTogc3RyaW5nIH1cbiAqIGBgYFxuICogQHR5cGVQYXJhbSBWIC0gVGhlIHR5cGUgb2YgYSB7QGxpbmsgVmFsaWRhdG9yfSBjb25zdHJ1Y3RlZCB3aXRoIHtAbGluayB2fS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCB0eXBlIEluZmVyPFQgZXh0ZW5kcyBWYWxpZGF0b3I8YW55LCBPcHRpb25hbFByb3BlcnR5LCBhbnk+PiA9IFRbXCJ0eXBlXCJdO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuaW1wb3J0IHsgY29udmV4VG9Kc29uIH0gZnJvbSBcIi4vdmFsdWUuanNcIjtcbmNvbnN0IFVOREVGSU5FRF9WQUxJREFUT1JfRVJST1JfVVJMID0gXCJodHRwczovL2RvY3MuY29udmV4LmRldi9lcnJvciN1bmRlZmluZWQtdmFsaWRhdG9yXCI7XG5mdW5jdGlvbiB0aHJvd1VuZGVmaW5lZFZhbGlkYXRvckVycm9yKGNvbnRleHQsIGZpZWxkTmFtZSkge1xuICBjb25zdCBmaWVsZEluZm8gPSBmaWVsZE5hbWUgIT09IHZvaWQgMCA/IGAgZm9yIGZpZWxkIFwiJHtmaWVsZE5hbWV9XCJgIDogXCJcIjtcbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgIGBBIHZhbGlkYXRvciBpcyB1bmRlZmluZWQke2ZpZWxkSW5mb30gaW4gJHtjb250ZXh0fS4gVGhpcyBpcyBvZnRlbiBjYXVzZWQgYnkgY2lyY3VsYXIgaW1wb3J0cy4gU2VlICR7VU5ERUZJTkVEX1ZBTElEQVRPUl9FUlJPUl9VUkx9IGZvciBkZXRhaWxzLmBcbiAgKTtcbn1cbmNsYXNzIEJhc2VWYWxpZGF0b3Ige1xuICBjb25zdHJ1Y3Rvcih7IGlzT3B0aW9uYWwgfSkge1xuICAgIC8qKlxuICAgICAqIE9ubHkgZm9yIFR5cGVTY3JpcHQsIHRoZSBUUyB0eXBlIG9mIHRoZSBKUyB2YWx1ZXMgdmFsaWRhdGVkXG4gICAgICogYnkgdGhpcyB2YWxpZGF0b3IuXG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInR5cGVcIik7XG4gICAgLyoqXG4gICAgICogT25seSBmb3IgVHlwZVNjcmlwdCwgaWYgdGhpcyBhbiBPYmplY3QgdmFsaWRhdG9yLCB0aGVuXG4gICAgICogdGhpcyBpcyB0aGUgVFMgdHlwZSBvZiBpdHMgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImZpZWxkUGF0aHNcIik7XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIGlzIGFuIG9wdGlvbmFsIE9iamVjdCBwcm9wZXJ0eSB2YWx1ZSB2YWxpZGF0b3IuXG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImlzT3B0aW9uYWxcIik7XG4gICAgLyoqXG4gICAgICogQWx3YXlzIGBcInRydWVcImAuXG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImlzQ29udmV4VmFsaWRhdG9yXCIpO1xuICAgIHRoaXMuaXNPcHRpb25hbCA9IGlzT3B0aW9uYWw7XG4gICAgdGhpcy5pc0NvbnZleFZhbGlkYXRvciA9IHRydWU7XG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBWSWQgZXh0ZW5kcyBCYXNlVmFsaWRhdG9yIHtcbiAgLyoqXG4gICAqIFVzdWFsbHkgeW91J2QgdXNlIGB2LmlkKHRhYmxlTmFtZSlgIGluc3RlYWQuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgaXNPcHRpb25hbCxcbiAgICB0YWJsZU5hbWVcbiAgfSkge1xuICAgIHN1cGVyKHsgaXNPcHRpb25hbCB9KTtcbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgdGFibGUgdGhhdCB0aGUgdmFsaWRhdGVkIElEcyBtdXN0IGJlbG9uZyB0by5cbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidGFibGVOYW1lXCIpO1xuICAgIC8qKlxuICAgICAqIFRoZSBraW5kIG9mIHZhbGlkYXRvciwgYFwiaWRcImAuXG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImtpbmRcIiwgXCJpZFwiKTtcbiAgICBpZiAodHlwZW9mIHRhYmxlTmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidi5pZCh0YWJsZU5hbWUpIHJlcXVpcmVzIGEgc3RyaW5nXCIpO1xuICAgIH1cbiAgICB0aGlzLnRhYmxlTmFtZSA9IHRhYmxlTmFtZTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBqc29uKCkge1xuICAgIHJldHVybiB7IHR5cGU6IFwiaWRcIiwgdGFibGVOYW1lOiB0aGlzLnRhYmxlTmFtZSB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgYXNPcHRpb25hbCgpIHtcbiAgICByZXR1cm4gbmV3IFZJZCh7XG4gICAgICBpc09wdGlvbmFsOiBcIm9wdGlvbmFsXCIsXG4gICAgICB0YWJsZU5hbWU6IHRoaXMudGFibGVOYW1lXG4gICAgfSk7XG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBWRmxvYXQ2NCBleHRlbmRzIEJhc2VWYWxpZGF0b3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIC8qKlxuICAgICAqIFRoZSBraW5kIG9mIHZhbGlkYXRvciwgYFwiZmxvYXQ2NFwiYC5cbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwia2luZFwiLCBcImZsb2F0NjRcIik7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQganNvbigpIHtcbiAgICByZXR1cm4geyB0eXBlOiBcIm51bWJlclwiIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBhc09wdGlvbmFsKCkge1xuICAgIHJldHVybiBuZXcgVkZsb2F0NjQoe1xuICAgICAgaXNPcHRpb25hbDogXCJvcHRpb25hbFwiXG4gICAgfSk7XG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBWSW50NjQgZXh0ZW5kcyBCYXNlVmFsaWRhdG9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAvKipcbiAgICAgKiBUaGUga2luZCBvZiB2YWxpZGF0b3IsIGBcImludDY0XCJgLlxuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJraW5kXCIsIFwiaW50NjRcIik7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQganNvbigpIHtcbiAgICByZXR1cm4geyB0eXBlOiBcImJpZ2ludFwiIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBhc09wdGlvbmFsKCkge1xuICAgIHJldHVybiBuZXcgVkludDY0KHsgaXNPcHRpb25hbDogXCJvcHRpb25hbFwiIH0pO1xuICB9XG59XG5leHBvcnQgY2xhc3MgVkJvb2xlYW4gZXh0ZW5kcyBCYXNlVmFsaWRhdG9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAvKipcbiAgICAgKiBUaGUga2luZCBvZiB2YWxpZGF0b3IsIGBcImJvb2xlYW5cImAuXG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImtpbmRcIiwgXCJib29sZWFuXCIpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0IGpzb24oKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogdGhpcy5raW5kIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBhc09wdGlvbmFsKCkge1xuICAgIHJldHVybiBuZXcgVkJvb2xlYW4oe1xuICAgICAgaXNPcHRpb25hbDogXCJvcHRpb25hbFwiXG4gICAgfSk7XG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBWQnl0ZXMgZXh0ZW5kcyBCYXNlVmFsaWRhdG9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAvKipcbiAgICAgKiBUaGUga2luZCBvZiB2YWxpZGF0b3IsIGBcImJ5dGVzXCJgLlxuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJraW5kXCIsIFwiYnl0ZXNcIik7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQganNvbigpIHtcbiAgICByZXR1cm4geyB0eXBlOiB0aGlzLmtpbmQgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGFzT3B0aW9uYWwoKSB7XG4gICAgcmV0dXJuIG5ldyBWQnl0ZXMoeyBpc09wdGlvbmFsOiBcIm9wdGlvbmFsXCIgfSk7XG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBWU3RyaW5nIGV4dGVuZHMgQmFzZVZhbGlkYXRvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgLyoqXG4gICAgICogVGhlIGtpbmQgb2YgdmFsaWRhdG9yLCBgXCJzdHJpbmdcImAuXG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImtpbmRcIiwgXCJzdHJpbmdcIik7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQganNvbigpIHtcbiAgICByZXR1cm4geyB0eXBlOiB0aGlzLmtpbmQgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGFzT3B0aW9uYWwoKSB7XG4gICAgcmV0dXJuIG5ldyBWU3RyaW5nKHtcbiAgICAgIGlzT3B0aW9uYWw6IFwib3B0aW9uYWxcIlxuICAgIH0pO1xuICB9XG59XG5leHBvcnQgY2xhc3MgVk51bGwgZXh0ZW5kcyBCYXNlVmFsaWRhdG9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAvKipcbiAgICAgKiBUaGUga2luZCBvZiB2YWxpZGF0b3IsIGBcIm51bGxcImAuXG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImtpbmRcIiwgXCJudWxsXCIpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0IGpzb24oKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogdGhpcy5raW5kIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBhc09wdGlvbmFsKCkge1xuICAgIHJldHVybiBuZXcgVk51bGwoeyBpc09wdGlvbmFsOiBcIm9wdGlvbmFsXCIgfSk7XG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBWQW55IGV4dGVuZHMgQmFzZVZhbGlkYXRvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgLyoqXG4gICAgICogVGhlIGtpbmQgb2YgdmFsaWRhdG9yLCBgXCJhbnlcImAuXG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImtpbmRcIiwgXCJhbnlcIik7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQganNvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogdGhpcy5raW5kXG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGFzT3B0aW9uYWwoKSB7XG4gICAgcmV0dXJuIG5ldyBWQW55KHtcbiAgICAgIGlzT3B0aW9uYWw6IFwib3B0aW9uYWxcIlxuICAgIH0pO1xuICB9XG59XG5leHBvcnQgY2xhc3MgVk9iamVjdCBleHRlbmRzIEJhc2VWYWxpZGF0b3Ige1xuICAvKipcbiAgICogVXN1YWxseSB5b3UnZCB1c2UgYHYub2JqZWN0KHsgLi4uIH0pYCBpbnN0ZWFkLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIGlzT3B0aW9uYWwsXG4gICAgZmllbGRzXG4gIH0pIHtcbiAgICBzdXBlcih7IGlzT3B0aW9uYWwgfSk7XG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IHdpdGggdGhlIHZhbGlkYXRvciBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZmllbGRzXCIpO1xuICAgIC8qKlxuICAgICAqIFRoZSBraW5kIG9mIHZhbGlkYXRvciwgYFwib2JqZWN0XCJgLlxuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJraW5kXCIsIFwib2JqZWN0XCIpO1xuICAgIGdsb2JhbFRoaXMuT2JqZWN0LmVudHJpZXMoZmllbGRzKS5mb3JFYWNoKChbZmllbGROYW1lLCB2YWxpZGF0b3JdKSA9PiB7XG4gICAgICBpZiAodmFsaWRhdG9yID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3dVbmRlZmluZWRWYWxpZGF0b3JFcnJvcihcInYub2JqZWN0KClcIiwgZmllbGROYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmICghdmFsaWRhdG9yLmlzQ29udmV4VmFsaWRhdG9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInYub2JqZWN0KCkgZW50cmllcyBtdXN0IGJlIHZhbGlkYXRvcnNcIik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5maWVsZHMgPSBmaWVsZHM7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQganNvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogdGhpcy5raW5kLFxuICAgICAgdmFsdWU6IGdsb2JhbFRoaXMuT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICBnbG9iYWxUaGlzLk9iamVjdC5lbnRyaWVzKHRoaXMuZmllbGRzKS5tYXAoKFtrLCB2XSkgPT4gW1xuICAgICAgICAgIGssXG4gICAgICAgICAge1xuICAgICAgICAgICAgZmllbGRUeXBlOiB2Lmpzb24sXG4gICAgICAgICAgICBvcHRpb25hbDogdi5pc09wdGlvbmFsID09PSBcIm9wdGlvbmFsXCIgPyB0cnVlIDogZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIF0pXG4gICAgICApXG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGFzT3B0aW9uYWwoKSB7XG4gICAgcmV0dXJuIG5ldyBWT2JqZWN0KHtcbiAgICAgIGlzT3B0aW9uYWw6IFwib3B0aW9uYWxcIixcbiAgICAgIGZpZWxkczogdGhpcy5maWVsZHNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFZPYmplY3Qgd2l0aCB0aGUgc3BlY2lmaWVkIGZpZWxkcyBvbWl0dGVkLlxuICAgKiBAcGFyYW0gZmllbGRzIFRoZSBmaWVsZCBuYW1lcyB0byBvbWl0IGZyb20gdGhpcyBWT2JqZWN0LlxuICAgKi9cbiAgb21pdCguLi5maWVsZHMpIHtcbiAgICBjb25zdCBuZXdGaWVsZHMgPSB7IC4uLnRoaXMuZmllbGRzIH07XG4gICAgZm9yIChjb25zdCBmaWVsZCBvZiBmaWVsZHMpIHtcbiAgICAgIGRlbGV0ZSBuZXdGaWVsZHNbZmllbGRdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFZPYmplY3Qoe1xuICAgICAgaXNPcHRpb25hbDogdGhpcy5pc09wdGlvbmFsLFxuICAgICAgZmllbGRzOiBuZXdGaWVsZHNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFZPYmplY3Qgd2l0aCBvbmx5IHRoZSBzcGVjaWZpZWQgZmllbGRzLlxuICAgKiBAcGFyYW0gZmllbGRzIFRoZSBmaWVsZCBuYW1lcyB0byBwaWNrIGZyb20gdGhpcyBWT2JqZWN0LlxuICAgKi9cbiAgcGljayguLi5maWVsZHMpIHtcbiAgICBjb25zdCBuZXdGaWVsZHMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGZpZWxkcykge1xuICAgICAgbmV3RmllbGRzW2ZpZWxkXSA9IHRoaXMuZmllbGRzW2ZpZWxkXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBWT2JqZWN0KHtcbiAgICAgIGlzT3B0aW9uYWw6IHRoaXMuaXNPcHRpb25hbCxcbiAgICAgIGZpZWxkczogbmV3RmllbGRzXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBWT2JqZWN0IHdpdGggYWxsIGZpZWxkcyBtYXJrZWQgYXMgb3B0aW9uYWwuXG4gICAqL1xuICBwYXJ0aWFsKCkge1xuICAgIGNvbnN0IG5ld0ZpZWxkcyA9IHt9O1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsaWRhdG9yXSBvZiBnbG9iYWxUaGlzLk9iamVjdC5lbnRyaWVzKHRoaXMuZmllbGRzKSkge1xuICAgICAgbmV3RmllbGRzW2tleV0gPSB2YWxpZGF0b3IuYXNPcHRpb25hbCgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFZPYmplY3Qoe1xuICAgICAgaXNPcHRpb25hbDogdGhpcy5pc09wdGlvbmFsLFxuICAgICAgZmllbGRzOiBuZXdGaWVsZHNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFZPYmplY3Qgd2l0aCBhZGRpdGlvbmFsIGZpZWxkcyBtZXJnZWQgaW4uXG4gICAqIEBwYXJhbSBmaWVsZHMgQW4gb2JqZWN0IHdpdGggYWRkaXRpb25hbCB2YWxpZGF0b3JzIHRvIG1lcmdlIGludG8gdGhpcyBWT2JqZWN0LlxuICAgKi9cbiAgZXh0ZW5kKGZpZWxkcykge1xuICAgIHJldHVybiBuZXcgVk9iamVjdCh7XG4gICAgICBpc09wdGlvbmFsOiB0aGlzLmlzT3B0aW9uYWwsXG4gICAgICBmaWVsZHM6IHsgLi4udGhpcy5maWVsZHMsIC4uLmZpZWxkcyB9XG4gICAgfSk7XG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBWTGl0ZXJhbCBleHRlbmRzIEJhc2VWYWxpZGF0b3Ige1xuICAvKipcbiAgICogVXN1YWxseSB5b3UnZCB1c2UgYHYubGl0ZXJhbCh2YWx1ZSlgIGluc3RlYWQuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGlzT3B0aW9uYWwsIHZhbHVlIH0pIHtcbiAgICBzdXBlcih7IGlzT3B0aW9uYWwgfSk7XG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIHRoYXQgdGhlIHZhbGlkYXRlZCB2YWx1ZXMgbXVzdCBiZSBlcXVhbCB0by5cbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidmFsdWVcIik7XG4gICAgLyoqXG4gICAgICogVGhlIGtpbmQgb2YgdmFsaWRhdG9yLCBgXCJsaXRlcmFsXCJgLlxuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJraW5kXCIsIFwibGl0ZXJhbFwiKTtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJib29sZWFuXCIgJiYgdHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJiaWdpbnRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidi5saXRlcmFsKHZhbHVlKSBtdXN0IGJlIGEgc3RyaW5nLCBudW1iZXIsIG9yIGJvb2xlYW5cIik7XG4gICAgfVxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBqc29uKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiB0aGlzLmtpbmQsXG4gICAgICB2YWx1ZTogY29udmV4VG9Kc29uKHRoaXMudmFsdWUpXG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGFzT3B0aW9uYWwoKSB7XG4gICAgcmV0dXJuIG5ldyBWTGl0ZXJhbCh7XG4gICAgICBpc09wdGlvbmFsOiBcIm9wdGlvbmFsXCIsXG4gICAgICB2YWx1ZTogdGhpcy52YWx1ZVxuICAgIH0pO1xuICB9XG59XG5leHBvcnQgY2xhc3MgVkFycmF5IGV4dGVuZHMgQmFzZVZhbGlkYXRvciB7XG4gIC8qKlxuICAgKiBVc3VhbGx5IHlvdSdkIHVzZSBgdi5hcnJheShlbGVtZW50KWAgaW5zdGVhZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBpc09wdGlvbmFsLFxuICAgIGVsZW1lbnRcbiAgfSkge1xuICAgIHN1cGVyKHsgaXNPcHRpb25hbCB9KTtcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsaWRhdG9yIGZvciB0aGUgZWxlbWVudHMgb2YgdGhlIGFycmF5LlxuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJlbGVtZW50XCIpO1xuICAgIC8qKlxuICAgICAqIFRoZSBraW5kIG9mIHZhbGlkYXRvciwgYFwiYXJyYXlcImAuXG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImtpbmRcIiwgXCJhcnJheVwiKTtcbiAgICBpZiAoZWxlbWVudCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvd1VuZGVmaW5lZFZhbGlkYXRvckVycm9yKFwidi5hcnJheSgpXCIpO1xuICAgIH1cbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0IGpzb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IHRoaXMua2luZCxcbiAgICAgIHZhbHVlOiB0aGlzLmVsZW1lbnQuanNvblxuICAgIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBhc09wdGlvbmFsKCkge1xuICAgIHJldHVybiBuZXcgVkFycmF5KHtcbiAgICAgIGlzT3B0aW9uYWw6IFwib3B0aW9uYWxcIixcbiAgICAgIGVsZW1lbnQ6IHRoaXMuZWxlbWVudFxuICAgIH0pO1xuICB9XG59XG5leHBvcnQgY2xhc3MgVlJlY29yZCBleHRlbmRzIEJhc2VWYWxpZGF0b3Ige1xuICAvKipcbiAgICogVXN1YWxseSB5b3UnZCB1c2UgYHYucmVjb3JkKGtleSwgdmFsdWUpYCBpbnN0ZWFkLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIGlzT3B0aW9uYWwsXG4gICAga2V5LFxuICAgIHZhbHVlXG4gIH0pIHtcbiAgICBzdXBlcih7IGlzT3B0aW9uYWwgfSk7XG4gICAgLyoqXG4gICAgICogVGhlIHZhbGlkYXRvciBmb3IgdGhlIGtleXMgb2YgdGhlIHJlY29yZC5cbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwia2V5XCIpO1xuICAgIC8qKlxuICAgICAqIFRoZSB2YWxpZGF0b3IgZm9yIHRoZSB2YWx1ZXMgb2YgdGhlIHJlY29yZC5cbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidmFsdWVcIik7XG4gICAgLyoqXG4gICAgICogVGhlIGtpbmQgb2YgdmFsaWRhdG9yLCBgXCJyZWNvcmRcImAuXG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImtpbmRcIiwgXCJyZWNvcmRcIik7XG4gICAgaWYgKGtleSA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvd1VuZGVmaW5lZFZhbGlkYXRvckVycm9yKFwidi5yZWNvcmQoKVwiLCBcImtleVwiKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93VW5kZWZpbmVkVmFsaWRhdG9yRXJyb3IoXCJ2LnJlY29yZCgpXCIsIFwidmFsdWVcIik7XG4gICAgfVxuICAgIGlmIChrZXkuaXNPcHRpb25hbCA9PT0gXCJvcHRpb25hbFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWNvcmQgdmFsaWRhdG9yIGNhbm5vdCBoYXZlIG9wdGlvbmFsIGtleXNcIik7XG4gICAgfVxuICAgIGlmICh2YWx1ZS5pc09wdGlvbmFsID09PSBcIm9wdGlvbmFsXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlY29yZCB2YWxpZGF0b3IgY2Fubm90IGhhdmUgb3B0aW9uYWwgdmFsdWVzXCIpO1xuICAgIH1cbiAgICBpZiAoIWtleS5pc0NvbnZleFZhbGlkYXRvciB8fCAhdmFsdWUuaXNDb252ZXhWYWxpZGF0b3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIktleSBhbmQgdmFsdWUgb2Ygdi5yZWNvcmQoKSBidXQgYmUgdmFsaWRhdG9yc1wiKTtcbiAgICB9XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0IGpzb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IHRoaXMua2luZCxcbiAgICAgIC8vIFRoaXMgY2FzdCBpcyBuZWVkZWQgYmVjYXVzZSBUeXBlU2NyaXB0IHRoaW5rcyB0aGUga2V5IHR5cGUgaXMgdG9vIHdpZGVcbiAgICAgIGtleXM6IHRoaXMua2V5Lmpzb24sXG4gICAgICB2YWx1ZXM6IHtcbiAgICAgICAgZmllbGRUeXBlOiB0aGlzLnZhbHVlLmpzb24sXG4gICAgICAgIG9wdGlvbmFsOiBmYWxzZVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBhc09wdGlvbmFsKCkge1xuICAgIHJldHVybiBuZXcgVlJlY29yZCh7XG4gICAgICBpc09wdGlvbmFsOiBcIm9wdGlvbmFsXCIsXG4gICAgICBrZXk6IHRoaXMua2V5LFxuICAgICAgdmFsdWU6IHRoaXMudmFsdWVcbiAgICB9KTtcbiAgfVxufVxuZXhwb3J0IGNsYXNzIFZVbmlvbiBleHRlbmRzIEJhc2VWYWxpZGF0b3Ige1xuICAvKipcbiAgICogVXN1YWxseSB5b3UnZCB1c2UgYHYudW5pb24oLi4ubWVtYmVycylgIGluc3RlYWQuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGlzT3B0aW9uYWwsIG1lbWJlcnMgfSkge1xuICAgIHN1cGVyKHsgaXNPcHRpb25hbCB9KTtcbiAgICAvKipcbiAgICAgKiBUaGUgYXJyYXkgb2YgdmFsaWRhdG9ycywgb25lIG9mIHdoaWNoIG11c3QgbWF0Y2ggdGhlIHZhbHVlLlxuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtZW1iZXJzXCIpO1xuICAgIC8qKlxuICAgICAqIFRoZSBraW5kIG9mIHZhbGlkYXRvciwgYFwidW5pb25cImAuXG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImtpbmRcIiwgXCJ1bmlvblwiKTtcbiAgICBtZW1iZXJzLmZvckVhY2goKG1lbWJlciwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChtZW1iZXIgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvd1VuZGVmaW5lZFZhbGlkYXRvckVycm9yKFwidi51bmlvbigpXCIsIGBtZW1iZXIgYXQgaW5kZXggJHtpbmRleH1gKTtcbiAgICAgIH1cbiAgICAgIGlmICghbWVtYmVyLmlzQ29udmV4VmFsaWRhdG9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFsbCBtZW1iZXJzIG9mIHYudW5pb24oKSBtdXN0IGJlIHZhbGlkYXRvcnNcIik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5tZW1iZXJzID0gbWVtYmVycztcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBqc29uKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiB0aGlzLmtpbmQsXG4gICAgICB2YWx1ZTogdGhpcy5tZW1iZXJzLm1hcCgodikgPT4gdi5qc29uKVxuICAgIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBhc09wdGlvbmFsKCkge1xuICAgIHJldHVybiBuZXcgVlVuaW9uKHtcbiAgICAgIGlzT3B0aW9uYWw6IFwib3B0aW9uYWxcIixcbiAgICAgIG1lbWJlcnM6IHRoaXMubWVtYmVyc1xuICAgIH0pO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWxpZGF0b3JzLmpzLm1hcFxuIiwiaW1wb3J0IHsgRXhwYW5kIH0gZnJvbSBcIi4uL3R5cGVfdXRpbHMuanNcIjtcbmltcG9ydCB7IEdlbmVyaWNJZCB9IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBHZW5lcmljVmFsaWRhdG9yLCBPYmplY3RUeXBlIH0gZnJvbSBcIi4vdmFsaWRhdG9yLmpzXCI7XG5pbXBvcnQgeyBKU09OVmFsdWUsIGNvbnZleFRvSnNvbiB9IGZyb20gXCIuL3ZhbHVlLmpzXCI7XG5cbnR5cGUgVGFibGVOYW1lRnJvbVR5cGU8VD4gPVxuICBUIGV4dGVuZHMgR2VuZXJpY0lkPGluZmVyIFRhYmxlTmFtZT4gPyBUYWJsZU5hbWUgOiBzdHJpbmc7XG5cbmNvbnN0IFVOREVGSU5FRF9WQUxJREFUT1JfRVJST1JfVVJMID1cbiAgXCJodHRwczovL2RvY3MuY29udmV4LmRldi9lcnJvciN1bmRlZmluZWQtdmFsaWRhdG9yXCI7XG5cbmZ1bmN0aW9uIHRocm93VW5kZWZpbmVkVmFsaWRhdG9yRXJyb3IoXG4gIGNvbnRleHQ6IHN0cmluZyxcbiAgZmllbGROYW1lPzogc3RyaW5nLFxuKTogbmV2ZXIge1xuICBjb25zdCBmaWVsZEluZm8gPSBmaWVsZE5hbWUgIT09IHVuZGVmaW5lZCA/IGAgZm9yIGZpZWxkIFwiJHtmaWVsZE5hbWV9XCJgIDogXCJcIjtcbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgIGBBIHZhbGlkYXRvciBpcyB1bmRlZmluZWQke2ZpZWxkSW5mb30gaW4gJHtjb250ZXh0fS4gYCArXG4gICAgICBgVGhpcyBpcyBvZnRlbiBjYXVzZWQgYnkgY2lyY3VsYXIgaW1wb3J0cy4gYCArXG4gICAgICBgU2VlICR7VU5ERUZJTkVEX1ZBTElEQVRPUl9FUlJPUl9VUkx9IGZvciBkZXRhaWxzLmAsXG4gICk7XG59XG5cbi8qKlxuICogQXZvaWQgdXNpbmcgYGluc3RhbmNlb2YgQmFzZVZhbGlkYXRvcmA7IHRoaXMgaXMgaW5oZXJpdGVuY2UgZm9yIGNvZGUgcmV1c2VcbiAqIG5vdCB0eXBlIGhlaXJhcmNoeS5cbiAqL1xuYWJzdHJhY3QgY2xhc3MgQmFzZVZhbGlkYXRvcjxcbiAgVHlwZSxcbiAgSXNPcHRpb25hbCBleHRlbmRzIE9wdGlvbmFsUHJvcGVydHkgPSBcInJlcXVpcmVkXCIsXG4gIEZpZWxkUGF0aHMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbj4ge1xuICAvKipcbiAgICogT25seSBmb3IgVHlwZVNjcmlwdCwgdGhlIFRTIHR5cGUgb2YgdGhlIEpTIHZhbHVlcyB2YWxpZGF0ZWRcbiAgICogYnkgdGhpcyB2YWxpZGF0b3IuXG4gICAqL1xuICByZWFkb25seSB0eXBlITogVHlwZTtcbiAgLyoqXG4gICAqIE9ubHkgZm9yIFR5cGVTY3JpcHQsIGlmIHRoaXMgYW4gT2JqZWN0IHZhbGlkYXRvciwgdGhlblxuICAgKiB0aGlzIGlzIHRoZSBUUyB0eXBlIG9mIGl0cyBwcm9wZXJ0eSBuYW1lcy5cbiAgICovXG4gIHJlYWRvbmx5IGZpZWxkUGF0aHMhOiBGaWVsZFBhdGhzO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoaXMgaXMgYW4gb3B0aW9uYWwgT2JqZWN0IHByb3BlcnR5IHZhbHVlIHZhbGlkYXRvci5cbiAgICovXG4gIHJlYWRvbmx5IGlzT3B0aW9uYWw6IElzT3B0aW9uYWw7XG5cbiAgLyoqXG4gICAqIEFsd2F5cyBgXCJ0cnVlXCJgLlxuICAgKi9cbiAgcmVhZG9ubHkgaXNDb252ZXhWYWxpZGF0b3I6IHRydWU7XG5cbiAgY29uc3RydWN0b3IoeyBpc09wdGlvbmFsIH06IHsgaXNPcHRpb25hbDogSXNPcHRpb25hbCB9KSB7XG4gICAgdGhpcy5pc09wdGlvbmFsID0gaXNPcHRpb25hbDtcbiAgICB0aGlzLmlzQ29udmV4VmFsaWRhdG9yID0gdHJ1ZTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGFic3RyYWN0IGdldCBqc29uKCk6IFZhbGlkYXRvckpTT047XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgYWJzdHJhY3QgYXNPcHRpb25hbCgpOiBWYWxpZGF0b3I8VHlwZSB8IHVuZGVmaW5lZCwgXCJvcHRpb25hbFwiLCBGaWVsZFBhdGhzPjtcbn1cblxuLyoqXG4gKiBUaGUgdHlwZSBvZiB0aGUgYHYuaWQodGFibGVOYW1lKWAgdmFsaWRhdG9yLlxuICovXG5leHBvcnQgY2xhc3MgVklkPFxuICBUeXBlLFxuICBJc09wdGlvbmFsIGV4dGVuZHMgT3B0aW9uYWxQcm9wZXJ0eSA9IFwicmVxdWlyZWRcIixcbj4gZXh0ZW5kcyBCYXNlVmFsaWRhdG9yPFR5cGUsIElzT3B0aW9uYWw+IHtcbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSB0YWJsZSB0aGF0IHRoZSB2YWxpZGF0ZWQgSURzIG11c3QgYmVsb25nIHRvLlxuICAgKi9cbiAgcmVhZG9ubHkgdGFibGVOYW1lOiBUYWJsZU5hbWVGcm9tVHlwZTxUeXBlPjtcblxuICAvKipcbiAgICogVGhlIGtpbmQgb2YgdmFsaWRhdG9yLCBgXCJpZFwiYC5cbiAgICovXG4gIHJlYWRvbmx5IGtpbmQgPSBcImlkXCIgYXMgY29uc3Q7XG5cbiAgLyoqXG4gICAqIFVzdWFsbHkgeW91J2QgdXNlIGB2LmlkKHRhYmxlTmFtZSlgIGluc3RlYWQuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgaXNPcHRpb25hbCxcbiAgICB0YWJsZU5hbWUsXG4gIH06IHtcbiAgICBpc09wdGlvbmFsOiBJc09wdGlvbmFsO1xuICAgIHRhYmxlTmFtZTogVGFibGVOYW1lRnJvbVR5cGU8VHlwZT47XG4gIH0pIHtcbiAgICBzdXBlcih7IGlzT3B0aW9uYWwgfSk7XG4gICAgaWYgKHR5cGVvZiB0YWJsZU5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInYuaWQodGFibGVOYW1lKSByZXF1aXJlcyBhIHN0cmluZ1wiKTtcbiAgICB9XG4gICAgdGhpcy50YWJsZU5hbWUgPSB0YWJsZU5hbWU7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQganNvbigpOiBWYWxpZGF0b3JKU09OIHtcbiAgICByZXR1cm4geyB0eXBlOiBcImlkXCIsIHRhYmxlTmFtZTogdGhpcy50YWJsZU5hbWUgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGFzT3B0aW9uYWwoKSB7XG4gICAgcmV0dXJuIG5ldyBWSWQ8VHlwZSB8IHVuZGVmaW5lZCwgXCJvcHRpb25hbFwiPih7XG4gICAgICBpc09wdGlvbmFsOiBcIm9wdGlvbmFsXCIsXG4gICAgICB0YWJsZU5hbWU6IHRoaXMudGFibGVOYW1lLFxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogVGhlIHR5cGUgb2YgdGhlIGB2LmZsb2F0NjQoKWAgdmFsaWRhdG9yLlxuICovXG5leHBvcnQgY2xhc3MgVkZsb2F0NjQ8XG4gIFR5cGUgPSBudW1iZXIsXG4gIElzT3B0aW9uYWwgZXh0ZW5kcyBPcHRpb25hbFByb3BlcnR5ID0gXCJyZXF1aXJlZFwiLFxuPiBleHRlbmRzIEJhc2VWYWxpZGF0b3I8VHlwZSwgSXNPcHRpb25hbD4ge1xuICAvKipcbiAgICogVGhlIGtpbmQgb2YgdmFsaWRhdG9yLCBgXCJmbG9hdDY0XCJgLlxuICAgKi9cbiAgcmVhZG9ubHkga2luZCA9IFwiZmxvYXQ2NFwiIGFzIGNvbnN0O1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0IGpzb24oKTogVmFsaWRhdG9ySlNPTiB7XG4gICAgLy8gU2VydmVyIGV4cGVjdHMgdGhlIG9sZCBuYW1lIGBudW1iZXJgIHN0cmluZyBpbnN0ZWFkIG9mIGBmbG9hdDY0YC5cbiAgICByZXR1cm4geyB0eXBlOiBcIm51bWJlclwiIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBhc09wdGlvbmFsKCkge1xuICAgIHJldHVybiBuZXcgVkZsb2F0NjQ8VHlwZSB8IHVuZGVmaW5lZCwgXCJvcHRpb25hbFwiPih7XG4gICAgICBpc09wdGlvbmFsOiBcIm9wdGlvbmFsXCIsXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgdHlwZSBvZiB0aGUgYHYuaW50NjQoKWAgdmFsaWRhdG9yLlxuICovXG5leHBvcnQgY2xhc3MgVkludDY0PFxuICBUeXBlID0gYmlnaW50LFxuICBJc09wdGlvbmFsIGV4dGVuZHMgT3B0aW9uYWxQcm9wZXJ0eSA9IFwicmVxdWlyZWRcIixcbj4gZXh0ZW5kcyBCYXNlVmFsaWRhdG9yPFR5cGUsIElzT3B0aW9uYWw+IHtcbiAgLyoqXG4gICAqIFRoZSBraW5kIG9mIHZhbGlkYXRvciwgYFwiaW50NjRcImAuXG4gICAqL1xuICByZWFkb25seSBraW5kID0gXCJpbnQ2NFwiIGFzIGNvbnN0O1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0IGpzb24oKTogVmFsaWRhdG9ySlNPTiB7XG4gICAgLy8gU2VydmVyIGV4cGVjdHMgdGhlIG9sZCBuYW1lIGBiaWdpbnRgLlxuICAgIHJldHVybiB7IHR5cGU6IFwiYmlnaW50XCIgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGFzT3B0aW9uYWwoKSB7XG4gICAgcmV0dXJuIG5ldyBWSW50NjQ8VHlwZSB8IHVuZGVmaW5lZCwgXCJvcHRpb25hbFwiPih7IGlzT3B0aW9uYWw6IFwib3B0aW9uYWxcIiB9KTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSB0eXBlIG9mIHRoZSBgdi5ib29sZWFuKClgIHZhbGlkYXRvci5cbiAqL1xuZXhwb3J0IGNsYXNzIFZCb29sZWFuPFxuICBUeXBlID0gYm9vbGVhbixcbiAgSXNPcHRpb25hbCBleHRlbmRzIE9wdGlvbmFsUHJvcGVydHkgPSBcInJlcXVpcmVkXCIsXG4+IGV4dGVuZHMgQmFzZVZhbGlkYXRvcjxUeXBlLCBJc09wdGlvbmFsPiB7XG4gIC8qKlxuICAgKiBUaGUga2luZCBvZiB2YWxpZGF0b3IsIGBcImJvb2xlYW5cImAuXG4gICAqL1xuICByZWFkb25seSBraW5kID0gXCJib29sZWFuXCIgYXMgY29uc3Q7XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQganNvbigpOiBWYWxpZGF0b3JKU09OIHtcbiAgICByZXR1cm4geyB0eXBlOiB0aGlzLmtpbmQgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGFzT3B0aW9uYWwoKSB7XG4gICAgcmV0dXJuIG5ldyBWQm9vbGVhbjxUeXBlIHwgdW5kZWZpbmVkLCBcIm9wdGlvbmFsXCI+KHtcbiAgICAgIGlzT3B0aW9uYWw6IFwib3B0aW9uYWxcIixcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSB0eXBlIG9mIHRoZSBgdi5ieXRlcygpYCB2YWxpZGF0b3IuXG4gKi9cbmV4cG9ydCBjbGFzcyBWQnl0ZXM8XG4gIFR5cGUgPSBBcnJheUJ1ZmZlcixcbiAgSXNPcHRpb25hbCBleHRlbmRzIE9wdGlvbmFsUHJvcGVydHkgPSBcInJlcXVpcmVkXCIsXG4+IGV4dGVuZHMgQmFzZVZhbGlkYXRvcjxUeXBlLCBJc09wdGlvbmFsPiB7XG4gIC8qKlxuICAgKiBUaGUga2luZCBvZiB2YWxpZGF0b3IsIGBcImJ5dGVzXCJgLlxuICAgKi9cbiAgcmVhZG9ubHkga2luZCA9IFwiYnl0ZXNcIiBhcyBjb25zdDtcblxuICAvKiogQGludGVybmFsICovXG4gIGdldCBqc29uKCk6IFZhbGlkYXRvckpTT04ge1xuICAgIHJldHVybiB7IHR5cGU6IHRoaXMua2luZCB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgYXNPcHRpb25hbCgpIHtcbiAgICByZXR1cm4gbmV3IFZCeXRlczxUeXBlIHwgdW5kZWZpbmVkLCBcIm9wdGlvbmFsXCI+KHsgaXNPcHRpb25hbDogXCJvcHRpb25hbFwiIH0pO1xuICB9XG59XG5cbi8qKlxuICogVGhlIHR5cGUgb2YgdGhlIGB2LnN0cmluZygpYCB2YWxpZGF0b3IuXG4gKi9cbmV4cG9ydCBjbGFzcyBWU3RyaW5nPFxuICBUeXBlID0gc3RyaW5nLFxuICBJc09wdGlvbmFsIGV4dGVuZHMgT3B0aW9uYWxQcm9wZXJ0eSA9IFwicmVxdWlyZWRcIixcbj4gZXh0ZW5kcyBCYXNlVmFsaWRhdG9yPFR5cGUsIElzT3B0aW9uYWw+IHtcbiAgLyoqXG4gICAqIFRoZSBraW5kIG9mIHZhbGlkYXRvciwgYFwic3RyaW5nXCJgLlxuICAgKi9cbiAgcmVhZG9ubHkga2luZCA9IFwic3RyaW5nXCIgYXMgY29uc3Q7XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQganNvbigpOiBWYWxpZGF0b3JKU09OIHtcbiAgICByZXR1cm4geyB0eXBlOiB0aGlzLmtpbmQgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGFzT3B0aW9uYWwoKSB7XG4gICAgcmV0dXJuIG5ldyBWU3RyaW5nPFR5cGUgfCB1bmRlZmluZWQsIFwib3B0aW9uYWxcIj4oe1xuICAgICAgaXNPcHRpb25hbDogXCJvcHRpb25hbFwiLFxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogVGhlIHR5cGUgb2YgdGhlIGB2Lm51bGwoKWAgdmFsaWRhdG9yLlxuICovXG5leHBvcnQgY2xhc3MgVk51bGw8XG4gIFR5cGUgPSBudWxsLFxuICBJc09wdGlvbmFsIGV4dGVuZHMgT3B0aW9uYWxQcm9wZXJ0eSA9IFwicmVxdWlyZWRcIixcbj4gZXh0ZW5kcyBCYXNlVmFsaWRhdG9yPFR5cGUsIElzT3B0aW9uYWw+IHtcbiAgLyoqXG4gICAqIFRoZSBraW5kIG9mIHZhbGlkYXRvciwgYFwibnVsbFwiYC5cbiAgICovXG4gIHJlYWRvbmx5IGtpbmQgPSBcIm51bGxcIiBhcyBjb25zdDtcblxuICAvKiogQGludGVybmFsICovXG4gIGdldCBqc29uKCk6IFZhbGlkYXRvckpTT04ge1xuICAgIHJldHVybiB7IHR5cGU6IHRoaXMua2luZCB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgYXNPcHRpb25hbCgpIHtcbiAgICByZXR1cm4gbmV3IFZOdWxsPFR5cGUgfCB1bmRlZmluZWQsIFwib3B0aW9uYWxcIj4oeyBpc09wdGlvbmFsOiBcIm9wdGlvbmFsXCIgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgdHlwZSBvZiB0aGUgYHYuYW55KClgIHZhbGlkYXRvci5cbiAqL1xuZXhwb3J0IGNsYXNzIFZBbnk8XG4gIFR5cGUgPSBhbnksXG4gIElzT3B0aW9uYWwgZXh0ZW5kcyBPcHRpb25hbFByb3BlcnR5ID0gXCJyZXF1aXJlZFwiLFxuICBGaWVsZFBhdGhzIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nLFxuPiBleHRlbmRzIEJhc2VWYWxpZGF0b3I8VHlwZSwgSXNPcHRpb25hbCwgRmllbGRQYXRocz4ge1xuICAvKipcbiAgICogVGhlIGtpbmQgb2YgdmFsaWRhdG9yLCBgXCJhbnlcImAuXG4gICAqL1xuICByZWFkb25seSBraW5kID0gXCJhbnlcIiBhcyBjb25zdDtcblxuICAvKiogQGludGVybmFsICovXG4gIGdldCBqc29uKCk6IFZhbGlkYXRvckpTT04ge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiB0aGlzLmtpbmQsXG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGFzT3B0aW9uYWwoKSB7XG4gICAgcmV0dXJuIG5ldyBWQW55PFR5cGUgfCB1bmRlZmluZWQsIFwib3B0aW9uYWxcIiwgRmllbGRQYXRocz4oe1xuICAgICAgaXNPcHRpb25hbDogXCJvcHRpb25hbFwiLFxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogVGhlIHR5cGUgb2YgdGhlIGB2Lm9iamVjdCgpYCB2YWxpZGF0b3IuXG4gKi9cbmV4cG9ydCBjbGFzcyBWT2JqZWN0PFxuICBUeXBlLFxuICBGaWVsZHMgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBHZW5lcmljVmFsaWRhdG9yPixcbiAgSXNPcHRpb25hbCBleHRlbmRzIE9wdGlvbmFsUHJvcGVydHkgPSBcInJlcXVpcmVkXCIsXG4gIEZpZWxkUGF0aHMgZXh0ZW5kcyBzdHJpbmcgPSB7XG4gICAgW1Byb3BlcnR5IGluIGtleW9mIEZpZWxkc106XG4gICAgICB8IEpvaW5GaWVsZFBhdGhzPFByb3BlcnR5ICYgc3RyaW5nLCBGaWVsZHNbUHJvcGVydHldW1wiZmllbGRQYXRoc1wiXT5cbiAgICAgIHwgUHJvcGVydHk7XG4gIH1ba2V5b2YgRmllbGRzXSAmXG4gICAgc3RyaW5nLFxuPiBleHRlbmRzIEJhc2VWYWxpZGF0b3I8VHlwZSwgSXNPcHRpb25hbCwgRmllbGRQYXRocz4ge1xuICAvKipcbiAgICogQW4gb2JqZWN0IHdpdGggdGhlIHZhbGlkYXRvciBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAgICovXG4gIHJlYWRvbmx5IGZpZWxkczogRmllbGRzO1xuXG4gIC8qKlxuICAgKiBUaGUga2luZCBvZiB2YWxpZGF0b3IsIGBcIm9iamVjdFwiYC5cbiAgICovXG4gIHJlYWRvbmx5IGtpbmQgPSBcIm9iamVjdFwiIGFzIGNvbnN0O1xuXG4gIC8qKlxuICAgKiBVc3VhbGx5IHlvdSdkIHVzZSBgdi5vYmplY3QoeyAuLi4gfSlgIGluc3RlYWQuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgaXNPcHRpb25hbCxcbiAgICBmaWVsZHMsXG4gIH06IHtcbiAgICBpc09wdGlvbmFsOiBJc09wdGlvbmFsO1xuICAgIGZpZWxkczogRmllbGRzO1xuICB9KSB7XG4gICAgc3VwZXIoeyBpc09wdGlvbmFsIH0pO1xuICAgIGdsb2JhbFRoaXMuT2JqZWN0LmVudHJpZXMoZmllbGRzKS5mb3JFYWNoKChbZmllbGROYW1lLCB2YWxpZGF0b3JdKSA9PiB7XG4gICAgICBpZiAodmFsaWRhdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3dVbmRlZmluZWRWYWxpZGF0b3JFcnJvcihcInYub2JqZWN0KClcIiwgZmllbGROYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmICghdmFsaWRhdG9yLmlzQ29udmV4VmFsaWRhdG9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInYub2JqZWN0KCkgZW50cmllcyBtdXN0IGJlIHZhbGlkYXRvcnNcIik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5maWVsZHMgPSBmaWVsZHM7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQganNvbigpOiBWYWxpZGF0b3JKU09OIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogdGhpcy5raW5kLFxuICAgICAgdmFsdWU6IGdsb2JhbFRoaXMuT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICBnbG9iYWxUaGlzLk9iamVjdC5lbnRyaWVzKHRoaXMuZmllbGRzKS5tYXAoKFtrLCB2XSkgPT4gW1xuICAgICAgICAgIGssXG4gICAgICAgICAge1xuICAgICAgICAgICAgZmllbGRUeXBlOiB2Lmpzb24sXG4gICAgICAgICAgICBvcHRpb25hbDogdi5pc09wdGlvbmFsID09PSBcIm9wdGlvbmFsXCIgPyB0cnVlIDogZmFsc2UsXG4gICAgICAgICAgfSxcbiAgICAgICAgXSksXG4gICAgICApLFxuICAgIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBhc09wdGlvbmFsKCkge1xuICAgIHJldHVybiBuZXcgVk9iamVjdDxUeXBlIHwgdW5kZWZpbmVkLCBGaWVsZHMsIFwib3B0aW9uYWxcIiwgRmllbGRQYXRocz4oe1xuICAgICAgaXNPcHRpb25hbDogXCJvcHRpb25hbFwiLFxuICAgICAgZmllbGRzOiB0aGlzLmZpZWxkcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgVk9iamVjdCB3aXRoIHRoZSBzcGVjaWZpZWQgZmllbGRzIG9taXR0ZWQuXG4gICAqIEBwYXJhbSBmaWVsZHMgVGhlIGZpZWxkIG5hbWVzIHRvIG9taXQgZnJvbSB0aGlzIFZPYmplY3QuXG4gICAqL1xuICBvbWl0PEsgZXh0ZW5kcyBrZXlvZiBGaWVsZHMgJiBzdHJpbmc+KFxuICAgIC4uLmZpZWxkczogS1tdXG4gICk6IFZPYmplY3Q8RXhwYW5kPE9taXQ8VHlwZSwgSz4+LCBFeHBhbmQ8T21pdDxGaWVsZHMsIEs+PiwgSXNPcHRpb25hbD4ge1xuICAgIGNvbnN0IG5ld0ZpZWxkcyA9IHsgLi4udGhpcy5maWVsZHMgfTtcbiAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGZpZWxkcykge1xuICAgICAgZGVsZXRlIG5ld0ZpZWxkc1tmaWVsZF07XG4gICAgfVxuICAgIHJldHVybiBuZXcgVk9iamVjdCh7XG4gICAgICBpc09wdGlvbmFsOiB0aGlzLmlzT3B0aW9uYWwsXG4gICAgICBmaWVsZHM6IG5ld0ZpZWxkcyBhcyBhbnksXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFZPYmplY3Qgd2l0aCBvbmx5IHRoZSBzcGVjaWZpZWQgZmllbGRzLlxuICAgKiBAcGFyYW0gZmllbGRzIFRoZSBmaWVsZCBuYW1lcyB0byBwaWNrIGZyb20gdGhpcyBWT2JqZWN0LlxuICAgKi9cbiAgcGljazxLIGV4dGVuZHMga2V5b2YgRmllbGRzICYgc3RyaW5nPihcbiAgICAuLi5maWVsZHM6IEtbXVxuICApOiBWT2JqZWN0PFxuICAgIEV4cGFuZDxQaWNrPFR5cGUsIEV4dHJhY3Q8a2V5b2YgVHlwZSwgSz4+PixcbiAgICBFeHBhbmQ8UGljazxGaWVsZHMsIEs+PixcbiAgICBJc09wdGlvbmFsXG4gID4ge1xuICAgIGNvbnN0IG5ld0ZpZWxkczogUmVjb3JkPHN0cmluZywgR2VuZXJpY1ZhbGlkYXRvcj4gPSB7fTtcbiAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGZpZWxkcykge1xuICAgICAgbmV3RmllbGRzW2ZpZWxkXSA9IHRoaXMuZmllbGRzW2ZpZWxkXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBWT2JqZWN0KHtcbiAgICAgIGlzT3B0aW9uYWw6IHRoaXMuaXNPcHRpb25hbCxcbiAgICAgIGZpZWxkczogbmV3RmllbGRzIGFzIEV4cGFuZDxQaWNrPEZpZWxkcywgSz4+LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBWT2JqZWN0IHdpdGggYWxsIGZpZWxkcyBtYXJrZWQgYXMgb3B0aW9uYWwuXG4gICAqL1xuICBwYXJ0aWFsKCk6IFZPYmplY3Q8XG4gICAgeyBbSyBpbiBrZXlvZiBUeXBlXT86IFR5cGVbS10gfSxcbiAgICB7IFtLIGluIGtleW9mIEZpZWxkc106IFZPcHRpb25hbDxGaWVsZHNbS10+IH0sXG4gICAgSXNPcHRpb25hbFxuICA+IHtcbiAgICBjb25zdCBuZXdGaWVsZHM6IFJlY29yZDxzdHJpbmcsIEdlbmVyaWNWYWxpZGF0b3I+ID0ge307XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWxpZGF0b3JdIG9mIGdsb2JhbFRoaXMuT2JqZWN0LmVudHJpZXModGhpcy5maWVsZHMpKSB7XG4gICAgICBuZXdGaWVsZHNba2V5XSA9IHZhbGlkYXRvci5hc09wdGlvbmFsKCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVk9iamVjdCh7XG4gICAgICBpc09wdGlvbmFsOiB0aGlzLmlzT3B0aW9uYWwsXG4gICAgICBmaWVsZHM6IG5ld0ZpZWxkcyBhcyB7XG4gICAgICAgIFtLIGluIGtleW9mIEZpZWxkc106IFZPcHRpb25hbDxGaWVsZHNbS10+O1xuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgVk9iamVjdCB3aXRoIGFkZGl0aW9uYWwgZmllbGRzIG1lcmdlZCBpbi5cbiAgICogQHBhcmFtIGZpZWxkcyBBbiBvYmplY3Qgd2l0aCBhZGRpdGlvbmFsIHZhbGlkYXRvcnMgdG8gbWVyZ2UgaW50byB0aGlzIFZPYmplY3QuXG4gICAqL1xuICBleHRlbmQ8TmV3RmllbGRzIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgR2VuZXJpY1ZhbGlkYXRvcj4+KFxuICAgIGZpZWxkczogTmV3RmllbGRzLFxuICApOiBWT2JqZWN0PFxuICAgIEV4cGFuZDxUeXBlICYgT2JqZWN0VHlwZTxOZXdGaWVsZHM+PixcbiAgICBFeHBhbmQ8RmllbGRzICYgTmV3RmllbGRzPixcbiAgICBJc09wdGlvbmFsXG4gID4ge1xuICAgIHJldHVybiBuZXcgVk9iamVjdCh7XG4gICAgICBpc09wdGlvbmFsOiB0aGlzLmlzT3B0aW9uYWwsXG4gICAgICBmaWVsZHM6IHsgLi4udGhpcy5maWVsZHMsIC4uLmZpZWxkcyB9IGFzIEV4cGFuZDxGaWVsZHMgJiBOZXdGaWVsZHM+LFxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogVGhlIHR5cGUgb2YgdGhlIGB2LmxpdGVyYWwoKWAgdmFsaWRhdG9yLlxuICovXG5leHBvcnQgY2xhc3MgVkxpdGVyYWw8XG4gIFR5cGUsXG4gIElzT3B0aW9uYWwgZXh0ZW5kcyBPcHRpb25hbFByb3BlcnR5ID0gXCJyZXF1aXJlZFwiLFxuPiBleHRlbmRzIEJhc2VWYWxpZGF0b3I8VHlwZSwgSXNPcHRpb25hbD4ge1xuICAvKipcbiAgICogVGhlIHZhbHVlIHRoYXQgdGhlIHZhbGlkYXRlZCB2YWx1ZXMgbXVzdCBiZSBlcXVhbCB0by5cbiAgICovXG4gIHJlYWRvbmx5IHZhbHVlOiBUeXBlO1xuXG4gIC8qKlxuICAgKiBUaGUga2luZCBvZiB2YWxpZGF0b3IsIGBcImxpdGVyYWxcImAuXG4gICAqL1xuICByZWFkb25seSBraW5kID0gXCJsaXRlcmFsXCIgYXMgY29uc3Q7XG5cbiAgLyoqXG4gICAqIFVzdWFsbHkgeW91J2QgdXNlIGB2LmxpdGVyYWwodmFsdWUpYCBpbnN0ZWFkLlxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBpc09wdGlvbmFsLCB2YWx1ZSB9OiB7IGlzT3B0aW9uYWw6IElzT3B0aW9uYWw7IHZhbHVlOiBUeXBlIH0pIHtcbiAgICBzdXBlcih7IGlzT3B0aW9uYWwgfSk7XG4gICAgaWYgKFxuICAgICAgdHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiICYmXG4gICAgICB0eXBlb2YgdmFsdWUgIT09IFwiYm9vbGVhblwiICYmXG4gICAgICB0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZSAhPT0gXCJiaWdpbnRcIlxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidi5saXRlcmFsKHZhbHVlKSBtdXN0IGJlIGEgc3RyaW5nLCBudW1iZXIsIG9yIGJvb2xlYW5cIik7XG4gICAgfVxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBqc29uKCk6IFZhbGlkYXRvckpTT04ge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiB0aGlzLmtpbmQsXG4gICAgICB2YWx1ZTogY29udmV4VG9Kc29uKHRoaXMudmFsdWUgYXMgc3RyaW5nIHwgYm9vbGVhbiB8IG51bWJlciB8IGJpZ2ludCksXG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGFzT3B0aW9uYWwoKSB7XG4gICAgcmV0dXJuIG5ldyBWTGl0ZXJhbDxUeXBlIHwgdW5kZWZpbmVkLCBcIm9wdGlvbmFsXCI+KHtcbiAgICAgIGlzT3B0aW9uYWw6IFwib3B0aW9uYWxcIixcbiAgICAgIHZhbHVlOiB0aGlzLnZhbHVlLFxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogVGhlIHR5cGUgb2YgdGhlIGB2LmFycmF5KClgIHZhbGlkYXRvci5cbiAqL1xuZXhwb3J0IGNsYXNzIFZBcnJheTxcbiAgVHlwZSxcbiAgRWxlbWVudCBleHRlbmRzIFZhbGlkYXRvcjxhbnksIFwicmVxdWlyZWRcIiwgYW55PixcbiAgSXNPcHRpb25hbCBleHRlbmRzIE9wdGlvbmFsUHJvcGVydHkgPSBcInJlcXVpcmVkXCIsXG4+IGV4dGVuZHMgQmFzZVZhbGlkYXRvcjxUeXBlLCBJc09wdGlvbmFsPiB7XG4gIC8qKlxuICAgKiBUaGUgdmFsaWRhdG9yIGZvciB0aGUgZWxlbWVudHMgb2YgdGhlIGFycmF5LlxuICAgKi9cbiAgcmVhZG9ubHkgZWxlbWVudDogRWxlbWVudDtcblxuICAvKipcbiAgICogVGhlIGtpbmQgb2YgdmFsaWRhdG9yLCBgXCJhcnJheVwiYC5cbiAgICovXG4gIHJlYWRvbmx5IGtpbmQgPSBcImFycmF5XCIgYXMgY29uc3Q7XG5cbiAgLyoqXG4gICAqIFVzdWFsbHkgeW91J2QgdXNlIGB2LmFycmF5KGVsZW1lbnQpYCBpbnN0ZWFkLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIGlzT3B0aW9uYWwsXG4gICAgZWxlbWVudCxcbiAgfToge1xuICAgIGlzT3B0aW9uYWw6IElzT3B0aW9uYWw7XG4gICAgZWxlbWVudDogRWxlbWVudDtcbiAgfSkge1xuICAgIHN1cGVyKHsgaXNPcHRpb25hbCB9KTtcbiAgICBpZiAoZWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvd1VuZGVmaW5lZFZhbGlkYXRvckVycm9yKFwidi5hcnJheSgpXCIpO1xuICAgIH1cbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0IGpzb24oKTogVmFsaWRhdG9ySlNPTiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IHRoaXMua2luZCxcbiAgICAgIHZhbHVlOiB0aGlzLmVsZW1lbnQuanNvbixcbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgYXNPcHRpb25hbCgpIHtcbiAgICByZXR1cm4gbmV3IFZBcnJheTxUeXBlIHwgdW5kZWZpbmVkLCBFbGVtZW50LCBcIm9wdGlvbmFsXCI+KHtcbiAgICAgIGlzT3B0aW9uYWw6IFwib3B0aW9uYWxcIixcbiAgICAgIGVsZW1lbnQ6IHRoaXMuZWxlbWVudCxcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSB0eXBlIG9mIHRoZSBgdi5yZWNvcmQoKWAgdmFsaWRhdG9yLlxuICovXG5leHBvcnQgY2xhc3MgVlJlY29yZDxcbiAgVHlwZSxcbiAgS2V5IGV4dGVuZHMgVmFsaWRhdG9yPHN0cmluZywgXCJyZXF1aXJlZFwiLCBhbnk+LFxuICBWYWx1ZSBleHRlbmRzIFZhbGlkYXRvcjxhbnksIFwicmVxdWlyZWRcIiwgYW55PixcbiAgSXNPcHRpb25hbCBleHRlbmRzIE9wdGlvbmFsUHJvcGVydHkgPSBcInJlcXVpcmVkXCIsXG4gIEZpZWxkUGF0aHMgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmcsXG4+IGV4dGVuZHMgQmFzZVZhbGlkYXRvcjxUeXBlLCBJc09wdGlvbmFsLCBGaWVsZFBhdGhzPiB7XG4gIC8qKlxuICAgKiBUaGUgdmFsaWRhdG9yIGZvciB0aGUga2V5cyBvZiB0aGUgcmVjb3JkLlxuICAgKi9cbiAgcmVhZG9ubHkga2V5OiBLZXk7XG5cbiAgLyoqXG4gICAqIFRoZSB2YWxpZGF0b3IgZm9yIHRoZSB2YWx1ZXMgb2YgdGhlIHJlY29yZC5cbiAgICovXG4gIHJlYWRvbmx5IHZhbHVlOiBWYWx1ZTtcblxuICAvKipcbiAgICogVGhlIGtpbmQgb2YgdmFsaWRhdG9yLCBgXCJyZWNvcmRcImAuXG4gICAqL1xuICByZWFkb25seSBraW5kID0gXCJyZWNvcmRcIiBhcyBjb25zdDtcblxuICAvKipcbiAgICogVXN1YWxseSB5b3UnZCB1c2UgYHYucmVjb3JkKGtleSwgdmFsdWUpYCBpbnN0ZWFkLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIGlzT3B0aW9uYWwsXG4gICAga2V5LFxuICAgIHZhbHVlLFxuICB9OiB7XG4gICAgaXNPcHRpb25hbDogSXNPcHRpb25hbDtcbiAgICBrZXk6IEtleTtcbiAgICB2YWx1ZTogVmFsdWU7XG4gIH0pIHtcbiAgICBzdXBlcih7IGlzT3B0aW9uYWwgfSk7XG4gICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvd1VuZGVmaW5lZFZhbGlkYXRvckVycm9yKFwidi5yZWNvcmQoKVwiLCBcImtleVwiKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93VW5kZWZpbmVkVmFsaWRhdG9yRXJyb3IoXCJ2LnJlY29yZCgpXCIsIFwidmFsdWVcIik7XG4gICAgfVxuICAgIGlmICgoa2V5LmlzT3B0aW9uYWwgYXMgT3B0aW9uYWxQcm9wZXJ0eSkgPT09IFwib3B0aW9uYWxcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVjb3JkIHZhbGlkYXRvciBjYW5ub3QgaGF2ZSBvcHRpb25hbCBrZXlzXCIpO1xuICAgIH1cbiAgICBpZiAoKHZhbHVlLmlzT3B0aW9uYWwgYXMgT3B0aW9uYWxQcm9wZXJ0eSkgPT09IFwib3B0aW9uYWxcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVjb3JkIHZhbGlkYXRvciBjYW5ub3QgaGF2ZSBvcHRpb25hbCB2YWx1ZXNcIik7XG4gICAgfVxuICAgIGlmICgha2V5LmlzQ29udmV4VmFsaWRhdG9yIHx8ICF2YWx1ZS5pc0NvbnZleFZhbGlkYXRvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5IGFuZCB2YWx1ZSBvZiB2LnJlY29yZCgpIGJ1dCBiZSB2YWxpZGF0b3JzXCIpO1xuICAgIH1cbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQganNvbigpOiBWYWxpZGF0b3JKU09OIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogdGhpcy5raW5kLFxuICAgICAgLy8gVGhpcyBjYXN0IGlzIG5lZWRlZCBiZWNhdXNlIFR5cGVTY3JpcHQgdGhpbmtzIHRoZSBrZXkgdHlwZSBpcyB0b28gd2lkZVxuICAgICAga2V5czogdGhpcy5rZXkuanNvbiBhcyBSZWNvcmRLZXlWYWxpZGF0b3JKU09OLFxuICAgICAgdmFsdWVzOiB7XG4gICAgICAgIGZpZWxkVHlwZTogdGhpcy52YWx1ZS5qc29uLFxuICAgICAgICBvcHRpb25hbDogZmFsc2UsXG4gICAgICB9LFxuICAgIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBhc09wdGlvbmFsKCkge1xuICAgIHJldHVybiBuZXcgVlJlY29yZDxUeXBlIHwgdW5kZWZpbmVkLCBLZXksIFZhbHVlLCBcIm9wdGlvbmFsXCIsIEZpZWxkUGF0aHM+KHtcbiAgICAgIGlzT3B0aW9uYWw6IFwib3B0aW9uYWxcIixcbiAgICAgIGtleTogdGhpcy5rZXksXG4gICAgICB2YWx1ZTogdGhpcy52YWx1ZSxcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSB0eXBlIG9mIHRoZSBgdi51bmlvbigpYCB2YWxpZGF0b3IuXG4gKi9cbmV4cG9ydCBjbGFzcyBWVW5pb248XG4gIFR5cGUsXG4gIFQgZXh0ZW5kcyBWYWxpZGF0b3I8YW55LCBcInJlcXVpcmVkXCIsIGFueT5bXSxcbiAgSXNPcHRpb25hbCBleHRlbmRzIE9wdGlvbmFsUHJvcGVydHkgPSBcInJlcXVpcmVkXCIsXG4gIEZpZWxkUGF0aHMgZXh0ZW5kcyBzdHJpbmcgPSBUW251bWJlcl1bXCJmaWVsZFBhdGhzXCJdLFxuPiBleHRlbmRzIEJhc2VWYWxpZGF0b3I8VHlwZSwgSXNPcHRpb25hbCwgRmllbGRQYXRocz4ge1xuICAvKipcbiAgICogVGhlIGFycmF5IG9mIHZhbGlkYXRvcnMsIG9uZSBvZiB3aGljaCBtdXN0IG1hdGNoIHRoZSB2YWx1ZS5cbiAgICovXG4gIHJlYWRvbmx5IG1lbWJlcnM6IFQ7XG5cbiAgLyoqXG4gICAqIFRoZSBraW5kIG9mIHZhbGlkYXRvciwgYFwidW5pb25cImAuXG4gICAqL1xuICByZWFkb25seSBraW5kID0gXCJ1bmlvblwiIGFzIGNvbnN0O1xuXG4gIC8qKlxuICAgKiBVc3VhbGx5IHlvdSdkIHVzZSBgdi51bmlvbiguLi5tZW1iZXJzKWAgaW5zdGVhZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgaXNPcHRpb25hbCwgbWVtYmVycyB9OiB7IGlzT3B0aW9uYWw6IElzT3B0aW9uYWw7IG1lbWJlcnM6IFQgfSkge1xuICAgIHN1cGVyKHsgaXNPcHRpb25hbCB9KTtcbiAgICBtZW1iZXJzLmZvckVhY2goKG1lbWJlciwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChtZW1iZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvd1VuZGVmaW5lZFZhbGlkYXRvckVycm9yKFwidi51bmlvbigpXCIsIGBtZW1iZXIgYXQgaW5kZXggJHtpbmRleH1gKTtcbiAgICAgIH1cbiAgICAgIGlmICghbWVtYmVyLmlzQ29udmV4VmFsaWRhdG9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFsbCBtZW1iZXJzIG9mIHYudW5pb24oKSBtdXN0IGJlIHZhbGlkYXRvcnNcIik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5tZW1iZXJzID0gbWVtYmVycztcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBqc29uKCk6IFZhbGlkYXRvckpTT04ge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiB0aGlzLmtpbmQsXG4gICAgICB2YWx1ZTogdGhpcy5tZW1iZXJzLm1hcCgodikgPT4gdi5qc29uKSxcbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgYXNPcHRpb25hbCgpIHtcbiAgICByZXR1cm4gbmV3IFZVbmlvbjxUeXBlIHwgdW5kZWZpbmVkLCBULCBcIm9wdGlvbmFsXCI+KHtcbiAgICAgIGlzT3B0aW9uYWw6IFwib3B0aW9uYWxcIixcbiAgICAgIG1lbWJlcnM6IHRoaXMubWVtYmVycyxcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBwcmV0dGllci1pZ25vcmVcbmV4cG9ydCB0eXBlIFZPcHRpb25hbDxUIGV4dGVuZHMgVmFsaWRhdG9yPGFueSwgT3B0aW9uYWxQcm9wZXJ0eSwgYW55Pj4gPVxuICBUIGV4dGVuZHMgVklkPGluZmVyIFR5cGUsIE9wdGlvbmFsUHJvcGVydHk+ID8gVklkPFR5cGUgfCB1bmRlZmluZWQsIFwib3B0aW9uYWxcIj5cbiAgOiBUIGV4dGVuZHMgVlN0cmluZzxpbmZlciBUeXBlLCBPcHRpb25hbFByb3BlcnR5PlxuICAgID8gVlN0cmluZzxUeXBlIHwgdW5kZWZpbmVkLCBcIm9wdGlvbmFsXCI+XG4gIDogVCBleHRlbmRzIFZGbG9hdDY0PGluZmVyIFR5cGUsIE9wdGlvbmFsUHJvcGVydHk+XG4gICAgPyBWRmxvYXQ2NDxUeXBlIHwgdW5kZWZpbmVkLCBcIm9wdGlvbmFsXCI+XG4gIDogVCBleHRlbmRzIFZJbnQ2NDxpbmZlciBUeXBlLCBPcHRpb25hbFByb3BlcnR5PlxuICAgID8gVkludDY0PFR5cGUgfCB1bmRlZmluZWQsIFwib3B0aW9uYWxcIj5cbiAgOiBUIGV4dGVuZHMgVkJvb2xlYW48aW5mZXIgVHlwZSwgT3B0aW9uYWxQcm9wZXJ0eT5cbiAgICA/IFZCb29sZWFuPFR5cGUgfCB1bmRlZmluZWQsIFwib3B0aW9uYWxcIj5cbiAgOiBUIGV4dGVuZHMgVk51bGw8aW5mZXIgVHlwZSwgT3B0aW9uYWxQcm9wZXJ0eT5cbiAgICA/IFZOdWxsPFR5cGUgfCB1bmRlZmluZWQsIFwib3B0aW9uYWxcIj5cbiAgOiBUIGV4dGVuZHMgVkFueTxpbmZlciBUeXBlLCBPcHRpb25hbFByb3BlcnR5PlxuICAgID8gVkFueTxUeXBlIHwgdW5kZWZpbmVkLCBcIm9wdGlvbmFsXCI+XG4gIDogVCBleHRlbmRzIFZMaXRlcmFsPGluZmVyIFR5cGUsIE9wdGlvbmFsUHJvcGVydHk+XG4gICAgPyBWTGl0ZXJhbDxUeXBlIHwgdW5kZWZpbmVkLCBcIm9wdGlvbmFsXCI+XG4gIDogVCBleHRlbmRzIFZCeXRlczxpbmZlciBUeXBlLCBPcHRpb25hbFByb3BlcnR5PlxuICAgID8gVkJ5dGVzPFR5cGUgfCB1bmRlZmluZWQsIFwib3B0aW9uYWxcIj5cbiAgOiBUIGV4dGVuZHMgVk9iamVjdDwgaW5mZXIgVHlwZSwgaW5mZXIgRmllbGRzLCBPcHRpb25hbFByb3BlcnR5LCBpbmZlciBGaWVsZFBhdGhzPlxuICAgID8gVk9iamVjdDxUeXBlIHwgdW5kZWZpbmVkLCBGaWVsZHMsIFwib3B0aW9uYWxcIiwgRmllbGRQYXRocz5cbiAgOiBUIGV4dGVuZHMgVkFycmF5PGluZmVyIFR5cGUsIGluZmVyIEVsZW1lbnQsIE9wdGlvbmFsUHJvcGVydHk+XG4gICAgPyBWQXJyYXk8VHlwZSB8IHVuZGVmaW5lZCwgRWxlbWVudCwgXCJvcHRpb25hbFwiPlxuICA6IFQgZXh0ZW5kcyBWUmVjb3JkPCBpbmZlciBUeXBlLCBpbmZlciBLZXksIGluZmVyIFZhbHVlLCBPcHRpb25hbFByb3BlcnR5LCBpbmZlciBGaWVsZFBhdGhzPlxuICAgID8gVlJlY29yZDxUeXBlIHwgdW5kZWZpbmVkLCBLZXksIFZhbHVlLCBcIm9wdGlvbmFsXCIsIEZpZWxkUGF0aHM+XG4gIDogVCBleHRlbmRzIFZVbmlvbjxpbmZlciBUeXBlLCBpbmZlciBNZW1iZXJzLCBPcHRpb25hbFByb3BlcnR5LCBpbmZlciBGaWVsZFBhdGhzPlxuICAgID8gVlVuaW9uPFR5cGUgfCB1bmRlZmluZWQsIE1lbWJlcnMsIFwib3B0aW9uYWxcIiwgRmllbGRQYXRocz5cbiAgOiBuZXZlclxuXG4vKipcbiAqIFR5cGUgcmVwcmVzZW50aW5nIHdoZXRoZXIgYSBwcm9wZXJ0eSBpbiBhbiBvYmplY3QgaXMgb3B0aW9uYWwgb3IgcmVxdWlyZWQuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgdHlwZSBPcHRpb25hbFByb3BlcnR5ID0gXCJvcHRpb25hbFwiIHwgXCJyZXF1aXJlZFwiO1xuXG4vKipcbiAqIEEgdmFsaWRhdG9yIGZvciBhIENvbnZleCB2YWx1ZS5cbiAqXG4gKiBUaGlzIHNob3VsZCBiZSBjb25zdHJ1Y3RlZCB1c2luZyB0aGUgdmFsaWRhdG9yIGJ1aWxkZXIsIHtAbGluayB2fS5cbiAqXG4gKiBBIHZhbGlkYXRvciBlbmNhcHN1bGF0ZXM6XG4gKiAtIFRoZSBUeXBlU2NyaXB0IHR5cGUgb2YgdGhpcyB2YWx1ZS5cbiAqIC0gV2hldGhlciB0aGlzIGZpZWxkIHNob3VsZCBiZSBvcHRpb25hbCBpZiBpdCdzIGluY2x1ZGVkIGluIGFuIG9iamVjdC5cbiAqIC0gVGhlIFR5cGVTY3JpcHQgdHlwZSBmb3IgdGhlIHNldCBvZiBpbmRleCBmaWVsZCBwYXRocyB0aGF0IGNhbiBiZSB1c2VkIHRvXG4gKiBidWlsZCBpbmRleGVzIG9uIHRoaXMgdmFsdWUuXG4gKiAtIEEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmFsaWRhdG9yLlxuICpcbiAqIFNwZWNpZmljIHR5cGVzIG9mIHZhbGlkYXRvcnMgY29udGFpbiBhZGRpdGlvbmFsIGluZm9ybWF0aW9uOiBmb3IgZXhhbXBsZVxuICogYW4gYEFycmF5VmFsaWRhdG9yYCBjb250YWlucyBhbiBgZWxlbWVudGAgcHJvcGVydHkgd2l0aCB0aGUgdmFsaWRhdG9yXG4gKiB1c2VkIHRvIHZhbGlkYXRlIGVhY2ggZWxlbWVudCBvZiB0aGUgbGlzdC4gVXNlIHRoZSBzaGFyZWQgJ2tpbmQnIHByb3BlcnR5XG4gKiB0byBpZGVudGl0eSB0aGUgdHlwZSBvZiB2YWxpZGF0b3IuXG4gKlxuICogTW9yZSB2YWxpZGF0b3JzIGNhbiBiZSBhZGRlZCBpbiBmdXR1cmUgcmVsZWFzZXMgc28gYW4gZXhoYXVzdGl2ZVxuICogc3dpdGNoIHN0YXRlbWVudCBvbiB2YWxpZGF0b3IgYGtpbmRgIHNob3VsZCBiZSBleHBlY3RlZCB0byBicmVha1xuICogaW4gZnV0dXJlIHJlbGVhc2VzIG9mIENvbnZleC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCB0eXBlIFZhbGlkYXRvcjxcbiAgVHlwZSxcbiAgSXNPcHRpb25hbCBleHRlbmRzIE9wdGlvbmFsUHJvcGVydHkgPSBcInJlcXVpcmVkXCIsXG4gIEZpZWxkUGF0aHMgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcixcbj4gPVxuICB8IFZJZDxUeXBlLCBJc09wdGlvbmFsPlxuICB8IFZTdHJpbmc8VHlwZSwgSXNPcHRpb25hbD5cbiAgfCBWRmxvYXQ2NDxUeXBlLCBJc09wdGlvbmFsPlxuICB8IFZJbnQ2NDxUeXBlLCBJc09wdGlvbmFsPlxuICB8IFZCb29sZWFuPFR5cGUsIElzT3B0aW9uYWw+XG4gIHwgVk51bGw8VHlwZSwgSXNPcHRpb25hbD5cbiAgfCBWQW55PFR5cGUsIElzT3B0aW9uYWw+XG4gIHwgVkxpdGVyYWw8VHlwZSwgSXNPcHRpb25hbD5cbiAgfCBWQnl0ZXM8VHlwZSwgSXNPcHRpb25hbD5cbiAgfCBWT2JqZWN0PFxuICAgICAgVHlwZSxcbiAgICAgIFJlY29yZDxzdHJpbmcsIFZhbGlkYXRvcjxhbnksIE9wdGlvbmFsUHJvcGVydHksIGFueT4+LFxuICAgICAgSXNPcHRpb25hbCxcbiAgICAgIEZpZWxkUGF0aHNcbiAgICA+XG4gIHwgVkFycmF5PFR5cGUsIFZhbGlkYXRvcjxhbnksIFwicmVxdWlyZWRcIiwgYW55PiwgSXNPcHRpb25hbD5cbiAgfCBWUmVjb3JkPFxuICAgICAgVHlwZSxcbiAgICAgIFZhbGlkYXRvcjxzdHJpbmcsIFwicmVxdWlyZWRcIiwgYW55PixcbiAgICAgIFZhbGlkYXRvcjxhbnksIFwicmVxdWlyZWRcIiwgYW55PixcbiAgICAgIElzT3B0aW9uYWwsXG4gICAgICBGaWVsZFBhdGhzXG4gICAgPlxuICB8IFZVbmlvbjxUeXBlLCBWYWxpZGF0b3I8YW55LCBcInJlcXVpcmVkXCIsIGFueT5bXSwgSXNPcHRpb25hbCwgRmllbGRQYXRocz47XG5cbi8qKlxuICogSm9pbiB0b2dldGhlciB0d28gaW5kZXggZmllbGQgcGF0aHMuXG4gKlxuICogVGhpcyBpcyB1c2VkIHdpdGhpbiB0aGUgdmFsaWRhdG9yIGJ1aWxkZXIsIHtAbGluayB2fS5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IHR5cGUgSm9pbkZpZWxkUGF0aHM8XG4gIFN0YXJ0IGV4dGVuZHMgc3RyaW5nLFxuICBFbmQgZXh0ZW5kcyBzdHJpbmcsXG4+ID0gYCR7U3RhcnR9LiR7RW5kfWA7XG5cbmV4cG9ydCB0eXBlIE9iamVjdEZpZWxkVHlwZSA9IHsgZmllbGRUeXBlOiBWYWxpZGF0b3JKU09OOyBvcHRpb25hbDogYm9vbGVhbiB9O1xuXG5leHBvcnQgdHlwZSBWYWxpZGF0b3JKU09OID1cbiAgfCB7IHR5cGU6IFwibnVsbFwiIH1cbiAgfCB7IHR5cGU6IFwibnVtYmVyXCIgfVxuICB8IHsgdHlwZTogXCJiaWdpbnRcIiB9XG4gIHwgeyB0eXBlOiBcImJvb2xlYW5cIiB9XG4gIHwgeyB0eXBlOiBcInN0cmluZ1wiIH1cbiAgfCB7IHR5cGU6IFwiYnl0ZXNcIiB9XG4gIHwgeyB0eXBlOiBcImFueVwiIH1cbiAgfCB7IHR5cGU6IFwibGl0ZXJhbFwiOyB2YWx1ZTogSlNPTlZhbHVlIH1cbiAgfCB7IHR5cGU6IFwiaWRcIjsgdGFibGVOYW1lOiBzdHJpbmcgfVxuICB8IHsgdHlwZTogXCJhcnJheVwiOyB2YWx1ZTogVmFsaWRhdG9ySlNPTiB9XG4gIHwge1xuICAgICAgdHlwZTogXCJyZWNvcmRcIjtcbiAgICAgIGtleXM6IFJlY29yZEtleVZhbGlkYXRvckpTT047XG4gICAgICB2YWx1ZXM6IFJlY29yZFZhbHVlVmFsaWRhdG9ySlNPTjtcbiAgICB9XG4gIHwgeyB0eXBlOiBcIm9iamVjdFwiOyB2YWx1ZTogUmVjb3JkPHN0cmluZywgT2JqZWN0RmllbGRUeXBlPiB9XG4gIHwgeyB0eXBlOiBcInVuaW9uXCI7IHZhbHVlOiBWYWxpZGF0b3JKU09OW10gfTtcblxuZXhwb3J0IHR5cGUgUmVjb3JkS2V5VmFsaWRhdG9ySlNPTiA9XG4gIHwgeyB0eXBlOiBcInN0cmluZ1wiIH1cbiAgfCB7IHR5cGU6IFwiaWRcIjsgdGFibGVOYW1lOiBzdHJpbmcgfVxuICB8IHsgdHlwZTogXCJ1bmlvblwiOyB2YWx1ZTogUmVjb3JkS2V5VmFsaWRhdG9ySlNPTltdIH07XG5cbmV4cG9ydCB0eXBlIFJlY29yZFZhbHVlVmFsaWRhdG9ySlNPTiA9IE9iamVjdEZpZWxkVHlwZSAmIHsgb3B0aW9uYWw6IGZhbHNlIH07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG52YXIgX2EsIF9iO1xuaW1wb3J0IHsgc3RyaW5naWZ5VmFsdWVGb3JFcnJvciB9IGZyb20gXCIuL3ZhbHVlLmpzXCI7XG5jb25zdCBJREVOVElGWUlOR19GSUVMRCA9IFN5bWJvbC5mb3IoXCJDb252ZXhFcnJvclwiKTtcbmV4cG9ydCBjbGFzcyBDb252ZXhFcnJvciBleHRlbmRzIChfYiA9IEVycm9yLCBfYSA9IElERU5USUZZSU5HX0ZJRUxELCBfYikge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgPyBkYXRhIDogc3RyaW5naWZ5VmFsdWVGb3JFcnJvcihkYXRhKSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm5hbWVcIiwgXCJDb252ZXhFcnJvclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZGF0YVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIF9hLCB0cnVlKTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMuanMubWFwXG4iLCJpbXBvcnQgeyBWYWx1ZSwgc3RyaW5naWZ5VmFsdWVGb3JFcnJvciB9IGZyb20gXCIuL3ZhbHVlLmpzXCI7XG5cbmNvbnN0IElERU5USUZZSU5HX0ZJRUxEID0gU3ltYm9sLmZvcihcIkNvbnZleEVycm9yXCIpO1xuXG5leHBvcnQgY2xhc3MgQ29udmV4RXJyb3I8VERhdGEgZXh0ZW5kcyBWYWx1ZT4gZXh0ZW5kcyBFcnJvciB7XG4gIG5hbWUgPSBcIkNvbnZleEVycm9yXCI7XG4gIGRhdGE6IFREYXRhO1xuICBbSURFTlRJRllJTkdfRklFTERdID0gdHJ1ZTtcblxuICBjb25zdHJ1Y3RvcihkYXRhOiBURGF0YSkge1xuICAgIHN1cGVyKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiID8gZGF0YSA6IHN0cmluZ2lmeVZhbHVlRm9yRXJyb3IoZGF0YSkpO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgY29tcGFyZVVURjggfSBmcm9tIFwiLi9jb21wYXJlX3V0ZjguanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlVmFsdWVzKGsxLCBrMikge1xuICByZXR1cm4gY29tcGFyZUFzVHVwbGVzKG1ha2VDb21wYXJhYmxlKGsxKSwgbWFrZUNvbXBhcmFibGUoazIpKTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVBc1R1cGxlcyhhLCBiKSB7XG4gIGlmIChhWzBdID09PSBiWzBdKSB7XG4gICAgcmV0dXJuIGNvbXBhcmVTYW1lVHlwZVZhbHVlcyhhWzFdLCBiWzFdKTtcbiAgfSBlbHNlIGlmIChhWzBdIDwgYlswXSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICByZXR1cm4gMTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVTYW1lVHlwZVZhbHVlcyh2MSwgdjIpIHtcbiAgaWYgKHYxID09PSB2b2lkIDAgfHwgdjEgPT09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAodHlwZW9mIHYxID09PSBcIm51bWJlclwiKSB7XG4gICAgaWYgKHR5cGVvZiB2MiAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHR5cGUgJHt2Mn1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBhcmVOdW1iZXJzKHYxLCB2Mik7XG4gIH1cbiAgaWYgKHR5cGVvZiB2MSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmICh0eXBlb2YgdjIgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCB0eXBlICR7djJ9YCk7XG4gICAgfVxuICAgIHJldHVybiBjb21wYXJlVVRGOCh2MSwgdjIpO1xuICB9XG4gIGlmICh0eXBlb2YgdjEgPT09IFwiYmlnaW50XCIgfHwgdHlwZW9mIHYxID09PSBcImJvb2xlYW5cIiB8fCB0eXBlb2YgdjEgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gdjEgPCB2MiA/IC0xIDogdjEgPT09IHYyID8gMCA6IDE7XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KHYxKSB8fCAhQXJyYXkuaXNBcnJheSh2MikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgdHlwZSAke3YxfWApO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdjEubGVuZ3RoICYmIGkgPCB2Mi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNtcCA9IGNvbXBhcmVBc1R1cGxlcyh2MVtpXSwgdjJbaV0pO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuICB9XG4gIGlmICh2MS5sZW5ndGggPCB2Mi5sZW5ndGgpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYgKHYxLmxlbmd0aCA+IHYyLmxlbmd0aCkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gY29tcGFyZU51bWJlcnModjEsIHYyKSB7XG4gIGlmIChpc05hTih2MSkgfHwgaXNOYU4odjIpKSB7XG4gICAgY29uc3QgYnVmZmVyMSA9IG5ldyBBcnJheUJ1ZmZlcig4KTtcbiAgICBjb25zdCBidWZmZXIyID0gbmV3IEFycmF5QnVmZmVyKDgpO1xuICAgIG5ldyBEYXRhVmlldyhidWZmZXIxKS5zZXRGbG9hdDY0KFxuICAgICAgMCxcbiAgICAgIHYxLFxuICAgICAgLyogbGl0dGxlLWVuZGlhbiAqL1xuICAgICAgdHJ1ZVxuICAgICk7XG4gICAgbmV3IERhdGFWaWV3KGJ1ZmZlcjIpLnNldEZsb2F0NjQoXG4gICAgICAwLFxuICAgICAgdjIsXG4gICAgICAvKiBsaXR0bGUtZW5kaWFuICovXG4gICAgICB0cnVlXG4gICAgKTtcbiAgICBjb25zdCB2MUJpdHMgPSBCaWdJbnQoXG4gICAgICBuZXcgRGF0YVZpZXcoYnVmZmVyMSkuZ2V0QmlnSW50NjQoXG4gICAgICAgIDAsXG4gICAgICAgIC8qIGxpdHRsZS1lbmRpYW4gKi9cbiAgICAgICAgdHJ1ZVxuICAgICAgKVxuICAgICk7XG4gICAgY29uc3QgdjJCaXRzID0gQmlnSW50KFxuICAgICAgbmV3IERhdGFWaWV3KGJ1ZmZlcjIpLmdldEJpZ0ludDY0KFxuICAgICAgICAwLFxuICAgICAgICAvKiBsaXR0bGUtZW5kaWFuICovXG4gICAgICAgIHRydWVcbiAgICAgIClcbiAgICApO1xuICAgIGNvbnN0IHYxU2lnbiA9ICh2MUJpdHMgJiAweDgwMDAwMDAwMDAwMDAwMDBuKSAhPT0gMG47XG4gICAgY29uc3QgdjJTaWduID0gKHYyQml0cyAmIDB4ODAwMDAwMDAwMDAwMDAwMG4pICE9PSAwbjtcbiAgICBpZiAoaXNOYU4odjEpICE9PSBpc05hTih2MikpIHtcbiAgICAgIGlmIChpc05hTih2MSkpIHtcbiAgICAgICAgcmV0dXJuIHYxU2lnbiA/IC0xIDogMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2MlNpZ24gPyAxIDogLTE7XG4gICAgfVxuICAgIGlmICh2MVNpZ24gIT09IHYyU2lnbikge1xuICAgICAgcmV0dXJuIHYxU2lnbiA/IC0xIDogMTtcbiAgICB9XG4gICAgcmV0dXJuIHYxQml0cyA8IHYyQml0cyA/IC0xIDogdjFCaXRzID09PSB2MkJpdHMgPyAwIDogMTtcbiAgfVxuICBpZiAoT2JqZWN0LmlzKHYxLCB2MikpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoT2JqZWN0LmlzKHYxLCAtMCkpIHtcbiAgICByZXR1cm4gT2JqZWN0LmlzKHYyLCAwKSA/IC0xIDogLU1hdGguc2lnbih2Mik7XG4gIH1cbiAgaWYgKE9iamVjdC5pcyh2MiwgLTApKSB7XG4gICAgcmV0dXJuIE9iamVjdC5pcyh2MSwgMCkgPyAxIDogTWF0aC5zaWduKHYxKTtcbiAgfVxuICByZXR1cm4gdjEgPCB2MiA/IC0xIDogMTtcbn1cbmZ1bmN0aW9uIG1ha2VDb21wYXJhYmxlKHYpIHtcbiAgaWYgKHYgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiBbMCwgdm9pZCAwXTtcbiAgfVxuICBpZiAodiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBbMSwgbnVsbF07XG4gIH1cbiAgaWYgKHR5cGVvZiB2ID09PSBcImJpZ2ludFwiKSB7XG4gICAgcmV0dXJuIFsyLCB2XTtcbiAgfVxuICBpZiAodHlwZW9mIHYgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gWzMsIHZdO1xuICB9XG4gIGlmICh0eXBlb2YgdiA9PT0gXCJib29sZWFuXCIpIHtcbiAgICByZXR1cm4gWzQsIHZdO1xuICB9XG4gIGlmICh0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBbNSwgdl07XG4gIH1cbiAgaWYgKHYgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBbNiwgQXJyYXkuZnJvbShuZXcgVWludDhBcnJheSh2KSkubWFwKG1ha2VDb21wYXJhYmxlKV07XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICByZXR1cm4gWzcsIHYubWFwKG1ha2VDb21wYXJhYmxlKV07XG4gIH1cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHYpLnNvcnQoKTtcbiAgY29uc3QgcG9qbyA9IGtleXMubWFwKChrKSA9PiBbaywgdltrXV0pO1xuICByZXR1cm4gWzgsIHBvam8ubWFwKG1ha2VDb21wYXJhYmxlKV07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wYXJlLmpzLm1hcFxuIiwiaW1wb3J0IHsgVmFsdWUgfSBmcm9tIFwiLi92YWx1ZS5qc1wiO1xuaW1wb3J0IHsgY29tcGFyZVVURjggfSBmcm9tIFwiLi9jb21wYXJlX3V0ZjguanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVWYWx1ZXMoazE6IFZhbHVlIHwgdW5kZWZpbmVkLCBrMjogVmFsdWUgfCB1bmRlZmluZWQpIHtcbiAgcmV0dXJuIGNvbXBhcmVBc1R1cGxlcyhtYWtlQ29tcGFyYWJsZShrMSksIG1ha2VDb21wYXJhYmxlKGsyKSk7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVBc1R1cGxlczxUPihhOiBbbnVtYmVyLCBUXSwgYjogW251bWJlciwgVF0pOiBudW1iZXIge1xuICBpZiAoYVswXSA9PT0gYlswXSkge1xuICAgIHJldHVybiBjb21wYXJlU2FtZVR5cGVWYWx1ZXMoYVsxXSwgYlsxXSk7XG4gIH0gZWxzZSBpZiAoYVswXSA8IGJbMF0pIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgcmV0dXJuIDE7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVTYW1lVHlwZVZhbHVlczxUPih2MTogVCwgdjI6IFQpOiBudW1iZXIge1xuICBpZiAodjEgPT09IHVuZGVmaW5lZCB8fCB2MSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmICh0eXBlb2YgdjEgPT09IFwibnVtYmVyXCIpIHtcbiAgICBpZiAodHlwZW9mIHYyICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgdHlwZSAke3YyIGFzIGFueX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBhcmVOdW1iZXJzKHYxLCB2Mik7XG4gIH1cbiAgaWYgKHR5cGVvZiB2MSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmICh0eXBlb2YgdjIgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCB0eXBlICR7djIgYXMgYW55fWApO1xuICAgIH1cbiAgICByZXR1cm4gY29tcGFyZVVURjgodjEsIHYyKTtcbiAgfVxuICBpZiAoXG4gICAgdHlwZW9mIHYxID09PSBcImJpZ2ludFwiIHx8XG4gICAgdHlwZW9mIHYxID09PSBcImJvb2xlYW5cIiB8fFxuICAgIHR5cGVvZiB2MSA9PT0gXCJzdHJpbmdcIlxuICApIHtcbiAgICByZXR1cm4gdjEgPCB2MiA/IC0xIDogdjEgPT09IHYyID8gMCA6IDE7XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KHYxKSB8fCAhQXJyYXkuaXNBcnJheSh2MikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgdHlwZSAke3YxIGFzIGFueX1gKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHYxLmxlbmd0aCAmJiBpIDwgdjIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjbXAgPSBjb21wYXJlQXNUdXBsZXModjFbaV0sIHYyW2ldKTtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cbiAgfVxuICBpZiAodjEubGVuZ3RoIDwgdjIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGlmICh2MS5sZW5ndGggPiB2Mi5sZW5ndGgpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gY29tcGFyZU51bWJlcnModjE6IG51bWJlciwgdjI6IG51bWJlcik6IG51bWJlciB7XG4gIC8vIEhhbmRsZSBOYU4gdmFsdWVzXG4gIGlmIChpc05hTih2MSkgfHwgaXNOYU4odjIpKSB7XG4gICAgLy8gQ3JlYXRlIERhdGFWaWV3cyBmb3IgYml0LWxldmVsIGNvbXBhcmlzb25cbiAgICBjb25zdCBidWZmZXIxID0gbmV3IEFycmF5QnVmZmVyKDgpO1xuICAgIGNvbnN0IGJ1ZmZlcjIgPSBuZXcgQXJyYXlCdWZmZXIoOCk7XG4gICAgbmV3IERhdGFWaWV3KGJ1ZmZlcjEpLnNldEZsb2F0NjQoMCwgdjEsIC8qIGxpdHRsZS1lbmRpYW4gKi8gdHJ1ZSk7XG4gICAgbmV3IERhdGFWaWV3KGJ1ZmZlcjIpLnNldEZsb2F0NjQoMCwgdjIsIC8qIGxpdHRsZS1lbmRpYW4gKi8gdHJ1ZSk7XG5cbiAgICAvLyBSZWFkIGFzIEJpZ0ludCB0byBjb21wYXJlIGJpdHNcbiAgICBjb25zdCB2MUJpdHMgPSBCaWdJbnQoXG4gICAgICBuZXcgRGF0YVZpZXcoYnVmZmVyMSkuZ2V0QmlnSW50NjQoMCwgLyogbGl0dGxlLWVuZGlhbiAqLyB0cnVlKSxcbiAgICApO1xuICAgIGNvbnN0IHYyQml0cyA9IEJpZ0ludChcbiAgICAgIG5ldyBEYXRhVmlldyhidWZmZXIyKS5nZXRCaWdJbnQ2NCgwLCAvKiBsaXR0bGUtZW5kaWFuICovIHRydWUpLFxuICAgICk7XG5cbiAgICAvLyBUaGUgc2lnbiBiaXQgaXMgdGhlIG1vc3Qgc2lnbmlmaWNhbnQgYml0IChiaXQgNjMpXG4gICAgY29uc3QgdjFTaWduID0gKHYxQml0cyAmIDB4ODAwMDAwMDAwMDAwMDAwMG4pICE9PSAwbjtcbiAgICBjb25zdCB2MlNpZ24gPSAodjJCaXRzICYgMHg4MDAwMDAwMDAwMDAwMDAwbikgIT09IDBuO1xuXG4gICAgLy8gSWYgb25lIHZhbHVlIGlzIE5hTiBhbmQgdGhlIG90aGVyIGlzbid0LCB1c2Ugc2lnbiBiaXRzIGZpcnN0XG4gICAgaWYgKGlzTmFOKHYxKSAhPT0gaXNOYU4odjIpKSB7XG4gICAgICAvLyBJZiB2MSBpcyBOYU4sIGNvbXBhcmUgYmFzZWQgb24gc2lnbiBiaXRzXG4gICAgICBpZiAoaXNOYU4odjEpKSB7XG4gICAgICAgIHJldHVybiB2MVNpZ24gPyAtMSA6IDE7XG4gICAgICB9XG4gICAgICAvLyBJZiB2MiBpcyBOYU4sIGNvbXBhcmUgYmFzZWQgb24gc2lnbiBiaXRzXG4gICAgICByZXR1cm4gdjJTaWduID8gMSA6IC0xO1xuICAgIH1cblxuICAgIC8vIElmIGJvdGggYXJlIE5hTiwgY29tcGFyZSB0aGVpciBiaW5hcnkgcmVwcmVzZW50YXRpb25zXG4gICAgaWYgKHYxU2lnbiAhPT0gdjJTaWduKSB7XG4gICAgICByZXR1cm4gdjFTaWduID8gLTEgOiAxOyAvLyB0cnVlIG1lYW5zIG5lZ2F0aXZlXG4gICAgfVxuICAgIHJldHVybiB2MUJpdHMgPCB2MkJpdHMgPyAtMSA6IHYxQml0cyA9PT0gdjJCaXRzID8gMCA6IDE7XG4gIH1cblxuICBpZiAoT2JqZWN0LmlzKHYxLCB2MikpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGlmIChPYmplY3QuaXModjEsIC0wKSkge1xuICAgIHJldHVybiBPYmplY3QuaXModjIsIDApID8gLTEgOiAtTWF0aC5zaWduKHYyKTtcbiAgfVxuICBpZiAoT2JqZWN0LmlzKHYyLCAtMCkpIHtcbiAgICByZXR1cm4gT2JqZWN0LmlzKHYxLCAwKSA/IDEgOiBNYXRoLnNpZ24odjEpO1xuICB9XG5cbiAgLy8gSGFuZGxlIHJlZ3VsYXIgbnVtYmVyIGNvbXBhcmlzb25cbiAgcmV0dXJuIHYxIDwgdjIgPyAtMSA6IDE7XG59XG5cbi8vIFJldHVybnMgYW4gYXJyYXkgd2hpY2ggY2FuIGJlIGNvbXBhcmVkIHRvIG90aGVyIGFycmF5cyBhcyBpZiB0aGV5IHdlcmUgdHVwbGVzLlxuLy8gRm9yIGV4YW1wbGUsIFsxLCBudWxsXSA8IFsyLCAxbl0gbWVhbnMgbnVsbCBzb3J0cyBiZWZvcmUgYWxsIGJpZ2ludHNcbi8vIEFuZCBbMywgNV0gPCBbMywgNl0gbWVhbnMgZmxvYXRzIHNvcnQgYXMgZXhwZWN0ZWRcbi8vIEFuZCBbNywgW1s1LCBcImFcIl1dXSA8IFs3LCBbWzUsIFwiYVwiXSwgWzUsIFwiYlwiXV1dIG1lYW5zIGFycmF5cyBzb3J0IGFzIGV4cGVjdGVkXG5mdW5jdGlvbiBtYWtlQ29tcGFyYWJsZSh2OiBWYWx1ZSB8IHVuZGVmaW5lZCk6IFtudW1iZXIsIGFueV0ge1xuICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIFswLCB1bmRlZmluZWRdO1xuICB9XG4gIGlmICh2ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFsxLCBudWxsXTtcbiAgfVxuICBpZiAodHlwZW9mIHYgPT09IFwiYmlnaW50XCIpIHtcbiAgICByZXR1cm4gWzIsIHZdO1xuICB9XG4gIGlmICh0eXBlb2YgdiA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiBbMywgdl07XG4gIH1cbiAgaWYgKHR5cGVvZiB2ID09PSBcImJvb2xlYW5cIikge1xuICAgIHJldHVybiBbNCwgdl07XG4gIH1cbiAgaWYgKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIFs1LCB2XTtcbiAgfVxuICBpZiAodiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIFs2LCBBcnJheS5mcm9tKG5ldyBVaW50OEFycmF5KHYpKS5tYXAobWFrZUNvbXBhcmFibGUpXTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2KSkge1xuICAgIHJldHVybiBbNywgdi5tYXAobWFrZUNvbXBhcmFibGUpXTtcbiAgfVxuICAvLyBPdGhlcndpc2UsIGl0J3MgYW4gUE9KTy5cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHYpLnNvcnQoKTtcbiAgY29uc3QgcG9qbzogVmFsdWVbXSA9IGtleXMubWFwKChrKSA9PiBbaywgdltrXSFdKTtcbiAgcmV0dXJuIFs4LCBwb2pvLm1hcChtYWtlQ29tcGFyYWJsZSldO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZVVURjgoYSwgYikge1xuICBjb25zdCBhTGVuZ3RoID0gYS5sZW5ndGg7XG4gIGNvbnN0IGJMZW5ndGggPSBiLmxlbmd0aDtcbiAgY29uc3QgbGVuZ3RoID0gTWF0aC5taW4oYUxlbmd0aCwgYkxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyApIHtcbiAgICBjb25zdCBhQ29kZVBvaW50ID0gYS5jb2RlUG9pbnRBdChpKTtcbiAgICBjb25zdCBiQ29kZVBvaW50ID0gYi5jb2RlUG9pbnRBdChpKTtcbiAgICBpZiAoYUNvZGVQb2ludCAhPT0gYkNvZGVQb2ludCkge1xuICAgICAgaWYgKGFDb2RlUG9pbnQgPCAxMjggJiYgYkNvZGVQb2ludCA8IDEyOCkge1xuICAgICAgICByZXR1cm4gYUNvZGVQb2ludCAtIGJDb2RlUG9pbnQ7XG4gICAgICB9XG4gICAgICBjb25zdCBhTGVuZ3RoMiA9IHV0ZjhCeXRlcyhhQ29kZVBvaW50LCBhQnl0ZXMpO1xuICAgICAgY29uc3QgYkxlbmd0aDIgPSB1dGY4Qnl0ZXMoYkNvZGVQb2ludCwgYkJ5dGVzKTtcbiAgICAgIHJldHVybiBjb21wYXJlQXJyYXlzKGFCeXRlcywgYUxlbmd0aDIsIGJCeXRlcywgYkxlbmd0aDIpO1xuICAgIH1cbiAgICBpICs9IHV0ZjE2TGVuZ3RoRm9yQ29kZVBvaW50KGFDb2RlUG9pbnQpO1xuICB9XG4gIHJldHVybiBhTGVuZ3RoIC0gYkxlbmd0aDtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVBcnJheXMoYSwgYUxlbmd0aCwgYiwgYkxlbmd0aCkge1xuICBjb25zdCBsZW5ndGggPSBNYXRoLm1pbihhTGVuZ3RoLCBiTGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGFWYWx1ZSA9IGFbaV07XG4gICAgY29uc3QgYlZhbHVlID0gYltpXTtcbiAgICBpZiAoYVZhbHVlICE9PSBiVmFsdWUpIHtcbiAgICAgIHJldHVybiBhVmFsdWUgLSBiVmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBhTGVuZ3RoIC0gYkxlbmd0aDtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1dGYxNkxlbmd0aEZvckNvZGVQb2ludChhQ29kZVBvaW50KSB7XG4gIHJldHVybiBhQ29kZVBvaW50ID4gNjU1MzUgPyAyIDogMTtcbn1cbmNvbnN0IGFyciA9ICgpID0+IEFycmF5LmZyb20oeyBsZW5ndGg6IDQgfSwgKCkgPT4gMCk7XG5jb25zdCBhQnl0ZXMgPSBhcnIoKTtcbmNvbnN0IGJCeXRlcyA9IGFycigpO1xuZnVuY3Rpb24gdXRmOEJ5dGVzKGNvZGVQb2ludCwgYnl0ZXMpIHtcbiAgaWYgKGNvZGVQb2ludCA8IDEyOCkge1xuICAgIGJ5dGVzWzBdID0gY29kZVBvaW50O1xuICAgIHJldHVybiAxO1xuICB9XG4gIGxldCBjb3VudDtcbiAgbGV0IG9mZnNldDtcbiAgaWYgKGNvZGVQb2ludCA8PSAyMDQ3KSB7XG4gICAgY291bnQgPSAxO1xuICAgIG9mZnNldCA9IDE5MjtcbiAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPD0gNjU1MzUpIHtcbiAgICBjb3VudCA9IDI7XG4gICAgb2Zmc2V0ID0gMjI0O1xuICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8PSAxMTE0MTExKSB7XG4gICAgY291bnQgPSAzO1xuICAgIG9mZnNldCA9IDI0MDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNvZGUgcG9pbnRcIik7XG4gIH1cbiAgYnl0ZXNbMF0gPSAoY29kZVBvaW50ID4+IDYgKiBjb3VudCkgKyBvZmZzZXQ7XG4gIGxldCBpID0gMTtcbiAgZm9yICg7IGNvdW50ID4gMDsgY291bnQtLSkge1xuICAgIGNvbnN0IHRlbXAgPSBjb2RlUG9pbnQgPj4gNiAqIChjb3VudCAtIDEpO1xuICAgIGJ5dGVzW2krK10gPSAxMjggfCB0ZW1wICYgNjM7XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ3JlYXRlclRoYW4oYSwgYikge1xuICByZXR1cm4gY29tcGFyZVVURjgoYSwgYikgPiAwO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdyZWF0ZXJUaGFuRXEoYSwgYikge1xuICByZXR1cm4gY29tcGFyZVVURjgoYSwgYikgPj0gMDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBsZXNzVGhhbihhLCBiKSB7XG4gIHJldHVybiBjb21wYXJlVVRGOChhLCBiKSA8IDA7XG59XG5leHBvcnQgZnVuY3Rpb24gbGVzc1RoYW5FcShhLCBiKSB7XG4gIHJldHVybiBjb21wYXJlVVRGOChhLCBiKSA8PSAwO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcGFyZV91dGY4LmpzLm1hcFxuIiwiLyoqXG4gKiBUYWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9yb2NpY29ycC9jb21wYXJlLXV0ZjgvYmxvYi9tYWluL0xJQ0VOU0VcbiAqIChBcGFjaGUgVmVyc2lvbiAyLjAsIEphbnVhcnkgMjAwNClcbiAqL1xuXG4vKipcbiAqIFRoaXMgaXMgY29waWVkIGhlcmUgaW5zdGVhZCBvZiBhZGRlZCBhcyBhIGRlcGVuZGVuY3kgdG8gYXZvaWQgYnVuZGxpbmcgaXNzdWVzLlxuICovXG5cbi8qKlxuICogQ29tcGFyZXMgdHdvIEphdmFTY3JpcHQgc3RyaW5ncyBhcyBpZiB0aGV5IHdlcmUgVVRGLTggZW5jb2RlZCBieXRlIGFycmF5cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBhXG4gKiBAcGFyYW0ge3N0cmluZ30gYlxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVVVEY4KGE6IHN0cmluZywgYjogc3RyaW5nKTogbnVtYmVyIHtcbiAgY29uc3QgYUxlbmd0aCA9IGEubGVuZ3RoO1xuICBjb25zdCBiTGVuZ3RoID0gYi5sZW5ndGg7XG4gIGNvbnN0IGxlbmd0aCA9IE1hdGgubWluKGFMZW5ndGgsIGJMZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKSB7XG4gICAgY29uc3QgYUNvZGVQb2ludCA9IGEuY29kZVBvaW50QXQoaSkhO1xuICAgIGNvbnN0IGJDb2RlUG9pbnQgPSBiLmNvZGVQb2ludEF0KGkpITtcbiAgICBpZiAoYUNvZGVQb2ludCAhPT0gYkNvZGVQb2ludCkge1xuICAgICAgLy8gQ29kZSBwb2ludHMgYmVsb3cgMHg4MCBhcmUgcmVwcmVzZW50ZWQgdGhlIHNhbWUgd2F5IGluIFVURi04IGFzIGluXG4gICAgICAvLyBVVEYtMTYuXG4gICAgICBpZiAoYUNvZGVQb2ludCA8IDB4ODAgJiYgYkNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgICAgcmV0dXJuIGFDb2RlUG9pbnQgLSBiQ29kZVBvaW50O1xuICAgICAgfVxuXG4gICAgICAvLyBnZXQgdGhlIFVURi04IGJ5dGVzIGZvciB0aGUgY29kZSBwb2ludHNcbiAgICAgIGNvbnN0IGFMZW5ndGggPSB1dGY4Qnl0ZXMoYUNvZGVQb2ludCwgYUJ5dGVzKTtcbiAgICAgIGNvbnN0IGJMZW5ndGggPSB1dGY4Qnl0ZXMoYkNvZGVQb2ludCwgYkJ5dGVzKTtcbiAgICAgIHJldHVybiBjb21wYXJlQXJyYXlzKGFCeXRlcywgYUxlbmd0aCwgYkJ5dGVzLCBiTGVuZ3RoKTtcbiAgICB9XG5cbiAgICBpICs9IHV0ZjE2TGVuZ3RoRm9yQ29kZVBvaW50KGFDb2RlUG9pbnQpO1xuICB9XG5cbiAgcmV0dXJuIGFMZW5ndGggLSBiTGVuZ3RoO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyW119IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBhTGVuZ3RoXG4gKiBAcGFyYW0ge251bWJlcltdfSBiXG4gKiBAcGFyYW0ge251bWJlcn0gYkxlbmd0aFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUFycmF5cyhcbiAgYTogbnVtYmVyW10sXG4gIGFMZW5ndGg6IG51bWJlcixcbiAgYjogbnVtYmVyW10sXG4gIGJMZW5ndGg6IG51bWJlcixcbikge1xuICBjb25zdCBsZW5ndGggPSBNYXRoLm1pbihhTGVuZ3RoLCBiTGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGFWYWx1ZSA9IGFbaV07XG4gICAgY29uc3QgYlZhbHVlID0gYltpXTtcbiAgICBpZiAoYVZhbHVlICE9PSBiVmFsdWUpIHtcbiAgICAgIHJldHVybiBhVmFsdWUgLSBiVmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBhTGVuZ3RoIC0gYkxlbmd0aDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gYUNvZGVQb2ludFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV0ZjE2TGVuZ3RoRm9yQ29kZVBvaW50KGFDb2RlUG9pbnQ6IG51bWJlcikge1xuICByZXR1cm4gYUNvZGVQb2ludCA+IDB4ZmZmZiA/IDIgOiAxO1xufVxuXG4vLyAyIHByZWFsbG9jYXRlZCBhcnJheXMgZm9yIHV0ZjhCeXRlcy5cbmNvbnN0IGFyciA9ICgpID0+IEFycmF5LmZyb20oeyBsZW5ndGg6IDQgfSwgKCkgPT4gMCk7XG5jb25zdCBhQnl0ZXMgPSBhcnIoKTtcbmNvbnN0IGJCeXRlcyA9IGFycigpO1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlUG9pbnRcbiAqIEBwYXJhbSB7bnVtYmVyW119IGJ5dGVzXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiB1dGY4Qnl0ZXMoY29kZVBvaW50OiBudW1iZXIsIGJ5dGVzOiBudW1iZXJbXSkge1xuICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgIGJ5dGVzWzBdID0gY29kZVBvaW50O1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgbGV0IGNvdW50O1xuICBsZXQgb2Zmc2V0O1xuXG4gIGlmIChjb2RlUG9pbnQgPD0gMHgwN2ZmKSB7XG4gICAgY291bnQgPSAxO1xuICAgIG9mZnNldCA9IDB4YzA7XG4gIH0gZWxzZSBpZiAoY29kZVBvaW50IDw9IDB4ZmZmZikge1xuICAgIGNvdW50ID0gMjtcbiAgICBvZmZzZXQgPSAweGUwO1xuICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8PSAweDEwZmZmZikge1xuICAgIGNvdW50ID0gMztcbiAgICBvZmZzZXQgPSAweGYwO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29kZSBwb2ludFwiKTtcbiAgfVxuXG4gIGJ5dGVzWzBdID0gKGNvZGVQb2ludCA+PiAoNiAqIGNvdW50KSkgKyBvZmZzZXQ7XG4gIGxldCBpID0gMTtcbiAgZm9yICg7IGNvdW50ID4gMDsgY291bnQtLSkge1xuICAgIGNvbnN0IHRlbXAgPSBjb2RlUG9pbnQgPj4gKDYgKiAoY291bnQgLSAxKSk7XG4gICAgYnl0ZXNbaSsrXSA9IDB4ODAgfCAodGVtcCAmIDB4M2YpO1xuICB9XG4gIHJldHVybiBpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBhXG4gKiBAcGFyYW0ge3N0cmluZ30gYlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBncmVhdGVyVGhhbihhOiBzdHJpbmcsIGI6IHN0cmluZykge1xuICByZXR1cm4gY29tcGFyZVVURjgoYSwgYikgPiAwO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBhXG4gKiBAcGFyYW0ge3N0cmluZ30gYlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBncmVhdGVyVGhhbkVxKGE6IHN0cmluZywgYjogc3RyaW5nKSB7XG4gIHJldHVybiBjb21wYXJlVVRGOChhLCBiKSA+PSAwO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBhXG4gKiBAcGFyYW0ge3N0cmluZ30gYlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZXNzVGhhbihhOiBzdHJpbmcsIGI6IHN0cmluZykge1xuICByZXR1cm4gY29tcGFyZVVURjgoYSwgYikgPCAwO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBhXG4gKiBAcGFyYW0ge3N0cmluZ30gYlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZXNzVGhhbkVxKGE6IHN0cmluZywgYjogc3RyaW5nKSB7XG4gIHJldHVybiBjb21wYXJlVVRGOChhLCBiKSA8PSAwO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuY29uc3QgSU5GT19DT0xPUiA9IFwiY29sb3I6cmdiKDAsIDE0NSwgMjU1KVwiO1xuZnVuY3Rpb24gcHJlZml4X2Zvcl9zb3VyY2Uoc291cmNlKSB7XG4gIHN3aXRjaCAoc291cmNlKSB7XG4gICAgY2FzZSBcInF1ZXJ5XCI6XG4gICAgICByZXR1cm4gXCJRXCI7XG4gICAgY2FzZSBcIm11dGF0aW9uXCI6XG4gICAgICByZXR1cm4gXCJNXCI7XG4gICAgY2FzZSBcImFjdGlvblwiOlxuICAgICAgcmV0dXJuIFwiQVwiO1xuICAgIGNhc2UgXCJhbnlcIjpcbiAgICAgIHJldHVybiBcIj9cIjtcbiAgfVxufVxuZXhwb3J0IGNsYXNzIERlZmF1bHRMb2dnZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9vbkxvZ0xpbmVGdW5jc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX3ZlcmJvc2VcIik7XG4gICAgdGhpcy5fb25Mb2dMaW5lRnVuY3MgPSB7fTtcbiAgICB0aGlzLl92ZXJib3NlID0gb3B0aW9ucy52ZXJib3NlO1xuICB9XG4gIGFkZExvZ0xpbmVMaXN0ZW5lcihmdW5jKSB7XG4gICAgbGV0IGlkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDE1KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLl9vbkxvZ0xpbmVGdW5jc1tpZF0gPT09IHZvaWQgMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDE1KTtcbiAgICB9XG4gICAgdGhpcy5fb25Mb2dMaW5lRnVuY3NbaWRdID0gZnVuYztcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZGVsZXRlIHRoaXMuX29uTG9nTGluZUZ1bmNzW2lkXTtcbiAgICB9O1xuICB9XG4gIGxvZ1ZlcmJvc2UoLi4uYXJncykge1xuICAgIGlmICh0aGlzLl92ZXJib3NlKSB7XG4gICAgICBmb3IgKGNvbnN0IGZ1bmMgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLl9vbkxvZ0xpbmVGdW5jcykpIHtcbiAgICAgICAgZnVuYyhcImRlYnVnXCIsIGAkeygvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkudG9JU09TdHJpbmcoKX1gLCAuLi5hcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbG9nKC4uLmFyZ3MpIHtcbiAgICBmb3IgKGNvbnN0IGZ1bmMgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLl9vbkxvZ0xpbmVGdW5jcykpIHtcbiAgICAgIGZ1bmMoXCJpbmZvXCIsIC4uLmFyZ3MpO1xuICAgIH1cbiAgfVxuICB3YXJuKC4uLmFyZ3MpIHtcbiAgICBmb3IgKGNvbnN0IGZ1bmMgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLl9vbkxvZ0xpbmVGdW5jcykpIHtcbiAgICAgIGZ1bmMoXCJ3YXJuXCIsIC4uLmFyZ3MpO1xuICAgIH1cbiAgfVxuICBlcnJvciguLi5hcmdzKSB7XG4gICAgZm9yIChjb25zdCBmdW5jIG9mIE9iamVjdC52YWx1ZXModGhpcy5fb25Mb2dMaW5lRnVuY3MpKSB7XG4gICAgICBmdW5jKFwiZXJyb3JcIiwgLi4uYXJncyk7XG4gICAgfVxuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaW5zdGFudGlhdGVEZWZhdWx0TG9nZ2VyKG9wdGlvbnMpIHtcbiAgY29uc3QgbG9nZ2VyID0gbmV3IERlZmF1bHRMb2dnZXIob3B0aW9ucyk7XG4gIGxvZ2dlci5hZGRMb2dMaW5lTGlzdGVuZXIoKGxldmVsLCAuLi5hcmdzKSA9PiB7XG4gICAgc3dpdGNoIChsZXZlbCkge1xuICAgICAgY2FzZSBcImRlYnVnXCI6XG4gICAgICAgIGNvbnNvbGUuZGVidWcoLi4uYXJncyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImluZm9cIjpcbiAgICAgICAgY29uc29sZS5sb2coLi4uYXJncyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIndhcm5cIjpcbiAgICAgICAgY29uc29sZS53YXJuKC4uLmFyZ3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICBjb25zb2xlLmVycm9yKC4uLmFyZ3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgbGV2ZWw7XG4gICAgICAgIGNvbnNvbGUubG9nKC4uLmFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBsb2dnZXI7XG59XG5leHBvcnQgZnVuY3Rpb24gaW5zdGFudGlhdGVOb29wTG9nZ2VyKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBEZWZhdWx0TG9nZ2VyKG9wdGlvbnMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGxvZ0ZvckZ1bmN0aW9uKGxvZ2dlciwgdHlwZSwgc291cmNlLCB1ZGZQYXRoLCBtZXNzYWdlKSB7XG4gIGNvbnN0IHByZWZpeCA9IHByZWZpeF9mb3Jfc291cmNlKHNvdXJjZSk7XG4gIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJvYmplY3RcIikge1xuICAgIG1lc3NhZ2UgPSBgQ29udmV4RXJyb3IgJHtKU09OLnN0cmluZ2lmeShtZXNzYWdlLmVycm9yRGF0YSwgbnVsbCwgMil9YDtcbiAgfVxuICBpZiAodHlwZSA9PT0gXCJpbmZvXCIpIHtcbiAgICBjb25zdCBtYXRjaCA9IG1lc3NhZ2UubWF0Y2goL15cXFsuKj9cXF0gLyk7XG4gICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoXG4gICAgICAgIGBbQ09OVkVYICR7cHJlZml4fSgke3VkZlBhdGh9KV0gQ291bGQgbm90IHBhcnNlIGNvbnNvbGUubG9nYFxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGV2ZWwgPSBtZXNzYWdlLnNsaWNlKDEsIG1hdGNoWzBdLmxlbmd0aCAtIDIpO1xuICAgIGNvbnN0IGFyZ3MgPSBtZXNzYWdlLnNsaWNlKG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgbG9nZ2VyLmxvZyhgJWNbQ09OVkVYICR7cHJlZml4fSgke3VkZlBhdGh9KV0gWyR7bGV2ZWx9XWAsIElORk9fQ09MT1IsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIGxvZ2dlci5lcnJvcihgW0NPTlZFWCAke3ByZWZpeH0oJHt1ZGZQYXRofSldICR7bWVzc2FnZX1gKTtcbiAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGxvZ0ZhdGFsRXJyb3IobG9nZ2VyLCBtZXNzYWdlKSB7XG4gIGNvbnN0IGVycm9yTWVzc2FnZSA9IGBbQ09OVkVYIEZBVEFMIEVSUk9SXSAke21lc3NhZ2V9YDtcbiAgbG9nZ2VyLmVycm9yKGVycm9yTWVzc2FnZSk7XG4gIHJldHVybiBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIeWJyaWRFcnJvclN0YWNrdHJhY2Uoc291cmNlLCB1ZGZQYXRoLCByZXN1bHQpIHtcbiAgY29uc3QgcHJlZml4ID0gcHJlZml4X2Zvcl9zb3VyY2Uoc291cmNlKTtcbiAgcmV0dXJuIGBbQ09OVkVYICR7cHJlZml4fSgke3VkZlBhdGh9KV0gJHtyZXN1bHQuZXJyb3JNZXNzYWdlfVxuICBDYWxsZWQgYnkgY2xpZW50YDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmb3J3YXJkRGF0YShyZXN1bHQsIGVycm9yKSB7XG4gIGVycm9yLmRhdGEgPSByZXN1bHQuZXJyb3JEYXRhO1xuICByZXR1cm4gZXJyb3I7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2dnaW5nLmpzLm1hcFxuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqLyAvLyBUaGlzIGlzIHRoZSBvbmUgZmlsZSB3aGVyZSB3ZSBjYW4gYGNvbnNvbGUubG9nYCBmb3IgdGhlIGRlZmF1bHQgbG9nZ2VyIGltcGxlbWVudGF0aW9uLlxuaW1wb3J0IHsgQ29udmV4RXJyb3IsIFZhbHVlIH0gZnJvbSBcIi4uL3ZhbHVlcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgRnVuY3Rpb25GYWlsdXJlIH0gZnJvbSBcIi4vc3luYy9mdW5jdGlvbl9yZXN1bHQuanNcIjtcblxuLy8gVGhpcyBpcyBibHVlICM5IGZyb20gaHR0cHM6Ly93d3cucmFkaXgtdWkuY29tL2RvY3MvY29sb3JzL3BhbGV0dGUtY29tcG9zaXRpb24vdGhlLXNjYWxlc1xuLy8gSXQgbXVzdCBsb29rIGdvb2QgaW4gYm90aCBsaWdodCBhbmQgZGFyayBtb2RlLlxuY29uc3QgSU5GT19DT0xPUiA9IFwiY29sb3I6cmdiKDAsIDE0NSwgMjU1KVwiO1xuXG5leHBvcnQgdHlwZSBVZGZUeXBlID0gXCJxdWVyeVwiIHwgXCJtdXRhdGlvblwiIHwgXCJhY3Rpb25cIiB8IFwiYW55XCI7XG5cbmZ1bmN0aW9uIHByZWZpeF9mb3Jfc291cmNlKHNvdXJjZTogVWRmVHlwZSkge1xuICBzd2l0Y2ggKHNvdXJjZSkge1xuICAgIGNhc2UgXCJxdWVyeVwiOlxuICAgICAgcmV0dXJuIFwiUVwiO1xuICAgIGNhc2UgXCJtdXRhdGlvblwiOlxuICAgICAgcmV0dXJuIFwiTVwiO1xuICAgIGNhc2UgXCJhY3Rpb25cIjpcbiAgICAgIHJldHVybiBcIkFcIjtcbiAgICBjYXNlIFwiYW55XCI6XG4gICAgICByZXR1cm4gXCI/XCI7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgTG9nTGV2ZWwgPSBcImRlYnVnXCIgfCBcImluZm9cIiB8IFwid2FyblwiIHwgXCJlcnJvclwiO1xuXG4vKipcbiAqIEEgbG9nZ2VyIHRoYXQgY2FuIGJlIHVzZWQgdG8gbG9nIG1lc3NhZ2VzLiBCeSBkZWZhdWx0LCB0aGlzIGlzIGEgd3JhcHBlclxuICogYXJvdW5kIGBjb25zb2xlYCwgYnV0IGNhbiBiZSBjb25maWd1cmVkIHRvIG5vdCBsb2cgYXQgYWxsIG9yIHRvIGxvZyBzb21ld2hlcmVcbiAqIGVsc2UuXG4gKi9cbmV4cG9ydCB0eXBlIExvZ2dlciA9IHtcbiAgbG9nVmVyYm9zZSguLi5hcmdzOiBhbnlbXSk6IHZvaWQ7XG4gIGxvZyguLi5hcmdzOiBhbnlbXSk6IHZvaWQ7XG4gIHdhcm4oLi4uYXJnczogYW55W10pOiB2b2lkO1xuICBlcnJvciguLi5hcmdzOiBhbnlbXSk6IHZvaWQ7XG59O1xuXG5leHBvcnQgY2xhc3MgRGVmYXVsdExvZ2dlciBpbXBsZW1lbnRzIExvZ2dlciB7XG4gIHByaXZhdGUgX29uTG9nTGluZUZ1bmNzOiBSZWNvcmQ8XG4gICAgc3RyaW5nLFxuICAgIChsZXZlbDogTG9nTGV2ZWwsIC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkXG4gID47XG4gIHByaXZhdGUgX3ZlcmJvc2U6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3Iob3B0aW9uczogeyB2ZXJib3NlOiBib29sZWFuIH0pIHtcbiAgICB0aGlzLl9vbkxvZ0xpbmVGdW5jcyA9IHt9O1xuICAgIHRoaXMuX3ZlcmJvc2UgPSBvcHRpb25zLnZlcmJvc2U7XG4gIH1cblxuICBhZGRMb2dMaW5lTGlzdGVuZXIoXG4gICAgZnVuYzogKGxldmVsOiBMb2dMZXZlbCwgLi4uYXJnczogYW55W10pID0+IHZvaWQsXG4gICk6ICgpID0+IHZvaWQge1xuICAgIGxldCBpZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxNSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5fb25Mb2dMaW5lRnVuY3NbaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxNSk7XG4gICAgfVxuICAgIHRoaXMuX29uTG9nTGluZUZ1bmNzW2lkXSA9IGZ1bmM7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9vbkxvZ0xpbmVGdW5jc1tpZF07XG4gICAgfTtcbiAgfVxuXG4gIGxvZ1ZlcmJvc2UoLi4uYXJnczogYW55W10pIHtcbiAgICBpZiAodGhpcy5fdmVyYm9zZSkge1xuICAgICAgZm9yIChjb25zdCBmdW5jIG9mIE9iamVjdC52YWx1ZXModGhpcy5fb25Mb2dMaW5lRnVuY3MpKSB7XG4gICAgICAgIGZ1bmMoXCJkZWJ1Z1wiLCBgJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9YCwgLi4uYXJncyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbG9nKC4uLmFyZ3M6IGFueVtdKSB7XG4gICAgZm9yIChjb25zdCBmdW5jIG9mIE9iamVjdC52YWx1ZXModGhpcy5fb25Mb2dMaW5lRnVuY3MpKSB7XG4gICAgICBmdW5jKFwiaW5mb1wiLCAuLi5hcmdzKTtcbiAgICB9XG4gIH1cblxuICB3YXJuKC4uLmFyZ3M6IGFueVtdKSB7XG4gICAgZm9yIChjb25zdCBmdW5jIG9mIE9iamVjdC52YWx1ZXModGhpcy5fb25Mb2dMaW5lRnVuY3MpKSB7XG4gICAgICBmdW5jKFwid2FyblwiLCAuLi5hcmdzKTtcbiAgICB9XG4gIH1cblxuICBlcnJvciguLi5hcmdzOiBhbnlbXSkge1xuICAgIGZvciAoY29uc3QgZnVuYyBvZiBPYmplY3QudmFsdWVzKHRoaXMuX29uTG9nTGluZUZ1bmNzKSkge1xuICAgICAgZnVuYyhcImVycm9yXCIsIC4uLmFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5zdGFudGlhdGVEZWZhdWx0TG9nZ2VyKG9wdGlvbnM6IHtcbiAgdmVyYm9zZTogYm9vbGVhbjtcbn0pOiBMb2dnZXIge1xuICBjb25zdCBsb2dnZXIgPSBuZXcgRGVmYXVsdExvZ2dlcihvcHRpb25zKTtcbiAgbG9nZ2VyLmFkZExvZ0xpbmVMaXN0ZW5lcigobGV2ZWwsIC4uLmFyZ3MpID0+IHtcbiAgICBzd2l0Y2ggKGxldmVsKSB7XG4gICAgICBjYXNlIFwiZGVidWdcIjpcbiAgICAgICAgY29uc29sZS5kZWJ1ZyguLi5hcmdzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaW5mb1wiOlxuICAgICAgICBjb25zb2xlLmxvZyguLi5hcmdzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwid2FyblwiOlxuICAgICAgICBjb25zb2xlLndhcm4oLi4uYXJncyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoLi4uYXJncyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBsZXZlbCBzYXRpc2ZpZXMgbmV2ZXI7XG4gICAgICAgIGNvbnNvbGUubG9nKC4uLmFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBsb2dnZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnN0YW50aWF0ZU5vb3BMb2dnZXIob3B0aW9uczogeyB2ZXJib3NlOiBib29sZWFuIH0pOiBMb2dnZXIge1xuICByZXR1cm4gbmV3IERlZmF1bHRMb2dnZXIob3B0aW9ucyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2dGb3JGdW5jdGlvbihcbiAgbG9nZ2VyOiBMb2dnZXIsXG4gIHR5cGU6IFwiaW5mb1wiIHwgXCJlcnJvclwiLFxuICBzb3VyY2U6IFVkZlR5cGUsXG4gIHVkZlBhdGg6IHN0cmluZyxcbiAgbWVzc2FnZTogc3RyaW5nIHwgeyBlcnJvckRhdGE6IFZhbHVlIH0sXG4pIHtcbiAgY29uc3QgcHJlZml4ID0gcHJlZml4X2Zvcl9zb3VyY2Uoc291cmNlKTtcblxuICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09IFwib2JqZWN0XCIpIHtcbiAgICBtZXNzYWdlID0gYENvbnZleEVycm9yICR7SlNPTi5zdHJpbmdpZnkobWVzc2FnZS5lcnJvckRhdGEsIG51bGwsIDIpfWA7XG4gIH1cbiAgaWYgKHR5cGUgPT09IFwiaW5mb1wiKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBtZXNzYWdlLm1hdGNoKC9eXFxbLio/XFxdIC8pO1xuICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgbG9nZ2VyLmVycm9yKFxuICAgICAgICBgW0NPTlZFWCAke3ByZWZpeH0oJHt1ZGZQYXRofSldIENvdWxkIG5vdCBwYXJzZSBjb25zb2xlLmxvZ2AsXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsZXZlbCA9IG1lc3NhZ2Uuc2xpY2UoMSwgbWF0Y2hbMF0ubGVuZ3RoIC0gMik7XG4gICAgY29uc3QgYXJncyA9IG1lc3NhZ2Uuc2xpY2UobWF0Y2hbMF0ubGVuZ3RoKTtcblxuICAgIGxvZ2dlci5sb2coYCVjW0NPTlZFWCAke3ByZWZpeH0oJHt1ZGZQYXRofSldIFske2xldmVsfV1gLCBJTkZPX0NPTE9SLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICBsb2dnZXIuZXJyb3IoYFtDT05WRVggJHtwcmVmaXh9KCR7dWRmUGF0aH0pXSAke21lc3NhZ2V9YCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvZ0ZhdGFsRXJyb3IobG9nZ2VyOiBMb2dnZXIsIG1lc3NhZ2U6IHN0cmluZyk6IEVycm9yIHtcbiAgY29uc3QgZXJyb3JNZXNzYWdlID0gYFtDT05WRVggRkFUQUwgRVJST1JdICR7bWVzc2FnZX1gO1xuICBsb2dnZXIuZXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgcmV0dXJuIG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSHlicmlkRXJyb3JTdGFja3RyYWNlKFxuICBzb3VyY2U6IFVkZlR5cGUsXG4gIHVkZlBhdGg6IHN0cmluZyxcbiAgcmVzdWx0OiBGdW5jdGlvbkZhaWx1cmUsXG4pOiBzdHJpbmcge1xuICBjb25zdCBwcmVmaXggPSBwcmVmaXhfZm9yX3NvdXJjZShzb3VyY2UpO1xuICByZXR1cm4gYFtDT05WRVggJHtwcmVmaXh9KCR7dWRmUGF0aH0pXSAke3Jlc3VsdC5lcnJvck1lc3NhZ2V9XFxuICBDYWxsZWQgYnkgY2xpZW50YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcndhcmREYXRhKFxuICByZXN1bHQ6IEZ1bmN0aW9uRmFpbHVyZSxcbiAgZXJyb3I6IENvbnZleEVycm9yPHN0cmluZz4sXG4pIHtcbiAgKGVycm9yIGFzIENvbnZleEVycm9yPGFueT4pLmRhdGEgPSByZXN1bHQuZXJyb3JEYXRhO1xuICByZXR1cm4gZXJyb3I7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG5pbXBvcnQgeyBjb252ZXhUb0pzb24gfSBmcm9tIFwiLi4vLi4vdmFsdWVzL2luZGV4LmpzXCI7XG5pbXBvcnQge1xuICBjYW5vbmljYWxpemVVZGZQYXRoLFxuICBzZXJpYWxpemVQYXRoQW5kQXJnc1xufSBmcm9tIFwiLi91ZGZfcGF0aF91dGlscy5qc1wiO1xuZXhwb3J0IGNsYXNzIExvY2FsU3luY1N0YXRlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm5leHRRdWVyeUlkXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJxdWVyeVNldFZlcnNpb25cIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInF1ZXJ5U2V0XCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJxdWVyeUlkVG9Ub2tlblwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaWRlbnRpdHlWZXJzaW9uXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJhdXRoXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJvdXRzdGFuZGluZ1F1ZXJpZXNPbGRlclRoYW5SZXN0YXJ0XCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJvdXRzdGFuZGluZ0F1dGhPbGRlclRoYW5SZXN0YXJ0XCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJwYXVzZWRcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInBlbmRpbmdRdWVyeVNldE1vZGlmaWNhdGlvbnNcIik7XG4gICAgdGhpcy5uZXh0UXVlcnlJZCA9IDA7XG4gICAgdGhpcy5xdWVyeVNldFZlcnNpb24gPSAwO1xuICAgIHRoaXMuaWRlbnRpdHlWZXJzaW9uID0gMDtcbiAgICB0aGlzLnF1ZXJ5U2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLnF1ZXJ5SWRUb1Rva2VuID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLm91dHN0YW5kaW5nUXVlcmllc09sZGVyVGhhblJlc3RhcnQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMub3V0c3RhbmRpbmdBdXRoT2xkZXJUaGFuUmVzdGFydCA9IGZhbHNlO1xuICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XG4gICAgdGhpcy5wZW5kaW5nUXVlcnlTZXRNb2RpZmljYXRpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBoYXNTeW5jZWRQYXN0TGFzdFJlY29ubmVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5vdXRzdGFuZGluZ1F1ZXJpZXNPbGRlclRoYW5SZXN0YXJ0LnNpemUgPT09IDAgJiYgIXRoaXMub3V0c3RhbmRpbmdBdXRoT2xkZXJUaGFuUmVzdGFydDtcbiAgfVxuICBtYXJrQXV0aENvbXBsZXRpb24oKSB7XG4gICAgdGhpcy5vdXRzdGFuZGluZ0F1dGhPbGRlclRoYW5SZXN0YXJ0ID0gZmFsc2U7XG4gIH1cbiAgc3Vic2NyaWJlKHVkZlBhdGgsIGFyZ3MsIGpvdXJuYWwsIGNvbXBvbmVudFBhdGgpIHtcbiAgICBjb25zdCBjYW5vbmljYWxpemVkVWRmUGF0aCA9IGNhbm9uaWNhbGl6ZVVkZlBhdGgodWRmUGF0aCk7XG4gICAgY29uc3QgcXVlcnlUb2tlbiA9IHNlcmlhbGl6ZVBhdGhBbmRBcmdzKGNhbm9uaWNhbGl6ZWRVZGZQYXRoLCBhcmdzKTtcbiAgICBjb25zdCBleGlzdGluZ0VudHJ5ID0gdGhpcy5xdWVyeVNldC5nZXQocXVlcnlUb2tlbik7XG4gICAgaWYgKGV4aXN0aW5nRW50cnkgIT09IHZvaWQgMCkge1xuICAgICAgZXhpc3RpbmdFbnRyeS5udW1TdWJzY3JpYmVycyArPSAxO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcXVlcnlUb2tlbixcbiAgICAgICAgbW9kaWZpY2F0aW9uOiBudWxsLFxuICAgICAgICB1bnN1YnNjcmliZTogKCkgPT4gdGhpcy5yZW1vdmVTdWJzY3JpYmVyKHF1ZXJ5VG9rZW4pXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBxdWVyeUlkID0gdGhpcy5uZXh0UXVlcnlJZCsrO1xuICAgICAgY29uc3QgcXVlcnkgPSB7XG4gICAgICAgIGlkOiBxdWVyeUlkLFxuICAgICAgICBjYW5vbmljYWxpemVkVWRmUGF0aCxcbiAgICAgICAgYXJncyxcbiAgICAgICAgbnVtU3Vic2NyaWJlcnM6IDEsXG4gICAgICAgIGpvdXJuYWwsXG4gICAgICAgIGNvbXBvbmVudFBhdGhcbiAgICAgIH07XG4gICAgICB0aGlzLnF1ZXJ5U2V0LnNldChxdWVyeVRva2VuLCBxdWVyeSk7XG4gICAgICB0aGlzLnF1ZXJ5SWRUb1Rva2VuLnNldChxdWVyeUlkLCBxdWVyeVRva2VuKTtcbiAgICAgIGNvbnN0IGJhc2VWZXJzaW9uID0gdGhpcy5xdWVyeVNldFZlcnNpb247XG4gICAgICBjb25zdCBuZXdWZXJzaW9uID0gdGhpcy5xdWVyeVNldFZlcnNpb24gKyAxO1xuICAgICAgY29uc3QgYWRkID0ge1xuICAgICAgICB0eXBlOiBcIkFkZFwiLFxuICAgICAgICBxdWVyeUlkLFxuICAgICAgICB1ZGZQYXRoOiBjYW5vbmljYWxpemVkVWRmUGF0aCxcbiAgICAgICAgYXJnczogW2NvbnZleFRvSnNvbihhcmdzKV0sXG4gICAgICAgIGpvdXJuYWwsXG4gICAgICAgIGNvbXBvbmVudFBhdGhcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5wYXVzZWQpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nUXVlcnlTZXRNb2RpZmljYXRpb25zLnNldChxdWVyeUlkLCBhZGQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5xdWVyeVNldFZlcnNpb24gPSBuZXdWZXJzaW9uO1xuICAgICAgfVxuICAgICAgY29uc3QgbW9kaWZpY2F0aW9uID0ge1xuICAgICAgICB0eXBlOiBcIk1vZGlmeVF1ZXJ5U2V0XCIsXG4gICAgICAgIGJhc2VWZXJzaW9uLFxuICAgICAgICBuZXdWZXJzaW9uLFxuICAgICAgICBtb2RpZmljYXRpb25zOiBbYWRkXVxuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHF1ZXJ5VG9rZW4sXG4gICAgICAgIG1vZGlmaWNhdGlvbixcbiAgICAgICAgdW5zdWJzY3JpYmU6ICgpID0+IHRoaXMucmVtb3ZlU3Vic2NyaWJlcihxdWVyeVRva2VuKVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgdHJhbnNpdGlvbih0cmFuc2l0aW9uKSB7XG4gICAgZm9yIChjb25zdCBtb2RpZmljYXRpb24gb2YgdHJhbnNpdGlvbi5tb2RpZmljYXRpb25zKSB7XG4gICAgICBzd2l0Y2ggKG1vZGlmaWNhdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJRdWVyeVVwZGF0ZWRcIjpcbiAgICAgICAgY2FzZSBcIlF1ZXJ5RmFpbGVkXCI6IHtcbiAgICAgICAgICB0aGlzLm91dHN0YW5kaW5nUXVlcmllc09sZGVyVGhhblJlc3RhcnQuZGVsZXRlKG1vZGlmaWNhdGlvbi5xdWVyeUlkKTtcbiAgICAgICAgICBjb25zdCBqb3VybmFsID0gbW9kaWZpY2F0aW9uLmpvdXJuYWw7XG4gICAgICAgICAgaWYgKGpvdXJuYWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlUb2tlbiA9IHRoaXMucXVlcnlJZFRvVG9rZW4uZ2V0KG1vZGlmaWNhdGlvbi5xdWVyeUlkKTtcbiAgICAgICAgICAgIGlmIChxdWVyeVRva2VuICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgdGhpcy5xdWVyeVNldC5nZXQocXVlcnlUb2tlbikuam91cm5hbCA9IGpvdXJuYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJRdWVyeVJlbW92ZWRcIjoge1xuICAgICAgICAgIHRoaXMub3V0c3RhbmRpbmdRdWVyaWVzT2xkZXJUaGFuUmVzdGFydC5kZWxldGUobW9kaWZpY2F0aW9uLnF1ZXJ5SWQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBtb2RpZmljYXRpb247XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1vZGlmaWNhdGlvbiAke21vZGlmaWNhdGlvbi50eXBlfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHF1ZXJ5SWQodWRmUGF0aCwgYXJncykge1xuICAgIGNvbnN0IGNhbm9uaWNhbGl6ZWRVZGZQYXRoID0gY2Fub25pY2FsaXplVWRmUGF0aCh1ZGZQYXRoKTtcbiAgICBjb25zdCBxdWVyeVRva2VuID0gc2VyaWFsaXplUGF0aEFuZEFyZ3MoY2Fub25pY2FsaXplZFVkZlBhdGgsIGFyZ3MpO1xuICAgIGNvbnN0IGV4aXN0aW5nRW50cnkgPSB0aGlzLnF1ZXJ5U2V0LmdldChxdWVyeVRva2VuKTtcbiAgICBpZiAoZXhpc3RpbmdFbnRyeSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gZXhpc3RpbmdFbnRyeS5pZDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaXNDdXJyZW50T3JOZXdlckF1dGhWZXJzaW9uKHZlcnNpb24pIHtcbiAgICByZXR1cm4gdmVyc2lvbiA+PSB0aGlzLmlkZW50aXR5VmVyc2lvbjtcbiAgfVxuICBnZXRBdXRoKCkge1xuICAgIHJldHVybiB0aGlzLmF1dGg7XG4gIH1cbiAgc2V0QXV0aCh2YWx1ZSkge1xuICAgIHRoaXMuYXV0aCA9IHtcbiAgICAgIHRva2VuVHlwZTogXCJVc2VyXCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gICAgY29uc3QgYmFzZVZlcnNpb24gPSB0aGlzLmlkZW50aXR5VmVyc2lvbjtcbiAgICBpZiAoIXRoaXMucGF1c2VkKSB7XG4gICAgICB0aGlzLmlkZW50aXR5VmVyc2lvbiA9IGJhc2VWZXJzaW9uICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiQXV0aGVudGljYXRlXCIsXG4gICAgICBiYXNlVmVyc2lvbixcbiAgICAgIC4uLnRoaXMuYXV0aFxuICAgIH07XG4gIH1cbiAgc2V0QWRtaW5BdXRoKHZhbHVlLCBhY3RpbmdBcykge1xuICAgIGNvbnN0IGF1dGggPSB7XG4gICAgICB0b2tlblR5cGU6IFwiQWRtaW5cIixcbiAgICAgIHZhbHVlLFxuICAgICAgaW1wZXJzb25hdGluZzogYWN0aW5nQXNcbiAgICB9O1xuICAgIHRoaXMuYXV0aCA9IGF1dGg7XG4gICAgY29uc3QgYmFzZVZlcnNpb24gPSB0aGlzLmlkZW50aXR5VmVyc2lvbjtcbiAgICBpZiAoIXRoaXMucGF1c2VkKSB7XG4gICAgICB0aGlzLmlkZW50aXR5VmVyc2lvbiA9IGJhc2VWZXJzaW9uICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiQXV0aGVudGljYXRlXCIsXG4gICAgICBiYXNlVmVyc2lvbixcbiAgICAgIC4uLmF1dGhcbiAgICB9O1xuICB9XG4gIGNsZWFyQXV0aCgpIHtcbiAgICB0aGlzLmF1dGggPSB2b2lkIDA7XG4gICAgdGhpcy5tYXJrQXV0aENvbXBsZXRpb24oKTtcbiAgICBjb25zdCBiYXNlVmVyc2lvbiA9IHRoaXMuaWRlbnRpdHlWZXJzaW9uO1xuICAgIGlmICghdGhpcy5wYXVzZWQpIHtcbiAgICAgIHRoaXMuaWRlbnRpdHlWZXJzaW9uID0gYmFzZVZlcnNpb24gKyAxO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJBdXRoZW50aWNhdGVcIixcbiAgICAgIHRva2VuVHlwZTogXCJOb25lXCIsXG4gICAgICBiYXNlVmVyc2lvblxuICAgIH07XG4gIH1cbiAgaGFzQXV0aCgpIHtcbiAgICByZXR1cm4gISF0aGlzLmF1dGg7XG4gIH1cbiAgaXNOZXdBdXRoKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuYXV0aD8udmFsdWUgIT09IHZhbHVlO1xuICB9XG4gIHF1ZXJ5UGF0aChxdWVyeUlkKSB7XG4gICAgY29uc3QgcGF0aEFuZEFyZ3MgPSB0aGlzLnF1ZXJ5SWRUb1Rva2VuLmdldChxdWVyeUlkKTtcbiAgICBpZiAocGF0aEFuZEFyZ3MpIHtcbiAgICAgIHJldHVybiB0aGlzLnF1ZXJ5U2V0LmdldChwYXRoQW5kQXJncykuY2Fub25pY2FsaXplZFVkZlBhdGg7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHF1ZXJ5QXJncyhxdWVyeUlkKSB7XG4gICAgY29uc3QgcGF0aEFuZEFyZ3MgPSB0aGlzLnF1ZXJ5SWRUb1Rva2VuLmdldChxdWVyeUlkKTtcbiAgICBpZiAocGF0aEFuZEFyZ3MpIHtcbiAgICAgIHJldHVybiB0aGlzLnF1ZXJ5U2V0LmdldChwYXRoQW5kQXJncykuYXJncztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcXVlcnlUb2tlbihxdWVyeUlkKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlJZFRvVG9rZW4uZ2V0KHF1ZXJ5SWQpID8/IG51bGw7XG4gIH1cbiAgcXVlcnlKb3VybmFsKHF1ZXJ5VG9rZW4pIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNldC5nZXQocXVlcnlUb2tlbik/LmpvdXJuYWw7XG4gIH1cbiAgcmVzdGFydChvbGRSZW1vdGVRdWVyeVJlc3VsdHMpIHtcbiAgICB0aGlzLnVucGF1c2UoKTtcbiAgICB0aGlzLm91dHN0YW5kaW5nUXVlcmllc09sZGVyVGhhblJlc3RhcnQuY2xlYXIoKTtcbiAgICBjb25zdCBtb2RpZmljYXRpb25zID0gW107XG4gICAgZm9yIChjb25zdCBsb2NhbFF1ZXJ5IG9mIHRoaXMucXVlcnlTZXQudmFsdWVzKCkpIHtcbiAgICAgIGNvbnN0IGFkZCA9IHtcbiAgICAgICAgdHlwZTogXCJBZGRcIixcbiAgICAgICAgcXVlcnlJZDogbG9jYWxRdWVyeS5pZCxcbiAgICAgICAgdWRmUGF0aDogbG9jYWxRdWVyeS5jYW5vbmljYWxpemVkVWRmUGF0aCxcbiAgICAgICAgYXJnczogW2NvbnZleFRvSnNvbihsb2NhbFF1ZXJ5LmFyZ3MpXSxcbiAgICAgICAgam91cm5hbDogbG9jYWxRdWVyeS5qb3VybmFsLFxuICAgICAgICBjb21wb25lbnRQYXRoOiBsb2NhbFF1ZXJ5LmNvbXBvbmVudFBhdGhcbiAgICAgIH07XG4gICAgICBtb2RpZmljYXRpb25zLnB1c2goYWRkKTtcbiAgICAgIGlmICghb2xkUmVtb3RlUXVlcnlSZXN1bHRzLmhhcyhsb2NhbFF1ZXJ5LmlkKSkge1xuICAgICAgICB0aGlzLm91dHN0YW5kaW5nUXVlcmllc09sZGVyVGhhblJlc3RhcnQuYWRkKGxvY2FsUXVlcnkuaWQpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnF1ZXJ5U2V0VmVyc2lvbiA9IDE7XG4gICAgY29uc3QgcXVlcnlTZXQgPSB7XG4gICAgICB0eXBlOiBcIk1vZGlmeVF1ZXJ5U2V0XCIsXG4gICAgICBiYXNlVmVyc2lvbjogMCxcbiAgICAgIG5ld1ZlcnNpb246IDEsXG4gICAgICBtb2RpZmljYXRpb25zXG4gICAgfTtcbiAgICBpZiAoIXRoaXMuYXV0aCkge1xuICAgICAgdGhpcy5pZGVudGl0eVZlcnNpb24gPSAwO1xuICAgICAgcmV0dXJuIFtxdWVyeVNldCwgdm9pZCAwXTtcbiAgICB9XG4gICAgdGhpcy5vdXRzdGFuZGluZ0F1dGhPbGRlclRoYW5SZXN0YXJ0ID0gdHJ1ZTtcbiAgICBjb25zdCBhdXRoZW50aWNhdGUgPSB7XG4gICAgICB0eXBlOiBcIkF1dGhlbnRpY2F0ZVwiLFxuICAgICAgYmFzZVZlcnNpb246IDAsXG4gICAgICAuLi50aGlzLmF1dGhcbiAgICB9O1xuICAgIHRoaXMuaWRlbnRpdHlWZXJzaW9uID0gMTtcbiAgICByZXR1cm4gW3F1ZXJ5U2V0LCBhdXRoZW50aWNhdGVdO1xuICB9XG4gIHBhdXNlKCkge1xuICAgIHRoaXMucGF1c2VkID0gdHJ1ZTtcbiAgfVxuICByZXN1bWUoKSB7XG4gICAgY29uc3QgcXVlcnlTZXQgPSB0aGlzLnBlbmRpbmdRdWVyeVNldE1vZGlmaWNhdGlvbnMuc2l6ZSA+IDAgPyB7XG4gICAgICB0eXBlOiBcIk1vZGlmeVF1ZXJ5U2V0XCIsXG4gICAgICBiYXNlVmVyc2lvbjogdGhpcy5xdWVyeVNldFZlcnNpb24sXG4gICAgICBuZXdWZXJzaW9uOiArK3RoaXMucXVlcnlTZXRWZXJzaW9uLFxuICAgICAgbW9kaWZpY2F0aW9uczogQXJyYXkuZnJvbShcbiAgICAgICAgdGhpcy5wZW5kaW5nUXVlcnlTZXRNb2RpZmljYXRpb25zLnZhbHVlcygpXG4gICAgICApXG4gICAgfSA6IHZvaWQgMDtcbiAgICBjb25zdCBhdXRoZW50aWNhdGUgPSB0aGlzLmF1dGggIT09IHZvaWQgMCA/IHtcbiAgICAgIHR5cGU6IFwiQXV0aGVudGljYXRlXCIsXG4gICAgICBiYXNlVmVyc2lvbjogdGhpcy5pZGVudGl0eVZlcnNpb24rKyxcbiAgICAgIC4uLnRoaXMuYXV0aFxuICAgIH0gOiB2b2lkIDA7XG4gICAgdGhpcy51bnBhdXNlKCk7XG4gICAgcmV0dXJuIFtxdWVyeVNldCwgYXV0aGVudGljYXRlXTtcbiAgfVxuICB1bnBhdXNlKCkge1xuICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XG4gICAgdGhpcy5wZW5kaW5nUXVlcnlTZXRNb2RpZmljYXRpb25zLmNsZWFyKCk7XG4gIH1cbiAgcmVtb3ZlU3Vic2NyaWJlcihxdWVyeVRva2VuKSB7XG4gICAgY29uc3QgbG9jYWxRdWVyeSA9IHRoaXMucXVlcnlTZXQuZ2V0KHF1ZXJ5VG9rZW4pO1xuICAgIGlmIChsb2NhbFF1ZXJ5Lm51bVN1YnNjcmliZXJzID4gMSkge1xuICAgICAgbG9jYWxRdWVyeS5udW1TdWJzY3JpYmVycyAtPSAxO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucXVlcnlTZXQuZGVsZXRlKHF1ZXJ5VG9rZW4pO1xuICAgICAgdGhpcy5xdWVyeUlkVG9Ub2tlbi5kZWxldGUobG9jYWxRdWVyeS5pZCk7XG4gICAgICB0aGlzLm91dHN0YW5kaW5nUXVlcmllc09sZGVyVGhhblJlc3RhcnQuZGVsZXRlKGxvY2FsUXVlcnkuaWQpO1xuICAgICAgY29uc3QgYmFzZVZlcnNpb24gPSB0aGlzLnF1ZXJ5U2V0VmVyc2lvbjtcbiAgICAgIGNvbnN0IG5ld1ZlcnNpb24gPSB0aGlzLnF1ZXJ5U2V0VmVyc2lvbiArIDE7XG4gICAgICBjb25zdCByZW1vdmUgPSB7XG4gICAgICAgIHR5cGU6IFwiUmVtb3ZlXCIsXG4gICAgICAgIHF1ZXJ5SWQ6IGxvY2FsUXVlcnkuaWRcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5wYXVzZWQpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ1F1ZXJ5U2V0TW9kaWZpY2F0aW9ucy5oYXMobG9jYWxRdWVyeS5pZCkpIHtcbiAgICAgICAgICB0aGlzLnBlbmRpbmdRdWVyeVNldE1vZGlmaWNhdGlvbnMuZGVsZXRlKGxvY2FsUXVlcnkuaWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucGVuZGluZ1F1ZXJ5U2V0TW9kaWZpY2F0aW9ucy5zZXQobG9jYWxRdWVyeS5pZCwgcmVtb3ZlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5xdWVyeVNldFZlcnNpb24gPSBuZXdWZXJzaW9uO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJNb2RpZnlRdWVyeVNldFwiLFxuICAgICAgICBiYXNlVmVyc2lvbixcbiAgICAgICAgbmV3VmVyc2lvbixcbiAgICAgICAgbW9kaWZpY2F0aW9uczogW3JlbW92ZV1cbiAgICAgIH07XG4gICAgfVxuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2NhbF9zdGF0ZS5qcy5tYXBcbiIsIi8qKlxuICogVGhlIGxvY2FsIHN0YXRlIG9mIHRoZSBjbGllbnQ6XG4gKiAtIHdoaWNoIHF1ZXJpZXMgYXJlIHN1YnNjcmliZWQgdG9cbiAqIC0gdGhlIFwiUXVlcnkgU2V0IFZlcnNpb24sXCIgdXNlZCB0byBwcm9kdWNlIFF1ZXJ5U2V0TW9kaWZpY2F0aW9uIG1lc3NhZ2VzXG4gKiAtIHRoZSBjdXJyZW50IGF1dGggdG9rZW4gYW5kIFwiSWRlbnRpdHkgVmVyc2lvblwiXG4gKlxuICogTG9jYWwgc3RhdGUgZG9lcyBub3QgaW5jbHVkZTpcbiAqIC0gcXVlcnkgcmVzdWx0cyAoc2VlIFJlbW90ZVF1ZXJ5U2V0KVxuICogLSBsb2NhbGx5IG1hZGUgXCJvcHRpbWlzdGljIHVwZGF0ZVwiIG1vZGlmaWNhdGlvbnMgdG8gcXVlcnkgcmVzdWx0cyAoc2VlIE9wdGltaXN0aWNRdWVyeVJlc3VsdHMpXG4gKiAtIGFueSBxdWVyeSByZXN1bHRzIGF0IGFsbFxuICoqL1xuXG5pbXBvcnQgeyBjb252ZXhUb0pzb24sIFZhbHVlIH0gZnJvbSBcIi4uLy4uL3ZhbHVlcy9pbmRleC5qc1wiO1xuaW1wb3J0IHtcbiAgQWRkUXVlcnksXG4gIFJlbW92ZVF1ZXJ5LFxuICBRdWVyeUlkLFxuICBRdWVyeVNldE1vZGlmaWNhdGlvbixcbiAgUXVlcnlTZXRWZXJzaW9uLFxuICBJZGVudGl0eVZlcnNpb24sXG4gIEF1dGhlbnRpY2F0ZSxcbiAgUXVlcnlKb3VybmFsLFxuICBUcmFuc2l0aW9uLFxuICBBZG1pbkF1dGhlbnRpY2F0aW9uLFxuICBVc2VySWRlbnRpdHlBdHRyaWJ1dGVzLFxufSBmcm9tIFwiLi9wcm90b2NvbC5qc1wiO1xuaW1wb3J0IHtcbiAgY2Fub25pY2FsaXplVWRmUGF0aCxcbiAgUXVlcnlUb2tlbixcbiAgc2VyaWFsaXplUGF0aEFuZEFyZ3MsXG59IGZyb20gXCIuL3VkZl9wYXRoX3V0aWxzLmpzXCI7XG5cbnR5cGUgTG9jYWxRdWVyeSA9IHtcbiAgaWQ6IFF1ZXJ5SWQ7XG4gIGNhbm9uaWNhbGl6ZWRVZGZQYXRoOiBzdHJpbmc7XG4gIGFyZ3M6IFJlY29yZDxzdHJpbmcsIFZhbHVlPjtcbiAgbnVtU3Vic2NyaWJlcnM6IG51bWJlcjtcbiAgam91cm5hbD86IFF1ZXJ5Sm91cm5hbCB8IHVuZGVmaW5lZDtcbiAgY29tcG9uZW50UGF0aD86IHN0cmluZyB8IHVuZGVmaW5lZDtcbn07XG5cbmV4cG9ydCB0eXBlIEF1dGhTdGF0ZSA9XG4gIHwge1xuICAgICAgdG9rZW5UeXBlOiBcIlVzZXJcIjtcbiAgICAgIHZhbHVlOiBzdHJpbmc7XG4gICAgfVxuICB8IHtcbiAgICAgIHRva2VuVHlwZTogXCJBZG1pblwiO1xuICAgICAgdmFsdWU6IHN0cmluZztcbiAgICAgIGltcGVyc29uYXRpbmc/OiBVc2VySWRlbnRpdHlBdHRyaWJ1dGVzIHwgdW5kZWZpbmVkO1xuICAgIH07XG5cbmV4cG9ydCBjbGFzcyBMb2NhbFN5bmNTdGF0ZSB7XG4gIHByaXZhdGUgbmV4dFF1ZXJ5SWQ6IFF1ZXJ5SWQ7XG4gIHByaXZhdGUgcXVlcnlTZXRWZXJzaW9uOiBRdWVyeVNldFZlcnNpb247XG4gIHByaXZhdGUgcmVhZG9ubHkgcXVlcnlTZXQ6IE1hcDxRdWVyeVRva2VuLCBMb2NhbFF1ZXJ5PjtcbiAgcHJpdmF0ZSByZWFkb25seSBxdWVyeUlkVG9Ub2tlbjogTWFwPFF1ZXJ5SWQsIFF1ZXJ5VG9rZW4+O1xuICBwcml2YXRlIGlkZW50aXR5VmVyc2lvbjogSWRlbnRpdHlWZXJzaW9uO1xuICBwcml2YXRlIGF1dGg6IEF1dGhTdGF0ZSB8IHVuZGVmaW5lZDtcbiAgcHJpdmF0ZSByZWFkb25seSBvdXRzdGFuZGluZ1F1ZXJpZXNPbGRlclRoYW5SZXN0YXJ0OiBTZXQ8UXVlcnlJZD47XG4gIHByaXZhdGUgb3V0c3RhbmRpbmdBdXRoT2xkZXJUaGFuUmVzdGFydDogYm9vbGVhbjtcbiAgcHJpdmF0ZSBwYXVzZWQ6IGJvb2xlYW47XG4gIHByaXZhdGUgcGVuZGluZ1F1ZXJ5U2V0TW9kaWZpY2F0aW9uczogTWFwPFF1ZXJ5SWQsIEFkZFF1ZXJ5IHwgUmVtb3ZlUXVlcnk+O1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubmV4dFF1ZXJ5SWQgPSAwO1xuICAgIHRoaXMucXVlcnlTZXRWZXJzaW9uID0gMDtcbiAgICB0aGlzLmlkZW50aXR5VmVyc2lvbiA9IDA7XG4gICAgdGhpcy5xdWVyeVNldCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnF1ZXJ5SWRUb1Rva2VuID0gbmV3IE1hcCgpO1xuICAgIHRoaXMub3V0c3RhbmRpbmdRdWVyaWVzT2xkZXJUaGFuUmVzdGFydCA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLm91dHN0YW5kaW5nQXV0aE9sZGVyVGhhblJlc3RhcnQgPSBmYWxzZTtcbiAgICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xuICAgIHRoaXMucGVuZGluZ1F1ZXJ5U2V0TW9kaWZpY2F0aW9ucyA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gIGhhc1N5bmNlZFBhc3RMYXN0UmVjb25uZWN0KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLm91dHN0YW5kaW5nUXVlcmllc09sZGVyVGhhblJlc3RhcnQuc2l6ZSA9PT0gMCAmJlxuICAgICAgIXRoaXMub3V0c3RhbmRpbmdBdXRoT2xkZXJUaGFuUmVzdGFydFxuICAgICk7XG4gIH1cblxuICBtYXJrQXV0aENvbXBsZXRpb24oKSB7XG4gICAgdGhpcy5vdXRzdGFuZGluZ0F1dGhPbGRlclRoYW5SZXN0YXJ0ID0gZmFsc2U7XG4gIH1cblxuICBzdWJzY3JpYmUoXG4gICAgdWRmUGF0aDogc3RyaW5nLFxuICAgIGFyZ3M6IFJlY29yZDxzdHJpbmcsIFZhbHVlPixcbiAgICBqb3VybmFsPzogUXVlcnlKb3VybmFsIHwgdW5kZWZpbmVkLFxuICAgIGNvbXBvbmVudFBhdGg/OiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICk6IHtcbiAgICBxdWVyeVRva2VuOiBRdWVyeVRva2VuO1xuICAgIG1vZGlmaWNhdGlvbjogUXVlcnlTZXRNb2RpZmljYXRpb24gfCBudWxsO1xuICAgIHVuc3Vic2NyaWJlOiAoKSA9PiBRdWVyeVNldE1vZGlmaWNhdGlvbiB8IG51bGw7XG4gIH0ge1xuICAgIGNvbnN0IGNhbm9uaWNhbGl6ZWRVZGZQYXRoID0gY2Fub25pY2FsaXplVWRmUGF0aCh1ZGZQYXRoKTtcbiAgICBjb25zdCBxdWVyeVRva2VuID0gc2VyaWFsaXplUGF0aEFuZEFyZ3MoY2Fub25pY2FsaXplZFVkZlBhdGgsIGFyZ3MpO1xuXG4gICAgY29uc3QgZXhpc3RpbmdFbnRyeSA9IHRoaXMucXVlcnlTZXQuZ2V0KHF1ZXJ5VG9rZW4pO1xuXG4gICAgaWYgKGV4aXN0aW5nRW50cnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZXhpc3RpbmdFbnRyeS5udW1TdWJzY3JpYmVycyArPSAxO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcXVlcnlUb2tlbixcbiAgICAgICAgbW9kaWZpY2F0aW9uOiBudWxsLFxuICAgICAgICB1bnN1YnNjcmliZTogKCkgPT4gdGhpcy5yZW1vdmVTdWJzY3JpYmVyKHF1ZXJ5VG9rZW4pLFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcXVlcnlJZCA9IHRoaXMubmV4dFF1ZXJ5SWQrKztcbiAgICAgIGNvbnN0IHF1ZXJ5OiBMb2NhbFF1ZXJ5ID0ge1xuICAgICAgICBpZDogcXVlcnlJZCxcbiAgICAgICAgY2Fub25pY2FsaXplZFVkZlBhdGgsXG4gICAgICAgIGFyZ3MsXG4gICAgICAgIG51bVN1YnNjcmliZXJzOiAxLFxuICAgICAgICBqb3VybmFsLFxuICAgICAgICBjb21wb25lbnRQYXRoLFxuICAgICAgfTtcbiAgICAgIHRoaXMucXVlcnlTZXQuc2V0KHF1ZXJ5VG9rZW4sIHF1ZXJ5KTtcbiAgICAgIHRoaXMucXVlcnlJZFRvVG9rZW4uc2V0KHF1ZXJ5SWQsIHF1ZXJ5VG9rZW4pO1xuXG4gICAgICBjb25zdCBiYXNlVmVyc2lvbiA9IHRoaXMucXVlcnlTZXRWZXJzaW9uO1xuICAgICAgY29uc3QgbmV3VmVyc2lvbiA9IHRoaXMucXVlcnlTZXRWZXJzaW9uICsgMTtcblxuICAgICAgY29uc3QgYWRkOiBBZGRRdWVyeSA9IHtcbiAgICAgICAgdHlwZTogXCJBZGRcIixcbiAgICAgICAgcXVlcnlJZCxcbiAgICAgICAgdWRmUGF0aDogY2Fub25pY2FsaXplZFVkZlBhdGgsXG4gICAgICAgIGFyZ3M6IFtjb252ZXhUb0pzb24oYXJncyldLFxuICAgICAgICBqb3VybmFsLFxuICAgICAgICBjb21wb25lbnRQYXRoLFxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMucGF1c2VkKSB7XG4gICAgICAgIHRoaXMucGVuZGluZ1F1ZXJ5U2V0TW9kaWZpY2F0aW9ucy5zZXQocXVlcnlJZCwgYWRkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucXVlcnlTZXRWZXJzaW9uID0gbmV3VmVyc2lvbjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbW9kaWZpY2F0aW9uOiBRdWVyeVNldE1vZGlmaWNhdGlvbiA9IHtcbiAgICAgICAgdHlwZTogXCJNb2RpZnlRdWVyeVNldFwiLFxuICAgICAgICBiYXNlVmVyc2lvbixcbiAgICAgICAgbmV3VmVyc2lvbixcbiAgICAgICAgbW9kaWZpY2F0aW9uczogW2FkZF0sXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcXVlcnlUb2tlbixcbiAgICAgICAgbW9kaWZpY2F0aW9uLFxuICAgICAgICB1bnN1YnNjcmliZTogKCkgPT4gdGhpcy5yZW1vdmVTdWJzY3JpYmVyKHF1ZXJ5VG9rZW4pLFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICB0cmFuc2l0aW9uKHRyYW5zaXRpb246IFRyYW5zaXRpb24pIHtcbiAgICBmb3IgKGNvbnN0IG1vZGlmaWNhdGlvbiBvZiB0cmFuc2l0aW9uLm1vZGlmaWNhdGlvbnMpIHtcbiAgICAgIHN3aXRjaCAobW9kaWZpY2F0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcIlF1ZXJ5VXBkYXRlZFwiOlxuICAgICAgICBjYXNlIFwiUXVlcnlGYWlsZWRcIjoge1xuICAgICAgICAgIHRoaXMub3V0c3RhbmRpbmdRdWVyaWVzT2xkZXJUaGFuUmVzdGFydC5kZWxldGUobW9kaWZpY2F0aW9uLnF1ZXJ5SWQpO1xuICAgICAgICAgIGNvbnN0IGpvdXJuYWwgPSBtb2RpZmljYXRpb24uam91cm5hbDtcbiAgICAgICAgICBpZiAoam91cm5hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVRva2VuID0gdGhpcy5xdWVyeUlkVG9Ub2tlbi5nZXQobW9kaWZpY2F0aW9uLnF1ZXJ5SWQpO1xuICAgICAgICAgICAgLy8gV2UgbWF5IGhhdmUgYWxyZWFkeSB1bnN1YnNjcmliZWQgdG8gdGhpcyBxdWVyeSBieSB0aGUgdGltZSB0aGUgc2VydmVyXG4gICAgICAgICAgICAvLyBzZW5kcyB1cyB0aGUgam91cm5hbC4gSWYgc28sIGp1c3QgaWdub3JlIGl0LlxuICAgICAgICAgICAgaWYgKHF1ZXJ5VG9rZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0aGlzLnF1ZXJ5U2V0LmdldChxdWVyeVRva2VuKSEuam91cm5hbCA9IGpvdXJuYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIlF1ZXJ5UmVtb3ZlZFwiOiB7XG4gICAgICAgICAgdGhpcy5vdXRzdGFuZGluZ1F1ZXJpZXNPbGRlclRoYW5SZXN0YXJ0LmRlbGV0ZShtb2RpZmljYXRpb24ucXVlcnlJZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIC8vIEVuZm9yY2UgdGhhdCB0aGUgc3dpdGNoLWNhc2UgaXMgZXhoYXVzdGl2ZS5cbiAgICAgICAgICBtb2RpZmljYXRpb24gc2F0aXNmaWVzIG5ldmVyO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBtb2RpZmljYXRpb24gJHsobW9kaWZpY2F0aW9uIGFzIGFueSkudHlwZX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHF1ZXJ5SWQodWRmUGF0aDogc3RyaW5nLCBhcmdzOiBSZWNvcmQ8c3RyaW5nLCBWYWx1ZT4pOiBRdWVyeUlkIHwgbnVsbCB7XG4gICAgY29uc3QgY2Fub25pY2FsaXplZFVkZlBhdGggPSBjYW5vbmljYWxpemVVZGZQYXRoKHVkZlBhdGgpO1xuICAgIGNvbnN0IHF1ZXJ5VG9rZW4gPSBzZXJpYWxpemVQYXRoQW5kQXJncyhjYW5vbmljYWxpemVkVWRmUGF0aCwgYXJncyk7XG4gICAgY29uc3QgZXhpc3RpbmdFbnRyeSA9IHRoaXMucXVlcnlTZXQuZ2V0KHF1ZXJ5VG9rZW4pO1xuICAgIGlmIChleGlzdGluZ0VudHJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBleGlzdGluZ0VudHJ5LmlkO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlzQ3VycmVudE9yTmV3ZXJBdXRoVmVyc2lvbih2ZXJzaW9uOiBJZGVudGl0eVZlcnNpb24pOiBib29sZWFuIHtcbiAgICByZXR1cm4gdmVyc2lvbiA+PSB0aGlzLmlkZW50aXR5VmVyc2lvbjtcbiAgfVxuXG4gIGdldEF1dGgoKTogQXV0aFN0YXRlIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5hdXRoO1xuICB9XG5cbiAgc2V0QXV0aCh2YWx1ZTogc3RyaW5nKTogQXV0aGVudGljYXRlIHtcbiAgICB0aGlzLmF1dGggPSB7XG4gICAgICB0b2tlblR5cGU6IFwiVXNlclwiIGFzIGNvbnN0LFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgIH07XG4gICAgY29uc3QgYmFzZVZlcnNpb24gPSB0aGlzLmlkZW50aXR5VmVyc2lvbjtcbiAgICBpZiAoIXRoaXMucGF1c2VkKSB7XG4gICAgICB0aGlzLmlkZW50aXR5VmVyc2lvbiA9IGJhc2VWZXJzaW9uICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiQXV0aGVudGljYXRlXCIsXG4gICAgICBiYXNlVmVyc2lvbjogYmFzZVZlcnNpb24sXG4gICAgICAuLi50aGlzLmF1dGgsXG4gICAgfTtcbiAgfVxuXG4gIHNldEFkbWluQXV0aChcbiAgICB2YWx1ZTogc3RyaW5nLFxuICAgIGFjdGluZ0FzPzogVXNlcklkZW50aXR5QXR0cmlidXRlcyxcbiAgKTogQWRtaW5BdXRoZW50aWNhdGlvbiB7XG4gICAgY29uc3QgYXV0aDogdHlwZW9mIHRoaXMuYXV0aCAmIHtcbiAgICAgIHRva2VuVHlwZTogXCJBZG1pblwiO1xuICAgIH0gPSB7XG4gICAgICB0b2tlblR5cGU6IFwiQWRtaW5cIixcbiAgICAgIHZhbHVlLFxuICAgICAgaW1wZXJzb25hdGluZzogYWN0aW5nQXMsXG4gICAgfTtcbiAgICB0aGlzLmF1dGggPSBhdXRoO1xuICAgIGNvbnN0IGJhc2VWZXJzaW9uID0gdGhpcy5pZGVudGl0eVZlcnNpb247XG4gICAgaWYgKCF0aGlzLnBhdXNlZCkge1xuICAgICAgdGhpcy5pZGVudGl0eVZlcnNpb24gPSBiYXNlVmVyc2lvbiArIDE7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkF1dGhlbnRpY2F0ZVwiLFxuICAgICAgYmFzZVZlcnNpb246IGJhc2VWZXJzaW9uLFxuICAgICAgLi4uYXV0aCxcbiAgICB9O1xuICB9XG5cbiAgY2xlYXJBdXRoKCk6IEF1dGhlbnRpY2F0ZSB7XG4gICAgdGhpcy5hdXRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWFya0F1dGhDb21wbGV0aW9uKCk7XG4gICAgY29uc3QgYmFzZVZlcnNpb24gPSB0aGlzLmlkZW50aXR5VmVyc2lvbjtcbiAgICBpZiAoIXRoaXMucGF1c2VkKSB7XG4gICAgICB0aGlzLmlkZW50aXR5VmVyc2lvbiA9IGJhc2VWZXJzaW9uICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiQXV0aGVudGljYXRlXCIsXG4gICAgICB0b2tlblR5cGU6IFwiTm9uZVwiLFxuICAgICAgYmFzZVZlcnNpb246IGJhc2VWZXJzaW9uLFxuICAgIH07XG4gIH1cblxuICBoYXNBdXRoKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhIXRoaXMuYXV0aDtcbiAgfVxuXG4gIGlzTmV3QXV0aCh2YWx1ZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuYXV0aD8udmFsdWUgIT09IHZhbHVlO1xuICB9XG5cbiAgcXVlcnlQYXRoKHF1ZXJ5SWQ6IFF1ZXJ5SWQpOiBzdHJpbmcgfCBudWxsIHtcbiAgICBjb25zdCBwYXRoQW5kQXJncyA9IHRoaXMucXVlcnlJZFRvVG9rZW4uZ2V0KHF1ZXJ5SWQpO1xuICAgIGlmIChwYXRoQW5kQXJncykge1xuICAgICAgcmV0dXJuIHRoaXMucXVlcnlTZXQuZ2V0KHBhdGhBbmRBcmdzKSEuY2Fub25pY2FsaXplZFVkZlBhdGg7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcXVlcnlBcmdzKHF1ZXJ5SWQ6IFF1ZXJ5SWQpOiBSZWNvcmQ8c3RyaW5nLCBWYWx1ZT4gfCBudWxsIHtcbiAgICBjb25zdCBwYXRoQW5kQXJncyA9IHRoaXMucXVlcnlJZFRvVG9rZW4uZ2V0KHF1ZXJ5SWQpO1xuICAgIGlmIChwYXRoQW5kQXJncykge1xuICAgICAgcmV0dXJuIHRoaXMucXVlcnlTZXQuZ2V0KHBhdGhBbmRBcmdzKSEuYXJncztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBxdWVyeVRva2VuKHF1ZXJ5SWQ6IFF1ZXJ5SWQpOiBRdWVyeVRva2VuIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlJZFRvVG9rZW4uZ2V0KHF1ZXJ5SWQpID8/IG51bGw7XG4gIH1cblxuICBxdWVyeUpvdXJuYWwocXVlcnlUb2tlbjogUXVlcnlUb2tlbik6IFF1ZXJ5Sm91cm5hbCB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZXQuZ2V0KHF1ZXJ5VG9rZW4pPy5qb3VybmFsO1xuICB9XG5cbiAgcmVzdGFydChcbiAgICBvbGRSZW1vdGVRdWVyeVJlc3VsdHM6IFNldDxRdWVyeUlkPixcbiAgKTogW1F1ZXJ5U2V0TW9kaWZpY2F0aW9uLCAoQXV0aGVudGljYXRlIHwgdW5kZWZpbmVkKT9dIHtcbiAgICAvLyBSZXN0YXJ0IHdvcmtzIHdoZXRoZXIgd2UgYXJlIHBhdXNlZCBvciB1bnBhdXNlZC5cbiAgICAvLyBUaGUgYHRoaXMucGVuZGluZ1F1ZXJ5U2V0TW9kaWZpY2F0aW9uc2AgaXMgbm90IHVzZWRcbiAgICAvLyB3aGVuIHJlc3RhcnRpbmcgYXMgdGhlIEFkZFF1ZXJ5IGFuZCBSZW1vdmVRdWVyeSBhcmUgY29tcHV0ZWRcbiAgICAvLyBmcm9tIHNjcmF0Y2gsIGJhc2VkIG9uIHRoZSBvbGQgcmVtb3RlIHF1ZXJ5IHJlc3VsdHMsIGhlcmUuXG4gICAgdGhpcy51bnBhdXNlKCk7XG5cbiAgICB0aGlzLm91dHN0YW5kaW5nUXVlcmllc09sZGVyVGhhblJlc3RhcnQuY2xlYXIoKTtcbiAgICBjb25zdCBtb2RpZmljYXRpb25zID0gW107XG4gICAgZm9yIChjb25zdCBsb2NhbFF1ZXJ5IG9mIHRoaXMucXVlcnlTZXQudmFsdWVzKCkpIHtcbiAgICAgIGNvbnN0IGFkZDogQWRkUXVlcnkgPSB7XG4gICAgICAgIHR5cGU6IFwiQWRkXCIsXG4gICAgICAgIHF1ZXJ5SWQ6IGxvY2FsUXVlcnkuaWQsXG4gICAgICAgIHVkZlBhdGg6IGxvY2FsUXVlcnkuY2Fub25pY2FsaXplZFVkZlBhdGgsXG4gICAgICAgIGFyZ3M6IFtjb252ZXhUb0pzb24obG9jYWxRdWVyeS5hcmdzKV0sXG4gICAgICAgIGpvdXJuYWw6IGxvY2FsUXVlcnkuam91cm5hbCxcbiAgICAgICAgY29tcG9uZW50UGF0aDogbG9jYWxRdWVyeS5jb21wb25lbnRQYXRoLFxuICAgICAgfTtcbiAgICAgIG1vZGlmaWNhdGlvbnMucHVzaChhZGQpO1xuXG4gICAgICBpZiAoIW9sZFJlbW90ZVF1ZXJ5UmVzdWx0cy5oYXMobG9jYWxRdWVyeS5pZCkpIHtcbiAgICAgICAgdGhpcy5vdXRzdGFuZGluZ1F1ZXJpZXNPbGRlclRoYW5SZXN0YXJ0LmFkZChsb2NhbFF1ZXJ5LmlkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5xdWVyeVNldFZlcnNpb24gPSAxO1xuICAgIGNvbnN0IHF1ZXJ5U2V0OiBRdWVyeVNldE1vZGlmaWNhdGlvbiA9IHtcbiAgICAgIHR5cGU6IFwiTW9kaWZ5UXVlcnlTZXRcIixcbiAgICAgIGJhc2VWZXJzaW9uOiAwLFxuICAgICAgbmV3VmVyc2lvbjogMSxcbiAgICAgIG1vZGlmaWNhdGlvbnMsXG4gICAgfTtcbiAgICAvLyBJZiB0aGVyZSdzIG5vIGF1dGgsIG5vIG5lZWQgdG8gc2VuZCBhbiB1cGRhdGUgYXMgdGhlIHNlcnZlciB3aWxsIGFsc28gc3RhcnQgd2l0aCBhbiB1bmtub3duIGlkZW50aXR5LlxuICAgIGlmICghdGhpcy5hdXRoKSB7XG4gICAgICB0aGlzLmlkZW50aXR5VmVyc2lvbiA9IDA7XG4gICAgICByZXR1cm4gW3F1ZXJ5U2V0LCB1bmRlZmluZWRdO1xuICAgIH1cbiAgICB0aGlzLm91dHN0YW5kaW5nQXV0aE9sZGVyVGhhblJlc3RhcnQgPSB0cnVlO1xuICAgIGNvbnN0IGF1dGhlbnRpY2F0ZTogQXV0aGVudGljYXRlID0ge1xuICAgICAgdHlwZTogXCJBdXRoZW50aWNhdGVcIixcbiAgICAgIGJhc2VWZXJzaW9uOiAwLFxuICAgICAgLi4udGhpcy5hdXRoLFxuICAgIH07XG4gICAgdGhpcy5pZGVudGl0eVZlcnNpb24gPSAxO1xuICAgIHJldHVybiBbcXVlcnlTZXQsIGF1dGhlbnRpY2F0ZV07XG4gIH1cblxuICBwYXVzZSgpIHtcbiAgICB0aGlzLnBhdXNlZCA9IHRydWU7XG4gIH1cblxuICByZXN1bWUoKTogW1F1ZXJ5U2V0TW9kaWZpY2F0aW9uIHwgdW5kZWZpbmVkLCBBdXRoZW50aWNhdGUgfCB1bmRlZmluZWRdIHtcbiAgICBjb25zdCBxdWVyeVNldDogUXVlcnlTZXRNb2RpZmljYXRpb24gfCB1bmRlZmluZWQgPVxuICAgICAgdGhpcy5wZW5kaW5nUXVlcnlTZXRNb2RpZmljYXRpb25zLnNpemUgPiAwXG4gICAgICAgID8ge1xuICAgICAgICAgICAgdHlwZTogXCJNb2RpZnlRdWVyeVNldFwiLFxuICAgICAgICAgICAgYmFzZVZlcnNpb246IHRoaXMucXVlcnlTZXRWZXJzaW9uLFxuICAgICAgICAgICAgbmV3VmVyc2lvbjogKyt0aGlzLnF1ZXJ5U2V0VmVyc2lvbixcbiAgICAgICAgICAgIG1vZGlmaWNhdGlvbnM6IEFycmF5LmZyb20oXG4gICAgICAgICAgICAgIHRoaXMucGVuZGluZ1F1ZXJ5U2V0TW9kaWZpY2F0aW9ucy52YWx1ZXMoKSxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBhdXRoZW50aWNhdGU6IEF1dGhlbnRpY2F0ZSB8IHVuZGVmaW5lZCA9XG4gICAgICB0aGlzLmF1dGggIT09IHVuZGVmaW5lZFxuICAgICAgICA/IHtcbiAgICAgICAgICAgIHR5cGU6IFwiQXV0aGVudGljYXRlXCIsXG4gICAgICAgICAgICBiYXNlVmVyc2lvbjogdGhpcy5pZGVudGl0eVZlcnNpb24rKyxcbiAgICAgICAgICAgIC4uLnRoaXMuYXV0aCxcbiAgICAgICAgICB9XG4gICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgdGhpcy51bnBhdXNlKCk7XG5cbiAgICByZXR1cm4gW3F1ZXJ5U2V0LCBhdXRoZW50aWNhdGVdO1xuICB9XG5cbiAgcHJpdmF0ZSB1bnBhdXNlKCkge1xuICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XG4gICAgdGhpcy5wZW5kaW5nUXVlcnlTZXRNb2RpZmljYXRpb25zLmNsZWFyKCk7XG4gIH1cblxuICBwcml2YXRlIHJlbW92ZVN1YnNjcmliZXIoXG4gICAgcXVlcnlUb2tlbjogUXVlcnlUb2tlbixcbiAgKTogUXVlcnlTZXRNb2RpZmljYXRpb24gfCBudWxsIHtcbiAgICBjb25zdCBsb2NhbFF1ZXJ5ID0gdGhpcy5xdWVyeVNldC5nZXQocXVlcnlUb2tlbikhO1xuXG4gICAgaWYgKGxvY2FsUXVlcnkubnVtU3Vic2NyaWJlcnMgPiAxKSB7XG4gICAgICBsb2NhbFF1ZXJ5Lm51bVN1YnNjcmliZXJzIC09IDE7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5xdWVyeVNldC5kZWxldGUocXVlcnlUb2tlbik7XG4gICAgICB0aGlzLnF1ZXJ5SWRUb1Rva2VuLmRlbGV0ZShsb2NhbFF1ZXJ5LmlkKTtcbiAgICAgIHRoaXMub3V0c3RhbmRpbmdRdWVyaWVzT2xkZXJUaGFuUmVzdGFydC5kZWxldGUobG9jYWxRdWVyeS5pZCk7XG4gICAgICBjb25zdCBiYXNlVmVyc2lvbiA9IHRoaXMucXVlcnlTZXRWZXJzaW9uO1xuICAgICAgY29uc3QgbmV3VmVyc2lvbiA9IHRoaXMucXVlcnlTZXRWZXJzaW9uICsgMTtcbiAgICAgIGNvbnN0IHJlbW92ZTogUmVtb3ZlUXVlcnkgPSB7XG4gICAgICAgIHR5cGU6IFwiUmVtb3ZlXCIsXG4gICAgICAgIHF1ZXJ5SWQ6IGxvY2FsUXVlcnkuaWQsXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMucGF1c2VkKSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdRdWVyeVNldE1vZGlmaWNhdGlvbnMuaGFzKGxvY2FsUXVlcnkuaWQpKSB7XG4gICAgICAgICAgdGhpcy5wZW5kaW5nUXVlcnlTZXRNb2RpZmljYXRpb25zLmRlbGV0ZShsb2NhbFF1ZXJ5LmlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnBlbmRpbmdRdWVyeVNldE1vZGlmaWNhdGlvbnMuc2V0KGxvY2FsUXVlcnkuaWQsIHJlbW92ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucXVlcnlTZXRWZXJzaW9uID0gbmV3VmVyc2lvbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiTW9kaWZ5UXVlcnlTZXRcIixcbiAgICAgICAgYmFzZVZlcnNpb24sXG4gICAgICAgIG5ld1ZlcnNpb24sXG4gICAgICAgIG1vZGlmaWNhdGlvbnM6IFtyZW1vdmVdLFxuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgY29udmV4VG9Kc29uIH0gZnJvbSBcIi4uLy4uL3ZhbHVlcy9pbmRleC5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGNhbm9uaWNhbGl6ZVVkZlBhdGgodWRmUGF0aCkge1xuICBjb25zdCBwaWVjZXMgPSB1ZGZQYXRoLnNwbGl0KFwiOlwiKTtcbiAgbGV0IG1vZHVsZU5hbWU7XG4gIGxldCBmdW5jdGlvbk5hbWU7XG4gIGlmIChwaWVjZXMubGVuZ3RoID09PSAxKSB7XG4gICAgbW9kdWxlTmFtZSA9IHBpZWNlc1swXTtcbiAgICBmdW5jdGlvbk5hbWUgPSBcImRlZmF1bHRcIjtcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGVOYW1lID0gcGllY2VzLnNsaWNlKDAsIHBpZWNlcy5sZW5ndGggLSAxKS5qb2luKFwiOlwiKTtcbiAgICBmdW5jdGlvbk5hbWUgPSBwaWVjZXNbcGllY2VzLmxlbmd0aCAtIDFdO1xuICB9XG4gIGlmIChtb2R1bGVOYW1lLmVuZHNXaXRoKFwiLmpzXCIpKSB7XG4gICAgbW9kdWxlTmFtZSA9IG1vZHVsZU5hbWUuc2xpY2UoMCwgLTMpO1xuICB9XG4gIHJldHVybiBgJHttb2R1bGVOYW1lfToke2Z1bmN0aW9uTmFtZX1gO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZVBhdGhBbmRBcmdzKHVkZlBhdGgsIGFyZ3MpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICB1ZGZQYXRoOiBjYW5vbmljYWxpemVVZGZQYXRoKHVkZlBhdGgpLFxuICAgIGFyZ3M6IGNvbnZleFRvSnNvbihhcmdzKVxuICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemVQYWdpbmF0ZWRQYXRoQW5kQXJncyh1ZGZQYXRoLCBhcmdzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgaW5pdGlhbE51bUl0ZW1zLCBpZCB9ID0gb3B0aW9ucztcbiAgY29uc3QgcmVzdWx0ID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgIHR5cGU6IFwicGFnaW5hdGVkXCIsXG4gICAgdWRmUGF0aDogY2Fub25pY2FsaXplVWRmUGF0aCh1ZGZQYXRoKSxcbiAgICBhcmdzOiBjb252ZXhUb0pzb24oYXJncyksXG4gICAgb3B0aW9uczogY29udmV4VG9Kc29uKHsgaW5pdGlhbE51bUl0ZW1zLCBpZCB9KVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemVkUXVlcnlUb2tlbklzUGFnaW5hdGVkKHRva2VuKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKHRva2VuKS50eXBlID09PSBcInBhZ2luYXRlZFwiO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dWRmX3BhdGhfdXRpbHMuanMubWFwXG4iLCJpbXBvcnQgeyBjb252ZXhUb0pzb24sIFZhbHVlIH0gZnJvbSBcIi4uLy4uL3ZhbHVlcy9pbmRleC5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gY2Fub25pY2FsaXplVWRmUGF0aCh1ZGZQYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBwaWVjZXMgPSB1ZGZQYXRoLnNwbGl0KFwiOlwiKTtcbiAgbGV0IG1vZHVsZU5hbWU6IHN0cmluZztcbiAgbGV0IGZ1bmN0aW9uTmFtZTogc3RyaW5nO1xuICBpZiAocGllY2VzLmxlbmd0aCA9PT0gMSkge1xuICAgIG1vZHVsZU5hbWUgPSBwaWVjZXNbMF07XG4gICAgZnVuY3Rpb25OYW1lID0gXCJkZWZhdWx0XCI7XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlTmFtZSA9IHBpZWNlcy5zbGljZSgwLCBwaWVjZXMubGVuZ3RoIC0gMSkuam9pbihcIjpcIik7XG4gICAgZnVuY3Rpb25OYW1lID0gcGllY2VzW3BpZWNlcy5sZW5ndGggLSAxXTtcbiAgfVxuICBpZiAobW9kdWxlTmFtZS5lbmRzV2l0aChcIi5qc1wiKSkge1xuICAgIG1vZHVsZU5hbWUgPSBtb2R1bGVOYW1lLnNsaWNlKDAsIC0zKTtcbiAgfVxuICByZXR1cm4gYCR7bW9kdWxlTmFtZX06JHtmdW5jdGlvbk5hbWV9YDtcbn1cblxuLyoqXG4gKiBUaGUgc2VyaWFsaXphdGlvbiBoZXJlIGlzIG5vdCBzdGFibGUsIHRoZXNlIHN0cmluZ3MgbmV2ZXIgbWFrZSBpdCBvdXRzaWRlIHRoZSBjbGllbnQuXG4gKi9cblxuLyoqXG4gKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIG5hbWUgYW5kIGFyZ3VtZW50cyBvZiBhIHF1ZXJ5LlxuICpcbiAqIFRoaXMgaXMgdXNlZCBieSB0aGUge0BsaW5rIEJhc2VDb252ZXhDbGllbnR9LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IHR5cGUgUXVlcnlUb2tlbiA9IHN0cmluZyAmIHsgX19xdWVyeVRva2VuOiB0cnVlIH07XG5cbi8qKlxuICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBuYW1lIGFuZCBhcmd1bWVudHMgb2YgYSBwYWdpbmF0ZWQgcXVlcnkuXG4gKlxuICogVGhpcyBpcyBhIHNwZWNpYWxpemVkIGZvcm0gb2YgUXVlcnlUb2tlbiB1c2VkIGZvciBwYWdpbmF0ZWQgcXVlcmllcy5cbiAqL1xuZXhwb3J0IHR5cGUgUGFnaW5hdGVkUXVlcnlUb2tlbiA9IFF1ZXJ5VG9rZW4gJiB7IF9fcGFnaW5hdGVkUXVlcnlUb2tlbjogdHJ1ZSB9O1xuXG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplUGF0aEFuZEFyZ3MoXG4gIHVkZlBhdGg6IHN0cmluZyxcbiAgYXJnczogUmVjb3JkPHN0cmluZywgVmFsdWU+LFxuKTogUXVlcnlUb2tlbiB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgdWRmUGF0aDogY2Fub25pY2FsaXplVWRmUGF0aCh1ZGZQYXRoKSxcbiAgICBhcmdzOiBjb252ZXhUb0pzb24oYXJncyksXG4gIH0pIGFzIFF1ZXJ5VG9rZW47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemVQYWdpbmF0ZWRQYXRoQW5kQXJncyhcbiAgdWRmUGF0aDogc3RyaW5nLFxuICBhcmdzOiBSZWNvcmQ8c3RyaW5nLCBWYWx1ZT4sIC8vIGFyZ3MgV0lUSE9VVCBwYWdpbmF0aW9uT3B0c1xuICBvcHRpb25zOiB7IGluaXRpYWxOdW1JdGVtczogbnVtYmVyOyBpZDogbnVtYmVyIH0sXG4pOiBQYWdpbmF0ZWRRdWVyeVRva2VuIHtcbiAgY29uc3QgeyBpbml0aWFsTnVtSXRlbXMsIGlkIH0gPSBvcHRpb25zO1xuICBjb25zdCByZXN1bHQgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgdHlwZTogXCJwYWdpbmF0ZWRcIixcbiAgICB1ZGZQYXRoOiBjYW5vbmljYWxpemVVZGZQYXRoKHVkZlBhdGgpLFxuICAgIGFyZ3M6IGNvbnZleFRvSnNvbihhcmdzKSxcbiAgICBvcHRpb25zOiBjb252ZXhUb0pzb24oeyBpbml0aWFsTnVtSXRlbXMsIGlkIH0pLFxuICB9KSBhcyBQYWdpbmF0ZWRRdWVyeVRva2VuO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplZFF1ZXJ5VG9rZW5Jc1BhZ2luYXRlZChcbiAgdG9rZW46IFF1ZXJ5VG9rZW4gfCBQYWdpbmF0ZWRRdWVyeVRva2VuLFxuKTogdG9rZW4gaXMgUGFnaW5hdGVkUXVlcnlUb2tlbiB7XG4gIHJldHVybiBKU09OLnBhcnNlKHRva2VuKS50eXBlID09PSBcInBhZ2luYXRlZFwiO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuaW1wb3J0IHsganNvblRvQ29udmV4IH0gZnJvbSBcIi4uLy4uL3ZhbHVlcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgbG9nRm9yRnVuY3Rpb24gfSBmcm9tIFwiLi4vbG9nZ2luZy5qc1wiO1xuZXhwb3J0IGNsYXNzIFJlcXVlc3RNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IobG9nZ2VyLCBtYXJrQ29ubmVjdGlvblN0YXRlRGlydHkpIHtcbiAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICB0aGlzLm1hcmtDb25uZWN0aW9uU3RhdGVEaXJ0eSA9IG1hcmtDb25uZWN0aW9uU3RhdGVEaXJ0eTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaW5mbGlnaHRSZXF1ZXN0c1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVxdWVzdHNPbGRlclRoYW5SZXN0YXJ0XCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJpbmZsaWdodE11dGF0aW9uc0NvdW50XCIsIDApO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJpbmZsaWdodEFjdGlvbnNDb3VudFwiLCAwKTtcbiAgICB0aGlzLmluZmxpZ2h0UmVxdWVzdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMucmVxdWVzdHNPbGRlclRoYW5SZXN0YXJ0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgfVxuICByZXF1ZXN0KG1lc3NhZ2UsIHNlbnQpIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgY29uc3Qgc3RhdHVzID0gc2VudCA/IFwiUmVxdWVzdGVkXCIgOiBcIk5vdFNlbnRcIjtcbiAgICAgIHRoaXMuaW5mbGlnaHRSZXF1ZXN0cy5zZXQobWVzc2FnZS5yZXF1ZXN0SWQsIHtcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgc3RhdHVzOiB7IHN0YXR1cywgcmVxdWVzdGVkQXQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLCBvblJlc3VsdDogcmVzb2x2ZSB9XG4gICAgICB9KTtcbiAgICAgIGlmIChtZXNzYWdlLnR5cGUgPT09IFwiTXV0YXRpb25cIikge1xuICAgICAgICB0aGlzLmluZmxpZ2h0TXV0YXRpb25zQ291bnQrKztcbiAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS50eXBlID09PSBcIkFjdGlvblwiKSB7XG4gICAgICAgIHRoaXMuaW5mbGlnaHRBY3Rpb25zQ291bnQrKztcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLm1hcmtDb25uZWN0aW9uU3RhdGVEaXJ0eSgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgc3RhdGUgYWZ0ZXIgcmVjZWl2aW5nIGEgcmVzcG9uc2UuXG4gICAqXG4gICAqIEByZXR1cm5zIEEgUmVxdWVzdElkIGlmIHRoZSByZXF1ZXN0IGlzIGNvbXBsZXRlIGFuZCBpdHMgb3B0aW1pc3RpYyB1cGRhdGVcbiAgICogY2FuIGJlIGRyb3BwZWQsIG51bGwgb3RoZXJ3aXNlLlxuICAgKi9cbiAgb25SZXNwb25zZShyZXNwb25zZSkge1xuICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gdGhpcy5pbmZsaWdodFJlcXVlc3RzLmdldChyZXNwb25zZS5yZXF1ZXN0SWQpO1xuICAgIGlmIChyZXF1ZXN0SW5mbyA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHJlcXVlc3RJbmZvLnN0YXR1cy5zdGF0dXMgPT09IFwiQ29tcGxldGVkXCIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB1ZGZUeXBlID0gcmVxdWVzdEluZm8ubWVzc2FnZS50eXBlID09PSBcIk11dGF0aW9uXCIgPyBcIm11dGF0aW9uXCIgOiBcImFjdGlvblwiO1xuICAgIGNvbnN0IHVkZlBhdGggPSByZXF1ZXN0SW5mby5tZXNzYWdlLnVkZlBhdGg7XG4gICAgZm9yIChjb25zdCBsaW5lIG9mIHJlc3BvbnNlLmxvZ0xpbmVzKSB7XG4gICAgICBsb2dGb3JGdW5jdGlvbih0aGlzLmxvZ2dlciwgXCJpbmZvXCIsIHVkZlR5cGUsIHVkZlBhdGgsIGxpbmUpO1xuICAgIH1cbiAgICBjb25zdCBzdGF0dXMgPSByZXF1ZXN0SW5mby5zdGF0dXM7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBsZXQgb25SZXNvbHZlO1xuICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGxvZ0xpbmVzOiByZXNwb25zZS5sb2dMaW5lcyxcbiAgICAgICAgdmFsdWU6IGpzb25Ub0NvbnZleChyZXNwb25zZS5yZXN1bHQpXG4gICAgICB9O1xuICAgICAgb25SZXNvbHZlID0gKCkgPT4gc3RhdHVzLm9uUmVzdWx0KHJlc3VsdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IHJlc3BvbnNlLnJlc3VsdDtcbiAgICAgIGNvbnN0IHsgZXJyb3JEYXRhIH0gPSByZXNwb25zZTtcbiAgICAgIGxvZ0ZvckZ1bmN0aW9uKHRoaXMubG9nZ2VyLCBcImVycm9yXCIsIHVkZlR5cGUsIHVkZlBhdGgsIGVycm9yTWVzc2FnZSk7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvck1lc3NhZ2UsXG4gICAgICAgIGVycm9yRGF0YTogZXJyb3JEYXRhICE9PSB2b2lkIDAgPyBqc29uVG9Db252ZXgoZXJyb3JEYXRhKSA6IHZvaWQgMCxcbiAgICAgICAgbG9nTGluZXM6IHJlc3BvbnNlLmxvZ0xpbmVzXG4gICAgICB9O1xuICAgICAgb25SZXNvbHZlID0gKCkgPT4gc3RhdHVzLm9uUmVzdWx0KHJlc3VsdCk7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS50eXBlID09PSBcIkFjdGlvblJlc3BvbnNlXCIgfHwgIXJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgIG9uUmVzb2x2ZSgpO1xuICAgICAgdGhpcy5pbmZsaWdodFJlcXVlc3RzLmRlbGV0ZShyZXNwb25zZS5yZXF1ZXN0SWQpO1xuICAgICAgdGhpcy5yZXF1ZXN0c09sZGVyVGhhblJlc3RhcnQuZGVsZXRlKHJlc3BvbnNlLnJlcXVlc3RJZCk7XG4gICAgICBpZiAocmVxdWVzdEluZm8ubWVzc2FnZS50eXBlID09PSBcIkFjdGlvblwiKSB7XG4gICAgICAgIHRoaXMuaW5mbGlnaHRBY3Rpb25zQ291bnQtLTtcbiAgICAgIH0gZWxzZSBpZiAocmVxdWVzdEluZm8ubWVzc2FnZS50eXBlID09PSBcIk11dGF0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5pbmZsaWdodE11dGF0aW9uc0NvdW50LS07XG4gICAgICB9XG4gICAgICB0aGlzLm1hcmtDb25uZWN0aW9uU3RhdGVEaXJ0eSgpO1xuICAgICAgcmV0dXJuIHsgcmVxdWVzdElkOiByZXNwb25zZS5yZXF1ZXN0SWQsIHJlc3VsdCB9O1xuICAgIH1cbiAgICByZXF1ZXN0SW5mby5zdGF0dXMgPSB7XG4gICAgICBzdGF0dXM6IFwiQ29tcGxldGVkXCIsXG4gICAgICByZXN1bHQsXG4gICAgICB0czogcmVzcG9uc2UudHMsXG4gICAgICBvblJlc29sdmVcbiAgICB9O1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8vIFJlbW92ZSBhbmQgcmV0dXJucyBjb21wbGV0ZWQgcmVxdWVzdHMuXG4gIHJlbW92ZUNvbXBsZXRlZCh0cykge1xuICAgIGNvbnN0IGNvbXBsZXRlUmVxdWVzdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgW3JlcXVlc3RJZCwgcmVxdWVzdEluZm9dIG9mIHRoaXMuaW5mbGlnaHRSZXF1ZXN0cy5lbnRyaWVzKCkpIHtcbiAgICAgIGNvbnN0IHN0YXR1cyA9IHJlcXVlc3RJbmZvLnN0YXR1cztcbiAgICAgIGlmIChzdGF0dXMuc3RhdHVzID09PSBcIkNvbXBsZXRlZFwiICYmIHN0YXR1cy50cy5sZXNzVGhhbk9yRXF1YWwodHMpKSB7XG4gICAgICAgIHN0YXR1cy5vblJlc29sdmUoKTtcbiAgICAgICAgY29tcGxldGVSZXF1ZXN0cy5zZXQocmVxdWVzdElkLCBzdGF0dXMucmVzdWx0KTtcbiAgICAgICAgaWYgKHJlcXVlc3RJbmZvLm1lc3NhZ2UudHlwZSA9PT0gXCJNdXRhdGlvblwiKSB7XG4gICAgICAgICAgdGhpcy5pbmZsaWdodE11dGF0aW9uc0NvdW50LS07XG4gICAgICAgIH0gZWxzZSBpZiAocmVxdWVzdEluZm8ubWVzc2FnZS50eXBlID09PSBcIkFjdGlvblwiKSB7XG4gICAgICAgICAgdGhpcy5pbmZsaWdodEFjdGlvbnNDb3VudC0tO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5mbGlnaHRSZXF1ZXN0cy5kZWxldGUocmVxdWVzdElkKTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0c09sZGVyVGhhblJlc3RhcnQuZGVsZXRlKHJlcXVlc3RJZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb21wbGV0ZVJlcXVlc3RzLnNpemUgPiAwKSB7XG4gICAgICB0aGlzLm1hcmtDb25uZWN0aW9uU3RhdGVEaXJ0eSgpO1xuICAgIH1cbiAgICByZXR1cm4gY29tcGxldGVSZXF1ZXN0cztcbiAgfVxuICByZXN0YXJ0KCkge1xuICAgIHRoaXMucmVxdWVzdHNPbGRlclRoYW5SZXN0YXJ0ID0gbmV3IFNldCh0aGlzLmluZmxpZ2h0UmVxdWVzdHMua2V5cygpKTtcbiAgICBjb25zdCBhbGxNZXNzYWdlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgW3JlcXVlc3RJZCwgdmFsdWVdIG9mIHRoaXMuaW5mbGlnaHRSZXF1ZXN0cykge1xuICAgICAgaWYgKHZhbHVlLnN0YXR1cy5zdGF0dXMgPT09IFwiTm90U2VudFwiKSB7XG4gICAgICAgIHZhbHVlLnN0YXR1cy5zdGF0dXMgPSBcIlJlcXVlc3RlZFwiO1xuICAgICAgICBhbGxNZXNzYWdlcy5wdXNoKHZhbHVlLm1lc3NhZ2UpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZS5tZXNzYWdlLnR5cGUgPT09IFwiTXV0YXRpb25cIikge1xuICAgICAgICBhbGxNZXNzYWdlcy5wdXNoKHZhbHVlLm1lc3NhZ2UpO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZS5tZXNzYWdlLnR5cGUgPT09IFwiQWN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5pbmZsaWdodFJlcXVlc3RzLmRlbGV0ZShyZXF1ZXN0SWQpO1xuICAgICAgICB0aGlzLnJlcXVlc3RzT2xkZXJUaGFuUmVzdGFydC5kZWxldGUocmVxdWVzdElkKTtcbiAgICAgICAgdGhpcy5pbmZsaWdodEFjdGlvbnNDb3VudC0tO1xuICAgICAgICBpZiAodmFsdWUuc3RhdHVzLnN0YXR1cyA9PT0gXCJDb21wbGV0ZWRcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFjdGlvbiBzaG91bGQgbmV2ZXIgYmUgaW4gJ0NvbXBsZXRlZCcgc3RhdGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUuc3RhdHVzLm9uUmVzdWx0KHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvck1lc3NhZ2U6IFwiQ29ubmVjdGlvbiBsb3N0IHdoaWxlIGFjdGlvbiB3YXMgaW4gZmxpZ2h0XCIsXG4gICAgICAgICAgbG9nTGluZXM6IFtdXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm1hcmtDb25uZWN0aW9uU3RhdGVEaXJ0eSgpO1xuICAgIHJldHVybiBhbGxNZXNzYWdlcztcbiAgfVxuICByZXN1bWUoKSB7XG4gICAgY29uc3QgYWxsTWVzc2FnZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFssIHZhbHVlXSBvZiB0aGlzLmluZmxpZ2h0UmVxdWVzdHMpIHtcbiAgICAgIGlmICh2YWx1ZS5zdGF0dXMuc3RhdHVzID09PSBcIk5vdFNlbnRcIikge1xuICAgICAgICB2YWx1ZS5zdGF0dXMuc3RhdHVzID0gXCJSZXF1ZXN0ZWRcIjtcbiAgICAgICAgYWxsTWVzc2FnZXMucHVzaCh2YWx1ZS5tZXNzYWdlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhbGxNZXNzYWdlcztcbiAgfVxuICAvKipcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGVyZSBhcmUgYW55IHJlcXVlc3RzIHRoYXQgaGF2ZSBiZWVuIHJlcXVlc3RlZCBidXQgaGF2ZVxuICAgKiBub3QgYmUgY29tcGxldGVkIHlldC5cbiAgICovXG4gIGhhc0luY29tcGxldGVSZXF1ZXN0cygpIHtcbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RJbmZvIG9mIHRoaXMuaW5mbGlnaHRSZXF1ZXN0cy52YWx1ZXMoKSkge1xuICAgICAgaWYgKHJlcXVlc3RJbmZvLnN0YXR1cy5zdGF0dXMgPT09IFwiUmVxdWVzdGVkXCIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGVyZSBhcmUgYW55IGluZmxpZ2h0IHJlcXVlc3RzLCBpbmNsdWRpbmcgb25lcyB0aGF0IGhhdmVcbiAgICogY29tcGxldGVkIG9uIHRoZSBzZXJ2ZXIsIGJ1dCBoYXZlIG5vdCBiZWVuIGFwcGxpZWQuXG4gICAqL1xuICBoYXNJbmZsaWdodFJlcXVlc3RzKCkge1xuICAgIHJldHVybiB0aGlzLmluZmxpZ2h0UmVxdWVzdHMuc2l6ZSA+IDA7XG4gIH1cbiAgLyoqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlcmUgYXJlIGFueSBpbmZsaWdodCByZXF1ZXN0cywgdGhhdCBoYXZlIGJlZW4gaGFuZ2luZyBhcm91bmRcbiAgICogc2luY2UgcHJpb3IgdG8gdGhlIG1vc3QgcmVjZW50IHJlc3RhcnQuXG4gICAqL1xuICBoYXNTeW5jZWRQYXN0TGFzdFJlY29ubmVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0c09sZGVyVGhhblJlc3RhcnQuc2l6ZSA9PT0gMDtcbiAgfVxuICB0aW1lT2ZPbGRlc3RJbmZsaWdodFJlcXVlc3QoKSB7XG4gICAgaWYgKHRoaXMuaW5mbGlnaHRSZXF1ZXN0cy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbGV0IG9sZGVzdEluZmxpZ2h0UmVxdWVzdCA9IERhdGUubm93KCk7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0IG9mIHRoaXMuaW5mbGlnaHRSZXF1ZXN0cy52YWx1ZXMoKSkge1xuICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzLnN0YXR1cyAhPT0gXCJDb21wbGV0ZWRcIikge1xuICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMucmVxdWVzdGVkQXQuZ2V0VGltZSgpIDwgb2xkZXN0SW5mbGlnaHRSZXF1ZXN0KSB7XG4gICAgICAgICAgb2xkZXN0SW5mbGlnaHRSZXF1ZXN0ID0gcmVxdWVzdC5zdGF0dXMucmVxdWVzdGVkQXQuZ2V0VGltZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGF0ZShvbGRlc3RJbmZsaWdodFJlcXVlc3QpO1xuICB9XG4gIC8qKlxuICAgKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIG11dGF0aW9ucyBjdXJyZW50bHkgaW4gZmxpZ2h0LlxuICAgKi9cbiAgaW5mbGlnaHRNdXRhdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5mbGlnaHRNdXRhdGlvbnNDb3VudDtcbiAgfVxuICAvKipcbiAgICogQHJldHVybnMgVGhlIG51bWJlciBvZiBhY3Rpb25zIGN1cnJlbnRseSBpbiBmbGlnaHQuXG4gICAqL1xuICBpbmZsaWdodEFjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5mbGlnaHRBY3Rpb25zQ291bnQ7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlcXVlc3RfbWFuYWdlci5qcy5tYXBcbiIsImltcG9ydCB7IGpzb25Ub0NvbnZleCB9IGZyb20gXCIuLi8uLi92YWx1ZXMvaW5kZXguanNcIjtcbmltcG9ydCB7IGxvZ0ZvckZ1bmN0aW9uLCBMb2dnZXIgfSBmcm9tIFwiLi4vbG9nZ2luZy5qc1wiO1xuaW1wb3J0IHsgTG9uZyB9IGZyb20gXCIuLi8uLi92ZW5kb3IvbG9uZy5qc1wiO1xuaW1wb3J0IHsgRnVuY3Rpb25SZXN1bHQgfSBmcm9tIFwiLi9mdW5jdGlvbl9yZXN1bHQuanNcIjtcbmltcG9ydCB7XG4gIEFjdGlvblJlcXVlc3QsXG4gIEFjdGlvblJlc3BvbnNlLFxuICBDbGllbnRNZXNzYWdlLFxuICBNdXRhdGlvblJlcXVlc3QsXG4gIE11dGF0aW9uUmVzcG9uc2UsXG4gIFJlcXVlc3RJZCxcbn0gZnJvbSBcIi4vcHJvdG9jb2wuanNcIjtcblxudHlwZSBSZXF1ZXN0U3RhdHVzID1cbiAgfCB7XG4gICAgICBzdGF0dXM6IFwiUmVxdWVzdGVkXCIgfCBcIk5vdFNlbnRcIjtcbiAgICAgIG9uUmVzdWx0OiAocmVzdWx0OiBGdW5jdGlvblJlc3VsdCkgPT4gdm9pZDtcbiAgICAgIHJlcXVlc3RlZEF0OiBEYXRlO1xuICAgIH1cbiAgfCB7XG4gICAgICBzdGF0dXM6IFwiQ29tcGxldGVkXCI7XG4gICAgICByZXN1bHQ6IEZ1bmN0aW9uUmVzdWx0O1xuICAgICAgb25SZXNvbHZlOiAoKSA9PiB2b2lkO1xuICAgICAgdHM6IExvbmc7XG4gICAgfTtcblxuZXhwb3J0IGNsYXNzIFJlcXVlc3RNYW5hZ2VyIHtcbiAgcHJpdmF0ZSBpbmZsaWdodFJlcXVlc3RzOiBNYXA8XG4gICAgUmVxdWVzdElkLFxuICAgIHtcbiAgICAgIG1lc3NhZ2U6IE11dGF0aW9uUmVxdWVzdCB8IEFjdGlvblJlcXVlc3Q7XG4gICAgICBzdGF0dXM6IFJlcXVlc3RTdGF0dXM7XG4gICAgfVxuICA+O1xuICBwcml2YXRlIHJlcXVlc3RzT2xkZXJUaGFuUmVzdGFydDogU2V0PFJlcXVlc3RJZD47XG4gIHByaXZhdGUgaW5mbGlnaHRNdXRhdGlvbnNDb3VudDogbnVtYmVyID0gMDtcbiAgcHJpdmF0ZSBpbmZsaWdodEFjdGlvbnNDb3VudDogbnVtYmVyID0gMDtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBsb2dnZXI6IExvZ2dlcixcbiAgICBwcml2YXRlIHJlYWRvbmx5IG1hcmtDb25uZWN0aW9uU3RhdGVEaXJ0eTogKCkgPT4gdm9pZCxcbiAgKSB7XG4gICAgdGhpcy5pbmZsaWdodFJlcXVlc3RzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMucmVxdWVzdHNPbGRlclRoYW5SZXN0YXJ0ID0gbmV3IFNldCgpO1xuICB9XG5cbiAgcmVxdWVzdChcbiAgICBtZXNzYWdlOiBNdXRhdGlvblJlcXVlc3QgfCBBY3Rpb25SZXF1ZXN0LFxuICAgIHNlbnQ6IGJvb2xlYW4sXG4gICk6IFByb21pc2U8RnVuY3Rpb25SZXN1bHQ+IHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgUHJvbWlzZTxGdW5jdGlvblJlc3VsdD4oKHJlc29sdmUpID0+IHtcbiAgICAgIGNvbnN0IHN0YXR1cyA9IHNlbnQgPyBcIlJlcXVlc3RlZFwiIDogXCJOb3RTZW50XCI7XG4gICAgICB0aGlzLmluZmxpZ2h0UmVxdWVzdHMuc2V0KG1lc3NhZ2UucmVxdWVzdElkLCB7XG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHN0YXR1czogeyBzdGF0dXMsIHJlcXVlc3RlZEF0OiBuZXcgRGF0ZSgpLCBvblJlc3VsdDogcmVzb2x2ZSB9LFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChtZXNzYWdlLnR5cGUgPT09IFwiTXV0YXRpb25cIikge1xuICAgICAgICB0aGlzLmluZmxpZ2h0TXV0YXRpb25zQ291bnQrKztcbiAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS50eXBlID09PSBcIkFjdGlvblwiKSB7XG4gICAgICAgIHRoaXMuaW5mbGlnaHRBY3Rpb25zQ291bnQrKztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMubWFya0Nvbm5lY3Rpb25TdGF0ZURpcnR5KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHN0YXRlIGFmdGVyIHJlY2VpdmluZyBhIHJlc3BvbnNlLlxuICAgKlxuICAgKiBAcmV0dXJucyBBIFJlcXVlc3RJZCBpZiB0aGUgcmVxdWVzdCBpcyBjb21wbGV0ZSBhbmQgaXRzIG9wdGltaXN0aWMgdXBkYXRlXG4gICAqIGNhbiBiZSBkcm9wcGVkLCBudWxsIG90aGVyd2lzZS5cbiAgICovXG4gIG9uUmVzcG9uc2UoXG4gICAgcmVzcG9uc2U6IE11dGF0aW9uUmVzcG9uc2UgfCBBY3Rpb25SZXNwb25zZSxcbiAgKTogeyByZXF1ZXN0SWQ6IFJlcXVlc3RJZDsgcmVzdWx0OiBGdW5jdGlvblJlc3VsdCB9IHwgbnVsbCB7XG4gICAgY29uc3QgcmVxdWVzdEluZm8gPSB0aGlzLmluZmxpZ2h0UmVxdWVzdHMuZ2V0KHJlc3BvbnNlLnJlcXVlc3RJZCk7XG4gICAgaWYgKHJlcXVlc3RJbmZvID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEFubm95aW5nbHkgd2UgY2FuIG9jY2FzaW9uYWxseSBnZXQgcmVzcG9uc2VzIHRvIG11dGF0aW9ucyB0aGF0IHdlJ3JlIG5vXG4gICAgICAvLyBsb25nZXIgdHJhY2tpbmcuIE9uZSBmbG93IHdoZXJlIHRoaXMgaGFwcGVucyBpczpcbiAgICAgIC8vIDEuIENsaWVudCBzZW5kcyBtdXRhdGlvbiAxXG4gICAgICAvLyAyLiBDbGllbnQgZ2V0cyByZXNwb25zZSBmb3IgbXV0YXRpb24gMS4gVGhlIHNldmVyIHNheXMgdGhhdCBpdCB3YXMgY29tbWl0dGVkIGF0IHRzPTEwLlxuICAgICAgLy8gMy4gQ2xpZW50IGlzIGRpc2Nvbm5lY3RlZFxuICAgICAgLy8gNC4gQ2xpZW50IHJlY29ubmVjdHMgYW5kIHJlLWlzc3VlcyBxdWVyaWVzIGFuZCB0aGlzIG11dGF0aW9uLlxuICAgICAgLy8gNS4gU2VydmVyIHNlbmRzIHRyYW5zaXRpb24gbWVzc2FnZSB0byB0cz0yMFxuICAgICAgLy8gNi4gQ2xpZW50IGRyb3BzIG11dGF0aW9uIGJlY2F1c2UgaXQncyBhbHJlYWR5IGJlZW4gb2JzZXJ2ZWQuXG4gICAgICAvLyA3LiBDbGllbnQgcmVjZWl2ZXMgYSBzZWNvbmQgcmVzcG9uc2UgZm9yIG11dGF0aW9uIDEgYnV0IGRvZXNuJ3Qga25vdyBhYm91dCBpdCBhbnltb3JlLlxuXG4gICAgICAvLyBUaGUgcmlnaHQgZml4IGZvciB0aGlzIGlzIHByb2JhYmx5IHRvIGFkZCBhIHJlY29uY2lsaWF0aW9uIHBoYXNlIG9uXG4gICAgICAvLyByZWNvbm5lY3Rpb24gd2hlcmUgd2UgcmVjZWl2ZSByZXNwb25zZXMgdG8gYWxsIHRoZSBtdXRhdGlvbnMgYmVmb3JlXG4gICAgICAvLyB0aGUgdHJhbnNpdGlvbiBtZXNzYWdlIHNvIHRoaXMgZmxvdyBjb3VsZCBuZXZlciBoYXBwZW4gKENYLTE1MTMpLlxuXG4gICAgICAvLyBGb3Igbm93IHRob3VnaCwgd2UgY2FuIGp1c3QgaWdub3JlIHRoaXMgbWVzc2FnZS5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIEJlY2F1c2UgYC5yZXN0YXJ0KClgIHJlLXJlcXVlc3RzIGNvbXBsZXRlZCByZXF1ZXN0cywgd2UgbWF5IGdldCBzb21lXG4gICAgLy8gcmVzcG9uc2VzIGZvciByZXF1ZXN0cyB0aGF0IGFyZSBhbHJlYWR5IGluIHRoZSBcIkNvbXBsZXRlZFwiIHN0YXRlLlxuICAgIC8vIFdlIGNhbiBzYWZlbHkgaWdub3JlIHRob3NlIGJlY2F1c2Ugd2UndmUgYWxyZWFkeSBub3RpZmllZCB0aGUgVUkgYWJvdXRcbiAgICAvLyB0aGVpciByZXN1bHRzLlxuICAgIGlmIChyZXF1ZXN0SW5mby5zdGF0dXMuc3RhdHVzID09PSBcIkNvbXBsZXRlZFwiKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCB1ZGZUeXBlID1cbiAgICAgIHJlcXVlc3RJbmZvLm1lc3NhZ2UudHlwZSA9PT0gXCJNdXRhdGlvblwiID8gXCJtdXRhdGlvblwiIDogXCJhY3Rpb25cIjtcbiAgICBjb25zdCB1ZGZQYXRoID0gcmVxdWVzdEluZm8ubWVzc2FnZS51ZGZQYXRoO1xuXG4gICAgZm9yIChjb25zdCBsaW5lIG9mIHJlc3BvbnNlLmxvZ0xpbmVzKSB7XG4gICAgICBsb2dGb3JGdW5jdGlvbih0aGlzLmxvZ2dlciwgXCJpbmZvXCIsIHVkZlR5cGUsIHVkZlBhdGgsIGxpbmUpO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXR1cyA9IHJlcXVlc3RJbmZvLnN0YXR1cztcbiAgICBsZXQgcmVzdWx0OiBGdW5jdGlvblJlc3VsdDtcbiAgICBsZXQgb25SZXNvbHZlO1xuICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGxvZ0xpbmVzOiByZXNwb25zZS5sb2dMaW5lcyxcbiAgICAgICAgdmFsdWU6IGpzb25Ub0NvbnZleChyZXNwb25zZS5yZXN1bHQpLFxuICAgICAgfTtcbiAgICAgIG9uUmVzb2x2ZSA9ICgpID0+IHN0YXR1cy5vblJlc3VsdChyZXN1bHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSByZXNwb25zZS5yZXN1bHQgYXMgc3RyaW5nO1xuICAgICAgY29uc3QgeyBlcnJvckRhdGEgfSA9IHJlc3BvbnNlO1xuICAgICAgbG9nRm9yRnVuY3Rpb24odGhpcy5sb2dnZXIsIFwiZXJyb3JcIiwgdWRmVHlwZSwgdWRmUGF0aCwgZXJyb3JNZXNzYWdlKTtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yTWVzc2FnZSxcbiAgICAgICAgZXJyb3JEYXRhOlxuICAgICAgICAgIGVycm9yRGF0YSAhPT0gdW5kZWZpbmVkID8ganNvblRvQ29udmV4KGVycm9yRGF0YSkgOiB1bmRlZmluZWQsXG4gICAgICAgIGxvZ0xpbmVzOiByZXNwb25zZS5sb2dMaW5lcyxcbiAgICAgIH07XG4gICAgICBvblJlc29sdmUgPSAoKSA9PiBzdGF0dXMub25SZXN1bHQocmVzdWx0KTtcbiAgICB9XG5cbiAgICAvLyBXZSBjYW4gcmVzb2x2ZSBNdXRhdGlvbiBmYWlsdXJlcyBpbW1lZGlhdGVseSBzaW5jZSB0aGV5IGRvbid0IGhhdmUgYW55XG4gICAgLy8gc2lkZSBlZmZlY3RzLiBBY3Rpb25zIGFyZSBpbnRlbnRpb25hbGx5IGRlY291cGxlZCBmcm9tXG4gICAgLy8gcXVlcmllcy9tdXRhdGlvbnMgaGVyZSBvbiB0aGUgc3luYyBwcm90b2NvbCBzaW5jZSB0aGV5IGhhdmUgZGlmZmVyZW50XG4gICAgLy8gZ3VhcmFudGVlcy5cbiAgICBpZiAocmVzcG9uc2UudHlwZSA9PT0gXCJBY3Rpb25SZXNwb25zZVwiIHx8ICFyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICBvblJlc29sdmUoKTtcbiAgICAgIHRoaXMuaW5mbGlnaHRSZXF1ZXN0cy5kZWxldGUocmVzcG9uc2UucmVxdWVzdElkKTtcbiAgICAgIHRoaXMucmVxdWVzdHNPbGRlclRoYW5SZXN0YXJ0LmRlbGV0ZShyZXNwb25zZS5yZXF1ZXN0SWQpO1xuXG4gICAgICBpZiAocmVxdWVzdEluZm8ubWVzc2FnZS50eXBlID09PSBcIkFjdGlvblwiKSB7XG4gICAgICAgIHRoaXMuaW5mbGlnaHRBY3Rpb25zQ291bnQtLTtcbiAgICAgIH0gZWxzZSBpZiAocmVxdWVzdEluZm8ubWVzc2FnZS50eXBlID09PSBcIk11dGF0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5pbmZsaWdodE11dGF0aW9uc0NvdW50LS07XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWFya0Nvbm5lY3Rpb25TdGF0ZURpcnR5KCk7XG4gICAgICByZXR1cm4geyByZXF1ZXN0SWQ6IHJlc3BvbnNlLnJlcXVlc3RJZCwgcmVzdWx0IH07XG4gICAgfVxuXG4gICAgLy8gV2UgaGF2ZSB0byB3YWl0IHRvIHJlc29sdmUgdGhlIHJlcXVlc3QgcHJvbWlzZSB1bnRpbCBhZnRlciB3ZSB0cmFuc2l0aW9uXG4gICAgLy8gcGFzdCB0aGlzIHRpbWVzdGFtcCBzbyBjbGllbnRzIGNhbiByZWFkIHRoZWlyIG93biB3cml0ZXMuXG4gICAgcmVxdWVzdEluZm8uc3RhdHVzID0ge1xuICAgICAgc3RhdHVzOiBcIkNvbXBsZXRlZFwiLFxuICAgICAgcmVzdWx0LFxuICAgICAgdHM6IHJlc3BvbnNlLnRzLFxuICAgICAgb25SZXNvbHZlLFxuICAgIH07XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIFJlbW92ZSBhbmQgcmV0dXJucyBjb21wbGV0ZWQgcmVxdWVzdHMuXG4gIHJlbW92ZUNvbXBsZXRlZCh0czogTG9uZyk6IE1hcDxSZXF1ZXN0SWQsIEZ1bmN0aW9uUmVzdWx0PiB7XG4gICAgY29uc3QgY29tcGxldGVSZXF1ZXN0czogTWFwPFJlcXVlc3RJZCwgRnVuY3Rpb25SZXN1bHQ+ID0gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgW3JlcXVlc3RJZCwgcmVxdWVzdEluZm9dIG9mIHRoaXMuaW5mbGlnaHRSZXF1ZXN0cy5lbnRyaWVzKCkpIHtcbiAgICAgIGNvbnN0IHN0YXR1cyA9IHJlcXVlc3RJbmZvLnN0YXR1cztcbiAgICAgIGlmIChzdGF0dXMuc3RhdHVzID09PSBcIkNvbXBsZXRlZFwiICYmIHN0YXR1cy50cy5sZXNzVGhhbk9yRXF1YWwodHMpKSB7XG4gICAgICAgIHN0YXR1cy5vblJlc29sdmUoKTtcbiAgICAgICAgY29tcGxldGVSZXF1ZXN0cy5zZXQocmVxdWVzdElkLCBzdGF0dXMucmVzdWx0KTtcblxuICAgICAgICBpZiAocmVxdWVzdEluZm8ubWVzc2FnZS50eXBlID09PSBcIk11dGF0aW9uXCIpIHtcbiAgICAgICAgICB0aGlzLmluZmxpZ2h0TXV0YXRpb25zQ291bnQtLTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXF1ZXN0SW5mby5tZXNzYWdlLnR5cGUgPT09IFwiQWN0aW9uXCIpIHtcbiAgICAgICAgICB0aGlzLmluZmxpZ2h0QWN0aW9uc0NvdW50LS07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmluZmxpZ2h0UmVxdWVzdHMuZGVsZXRlKHJlcXVlc3RJZCk7XG4gICAgICAgIHRoaXMucmVxdWVzdHNPbGRlclRoYW5SZXN0YXJ0LmRlbGV0ZShyZXF1ZXN0SWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29tcGxldGVSZXF1ZXN0cy5zaXplID4gMCkge1xuICAgICAgdGhpcy5tYXJrQ29ubmVjdGlvblN0YXRlRGlydHkoKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBsZXRlUmVxdWVzdHM7XG4gIH1cblxuICByZXN0YXJ0KCk6IENsaWVudE1lc3NhZ2VbXSB7XG4gICAgLy8gV2hlbiB3ZSByZWNvbm5lY3QgdG8gdGhlIGJhY2tlbmQsIHJlLXJlcXVlc3QgYWxsIHJlcXVlc3RzIHRoYXQgYXJlIHNhZmVcbiAgICAvLyB0byBiZSByZXNlbmQuXG5cbiAgICB0aGlzLnJlcXVlc3RzT2xkZXJUaGFuUmVzdGFydCA9IG5ldyBTZXQodGhpcy5pbmZsaWdodFJlcXVlc3RzLmtleXMoKSk7XG4gICAgY29uc3QgYWxsTWVzc2FnZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtyZXF1ZXN0SWQsIHZhbHVlXSBvZiB0aGlzLmluZmxpZ2h0UmVxdWVzdHMpIHtcbiAgICAgIGlmICh2YWx1ZS5zdGF0dXMuc3RhdHVzID09PSBcIk5vdFNlbnRcIikge1xuICAgICAgICB2YWx1ZS5zdGF0dXMuc3RhdHVzID0gXCJSZXF1ZXN0ZWRcIjtcbiAgICAgICAgYWxsTWVzc2FnZXMucHVzaCh2YWx1ZS5tZXNzYWdlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZS5tZXNzYWdlLnR5cGUgPT09IFwiTXV0YXRpb25cIikge1xuICAgICAgICAvLyBUaGlzIGluY2x1ZGVzIG9uZXMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBjb21wbGV0ZWQgYmVjYXVzZSB3ZSBzdGlsbFxuICAgICAgICAvLyB3YW50IHRvIHRlbGwgdGhlIGJhY2tlbmQgdG8gdHJhbnNpdGlvbiB0aGUgY2xpZW50IHBhc3QgdGhlIGNvbXBsZXRlZFxuICAgICAgICAvLyB0aW1lc3RhbXAuIFRoaXMgaXMgc2FmZSBzaW5jZSBtdXRhdGlvbnMgYXJlIGlkZW1wb3RlbnQuXG4gICAgICAgIGFsbE1lc3NhZ2VzLnB1c2godmFsdWUubWVzc2FnZSk7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlLm1lc3NhZ2UudHlwZSA9PT0gXCJBY3Rpb25cIikge1xuICAgICAgICAvLyBVbmxpa2UgbXV0YXRpb25zLCBhY3Rpb25zIGFyZSBub3QgaWRlbXBvdGVudC4gV2hlbiB3ZSByZWNvbm5lY3QgdG8gdGhlXG4gICAgICAgIC8vIGJhY2tlbmQsIHdlIGRvbid0IGtub3cgaWYgaXQgaXMgc2FmZSB0byByZXNlbmQgaW4tZmxpZ2h0IGFjdGlvbnMsIHNvIHdlXG4gICAgICAgIC8vIGNhbmNlbCB0aGVtIGFuZCBjb25zaWRlciB0aGVtIGZhaWxlZC5cbiAgICAgICAgdGhpcy5pbmZsaWdodFJlcXVlc3RzLmRlbGV0ZShyZXF1ZXN0SWQpO1xuICAgICAgICB0aGlzLnJlcXVlc3RzT2xkZXJUaGFuUmVzdGFydC5kZWxldGUocmVxdWVzdElkKTtcbiAgICAgICAgdGhpcy5pbmZsaWdodEFjdGlvbnNDb3VudC0tO1xuICAgICAgICBpZiAodmFsdWUuc3RhdHVzLnN0YXR1cyA9PT0gXCJDb21wbGV0ZWRcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFjdGlvbiBzaG91bGQgbmV2ZXIgYmUgaW4gJ0NvbXBsZXRlZCcgc3RhdGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUuc3RhdHVzLm9uUmVzdWx0KHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvck1lc3NhZ2U6IFwiQ29ubmVjdGlvbiBsb3N0IHdoaWxlIGFjdGlvbiB3YXMgaW4gZmxpZ2h0XCIsXG4gICAgICAgICAgbG9nTGluZXM6IFtdLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5tYXJrQ29ubmVjdGlvblN0YXRlRGlydHkoKTtcbiAgICByZXR1cm4gYWxsTWVzc2FnZXM7XG4gIH1cblxuICByZXN1bWUoKTogQ2xpZW50TWVzc2FnZVtdIHtcbiAgICBjb25zdCBhbGxNZXNzYWdlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgWywgdmFsdWVdIG9mIHRoaXMuaW5mbGlnaHRSZXF1ZXN0cykge1xuICAgICAgaWYgKHZhbHVlLnN0YXR1cy5zdGF0dXMgPT09IFwiTm90U2VudFwiKSB7XG4gICAgICAgIHZhbHVlLnN0YXR1cy5zdGF0dXMgPSBcIlJlcXVlc3RlZFwiO1xuICAgICAgICBhbGxNZXNzYWdlcy5wdXNoKHZhbHVlLm1lc3NhZ2UpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFsbE1lc3NhZ2VzO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlcmUgYXJlIGFueSByZXF1ZXN0cyB0aGF0IGhhdmUgYmVlbiByZXF1ZXN0ZWQgYnV0IGhhdmVcbiAgICogbm90IGJlIGNvbXBsZXRlZCB5ZXQuXG4gICAqL1xuICBoYXNJbmNvbXBsZXRlUmVxdWVzdHMoKTogYm9vbGVhbiB7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0SW5mbyBvZiB0aGlzLmluZmxpZ2h0UmVxdWVzdHMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChyZXF1ZXN0SW5mby5zdGF0dXMuc3RhdHVzID09PSBcIlJlcXVlc3RlZFwiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGVyZSBhcmUgYW55IGluZmxpZ2h0IHJlcXVlc3RzLCBpbmNsdWRpbmcgb25lcyB0aGF0IGhhdmVcbiAgICogY29tcGxldGVkIG9uIHRoZSBzZXJ2ZXIsIGJ1dCBoYXZlIG5vdCBiZWVuIGFwcGxpZWQuXG4gICAqL1xuICBoYXNJbmZsaWdodFJlcXVlc3RzKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmluZmxpZ2h0UmVxdWVzdHMuc2l6ZSA+IDA7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGVyZSBhcmUgYW55IGluZmxpZ2h0IHJlcXVlc3RzLCB0aGF0IGhhdmUgYmVlbiBoYW5naW5nIGFyb3VuZFxuICAgKiBzaW5jZSBwcmlvciB0byB0aGUgbW9zdCByZWNlbnQgcmVzdGFydC5cbiAgICovXG4gIGhhc1N5bmNlZFBhc3RMYXN0UmVjb25uZWN0KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3RzT2xkZXJUaGFuUmVzdGFydC5zaXplID09PSAwO1xuICB9XG5cbiAgdGltZU9mT2xkZXN0SW5mbGlnaHRSZXF1ZXN0KCk6IERhdGUgfCBudWxsIHtcbiAgICBpZiAodGhpcy5pbmZsaWdodFJlcXVlc3RzLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgb2xkZXN0SW5mbGlnaHRSZXF1ZXN0ID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGNvbnN0IHJlcXVlc3Qgb2YgdGhpcy5pbmZsaWdodFJlcXVlc3RzLnZhbHVlcygpKSB7XG4gICAgICBpZiAocmVxdWVzdC5zdGF0dXMuc3RhdHVzICE9PSBcIkNvbXBsZXRlZFwiKSB7XG4gICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cy5yZXF1ZXN0ZWRBdC5nZXRUaW1lKCkgPCBvbGRlc3RJbmZsaWdodFJlcXVlc3QpIHtcbiAgICAgICAgICBvbGRlc3RJbmZsaWdodFJlcXVlc3QgPSByZXF1ZXN0LnN0YXR1cy5yZXF1ZXN0ZWRBdC5nZXRUaW1lKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEYXRlKG9sZGVzdEluZmxpZ2h0UmVxdWVzdCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgVGhlIG51bWJlciBvZiBtdXRhdGlvbnMgY3VycmVudGx5IGluIGZsaWdodC5cbiAgICovXG4gIGluZmxpZ2h0TXV0YXRpb25zKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuaW5mbGlnaHRNdXRhdGlvbnNDb3VudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIGFjdGlvbnMgY3VycmVudGx5IGluIGZsaWdodC5cbiAgICovXG4gIGluZmxpZ2h0QWN0aW9ucygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmluZmxpZ2h0QWN0aW9uc0NvdW50O1xuICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG5pbXBvcnQge1xuICBnZXRGdW5jdGlvbk5hbWVcbn0gZnJvbSBcIi4uLy4uL3NlcnZlci9hcGkuanNcIjtcbmltcG9ydCB7IHBhcnNlQXJncyB9IGZyb20gXCIuLi8uLi9jb21tb24vaW5kZXguanNcIjtcbmltcG9ydCB7IGNyZWF0ZUh5YnJpZEVycm9yU3RhY2t0cmFjZSwgZm9yd2FyZERhdGEgfSBmcm9tIFwiLi4vbG9nZ2luZy5qc1wiO1xuaW1wb3J0IHtcbiAgY2Fub25pY2FsaXplVWRmUGF0aCxcbiAgc2VyaWFsaXplUGF0aEFuZEFyZ3Ncbn0gZnJvbSBcIi4vdWRmX3BhdGhfdXRpbHMuanNcIjtcbmltcG9ydCB7IENvbnZleEVycm9yIH0gZnJvbSBcIi4uLy4uL3ZhbHVlcy9lcnJvcnMuanNcIjtcbmNsYXNzIE9wdGltaXN0aWNMb2NhbFN0b3JlSW1wbCB7XG4gIGNvbnN0cnVjdG9yKHF1ZXJ5UmVzdWx0cykge1xuICAgIC8vIEEgcmVmZXJlbmNlcyBvZiB0aGUgcXVlcnkgcmVzdWx0cyBpbiBPcHRpbWlzdGljUXVlcnlSZXN1bHRzXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInF1ZXJ5UmVzdWx0c1wiKTtcbiAgICAvLyBBbGwgb2YgdGhlIHF1ZXJpZXMgbW9kaWZpZWQgYnkgdGhpcyBjbGFzc1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtb2RpZmllZFF1ZXJpZXNcIik7XG4gICAgdGhpcy5xdWVyeVJlc3VsdHMgPSBxdWVyeVJlc3VsdHM7XG4gICAgdGhpcy5tb2RpZmllZFF1ZXJpZXMgPSBbXTtcbiAgfVxuICBnZXRRdWVyeShxdWVyeSwgLi4uYXJncykge1xuICAgIGNvbnN0IHF1ZXJ5QXJncyA9IHBhcnNlQXJncyhhcmdzWzBdKTtcbiAgICBjb25zdCBuYW1lID0gZ2V0RnVuY3Rpb25OYW1lKHF1ZXJ5KTtcbiAgICBjb25zdCBxdWVyeVJlc3VsdCA9IHRoaXMucXVlcnlSZXN1bHRzLmdldChcbiAgICAgIHNlcmlhbGl6ZVBhdGhBbmRBcmdzKG5hbWUsIHF1ZXJ5QXJncylcbiAgICApO1xuICAgIGlmIChxdWVyeVJlc3VsdCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gT3B0aW1pc3RpY0xvY2FsU3RvcmVJbXBsLnF1ZXJ5VmFsdWUocXVlcnlSZXN1bHQucmVzdWx0KTtcbiAgfVxuICBnZXRBbGxRdWVyaWVzKHF1ZXJ5KSB7XG4gICAgY29uc3QgcXVlcmllc1dpdGhOYW1lID0gW107XG4gICAgY29uc3QgbmFtZSA9IGdldEZ1bmN0aW9uTmFtZShxdWVyeSk7XG4gICAgZm9yIChjb25zdCBxdWVyeVJlc3VsdCBvZiB0aGlzLnF1ZXJ5UmVzdWx0cy52YWx1ZXMoKSkge1xuICAgICAgaWYgKHF1ZXJ5UmVzdWx0LnVkZlBhdGggPT09IGNhbm9uaWNhbGl6ZVVkZlBhdGgobmFtZSkpIHtcbiAgICAgICAgcXVlcmllc1dpdGhOYW1lLnB1c2goe1xuICAgICAgICAgIGFyZ3M6IHF1ZXJ5UmVzdWx0LmFyZ3MsXG4gICAgICAgICAgdmFsdWU6IE9wdGltaXN0aWNMb2NhbFN0b3JlSW1wbC5xdWVyeVZhbHVlKHF1ZXJ5UmVzdWx0LnJlc3VsdClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBxdWVyaWVzV2l0aE5hbWU7XG4gIH1cbiAgc2V0UXVlcnkocXVlcnlSZWZlcmVuY2UsIGFyZ3MsIHZhbHVlKSB7XG4gICAgY29uc3QgcXVlcnlBcmdzID0gcGFyc2VBcmdzKGFyZ3MpO1xuICAgIGNvbnN0IG5hbWUgPSBnZXRGdW5jdGlvbk5hbWUocXVlcnlSZWZlcmVuY2UpO1xuICAgIGNvbnN0IHF1ZXJ5VG9rZW4gPSBzZXJpYWxpemVQYXRoQW5kQXJncyhuYW1lLCBxdWVyeUFyZ3MpO1xuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJlc3VsdCA9IHZvaWQgMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgLy8gSXQncyBhbiBvcHRpbWlzdGljIHVwZGF0ZSwgc28gdGhlcmUgYXJlIG5vIGZ1bmN0aW9uIGxvZ3MgdG8gc2hvdy5cbiAgICAgICAgbG9nTGluZXM6IFtdXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBxdWVyeSA9IHtcbiAgICAgIHVkZlBhdGg6IG5hbWUsXG4gICAgICBhcmdzOiBxdWVyeUFyZ3MsXG4gICAgICByZXN1bHRcbiAgICB9O1xuICAgIHRoaXMucXVlcnlSZXN1bHRzLnNldChxdWVyeVRva2VuLCBxdWVyeSk7XG4gICAgdGhpcy5tb2RpZmllZFF1ZXJpZXMucHVzaChxdWVyeVRva2VuKTtcbiAgfVxuICBzdGF0aWMgcXVlcnlWYWx1ZShyZXN1bHQpIHtcbiAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfSBlbHNlIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBPcHRpbWlzdGljUXVlcnlSZXN1bHRzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInF1ZXJ5UmVzdWx0c1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwib3B0aW1pc3RpY1VwZGF0ZXNcIik7XG4gICAgdGhpcy5xdWVyeVJlc3VsdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMub3B0aW1pc3RpY1VwZGF0ZXMgPSBbXTtcbiAgfVxuICAvKipcbiAgICogQXBwbHkgYWxsIG9wdGltaXN0aWMgdXBkYXRlcyBvbiB0b3Agb2Ygc2VydmVyIHF1ZXJ5IHJlc3VsdHNcbiAgICovXG4gIGluZ2VzdFF1ZXJ5UmVzdWx0c0Zyb21TZXJ2ZXIoc2VydmVyUXVlcnlSZXN1bHRzLCBvcHRpbWlzdGljVXBkYXRlc1RvRHJvcCkge1xuICAgIHRoaXMub3B0aW1pc3RpY1VwZGF0ZXMgPSB0aGlzLm9wdGltaXN0aWNVcGRhdGVzLmZpbHRlcigodXBkYXRlQW5kSWQpID0+IHtcbiAgICAgIHJldHVybiAhb3B0aW1pc3RpY1VwZGF0ZXNUb0Ryb3AuaGFzKHVwZGF0ZUFuZElkLm11dGF0aW9uSWQpO1xuICAgIH0pO1xuICAgIGNvbnN0IG9sZFF1ZXJ5UmVzdWx0cyA9IHRoaXMucXVlcnlSZXN1bHRzO1xuICAgIHRoaXMucXVlcnlSZXN1bHRzID0gbmV3IE1hcChzZXJ2ZXJRdWVyeVJlc3VsdHMpO1xuICAgIGNvbnN0IGxvY2FsU3RvcmUgPSBuZXcgT3B0aW1pc3RpY0xvY2FsU3RvcmVJbXBsKHRoaXMucXVlcnlSZXN1bHRzKTtcbiAgICBmb3IgKGNvbnN0IHVwZGF0ZUFuZElkIG9mIHRoaXMub3B0aW1pc3RpY1VwZGF0ZXMpIHtcbiAgICAgIHVwZGF0ZUFuZElkLnVwZGF0ZShsb2NhbFN0b3JlKTtcbiAgICB9XG4gICAgY29uc3QgY2hhbmdlZFF1ZXJpZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtxdWVyeVRva2VuLCBxdWVyeV0gb2YgdGhpcy5xdWVyeVJlc3VsdHMpIHtcbiAgICAgIGNvbnN0IG9sZFF1ZXJ5ID0gb2xkUXVlcnlSZXN1bHRzLmdldChxdWVyeVRva2VuKTtcbiAgICAgIGlmIChvbGRRdWVyeSA9PT0gdm9pZCAwIHx8IG9sZFF1ZXJ5LnJlc3VsdCAhPT0gcXVlcnkucmVzdWx0KSB7XG4gICAgICAgIGNoYW5nZWRRdWVyaWVzLnB1c2gocXVlcnlUb2tlbik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkUXVlcmllcztcbiAgfVxuICBhcHBseU9wdGltaXN0aWNVcGRhdGUodXBkYXRlLCBtdXRhdGlvbklkKSB7XG4gICAgdGhpcy5vcHRpbWlzdGljVXBkYXRlcy5wdXNoKHtcbiAgICAgIHVwZGF0ZSxcbiAgICAgIG11dGF0aW9uSWRcbiAgICB9KTtcbiAgICBjb25zdCBsb2NhbFN0b3JlID0gbmV3IE9wdGltaXN0aWNMb2NhbFN0b3JlSW1wbCh0aGlzLnF1ZXJ5UmVzdWx0cyk7XG4gICAgdXBkYXRlKGxvY2FsU3RvcmUpO1xuICAgIHJldHVybiBsb2NhbFN0b3JlLm1vZGlmaWVkUXVlcmllcztcbiAgfVxuICAvKipcbiAgICogXCJSYXdcIiB3aXRoIHJlc3BlY3QgdG8gZXJyb3JzIHZzIHZhbHVlcywgYnV0IHF1ZXJ5IHJlc3VsdHMgc3RpbGwgaGF2ZVxuICAgKiBvcHRpbWlzdGljIHVwZGF0ZXMgYXBwbGllZC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICByYXdRdWVyeVJlc3VsdChxdWVyeVRva2VuKSB7XG4gICAgY29uc3QgcXVlcnkgPSB0aGlzLnF1ZXJ5UmVzdWx0cy5nZXQocXVlcnlUb2tlbik7XG4gICAgaWYgKHF1ZXJ5ID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBxdWVyeS5yZXN1bHQ7XG4gIH1cbiAgcXVlcnlSZXN1bHQocXVlcnlUb2tlbikge1xuICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5xdWVyeVJlc3VsdHMuZ2V0KHF1ZXJ5VG9rZW4pO1xuICAgIGlmIChxdWVyeSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBxdWVyeS5yZXN1bHQ7XG4gICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH0gZWxzZSBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyZXN1bHQuZXJyb3JEYXRhICE9PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgZm9yd2FyZERhdGEoXG4gICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgIG5ldyBDb252ZXhFcnJvcihcbiAgICAgICAgICAgIGNyZWF0ZUh5YnJpZEVycm9yU3RhY2t0cmFjZShcInF1ZXJ5XCIsIHF1ZXJ5LnVkZlBhdGgsIHJlc3VsdClcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGNyZWF0ZUh5YnJpZEVycm9yU3RhY2t0cmFjZShcInF1ZXJ5XCIsIHF1ZXJ5LnVkZlBhdGgsIHJlc3VsdClcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGhhc1F1ZXJ5UmVzdWx0KHF1ZXJ5VG9rZW4pIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVJlc3VsdHMuZ2V0KHF1ZXJ5VG9rZW4pICE9PSB2b2lkIDA7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcXVlcnlMb2dzKHF1ZXJ5VG9rZW4pIHtcbiAgICBjb25zdCBxdWVyeSA9IHRoaXMucXVlcnlSZXN1bHRzLmdldChxdWVyeVRva2VuKTtcbiAgICByZXR1cm4gcXVlcnk/LnJlc3VsdD8ubG9nTGluZXM7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wdGltaXN0aWNfdXBkYXRlc19pbXBsLmpzLm1hcFxuIiwiaW1wb3J0IHtcbiAgRnVuY3Rpb25BcmdzLFxuICBGdW5jdGlvblJlZmVyZW5jZSxcbiAgRnVuY3Rpb25SZXR1cm5UeXBlLFxuICBPcHRpb25hbFJlc3RBcmdzLFxuICBnZXRGdW5jdGlvbk5hbWUsXG59IGZyb20gXCIuLi8uLi9zZXJ2ZXIvYXBpLmpzXCI7XG5pbXBvcnQgeyBwYXJzZUFyZ3MgfSBmcm9tIFwiLi4vLi4vY29tbW9uL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBWYWx1ZSB9IGZyb20gXCIuLi8uLi92YWx1ZXMvaW5kZXguanNcIjtcbmltcG9ydCB7IGNyZWF0ZUh5YnJpZEVycm9yU3RhY2t0cmFjZSwgZm9yd2FyZERhdGEgfSBmcm9tIFwiLi4vbG9nZ2luZy5qc1wiO1xuaW1wb3J0IHsgRnVuY3Rpb25SZXN1bHQgfSBmcm9tIFwiLi9mdW5jdGlvbl9yZXN1bHQuanNcIjtcbmltcG9ydCB7IE9wdGltaXN0aWNMb2NhbFN0b3JlIH0gZnJvbSBcIi4vb3B0aW1pc3RpY191cGRhdGVzLmpzXCI7XG5pbXBvcnQgeyBSZXF1ZXN0SWQgfSBmcm9tIFwiLi9wcm90b2NvbC5qc1wiO1xuaW1wb3J0IHtcbiAgY2Fub25pY2FsaXplVWRmUGF0aCxcbiAgUXVlcnlUb2tlbixcbiAgc2VyaWFsaXplUGF0aEFuZEFyZ3MsXG59IGZyb20gXCIuL3VkZl9wYXRoX3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBDb252ZXhFcnJvciB9IGZyb20gXCIuLi8uLi92YWx1ZXMvZXJyb3JzLmpzXCI7XG5cbi8qKlxuICogQW4gb3B0aW1pc3RpYyB1cGRhdGUgZnVuY3Rpb24gdGhhdCBoYXMgYmVlbiBjdXJyaWVkIG92ZXIgaXRzIGFyZ3VtZW50cy5cbiAqL1xudHlwZSBXcmFwcGVkT3B0aW1pc3RpY1VwZGF0ZSA9IChsb2NhUXVlcnlTdG9yZTogT3B0aW1pc3RpY0xvY2FsU3RvcmUpID0+IHZvaWQ7XG5cbi8qKlxuICogVGhlIGltcGxlbWVudGF0aW9uIG9mIGBPcHRpbWlzdGljTG9jYWxTdG9yZWAuXG4gKlxuICogVGhpcyBjbGFzcyBwcm92aWRlcyB0aGUgaW50ZXJmYWNlIGZvciBvcHRpbWlzdGljIHVwZGF0ZXMgdG8gbW9kaWZ5IHF1ZXJ5IHJlc3VsdHMuXG4gKi9cbmNsYXNzIE9wdGltaXN0aWNMb2NhbFN0b3JlSW1wbCBpbXBsZW1lbnRzIE9wdGltaXN0aWNMb2NhbFN0b3JlIHtcbiAgLy8gQSByZWZlcmVuY2VzIG9mIHRoZSBxdWVyeSByZXN1bHRzIGluIE9wdGltaXN0aWNRdWVyeVJlc3VsdHNcbiAgcHJpdmF0ZSByZWFkb25seSBxdWVyeVJlc3VsdHM6IFF1ZXJ5UmVzdWx0c01hcDtcblxuICAvLyBBbGwgb2YgdGhlIHF1ZXJpZXMgbW9kaWZpZWQgYnkgdGhpcyBjbGFzc1xuICByZWFkb25seSBtb2RpZmllZFF1ZXJpZXM6IFF1ZXJ5VG9rZW5bXTtcblxuICBjb25zdHJ1Y3RvcihxdWVyeVJlc3VsdHM6IFF1ZXJ5UmVzdWx0c01hcCkge1xuICAgIHRoaXMucXVlcnlSZXN1bHRzID0gcXVlcnlSZXN1bHRzO1xuICAgIHRoaXMubW9kaWZpZWRRdWVyaWVzID0gW107XG4gIH1cblxuICBnZXRRdWVyeTxRdWVyeSBleHRlbmRzIEZ1bmN0aW9uUmVmZXJlbmNlPFwicXVlcnlcIj4+KFxuICAgIHF1ZXJ5OiBRdWVyeSxcbiAgICAuLi5hcmdzOiBPcHRpb25hbFJlc3RBcmdzPFF1ZXJ5PlxuICApOiB1bmRlZmluZWQgfCBGdW5jdGlvblJldHVyblR5cGU8UXVlcnk+IHtcbiAgICBjb25zdCBxdWVyeUFyZ3MgPSBwYXJzZUFyZ3MoYXJnc1swXSk7XG4gICAgY29uc3QgbmFtZSA9IGdldEZ1bmN0aW9uTmFtZShxdWVyeSk7XG4gICAgY29uc3QgcXVlcnlSZXN1bHQgPSB0aGlzLnF1ZXJ5UmVzdWx0cy5nZXQoXG4gICAgICBzZXJpYWxpemVQYXRoQW5kQXJncyhuYW1lLCBxdWVyeUFyZ3MpLFxuICAgICk7XG4gICAgaWYgKHF1ZXJ5UmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBPcHRpbWlzdGljTG9jYWxTdG9yZUltcGwucXVlcnlWYWx1ZShxdWVyeVJlc3VsdC5yZXN1bHQpO1xuICB9XG5cbiAgZ2V0QWxsUXVlcmllczxRdWVyeSBleHRlbmRzIEZ1bmN0aW9uUmVmZXJlbmNlPFwicXVlcnlcIj4+KFxuICAgIHF1ZXJ5OiBRdWVyeSxcbiAgKToge1xuICAgIGFyZ3M6IEZ1bmN0aW9uQXJnczxRdWVyeT47XG4gICAgdmFsdWU6IHVuZGVmaW5lZCB8IEZ1bmN0aW9uUmV0dXJuVHlwZTxRdWVyeT47XG4gIH1bXSB7XG4gICAgY29uc3QgcXVlcmllc1dpdGhOYW1lOiB7XG4gICAgICBhcmdzOiBGdW5jdGlvbkFyZ3M8UXVlcnk+O1xuICAgICAgdmFsdWU6IHVuZGVmaW5lZCB8IEZ1bmN0aW9uUmV0dXJuVHlwZTxRdWVyeT47XG4gICAgfVtdID0gW107XG4gICAgY29uc3QgbmFtZSA9IGdldEZ1bmN0aW9uTmFtZShxdWVyeSk7XG4gICAgZm9yIChjb25zdCBxdWVyeVJlc3VsdCBvZiB0aGlzLnF1ZXJ5UmVzdWx0cy52YWx1ZXMoKSkge1xuICAgICAgaWYgKHF1ZXJ5UmVzdWx0LnVkZlBhdGggPT09IGNhbm9uaWNhbGl6ZVVkZlBhdGgobmFtZSkpIHtcbiAgICAgICAgcXVlcmllc1dpdGhOYW1lLnB1c2goe1xuICAgICAgICAgIGFyZ3M6IHF1ZXJ5UmVzdWx0LmFyZ3MgYXMgRnVuY3Rpb25BcmdzPFF1ZXJ5PixcbiAgICAgICAgICB2YWx1ZTogT3B0aW1pc3RpY0xvY2FsU3RvcmVJbXBsLnF1ZXJ5VmFsdWUocXVlcnlSZXN1bHQucmVzdWx0KSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBxdWVyaWVzV2l0aE5hbWU7XG4gIH1cblxuICBzZXRRdWVyeTxRdWVyeVJlZmVyZW5jZSBleHRlbmRzIEZ1bmN0aW9uUmVmZXJlbmNlPFwicXVlcnlcIj4+KFxuICAgIHF1ZXJ5UmVmZXJlbmNlOiBRdWVyeVJlZmVyZW5jZSxcbiAgICBhcmdzOiBGdW5jdGlvbkFyZ3M8UXVlcnlSZWZlcmVuY2U+LFxuICAgIHZhbHVlOiB1bmRlZmluZWQgfCBGdW5jdGlvblJldHVyblR5cGU8UXVlcnlSZWZlcmVuY2U+LFxuICApOiB2b2lkIHtcbiAgICBjb25zdCBxdWVyeUFyZ3MgPSBwYXJzZUFyZ3MoYXJncyk7XG4gICAgY29uc3QgbmFtZSA9IGdldEZ1bmN0aW9uTmFtZShxdWVyeVJlZmVyZW5jZSk7XG4gICAgY29uc3QgcXVlcnlUb2tlbiA9IHNlcmlhbGl6ZVBhdGhBbmRBcmdzKG5hbWUsIHF1ZXJ5QXJncyk7XG5cbiAgICBsZXQgcmVzdWx0OiBGdW5jdGlvblJlc3VsdCB8IHVuZGVmaW5lZDtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICAvLyBJdCdzIGFuIG9wdGltaXN0aWMgdXBkYXRlLCBzbyB0aGVyZSBhcmUgbm8gZnVuY3Rpb24gbG9ncyB0byBzaG93LlxuICAgICAgICBsb2dMaW5lczogW10sXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBxdWVyeTogUXVlcnkgPSB7XG4gICAgICB1ZGZQYXRoOiBuYW1lLFxuICAgICAgYXJnczogcXVlcnlBcmdzLFxuICAgICAgcmVzdWx0LFxuICAgIH07XG4gICAgdGhpcy5xdWVyeVJlc3VsdHMuc2V0KHF1ZXJ5VG9rZW4sIHF1ZXJ5KTtcbiAgICB0aGlzLm1vZGlmaWVkUXVlcmllcy5wdXNoKHF1ZXJ5VG9rZW4pO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgcXVlcnlWYWx1ZShcbiAgICByZXN1bHQ6IEZ1bmN0aW9uUmVzdWx0IHwgdW5kZWZpbmVkLFxuICApOiBWYWx1ZSB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZSBxdWVyeSBpcyBhbiBlcnJvciBzdGF0ZSwganVzdCByZXR1cm4gYHVuZGVmaW5lZGAgYXMgdGhvdWdoXG4gICAgICAvLyBpdCdzIGxvYWRpbmcuIE9wdGltaXN0aWMgdXBkYXRlcyBzaG91bGQgYWxyZWFkeSBoYW5kbGUgYHVuZGVmaW5lZGAgd2VsbFxuICAgICAgLy8gYW5kIHRoZXJlIGlzbid0IGEgbmVlZCB0byBicmVhayB0aGUgd2hvbGUgdXBkYXRlIGJlY2F1c2UgaXQgdHJpZWRcbiAgICAgIC8vIHRvIGxvYWQgYSBzaW5nbGUgcXVlcnkgdGhhdCBlcnJvcmVkLlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbn1cblxudHlwZSBPcHRpbWlzdGljVXBkYXRlQW5kSWQgPSB7XG4gIHVwZGF0ZTogV3JhcHBlZE9wdGltaXN0aWNVcGRhdGU7XG4gIG11dGF0aW9uSWQ6IFJlcXVlc3RJZDtcbn07XG5cbnR5cGUgUXVlcnkgPSB7XG4gIC8vIHVuZGVmaW5lZCBtZWFucyB0aGUgcXVlcnkgd2FzIHNldCB0byBiZSBsb2FkaW5nICh1bmRlZmluZWQpIGluIGFuIG9wdGltaXN0aWMgdXBkYXRlLlxuICAvLyBOb3RlIHRoYXQgd2UgY2FuIGFsc28gaGF2ZSBxdWVyaWVzIG5vdCBwcmVzZW50IGluIHRoZSBRdWVyeVJlc3VsdE1hcFxuICAvLyBhdCBhbGwgYmVjYXVzZSB0aGV5IGFyZSBzdGlsbCBsb2FkaW5nIGZyb20gdGhlIHNlcnZlciBhbmQgaGF2ZSBubyBvcHRpbWlzdGljIHVwZGF0ZVxuICAvLyBzZXR0aW5nIGFuIG9wdGltaXN0aWMgdmFsdWUgaW4gYWR2YW5jZS5cbiAgcmVzdWx0OiBGdW5jdGlvblJlc3VsdCB8IHVuZGVmaW5lZDtcbiAgdWRmUGF0aDogc3RyaW5nO1xuICBhcmdzOiBSZWNvcmQ8c3RyaW5nLCBWYWx1ZT47XG59O1xuZXhwb3J0IHR5cGUgUXVlcnlSZXN1bHRzTWFwID0gTWFwPFF1ZXJ5VG9rZW4sIFF1ZXJ5PjtcblxudHlwZSBDaGFuZ2VkUXVlcmllcyA9IFF1ZXJ5VG9rZW5bXTtcblxuLyoqXG4gKiBBIHZpZXcgb2YgYWxsIG9mIG91ciBxdWVyeSByZXN1bHRzIHdpdGggb3B0aW1pc3RpYyB1cGRhdGVzIGFwcGxpZWQgb24gdG9wLlxuICovXG5leHBvcnQgY2xhc3MgT3B0aW1pc3RpY1F1ZXJ5UmVzdWx0cyB7XG4gIHByaXZhdGUgcXVlcnlSZXN1bHRzOiBRdWVyeVJlc3VsdHNNYXA7XG4gIHByaXZhdGUgb3B0aW1pc3RpY1VwZGF0ZXM6IE9wdGltaXN0aWNVcGRhdGVBbmRJZFtdO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucXVlcnlSZXN1bHRzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMub3B0aW1pc3RpY1VwZGF0ZXMgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBseSBhbGwgb3B0aW1pc3RpYyB1cGRhdGVzIG9uIHRvcCBvZiBzZXJ2ZXIgcXVlcnkgcmVzdWx0c1xuICAgKi9cbiAgaW5nZXN0UXVlcnlSZXN1bHRzRnJvbVNlcnZlcihcbiAgICBzZXJ2ZXJRdWVyeVJlc3VsdHM6IFF1ZXJ5UmVzdWx0c01hcCxcbiAgICBvcHRpbWlzdGljVXBkYXRlc1RvRHJvcDogU2V0PFJlcXVlc3RJZD4sXG4gICk6IENoYW5nZWRRdWVyaWVzIHtcbiAgICB0aGlzLm9wdGltaXN0aWNVcGRhdGVzID0gdGhpcy5vcHRpbWlzdGljVXBkYXRlcy5maWx0ZXIoKHVwZGF0ZUFuZElkKSA9PiB7XG4gICAgICByZXR1cm4gIW9wdGltaXN0aWNVcGRhdGVzVG9Ecm9wLmhhcyh1cGRhdGVBbmRJZC5tdXRhdGlvbklkKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IG9sZFF1ZXJ5UmVzdWx0cyA9IHRoaXMucXVlcnlSZXN1bHRzO1xuICAgIHRoaXMucXVlcnlSZXN1bHRzID0gbmV3IE1hcChzZXJ2ZXJRdWVyeVJlc3VsdHMpO1xuICAgIGNvbnN0IGxvY2FsU3RvcmUgPSBuZXcgT3B0aW1pc3RpY0xvY2FsU3RvcmVJbXBsKHRoaXMucXVlcnlSZXN1bHRzKTtcbiAgICBmb3IgKGNvbnN0IHVwZGF0ZUFuZElkIG9mIHRoaXMub3B0aW1pc3RpY1VwZGF0ZXMpIHtcbiAgICAgIHVwZGF0ZUFuZElkLnVwZGF0ZShsb2NhbFN0b3JlKTtcbiAgICB9XG5cbiAgICAvLyBUbyBmaW5kIHRoZSBjaGFuZ2VkIHF1ZXJpZXMsIGp1c3QgZG8gYSBzaGFsbG93IGNvbXBhcmlzb25cbiAgICAvLyBUT0RPKENYLTczMyk6IENoYW5nZSB0aGlzIHNvIHdlIGF2b2lkIHVubmVjZXNzYXJ5IHJlcmVuZGVyc1xuICAgIGNvbnN0IGNoYW5nZWRRdWVyaWVzOiBDaGFuZ2VkUXVlcmllcyA9IFtdO1xuICAgIGZvciAoY29uc3QgW3F1ZXJ5VG9rZW4sIHF1ZXJ5XSBvZiB0aGlzLnF1ZXJ5UmVzdWx0cykge1xuICAgICAgY29uc3Qgb2xkUXVlcnkgPSBvbGRRdWVyeVJlc3VsdHMuZ2V0KHF1ZXJ5VG9rZW4pO1xuICAgICAgaWYgKG9sZFF1ZXJ5ID09PSB1bmRlZmluZWQgfHwgb2xkUXVlcnkucmVzdWx0ICE9PSBxdWVyeS5yZXN1bHQpIHtcbiAgICAgICAgY2hhbmdlZFF1ZXJpZXMucHVzaChxdWVyeVRva2VuKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2hhbmdlZFF1ZXJpZXM7XG4gIH1cblxuICBhcHBseU9wdGltaXN0aWNVcGRhdGUoXG4gICAgdXBkYXRlOiBXcmFwcGVkT3B0aW1pc3RpY1VwZGF0ZSxcbiAgICBtdXRhdGlvbklkOiBSZXF1ZXN0SWQsXG4gICk6IENoYW5nZWRRdWVyaWVzIHtcbiAgICAvLyBBcHBseSB0aGUgdXBkYXRlIHRvIG91ciBzdG9yZVxuICAgIHRoaXMub3B0aW1pc3RpY1VwZGF0ZXMucHVzaCh7XG4gICAgICB1cGRhdGUsXG4gICAgICBtdXRhdGlvbklkLFxuICAgIH0pO1xuICAgIGNvbnN0IGxvY2FsU3RvcmUgPSBuZXcgT3B0aW1pc3RpY0xvY2FsU3RvcmVJbXBsKHRoaXMucXVlcnlSZXN1bHRzKTtcbiAgICB1cGRhdGUobG9jYWxTdG9yZSk7XG5cbiAgICAvLyBOb3RpZnkgYWJvdXQgYW55IHF1ZXJ5IHJlc3VsdHMgdGhhdCBjaGFuZ2VkXG4gICAgLy8gVE9ETyhDWC03MzMpOiBDaGFuZ2UgdGhpcyBzbyB3ZSBhdm9pZCB1bm5lY2Vzc2FyeSByZXJlbmRlcnNcbiAgICByZXR1cm4gbG9jYWxTdG9yZS5tb2RpZmllZFF1ZXJpZXM7XG4gIH1cblxuICAvKipcbiAgICogXCJSYXdcIiB3aXRoIHJlc3BlY3QgdG8gZXJyb3JzIHZzIHZhbHVlcywgYnV0IHF1ZXJ5IHJlc3VsdHMgc3RpbGwgaGF2ZVxuICAgKiBvcHRpbWlzdGljIHVwZGF0ZXMgYXBwbGllZC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICByYXdRdWVyeVJlc3VsdChxdWVyeVRva2VuOiBRdWVyeVRva2VuKTogRnVuY3Rpb25SZXN1bHQgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5xdWVyeVJlc3VsdHMuZ2V0KHF1ZXJ5VG9rZW4pO1xuICAgIGlmIChxdWVyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gcXVlcnkucmVzdWx0O1xuICB9XG5cbiAgcXVlcnlSZXN1bHQocXVlcnlUb2tlbjogUXVlcnlUb2tlbik6IFZhbHVlIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBxdWVyeSA9IHRoaXMucXVlcnlSZXN1bHRzLmdldChxdWVyeVRva2VuKTtcbiAgICBpZiAocXVlcnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gcXVlcnkucmVzdWx0O1xuICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocmVzdWx0LmVycm9yRGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IGZvcndhcmREYXRhKFxuICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICBuZXcgQ29udmV4RXJyb3IoXG4gICAgICAgICAgICBjcmVhdGVIeWJyaWRFcnJvclN0YWNrdHJhY2UoXCJxdWVyeVwiLCBxdWVyeS51ZGZQYXRoLCByZXN1bHQpLFxuICAgICAgICAgICksXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGNyZWF0ZUh5YnJpZEVycm9yU3RhY2t0cmFjZShcInF1ZXJ5XCIsIHF1ZXJ5LnVkZlBhdGgsIHJlc3VsdCksXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGhhc1F1ZXJ5UmVzdWx0KHF1ZXJ5VG9rZW46IFF1ZXJ5VG9rZW4pOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVJlc3VsdHMuZ2V0KHF1ZXJ5VG9rZW4pICE9PSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBxdWVyeUxvZ3MocXVlcnlUb2tlbjogUXVlcnlUb2tlbik6IHN0cmluZ1tdIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBxdWVyeSA9IHRoaXMucXVlcnlSZXN1bHRzLmdldChxdWVyeVRva2VuKTtcbiAgICByZXR1cm4gcXVlcnk/LnJlc3VsdD8ubG9nTGluZXM7XG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgZnVuY3Rpb25OYW1lIH0gZnJvbSBcIi4vZnVuY3Rpb25OYW1lLmpzXCI7XG5pbXBvcnQgeyBnZXRGdW5jdGlvbkFkZHJlc3MgfSBmcm9tIFwiLi9jb21wb25lbnRzL3BhdGhzLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gZ2V0RnVuY3Rpb25OYW1lKGZ1bmN0aW9uUmVmZXJlbmNlKSB7XG4gIGNvbnN0IGFkZHJlc3MgPSBnZXRGdW5jdGlvbkFkZHJlc3MoZnVuY3Rpb25SZWZlcmVuY2UpO1xuICBpZiAoYWRkcmVzcy5uYW1lID09PSB2b2lkIDApIHtcbiAgICBpZiAoYWRkcmVzcy5mdW5jdGlvbkhhbmRsZSAhPT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBFeHBlY3RlZCBmdW5jdGlvbiByZWZlcmVuY2UgbGlrZSBcImFwaS5maWxlLmZ1bmNcIiBvciBcImludGVybmFsLmZpbGUuZnVuY1wiLCBidXQgcmVjZWl2ZWQgZnVuY3Rpb24gaGFuZGxlICR7YWRkcmVzcy5mdW5jdGlvbkhhbmRsZX1gXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoYWRkcmVzcy5yZWZlcmVuY2UgIT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRXhwZWN0ZWQgZnVuY3Rpb24gcmVmZXJlbmNlIGluIHRoZSBjdXJyZW50IGNvbXBvbmVudCBsaWtlIFwiYXBpLmZpbGUuZnVuY1wiIG9yIFwiaW50ZXJuYWwuZmlsZS5mdW5jXCIsIGJ1dCByZWNlaXZlZCByZWZlcmVuY2UgJHthZGRyZXNzLnJlZmVyZW5jZX1gXG4gICAgICApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgRXhwZWN0ZWQgZnVuY3Rpb24gcmVmZXJlbmNlIGxpa2UgXCJhcGkuZmlsZS5mdW5jXCIgb3IgXCJpbnRlcm5hbC5maWxlLmZ1bmNcIiwgYnV0IHJlY2VpdmVkICR7SlNPTi5zdHJpbmdpZnkoYWRkcmVzcyl9YFxuICAgICk7XG4gIH1cbiAgaWYgKHR5cGVvZiBmdW5jdGlvblJlZmVyZW5jZSA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGZ1bmN0aW9uUmVmZXJlbmNlO1xuICBjb25zdCBuYW1lID0gZnVuY3Rpb25SZWZlcmVuY2VbZnVuY3Rpb25OYW1lXTtcbiAgaWYgKCFuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke2Z1bmN0aW9uUmVmZXJlbmNlfSBpcyBub3QgYSBmdW5jdGlvblJlZmVyZW5jZWApO1xuICB9XG4gIHJldHVybiBuYW1lO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VGdW5jdGlvblJlZmVyZW5jZShuYW1lKSB7XG4gIHJldHVybiB7IFtmdW5jdGlvbk5hbWVdOiBuYW1lIH07XG59XG5mdW5jdGlvbiBjcmVhdGVBcGkocGF0aFBhcnRzID0gW10pIHtcbiAgY29uc3QgaGFuZGxlciA9IHtcbiAgICBnZXQoXywgcHJvcCkge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnN0IG5ld1BhcnRzID0gWy4uLnBhdGhQYXJ0cywgcHJvcF07XG4gICAgICAgIHJldHVybiBjcmVhdGVBcGkobmV3UGFydHMpO1xuICAgICAgfSBlbHNlIGlmIChwcm9wID09PSBmdW5jdGlvbk5hbWUpIHtcbiAgICAgICAgaWYgKHBhdGhQYXJ0cy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgY29uc3QgZm91bmQgPSBbXCJhcGlcIiwgLi4ucGF0aFBhcnRzXS5qb2luKFwiLlwiKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgQVBJIHBhdGggaXMgZXhwZWN0ZWQgdG8gYmUgb2YgdGhlIGZvcm0gXFxgYXBpLm1vZHVsZU5hbWUuZnVuY3Rpb25OYW1lXFxgLiBGb3VuZDogXFxgJHtmb3VuZH1cXGBgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXRoID0gcGF0aFBhcnRzLnNsaWNlKDAsIC0xKS5qb2luKFwiL1wiKTtcbiAgICAgICAgY29uc3QgZXhwb3J0TmFtZSA9IHBhdGhQYXJ0c1twYXRoUGFydHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChleHBvcnROYW1lID09PSBcImRlZmF1bHRcIikge1xuICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBwYXRoICsgXCI6XCIgKyBleHBvcnROYW1lO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHByb3AgPT09IFN5bWJvbC50b1N0cmluZ1RhZykge1xuICAgICAgICByZXR1cm4gXCJGdW5jdGlvblJlZmVyZW5jZVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBuZXcgUHJveHkoe30sIGhhbmRsZXIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlckFwaShhcGkpIHtcbiAgcmV0dXJuIGFwaTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBqdXN0SW50ZXJuYWwoYXBpKSB7XG4gIHJldHVybiBhcGk7XG59XG5leHBvcnQgZnVuY3Rpb24ganVzdFB1YmxpYyhhcGkpIHtcbiAgcmV0dXJuIGFwaTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBqdXN0UXVlcmllcyhhcGkpIHtcbiAgcmV0dXJuIGFwaTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBqdXN0TXV0YXRpb25zKGFwaSkge1xuICByZXR1cm4gYXBpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGp1c3RBY3Rpb25zKGFwaSkge1xuICByZXR1cm4gYXBpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGp1c3RQYWdpbmF0ZWRRdWVyaWVzKGFwaSkge1xuICByZXR1cm4gYXBpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGp1c3RTY2hlZHVsYWJsZShhcGkpIHtcbiAgcmV0dXJuIGFwaTtcbn1cbmV4cG9ydCBjb25zdCBhbnlBcGkgPSBjcmVhdGVBcGkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwaS5qcy5tYXBcbiIsImltcG9ydCB7XG4gIEVtcHR5T2JqZWN0LFxuICBEZWZhdWx0RnVuY3Rpb25BcmdzLFxuICBGdW5jdGlvblZpc2liaWxpdHksXG4gIFJlZ2lzdGVyZWRBY3Rpb24sXG4gIFJlZ2lzdGVyZWRNdXRhdGlvbixcbiAgUmVnaXN0ZXJlZFF1ZXJ5LFxufSBmcm9tIFwiLi9yZWdpc3RyYXRpb24uanNcIjtcbmltcG9ydCB7IEV4cGFuZCwgVW5pb25Ub0ludGVyc2VjdGlvbiB9IGZyb20gXCIuLi90eXBlX3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBQYWdpbmF0aW9uT3B0aW9ucywgUGFnaW5hdGlvblJlc3VsdCB9IGZyb20gXCIuL3BhZ2luYXRpb24uanNcIjtcbmltcG9ydCB7IGZ1bmN0aW9uTmFtZSB9IGZyb20gXCIuL2Z1bmN0aW9uTmFtZS5qc1wiO1xuaW1wb3J0IHsgZ2V0RnVuY3Rpb25BZGRyZXNzIH0gZnJvbSBcIi4vY29tcG9uZW50cy9wYXRocy5qc1wiO1xuXG4vKipcbiAqIFRoZSB0eXBlIG9mIGEgQ29udmV4IGZ1bmN0aW9uLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IHR5cGUgRnVuY3Rpb25UeXBlID0gXCJxdWVyeVwiIHwgXCJtdXRhdGlvblwiIHwgXCJhY3Rpb25cIjtcblxuLyoqXG4gKiBBIHJlZmVyZW5jZSB0byBhIHJlZ2lzdGVyZWQgQ29udmV4IGZ1bmN0aW9uLlxuICpcbiAqIFlvdSBjYW4gY3JlYXRlIGEge0BsaW5rIEZ1bmN0aW9uUmVmZXJlbmNlfSB1c2luZyB0aGUgZ2VuZXJhdGVkIGBhcGlgIHV0aWxpdHk6XG4gKiBgYGBqc1xuICogaW1wb3J0IHsgYXBpIH0gZnJvbSBcIi4uL2NvbnZleC9fZ2VuZXJhdGVkL2FwaVwiO1xuICpcbiAqIGNvbnN0IHJlZmVyZW5jZSA9IGFwaS5teU1vZHVsZS5teUZ1bmN0aW9uO1xuICogYGBgXG4gKlxuICogSWYgeW91IGFyZW4ndCB1c2luZyBjb2RlIGdlbmVyYXRpb24sIHlvdSBjYW4gY3JlYXRlIHJlZmVyZW5jZXMgdXNpbmdcbiAqIHtAbGluayBhbnlBcGl9OlxuICogYGBganNcbiAqIGltcG9ydCB7IGFueUFwaSB9IGZyb20gXCJjb252ZXgvc2VydmVyXCI7XG4gKlxuICogY29uc3QgcmVmZXJlbmNlID0gYW55QXBpLm15TW9kdWxlLm15RnVuY3Rpb247XG4gKiBgYGBcbiAqXG4gKiBGdW5jdGlvbiByZWZlcmVuY2VzIGNhbiBiZSB1c2VkIHRvIGludm9rZSBmdW5jdGlvbnMgZnJvbSB0aGUgY2xpZW50LiBGb3JcbiAqIGV4YW1wbGUsIGluIFJlYWN0IHlvdSBjYW4gcGFzcyByZWZlcmVuY2VzIHRvIHRoZSB7QGxpbmsgcmVhY3QudXNlUXVlcnl9IGhvb2s6XG4gKiBgYGBqc1xuICogY29uc3QgcmVzdWx0ID0gdXNlUXVlcnkoYXBpLm15TW9kdWxlLm15RnVuY3Rpb24pO1xuICogYGBgXG4gKlxuICogQHR5cGVQYXJhbSBUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIGZ1bmN0aW9uIChcInF1ZXJ5XCIsIFwibXV0YXRpb25cIiwgb3IgXCJhY3Rpb25cIikuXG4gKiBAdHlwZVBhcmFtIFZpc2liaWxpdHkgLSBUaGUgdmlzaWJpbGl0eSBvZiB0aGUgZnVuY3Rpb24gKFwicHVibGljXCIgb3IgXCJpbnRlcm5hbFwiKS5cbiAqIEB0eXBlUGFyYW0gQXJncyAtIFRoZSBhcmd1bWVudHMgdG8gdGhpcyBmdW5jdGlvbi4gVGhpcyBpcyBhbiBvYmplY3QgbWFwcGluZ1xuICogYXJndW1lbnQgbmFtZXMgdG8gdGhlaXIgdHlwZXMuXG4gKiBAdHlwZVBhcmFtIFJldHVyblR5cGUgLSBUaGUgcmV0dXJuIHR5cGUgb2YgdGhpcyBmdW5jdGlvbi5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IHR5cGUgRnVuY3Rpb25SZWZlcmVuY2U8XG4gIFR5cGUgZXh0ZW5kcyBGdW5jdGlvblR5cGUsXG4gIFZpc2liaWxpdHkgZXh0ZW5kcyBGdW5jdGlvblZpc2liaWxpdHkgPSBcInB1YmxpY1wiLFxuICBBcmdzIGV4dGVuZHMgRGVmYXVsdEZ1bmN0aW9uQXJncyA9IGFueSxcbiAgUmV0dXJuVHlwZSA9IGFueSxcbiAgQ29tcG9uZW50UGF0aCA9IHN0cmluZyB8IHVuZGVmaW5lZCxcbj4gPSB7XG4gIF90eXBlOiBUeXBlO1xuICBfdmlzaWJpbGl0eTogVmlzaWJpbGl0eTtcbiAgX2FyZ3M6IEFyZ3M7XG4gIF9yZXR1cm5UeXBlOiBSZXR1cm5UeXBlO1xuICBfY29tcG9uZW50UGF0aDogQ29tcG9uZW50UGF0aDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBuYW1lIG9mIGEgZnVuY3Rpb24gZnJvbSBhIHtAbGluayBGdW5jdGlvblJlZmVyZW5jZX0uXG4gKlxuICogVGhlIG5hbWUgaXMgYSBzdHJpbmcgbGlrZSBcIm15RGlyL215TW9kdWxlOm15RnVuY3Rpb25cIi4gSWYgdGhlIGV4cG9ydGVkIG5hbWVcbiAqIG9mIHRoZSBmdW5jdGlvbiBpcyBgXCJkZWZhdWx0XCJgLCB0aGUgZnVuY3Rpb24gbmFtZSBpcyBvbWl0dGVkXG4gKiAoZS5nLiBcIm15RGlyL215TW9kdWxlXCIpLlxuICpcbiAqIEBwYXJhbSBmdW5jdGlvblJlZmVyZW5jZSAtIEEge0BsaW5rIEZ1bmN0aW9uUmVmZXJlbmNlfSB0byBnZXQgdGhlIG5hbWUgb2YuXG4gKiBAcmV0dXJucyBBIHN0cmluZyBvZiB0aGUgZnVuY3Rpb24ncyBuYW1lLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZ1bmN0aW9uTmFtZShcbiAgZnVuY3Rpb25SZWZlcmVuY2U6IEFueUZ1bmN0aW9uUmVmZXJlbmNlLFxuKTogc3RyaW5nIHtcbiAgY29uc3QgYWRkcmVzcyA9IGdldEZ1bmN0aW9uQWRkcmVzcyhmdW5jdGlvblJlZmVyZW5jZSk7XG5cbiAgaWYgKGFkZHJlc3MubmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGFkZHJlc3MuZnVuY3Rpb25IYW5kbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRXhwZWN0ZWQgZnVuY3Rpb24gcmVmZXJlbmNlIGxpa2UgXCJhcGkuZmlsZS5mdW5jXCIgb3IgXCJpbnRlcm5hbC5maWxlLmZ1bmNcIiwgYnV0IHJlY2VpdmVkIGZ1bmN0aW9uIGhhbmRsZSAke2FkZHJlc3MuZnVuY3Rpb25IYW5kbGV9YCxcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChhZGRyZXNzLnJlZmVyZW5jZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBFeHBlY3RlZCBmdW5jdGlvbiByZWZlcmVuY2UgaW4gdGhlIGN1cnJlbnQgY29tcG9uZW50IGxpa2UgXCJhcGkuZmlsZS5mdW5jXCIgb3IgXCJpbnRlcm5hbC5maWxlLmZ1bmNcIiwgYnV0IHJlY2VpdmVkIHJlZmVyZW5jZSAke2FkZHJlc3MucmVmZXJlbmNlfWAsXG4gICAgICApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgRXhwZWN0ZWQgZnVuY3Rpb24gcmVmZXJlbmNlIGxpa2UgXCJhcGkuZmlsZS5mdW5jXCIgb3IgXCJpbnRlcm5hbC5maWxlLmZ1bmNcIiwgYnV0IHJlY2VpdmVkICR7SlNPTi5zdHJpbmdpZnkoYWRkcmVzcyl9YCxcbiAgICApO1xuICB9XG4gIC8vIEJvdGggYSBsZWdhY3kgdGhpbmcgYW5kIGFsc28gYSBjb252ZW5pZW5jZSBmb3IgaW50ZXJhY3RpdmUgdXNlOlxuICAvLyB0aGUgdHlwZXMgd29uJ3QgY2hlY2sgYnV0IGEgc3RyaW5nIGlzIGFsd2F5cyBhbGxvd2VkIGF0IHJ1bnRpbWUuXG4gIGlmICh0eXBlb2YgZnVuY3Rpb25SZWZlcmVuY2UgPT09IFwic3RyaW5nXCIpIHJldHVybiBmdW5jdGlvblJlZmVyZW5jZTtcblxuICAvLyBUd28gZGlmZmVyZW50IHJ1bnRpbWUgdmFsdWVzIGZvciBGdW5jdGlvblJlZmVyZW5jZSBpbXBsZW1lbnQgdGhpc1xuICAvLyBpbnRlcmZhY2U6IGFwaSBvYmplY3RzIHJldHVybmVkIGZyb20gYGNyZWF0ZUFwaSgpYCBhbmQgc3RhbmRhbG9uZVxuICAvLyBmdW5jdGlvbiByZWZlcmVuY2Ugb2JqZWN0cyByZXR1cm5lZCBmcm9tIG1ha2VGdW5jdGlvblJlZmVyZW5jZS5cbiAgY29uc3QgbmFtZSA9IChmdW5jdGlvblJlZmVyZW5jZSBhcyBhbnkpW2Z1bmN0aW9uTmFtZV07XG4gIGlmICghbmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHtmdW5jdGlvblJlZmVyZW5jZSBhcyBhbnl9IGlzIG5vdCBhIGZ1bmN0aW9uUmVmZXJlbmNlYCk7XG4gIH1cbiAgcmV0dXJuIG5hbWU7XG59XG5cbi8qKlxuICogRnVuY3Rpb25SZWZlcmVuY2VzIGdlbmVyYWxseSBjb21lIGZyb20gZ2VuZXJhdGVkIGNvZGUsIGJ1dCBpbiBjdXN0b20gY2xpZW50c1xuICogaXQgbWF5IGJlIHVzZWZ1bCB0byBiZSBhYmxlIHRvIGJ1aWxkIG9uZSBtYW51YWxseS5cbiAqXG4gKiBSZWFsIGZ1bmN0aW9uIHJlZmVyZW5jZXMgYXJlIGVtcHR5IG9iamVjdHMgYXQgcnVudGltZSwgYnV0IHRoZSBzYW1lIGludGVyZmFjZVxuICogY2FuIGJlIGltcGxlbWVudGVkIHdpdGggYW4gb2JqZWN0IGZvciB0ZXN0cyBhbmQgY2xpZW50cyB3aGljaCBkb24ndCB1c2VcbiAqIGNvZGUgZ2VuZXJhdGlvbi5cbiAqXG4gKiBAcGFyYW0gbmFtZSAtIFRoZSBpZGVudGlmaWVyIG9mIHRoZSBmdW5jdGlvbi4gRS5nLiBgcGF0aC90by9maWxlOmZ1bmN0aW9uTmFtZWBcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VGdW5jdGlvblJlZmVyZW5jZTxcbiAgdHlwZSBleHRlbmRzIEZ1bmN0aW9uVHlwZSxcbiAgYXJncyBleHRlbmRzIERlZmF1bHRGdW5jdGlvbkFyZ3MgPSBhbnksXG4gIHJldCA9IGFueSxcbj4obmFtZTogc3RyaW5nKTogRnVuY3Rpb25SZWZlcmVuY2U8dHlwZSwgXCJwdWJsaWNcIiwgYXJncywgcmV0PiB7XG4gIHJldHVybiB7IFtmdW5jdGlvbk5hbWVdOiBuYW1lIH0gYXMgdW5rbm93biBhcyBGdW5jdGlvblJlZmVyZW5jZTxcbiAgICB0eXBlLFxuICAgIFwicHVibGljXCIsXG4gICAgYXJncyxcbiAgICByZXRcbiAgPjtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBydW50aW1lIEFQSSBvYmplY3QgdGhhdCBpbXBsZW1lbnRzIHtAbGluayBBbnlBcGl9LlxuICpcbiAqIFRoaXMgYWxsb3dzIGFjY2Vzc2luZyBhbnkgcGF0aCByZWdhcmRsZXNzIG9mIHdoYXQgZGlyZWN0b3JpZXMsIG1vZHVsZXMsXG4gKiBvciBmdW5jdGlvbnMgYXJlIGRlZmluZWQuXG4gKlxuICogQHBhcmFtIHBhdGhQYXJ0cyAtIFRoZSBwYXRoIHRvIHRoZSBjdXJyZW50IG5vZGUgaW4gdGhlIEFQSS5cbiAqIEByZXR1cm5zIEFuIHtAbGluayBBbnlBcGl9XG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFwaShwYXRoUGFydHM6IHN0cmluZ1tdID0gW10pOiBBbnlBcGkge1xuICBjb25zdCBoYW5kbGVyOiBQcm94eUhhbmRsZXI8b2JqZWN0PiA9IHtcbiAgICBnZXQoXywgcHJvcDogc3RyaW5nIHwgc3ltYm9sKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3AgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgbmV3UGFydHMgPSBbLi4ucGF0aFBhcnRzLCBwcm9wXTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUFwaShuZXdQYXJ0cyk7XG4gICAgICB9IGVsc2UgaWYgKHByb3AgPT09IGZ1bmN0aW9uTmFtZSkge1xuICAgICAgICBpZiAocGF0aFBhcnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICBjb25zdCBmb3VuZCA9IFtcImFwaVwiLCAuLi5wYXRoUGFydHNdLmpvaW4oXCIuXCIpO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBBUEkgcGF0aCBpcyBleHBlY3RlZCB0byBiZSBvZiB0aGUgZm9ybSBcXGBhcGkubW9kdWxlTmFtZS5mdW5jdGlvbk5hbWVcXGAuIEZvdW5kOiBcXGAke2ZvdW5kfVxcYGAsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXRoID0gcGF0aFBhcnRzLnNsaWNlKDAsIC0xKS5qb2luKFwiL1wiKTtcbiAgICAgICAgY29uc3QgZXhwb3J0TmFtZSA9IHBhdGhQYXJ0c1twYXRoUGFydHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChleHBvcnROYW1lID09PSBcImRlZmF1bHRcIikge1xuICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBwYXRoICsgXCI6XCIgKyBleHBvcnROYW1lO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHByb3AgPT09IFN5bWJvbC50b1N0cmluZ1RhZykge1xuICAgICAgICByZXR1cm4gXCJGdW5jdGlvblJlZmVyZW5jZVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9LFxuICB9O1xuXG4gIHJldHVybiBuZXcgUHJveHkoe30sIGhhbmRsZXIpO1xufVxuXG4vKipcbiAqIEdpdmVuIGFuIGV4cG9ydCBmcm9tIGEgbW9kdWxlLCBjb252ZXJ0IGl0IHRvIGEge0BsaW5rIEZ1bmN0aW9uUmVmZXJlbmNlfVxuICogaWYgaXQgaXMgYSBDb252ZXggZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCB0eXBlIEZ1bmN0aW9uUmVmZXJlbmNlRnJvbUV4cG9ydDxFeHBvcnQ+ID1cbiAgRXhwb3J0IGV4dGVuZHMgUmVnaXN0ZXJlZFF1ZXJ5PFxuICAgIGluZmVyIFZpc2liaWxpdHksXG4gICAgaW5mZXIgQXJncyxcbiAgICBpbmZlciBSZXR1cm5WYWx1ZVxuICA+XG4gICAgPyBGdW5jdGlvblJlZmVyZW5jZTxcbiAgICAgICAgXCJxdWVyeVwiLFxuICAgICAgICBWaXNpYmlsaXR5LFxuICAgICAgICBBcmdzLFxuICAgICAgICBDb252ZXJ0UmV0dXJuVHlwZTxSZXR1cm5WYWx1ZT5cbiAgICAgID5cbiAgICA6IEV4cG9ydCBleHRlbmRzIFJlZ2lzdGVyZWRNdXRhdGlvbjxcbiAgICAgICAgICBpbmZlciBWaXNpYmlsaXR5LFxuICAgICAgICAgIGluZmVyIEFyZ3MsXG4gICAgICAgICAgaW5mZXIgUmV0dXJuVmFsdWVcbiAgICAgICAgPlxuICAgICAgPyBGdW5jdGlvblJlZmVyZW5jZTxcbiAgICAgICAgICBcIm11dGF0aW9uXCIsXG4gICAgICAgICAgVmlzaWJpbGl0eSxcbiAgICAgICAgICBBcmdzLFxuICAgICAgICAgIENvbnZlcnRSZXR1cm5UeXBlPFJldHVyblZhbHVlPlxuICAgICAgICA+XG4gICAgICA6IEV4cG9ydCBleHRlbmRzIFJlZ2lzdGVyZWRBY3Rpb248XG4gICAgICAgICAgICBpbmZlciBWaXNpYmlsaXR5LFxuICAgICAgICAgICAgaW5mZXIgQXJncyxcbiAgICAgICAgICAgIGluZmVyIFJldHVyblZhbHVlXG4gICAgICAgICAgPlxuICAgICAgICA/IEZ1bmN0aW9uUmVmZXJlbmNlPFxuICAgICAgICAgICAgXCJhY3Rpb25cIixcbiAgICAgICAgICAgIFZpc2liaWxpdHksXG4gICAgICAgICAgICBBcmdzLFxuICAgICAgICAgICAgQ29udmVydFJldHVyblR5cGU8UmV0dXJuVmFsdWU+XG4gICAgICAgICAgPlxuICAgICAgICA6IG5ldmVyO1xuXG4vKipcbiAqIEdpdmVuIGEgbW9kdWxlLCBjb252ZXJ0IGFsbCB0aGUgQ29udmV4IGZ1bmN0aW9ucyBpbnRvXG4gKiB7QGxpbmsgRnVuY3Rpb25SZWZlcmVuY2V9cyBhbmQgcmVtb3ZlIHRoZSBvdGhlciBleHBvcnRzLlxuICpcbiAqIEJFIENBUkVGVUwgV0hFTiBFRElUSU5HIFRISVMhXG4gKlxuICogVGhpcyBpcyB3cml0dGVuIGNhcmVmdWxseSB0byBwcmVzZXJ2ZSBqdW1waW5nIHRvIGZ1bmN0aW9uIGRlZmluaXRpb25zIHVzaW5nXG4gKiBjbWQrY2xpY2suIElmIHlvdSBlZGl0IGl0LCBwbGVhc2UgdGVzdCB0aGF0IGNtZCtjbGljayBzdGlsbCB3b3Jrcy5cbiAqL1xudHlwZSBGdW5jdGlvblJlZmVyZW5jZXNJbk1vZHVsZTxNb2R1bGUgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+PiA9IHtcbiAgLXJlYWRvbmx5IFtFeHBvcnROYW1lIGluIGtleW9mIE1vZHVsZSBhcyBNb2R1bGVbRXhwb3J0TmFtZV1bXCJpc0NvbnZleEZ1bmN0aW9uXCJdIGV4dGVuZHMgdHJ1ZVxuICAgID8gRXhwb3J0TmFtZVxuICAgIDogbmV2ZXJdOiBGdW5jdGlvblJlZmVyZW5jZUZyb21FeHBvcnQ8TW9kdWxlW0V4cG9ydE5hbWVdPjtcbn07XG5cbi8qKlxuICogR2l2ZW4gYSBwYXRoIHRvIGEgbW9kdWxlIGFuZCBpdCdzIHR5cGUsIGdlbmVyYXRlIGFuIEFQSSB0eXBlIGZvciB0aGlzIG1vZHVsZS5cbiAqXG4gKiBUaGlzIGlzIGEgbmVzdGVkIG9iamVjdCBhY2NvcmRpbmcgdG8gdGhlIG1vZHVsZSdzIHBhdGguXG4gKi9cbnR5cGUgQXBpRm9yTW9kdWxlPFxuICBNb2R1bGVQYXRoIGV4dGVuZHMgc3RyaW5nLFxuICBNb2R1bGUgZXh0ZW5kcyBvYmplY3QsXG4+ID0gTW9kdWxlUGF0aCBleHRlbmRzIGAke2luZmVyIEZpcnN0fS8ke2luZmVyIFNlY29uZH1gXG4gID8ge1xuICAgICAgW18gaW4gRmlyc3RdOiBBcGlGb3JNb2R1bGU8U2Vjb25kLCBNb2R1bGU+O1xuICAgIH1cbiAgOiB7IFtfIGluIE1vZHVsZVBhdGhdOiBGdW5jdGlvblJlZmVyZW5jZXNJbk1vZHVsZTxNb2R1bGU+IH07XG5cbi8qKlxuICogR2l2ZW4gdGhlIHR5cGVzIG9mIGFsbCBtb2R1bGVzIGluIHRoZSBgY29udmV4L2AgZGlyZWN0b3J5LCBjb25zdHJ1Y3QgdGhlIHR5cGVcbiAqIG9mIGBhcGlgLlxuICpcbiAqIGBhcGlgIGlzIGEgdXRpbGl0eSBmb3IgY29uc3RydWN0aW5nIHtAbGluayBGdW5jdGlvblJlZmVyZW5jZX1zLlxuICpcbiAqIEB0eXBlUGFyYW0gQWxsTW9kdWxlcyAtIEEgdHlwZSBtYXBwaW5nIG1vZHVsZSBwYXRocyAobGlrZSBgXCJkaXIvbXlNb2R1bGVcImApIHRvXG4gKiB0aGUgdHlwZXMgb2YgdGhlIG1vZHVsZXMuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCB0eXBlIEFwaUZyb21Nb2R1bGVzPEFsbE1vZHVsZXMgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBvYmplY3Q+PiA9XG4gIEZpbHRlckFwaTxcbiAgICBBcGlGcm9tTW9kdWxlc0FsbG93RW1wdHlOb2RlczxBbGxNb2R1bGVzPixcbiAgICBGdW5jdGlvblJlZmVyZW5jZTxhbnksIGFueSwgYW55LCBhbnk+XG4gID47XG5cbnR5cGUgQXBpRnJvbU1vZHVsZXNBbGxvd0VtcHR5Tm9kZXM8QWxsTW9kdWxlcyBleHRlbmRzIFJlY29yZDxzdHJpbmcsIG9iamVjdD4+ID1cbiAgRXhwYW5kTW9kdWxlc0FuZERpcnM8XG4gICAgVW5pb25Ub0ludGVyc2VjdGlvbjxcbiAgICAgIHtcbiAgICAgICAgW01vZHVsZVBhdGggaW4ga2V5b2YgQWxsTW9kdWxlc106IEFwaUZvck1vZHVsZTxcbiAgICAgICAgICBNb2R1bGVQYXRoICYgc3RyaW5nLFxuICAgICAgICAgIEFsbE1vZHVsZXNbTW9kdWxlUGF0aF1cbiAgICAgICAgPjtcbiAgICAgIH1ba2V5b2YgQWxsTW9kdWxlc11cbiAgICA+XG4gID47XG5cbi8qKlxuICogQHB1YmxpY1xuICpcbiAqIEZpbHRlciBhIENvbnZleCBkZXBsb3ltZW50IGFwaSBvYmplY3QgZm9yIGZ1bmN0aW9ucyB3aGljaCBtZWV0IGNyaXRlcmlhLFxuICogZm9yIGV4YW1wbGUgYWxsIHB1YmxpYyBxdWVyaWVzLlxuICovXG5leHBvcnQgdHlwZSBGaWx0ZXJBcGk8QVBJLCBQcmVkaWNhdGU+ID0gRXhwYW5kPHtcbiAgW21vZCBpbiBrZXlvZiBBUEkgYXMgQVBJW21vZF0gZXh0ZW5kcyBQcmVkaWNhdGVcbiAgICA/IG1vZFxuICAgIDogQVBJW21vZF0gZXh0ZW5kcyBGdW5jdGlvblJlZmVyZW5jZTxhbnksIGFueSwgYW55LCBhbnk+XG4gICAgICA/IG5ldmVyXG4gICAgICA6IEZpbHRlckFwaTxBUElbbW9kXSwgUHJlZGljYXRlPiBleHRlbmRzIFJlY29yZDxzdHJpbmcsIG5ldmVyPlxuICAgICAgICA/IG5ldmVyXG4gICAgICAgIDogbW9kXTogQVBJW21vZF0gZXh0ZW5kcyBQcmVkaWNhdGVcbiAgICA/IEFQSVttb2RdXG4gICAgOiBGaWx0ZXJBcGk8QVBJW21vZF0sIFByZWRpY2F0ZT47XG59PjtcblxuLyoqXG4gKiBHaXZlbiBhbiBhcGkgb2YgdHlwZSBBUEkgYW5kIGEgRnVuY3Rpb25SZWZlcmVuY2Ugc3VidHlwZSwgcmV0dXJuIGFuIGFwaSBvYmplY3RcbiAqIGNvbnRhaW5pbmcgb25seSB0aGUgZnVuY3Rpb24gcmVmZXJlbmNlcyB0aGF0IG1hdGNoLlxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCBxID0gZmlsdGVyQXBpPHR5cGVvZiBhcGksIEZ1bmN0aW9uUmVmZXJlbmNlPFwicXVlcnlcIj4+KGFwaSlcbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlckFwaTxBUEksIFByZWRpY2F0ZT4oYXBpOiBBUEkpOiBGaWx0ZXJBcGk8QVBJLCBQcmVkaWNhdGU+IHtcbiAgcmV0dXJuIGFwaSBhcyBhbnk7XG59XG5cbi8vIFRoZXNlIGp1c3QqIEFQSSBmaWx0ZXIgaGVscGVycyByZXF1aXJlIG5vIHR5cGUgcGFyYW1ldGVycyBzbyBhcmUgdXNlYWJsZSBmcm9tIEphdmFTY3JpcHQuXG4vKiogQHB1YmxpYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGp1c3RJbnRlcm5hbDxBUEk+KFxuICBhcGk6IEFQSSxcbik6IEZpbHRlckFwaTxBUEksIEZ1bmN0aW9uUmVmZXJlbmNlPGFueSwgXCJpbnRlcm5hbFwiLCBhbnksIGFueT4+IHtcbiAgcmV0dXJuIGFwaSBhcyBhbnk7XG59XG5cbi8qKiBAcHVibGljICovXG5leHBvcnQgZnVuY3Rpb24ganVzdFB1YmxpYzxBUEk+KFxuICBhcGk6IEFQSSxcbik6IEZpbHRlckFwaTxBUEksIEZ1bmN0aW9uUmVmZXJlbmNlPGFueSwgXCJwdWJsaWNcIiwgYW55LCBhbnk+PiB7XG4gIHJldHVybiBhcGkgYXMgYW55O1xufVxuXG4vKiogQHB1YmxpYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGp1c3RRdWVyaWVzPEFQST4oXG4gIGFwaTogQVBJLFxuKTogRmlsdGVyQXBpPEFQSSwgRnVuY3Rpb25SZWZlcmVuY2U8XCJxdWVyeVwiLCBhbnksIGFueSwgYW55Pj4ge1xuICByZXR1cm4gYXBpIGFzIGFueTtcbn1cblxuLyoqIEBwdWJsaWMgKi9cbmV4cG9ydCBmdW5jdGlvbiBqdXN0TXV0YXRpb25zPEFQST4oXG4gIGFwaTogQVBJLFxuKTogRmlsdGVyQXBpPEFQSSwgRnVuY3Rpb25SZWZlcmVuY2U8XCJtdXRhdGlvblwiLCBhbnksIGFueSwgYW55Pj4ge1xuICByZXR1cm4gYXBpIGFzIGFueTtcbn1cblxuLyoqIEBwdWJsaWMgKi9cbmV4cG9ydCBmdW5jdGlvbiBqdXN0QWN0aW9uczxBUEk+KFxuICBhcGk6IEFQSSxcbik6IEZpbHRlckFwaTxBUEksIEZ1bmN0aW9uUmVmZXJlbmNlPFwiYWN0aW9uXCIsIGFueSwgYW55LCBhbnk+PiB7XG4gIHJldHVybiBhcGkgYXMgYW55O1xufVxuXG4vKiogQHB1YmxpYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGp1c3RQYWdpbmF0ZWRRdWVyaWVzPEFQST4oXG4gIGFwaTogQVBJLFxuKTogRmlsdGVyQXBpPFxuICBBUEksXG4gIEZ1bmN0aW9uUmVmZXJlbmNlPFxuICAgIFwicXVlcnlcIixcbiAgICBhbnksXG4gICAgeyBwYWdpbmF0aW9uT3B0czogUGFnaW5hdGlvbk9wdGlvbnMgfSxcbiAgICBQYWdpbmF0aW9uUmVzdWx0PGFueT5cbiAgPlxuPiB7XG4gIHJldHVybiBhcGkgYXMgYW55O1xufVxuXG4vKiogQHB1YmxpYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGp1c3RTY2hlZHVsYWJsZTxBUEk+KFxuICBhcGk6IEFQSSxcbik6IEZpbHRlckFwaTxBUEksIEZ1bmN0aW9uUmVmZXJlbmNlPFwibXV0YXRpb25cIiB8IFwiYWN0aW9uXCIsIGFueSwgYW55LCBhbnk+PiB7XG4gIHJldHVybiBhcGkgYXMgYW55O1xufVxuXG4vKipcbiAqIExpa2Uge0BsaW5rIEV4cGFuZH0sIHRoaXMgc2ltcGxpZmllcyBob3cgVHlwZVNjcmlwdCBkaXNwbGF5cyBvYmplY3QgdHlwZXMuXG4gKiBUaGUgZGlmZmVyZW5jZXMgYXJlOlxuICogMS4gVGhpcyB2ZXJzaW9uIGlzIHJlY3Vyc2l2ZS5cbiAqIDIuIFRoaXMgc3RvcHMgcmVjdXJzaW5nIHdoZW4gaXQgaGl0cyBhIHtAbGluayBGdW5jdGlvblJlZmVyZW5jZX0uXG4gKi9cbnR5cGUgRXhwYW5kTW9kdWxlc0FuZERpcnM8T2JqZWN0VHlwZT4gPSBPYmplY3RUeXBlIGV4dGVuZHMgQW55RnVuY3Rpb25SZWZlcmVuY2VcbiAgPyBPYmplY3RUeXBlXG4gIDoge1xuICAgICAgW0tleSBpbiBrZXlvZiBPYmplY3RUeXBlXTogRXhwYW5kTW9kdWxlc0FuZERpcnM8T2JqZWN0VHlwZVtLZXldPjtcbiAgICB9O1xuXG4vKipcbiAqIEEge0BsaW5rIEZ1bmN0aW9uUmVmZXJlbmNlfSBvZiBhbnkgdHlwZSBhbmQgYW55IHZpc2liaWxpdHkgd2l0aCBhbnlcbiAqIGFyZ3VtZW50cyBhbmQgYW55IHJldHVybiB0eXBlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IHR5cGUgQW55RnVuY3Rpb25SZWZlcmVuY2UgPSBGdW5jdGlvblJlZmVyZW5jZTxhbnksIGFueT47XG5cbnR5cGUgQW55TW9kdWxlRGlyT3JGdW5jID0ge1xuICBba2V5OiBzdHJpbmddOiBBbnlNb2R1bGVEaXJPckZ1bmM7XG59ICYgQW55RnVuY3Rpb25SZWZlcmVuY2U7XG5cbi8qKlxuICogVGhlIHR5cGUgdGhhdCBDb252ZXggYXBpIG9iamVjdHMgZXh0ZW5kLiBJZiB5b3Ugd2VyZSB3cml0aW5nIGFuIGFwaSBmcm9tXG4gKiBzY3JhdGNoIGl0IHNob3VsZCBleHRlbmQgdGhpcyB0eXBlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IHR5cGUgQW55QXBpID0gUmVjb3JkPHN0cmluZywgUmVjb3JkPHN0cmluZywgQW55TW9kdWxlRGlyT3JGdW5jPj47XG5cbi8qKlxuICogUmVjdXJzaXZlIHBhcnRpYWwgQVBJLCB1c2VmdWwgZm9yIGRlZmluaW5nIGEgc3Vic2V0IG9mIGFuIEFQSSB3aGVuIG1vY2tpbmdcbiAqIG9yIGJ1aWxkaW5nIGN1c3RvbSBhcGkgb2JqZWN0cy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCB0eXBlIFBhcnRpYWxBcGk8QVBJPiA9IHtcbiAgW21vZCBpbiBrZXlvZiBBUEldPzogQVBJW21vZF0gZXh0ZW5kcyBGdW5jdGlvblJlZmVyZW5jZTxhbnksIGFueSwgYW55LCBhbnk+XG4gICAgPyBBUElbbW9kXVxuICAgIDogUGFydGlhbEFwaTxBUElbbW9kXT47XG59O1xuXG4vKipcbiAqIEEgdXRpbGl0eSBmb3IgY29uc3RydWN0aW5nIHtAbGluayBGdW5jdGlvblJlZmVyZW5jZX1zIGluIHByb2plY3RzIHRoYXRcbiAqIGFyZSBub3QgdXNpbmcgY29kZSBnZW5lcmF0aW9uLlxuICpcbiAqIFlvdSBjYW4gY3JlYXRlIGEgcmVmZXJlbmNlIHRvIGEgZnVuY3Rpb24gbGlrZTpcbiAqIGBgYGpzXG4gKiBjb25zdCByZWZlcmVuY2UgPSBhbnlBcGkubXlNb2R1bGUubXlGdW5jdGlvbjtcbiAqIGBgYFxuICpcbiAqIFRoaXMgc3VwcG9ydHMgYWNjZXNzaW5nIGFueSBwYXRoIHJlZ2FyZGxlc3Mgb2Ygd2hhdCBkaXJlY3RvcmllcyBhbmQgbW9kdWxlc1xuICogYXJlIGluIHlvdXIgcHJvamVjdC4gQWxsIGZ1bmN0aW9uIHJlZmVyZW5jZXMgYXJlIHR5cGVkIGFzXG4gKiB7QGxpbmsgQW55RnVuY3Rpb25SZWZlcmVuY2V9LlxuICpcbiAqXG4gKiBJZiB5b3UncmUgdXNpbmcgY29kZSBnZW5lcmF0aW9uLCB1c2UgYGFwaWAgZnJvbSBgY29udmV4L19nZW5lcmF0ZWQvYXBpYFxuICogaW5zdGVhZC4gSXQgd2lsbCBiZSBtb3JlIHR5cGUtc2FmZSBhbmQgcHJvZHVjZSBiZXR0ZXIgYXV0by1jb21wbGV0ZVxuICogaW4geW91ciBlZGl0b3IuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgYW55QXBpOiBBbnlBcGkgPSBjcmVhdGVBcGkoKSBhcyBhbnk7XG5cbi8qKlxuICogR2l2ZW4gYSB7QGxpbmsgRnVuY3Rpb25SZWZlcmVuY2V9LCBnZXQgdGhlIHJldHVybiB0eXBlIG9mIHRoZSBmdW5jdGlvbi5cbiAqXG4gKiBUaGlzIGlzIHJlcHJlc2VudGVkIGFzIGFuIG9iamVjdCBtYXBwaW5nIGFyZ3VtZW50IG5hbWVzIHRvIHZhbHVlcy5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IHR5cGUgRnVuY3Rpb25BcmdzPEZ1bmNSZWYgZXh0ZW5kcyBBbnlGdW5jdGlvblJlZmVyZW5jZT4gPVxuICBGdW5jUmVmW1wiX2FyZ3NcIl07XG5cbi8qKlxuICogQSB0dXBsZSB0eXBlIG9mIHRoZSAobWF5YmUgb3B0aW9uYWwpIGFyZ3VtZW50cyB0byBgRnVuY1JlZmAuXG4gKlxuICogVGhpcyB0eXBlIGlzIHVzZWQgdG8gbWFrZSBtZXRob2RzIGludm9sdmluZyBhcmd1bWVudHMgdHlwZSBzYWZlIHdoaWxlIGFsbG93aW5nXG4gKiBza2lwcGluZyB0aGUgYXJndW1lbnRzIGZvciBmdW5jdGlvbnMgdGhhdCBkb24ndCByZXF1aXJlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCB0eXBlIE9wdGlvbmFsUmVzdEFyZ3M8RnVuY1JlZiBleHRlbmRzIEFueUZ1bmN0aW9uUmVmZXJlbmNlPiA9XG4gIEZ1bmNSZWZbXCJfYXJnc1wiXSBleHRlbmRzIEVtcHR5T2JqZWN0XG4gICAgPyBbYXJncz86IEVtcHR5T2JqZWN0XVxuICAgIDogW2FyZ3M6IEZ1bmNSZWZbXCJfYXJnc1wiXV07XG5cbi8qKlxuICogQSB0dXBsZSB0eXBlIG9mIHRoZSAobWF5YmUgb3B0aW9uYWwpIGFyZ3VtZW50cyB0byBgRnVuY1JlZmAsIGZvbGxvd2VkIGJ5IGFuIG9wdGlvbnNcbiAqIG9iamVjdCBvZiB0eXBlIGBPcHRpb25zYC5cbiAqXG4gKiBUaGlzIHR5cGUgaXMgdXNlZCB0byBtYWtlIG1ldGhvZHMgbGlrZSBgdXNlUXVlcnlgIHR5cGUtc2FmZSB3aGlsZSBhbGxvd2luZ1xuICogMS4gU2tpcHBpbmcgYXJndW1lbnRzIGZvciBmdW5jdGlvbnMgdGhhdCBkb24ndCByZXF1aXJlIGFyZ3VtZW50cy5cbiAqIDIuIFNraXBwaW5nIHRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IHR5cGUgQXJnc0FuZE9wdGlvbnM8XG4gIEZ1bmNSZWYgZXh0ZW5kcyBBbnlGdW5jdGlvblJlZmVyZW5jZSxcbiAgT3B0aW9ucyxcbj4gPSBGdW5jUmVmW1wiX2FyZ3NcIl0gZXh0ZW5kcyBFbXB0eU9iamVjdFxuICA/IFthcmdzPzogRW1wdHlPYmplY3QsIG9wdGlvbnM/OiBPcHRpb25zXVxuICA6IFthcmdzOiBGdW5jUmVmW1wiX2FyZ3NcIl0sIG9wdGlvbnM/OiBPcHRpb25zXTtcblxuLyoqXG4gKiBHaXZlbiBhIHtAbGluayBGdW5jdGlvblJlZmVyZW5jZX0sIGdldCB0aGUgcmV0dXJuIHR5cGUgb2YgdGhlIGZ1bmN0aW9uLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IHR5cGUgRnVuY3Rpb25SZXR1cm5UeXBlPEZ1bmNSZWYgZXh0ZW5kcyBBbnlGdW5jdGlvblJlZmVyZW5jZT4gPVxuICBGdW5jUmVmW1wiX3JldHVyblR5cGVcIl07XG5cbnR5cGUgVW5kZWZpbmVkVG9OdWxsPFQ+ID0gVCBleHRlbmRzIHZvaWQgPyBudWxsIDogVDtcblxudHlwZSBOdWxsVG9VbmRlZmluZWRPck51bGw8VD4gPSBUIGV4dGVuZHMgbnVsbCA/IFQgfCB1bmRlZmluZWQgfCB2b2lkIDogVDtcblxuLyoqXG4gKiBDb252ZXJ0IHRoZSByZXR1cm4gdHlwZSBvZiBhIGZ1bmN0aW9uIHRvIGl0J3MgY2xpZW50LWZhY2luZyBmb3JtYXQuXG4gKlxuICogVGhpcyBtZWFuczpcbiAqIC0gQ29udmVydGluZyBgdW5kZWZpbmVkYCBhbmQgYHZvaWRgIHRvIGBudWxsYFxuICogLSBSZW1vdmluZyBhbGwgYFByb21pc2VgIHdyYXBwZXJzXG4gKi9cbmV4cG9ydCB0eXBlIENvbnZlcnRSZXR1cm5UeXBlPFQ+ID0gVW5kZWZpbmVkVG9OdWxsPEF3YWl0ZWQ8VD4+O1xuXG5leHBvcnQgdHlwZSBWYWxpZGF0b3JUeXBlVG9SZXR1cm5UeXBlPFQ+ID1cbiAgfCBQcm9taXNlPE51bGxUb1VuZGVmaW5lZE9yTnVsbDxUPj5cbiAgfCBOdWxsVG9VbmRlZmluZWRPck51bGw8VD47XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydCBjb25zdCBmdW5jdGlvbk5hbWUgPSBTeW1ib2wuZm9yKFwiZnVuY3Rpb25OYW1lXCIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnVuY3Rpb25OYW1lLmpzLm1hcFxuIiwiLyoqXG4gKiBBIHN5bWJvbCBmb3IgYWNjZXNzaW5nIHRoZSBuYW1lIG9mIGEge0BsaW5rIEZ1bmN0aW9uUmVmZXJlbmNlfSBhdCBydW50aW1lLlxuICovXG5leHBvcnQgY29uc3QgZnVuY3Rpb25OYW1lID0gU3ltYm9sLmZvcihcImZ1bmN0aW9uTmFtZVwiKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgZnVuY3Rpb25OYW1lIH0gZnJvbSBcIi4uL2Z1bmN0aW9uTmFtZS5qc1wiO1xuZXhwb3J0IGNvbnN0IHRvUmVmZXJlbmNlUGF0aCA9IFN5bWJvbC5mb3IoXCJ0b1JlZmVyZW5jZVBhdGhcIik7XG5leHBvcnQgZnVuY3Rpb24gc2V0UmVmZXJlbmNlUGF0aChvYmosIHZhbHVlKSB7XG4gIG9ialt0b1JlZmVyZW5jZVBhdGhdID0gdmFsdWU7XG59XG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFJlZmVyZW5jZVBhdGgocmVmZXJlbmNlKSB7XG4gIHJldHVybiByZWZlcmVuY2VbdG9SZWZlcmVuY2VQYXRoXSA/PyBudWxsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzRnVuY3Rpb25IYW5kbGUocykge1xuICByZXR1cm4gcy5zdGFydHNXaXRoKFwiZnVuY3Rpb246Ly9cIik7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0RnVuY3Rpb25BZGRyZXNzKGZ1bmN0aW9uUmVmZXJlbmNlKSB7XG4gIGxldCBmdW5jdGlvbkFkZHJlc3M7XG4gIGlmICh0eXBlb2YgZnVuY3Rpb25SZWZlcmVuY2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAoaXNGdW5jdGlvbkhhbmRsZShmdW5jdGlvblJlZmVyZW5jZSkpIHtcbiAgICAgIGZ1bmN0aW9uQWRkcmVzcyA9IHsgZnVuY3Rpb25IYW5kbGU6IGZ1bmN0aW9uUmVmZXJlbmNlIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGZ1bmN0aW9uQWRkcmVzcyA9IHsgbmFtZTogZnVuY3Rpb25SZWZlcmVuY2UgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZnVuY3Rpb25SZWZlcmVuY2VbZnVuY3Rpb25OYW1lXSkge1xuICAgIGZ1bmN0aW9uQWRkcmVzcyA9IHsgbmFtZTogZnVuY3Rpb25SZWZlcmVuY2VbZnVuY3Rpb25OYW1lXSB9O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHJlZmVyZW5jZVBhdGggPSBleHRyYWN0UmVmZXJlbmNlUGF0aChmdW5jdGlvblJlZmVyZW5jZSk7XG4gICAgaWYgKCFyZWZlcmVuY2VQYXRoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZnVuY3Rpb25SZWZlcmVuY2V9IGlzIG5vdCBhIGZ1bmN0aW9uUmVmZXJlbmNlYCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uQWRkcmVzcyA9IHsgcmVmZXJlbmNlOiByZWZlcmVuY2VQYXRoIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uQWRkcmVzcztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdGhzLmpzLm1hcFxuIiwiaW1wb3J0IHsgZnVuY3Rpb25OYW1lIH0gZnJvbSBcIi4uL2Z1bmN0aW9uTmFtZS5qc1wiO1xuXG5leHBvcnQgY29uc3QgdG9SZWZlcmVuY2VQYXRoID0gU3ltYm9sLmZvcihcInRvUmVmZXJlbmNlUGF0aFwiKTtcblxuLy8gTXVsdGlwbGUgaW5zdGFuY2VzIG9mIHRoZSBzYW1lIFN5bWJvbC5mb3IoKSBhcmUgZXF1YWwgYXQgcnVudGltZSBidXQgbm90XG4vLyBhdCB0eXBlLXRpbWUsIHNvIGBbdG9SZWZlcmVuY2VQYXRoXWAgcHJvcGVydGllcyBhcmVuJ3QgdXNlZCBpbiB0eXBlcy5cbi8vIFVzZSB0aGlzIGZ1bmN0aW9uIHRvIHNldCB0aGUgcHJvcGVydHkgaW52aXNpYmx5LlxuZXhwb3J0IGZ1bmN0aW9uIHNldFJlZmVyZW5jZVBhdGg8VD4ob2JqOiBULCB2YWx1ZTogc3RyaW5nKSB7XG4gIChvYmogYXMgYW55KVt0b1JlZmVyZW5jZVBhdGhdID0gdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0UmVmZXJlbmNlUGF0aChyZWZlcmVuY2U6IGFueSk6IHN0cmluZyB8IG51bGwge1xuICByZXR1cm4gcmVmZXJlbmNlW3RvUmVmZXJlbmNlUGF0aF0gPz8gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRnVuY3Rpb25IYW5kbGUoczogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBzLnN0YXJ0c1dpdGgoXCJmdW5jdGlvbjovL1wiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZ1bmN0aW9uQWRkcmVzcyhmdW5jdGlvblJlZmVyZW5jZTogYW55KSB7XG4gIC8vIFRoZSBgcnVuKmAgc3lzY2FsbHMgZXhwZWN0IGVpdGhlciBhIFVERiBwYXRoIGF0IFwibmFtZVwiIG9yIGEgc2VyaWFsaXplZFxuICAvLyByZWZlcmVuY2UgYXQgXCJyZWZlcmVuY2VcIi4gRGlzcGF0Y2ggb24gYGZ1bmN0aW9uUmVmZXJlbmNlYCB0byBjb2VyY2VcbiAgLy8gaXQgdG8gb25lIG9yIHRoZSBvdGhlci5cbiAgbGV0IGZ1bmN0aW9uQWRkcmVzcztcblxuICAvLyBMZWdhY3kgcGF0aCBmb3IgcGFzc2luZyBpbiBVREYgcGF0aHMgZGlyZWN0bHkgYXMgZnVuY3Rpb24gcmVmZXJlbmNlcy5cbiAgaWYgKHR5cGVvZiBmdW5jdGlvblJlZmVyZW5jZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChpc0Z1bmN0aW9uSGFuZGxlKGZ1bmN0aW9uUmVmZXJlbmNlKSkge1xuICAgICAgZnVuY3Rpb25BZGRyZXNzID0geyBmdW5jdGlvbkhhbmRsZTogZnVuY3Rpb25SZWZlcmVuY2UgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnVuY3Rpb25BZGRyZXNzID0geyBuYW1lOiBmdW5jdGlvblJlZmVyZW5jZSB9O1xuICAgIH1cbiAgfVxuICAvLyBQYXRoIGZvciBwYXNzaW5nIGluIGEgYEZ1bmN0aW9uUmVmZXJlbmNlYCwgZWl0aGVyIGZyb20gYGFwaWAgb3IgZGlyZWN0bHlcbiAgLy8gY3JlYXRlZCBmcm9tIGEgVURGIHBhdGggd2l0aCBgbWFrZUZ1bmN0aW9uUmVmZXJlbmNlYC5cbiAgZWxzZSBpZiAoZnVuY3Rpb25SZWZlcmVuY2VbZnVuY3Rpb25OYW1lXSkge1xuICAgIGZ1bmN0aW9uQWRkcmVzcyA9IHsgbmFtZTogZnVuY3Rpb25SZWZlcmVuY2VbZnVuY3Rpb25OYW1lXSB9O1xuICB9XG4gIC8vIFJlZmVyZW5jZSB0byBhIGNvbXBvbmVudCdzIGZ1bmN0aW9uIGRlcml2ZWQgZnJvbSBgYXBwYCBvciBgY29tcG9uZW50YC5cbiAgZWxzZSB7XG4gICAgY29uc3QgcmVmZXJlbmNlUGF0aCA9IGV4dHJhY3RSZWZlcmVuY2VQYXRoKGZ1bmN0aW9uUmVmZXJlbmNlKTtcbiAgICBpZiAoIXJlZmVyZW5jZVBhdGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtmdW5jdGlvblJlZmVyZW5jZX0gaXMgbm90IGEgZnVuY3Rpb25SZWZlcmVuY2VgKTtcbiAgICB9XG4gICAgZnVuY3Rpb25BZGRyZXNzID0geyByZWZlcmVuY2U6IHJlZmVyZW5jZVBhdGggfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb25BZGRyZXNzO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuaW1wb3J0IHsganNvblRvQ29udmV4IH0gZnJvbSBcIi4uLy4uL3ZhbHVlcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgTG9uZyB9IGZyb20gXCIuLi8uLi92ZW5kb3IvbG9uZy5qc1wiO1xuaW1wb3J0IHsgbG9nRm9yRnVuY3Rpb24gfSBmcm9tIFwiLi4vbG9nZ2luZy5qc1wiO1xuZXhwb3J0IGNsYXNzIFJlbW90ZVF1ZXJ5U2V0IHtcbiAgY29uc3RydWN0b3IocXVlcnlQYXRoLCBsb2dnZXIpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidmVyc2lvblwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVtb3RlUXVlcnlTZXRcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInF1ZXJ5UGF0aFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibG9nZ2VyXCIpO1xuICAgIHRoaXMudmVyc2lvbiA9IHsgcXVlcnlTZXQ6IDAsIHRzOiBMb25nLmZyb21OdW1iZXIoMCksIGlkZW50aXR5OiAwIH07XG4gICAgdGhpcy5yZW1vdGVRdWVyeVNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5xdWVyeVBhdGggPSBxdWVyeVBhdGg7XG4gICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gIH1cbiAgdHJhbnNpdGlvbih0cmFuc2l0aW9uKSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0cmFuc2l0aW9uLnN0YXJ0VmVyc2lvbjtcbiAgICBpZiAodGhpcy52ZXJzaW9uLnF1ZXJ5U2V0ICE9PSBzdGFydC5xdWVyeVNldCB8fCB0aGlzLnZlcnNpb24udHMubm90RXF1YWxzKHN0YXJ0LnRzKSB8fCB0aGlzLnZlcnNpb24uaWRlbnRpdHkgIT09IHN0YXJ0LmlkZW50aXR5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIHN0YXJ0IHZlcnNpb246ICR7c3RhcnQudHMudG9TdHJpbmcoKX06JHtzdGFydC5xdWVyeVNldH06JHtzdGFydC5pZGVudGl0eX0sIHRyYW5zaXRpb25pbmcgZnJvbSAke3RoaXMudmVyc2lvbi50cy50b1N0cmluZygpfToke3RoaXMudmVyc2lvbi5xdWVyeVNldH06JHt0aGlzLnZlcnNpb24uaWRlbnRpdHl9YFxuICAgICAgKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBtb2RpZmljYXRpb24gb2YgdHJhbnNpdGlvbi5tb2RpZmljYXRpb25zKSB7XG4gICAgICBzd2l0Y2ggKG1vZGlmaWNhdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJRdWVyeVVwZGF0ZWRcIjoge1xuICAgICAgICAgIGNvbnN0IHF1ZXJ5UGF0aCA9IHRoaXMucXVlcnlQYXRoKG1vZGlmaWNhdGlvbi5xdWVyeUlkKTtcbiAgICAgICAgICBpZiAocXVlcnlQYXRoKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbW9kaWZpY2F0aW9uLmxvZ0xpbmVzKSB7XG4gICAgICAgICAgICAgIGxvZ0ZvckZ1bmN0aW9uKHRoaXMubG9nZ2VyLCBcImluZm9cIiwgXCJxdWVyeVwiLCBxdWVyeVBhdGgsIGxpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGpzb25Ub0NvbnZleChtb2RpZmljYXRpb24udmFsdWUgPz8gbnVsbCk7XG4gICAgICAgICAgdGhpcy5yZW1vdGVRdWVyeVNldC5zZXQobW9kaWZpY2F0aW9uLnF1ZXJ5SWQsIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGxvZ0xpbmVzOiBtb2RpZmljYXRpb24ubG9nTGluZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiUXVlcnlGYWlsZWRcIjoge1xuICAgICAgICAgIGNvbnN0IHF1ZXJ5UGF0aCA9IHRoaXMucXVlcnlQYXRoKG1vZGlmaWNhdGlvbi5xdWVyeUlkKTtcbiAgICAgICAgICBpZiAocXVlcnlQYXRoKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbW9kaWZpY2F0aW9uLmxvZ0xpbmVzKSB7XG4gICAgICAgICAgICAgIGxvZ0ZvckZ1bmN0aW9uKHRoaXMubG9nZ2VyLCBcImluZm9cIiwgXCJxdWVyeVwiLCBxdWVyeVBhdGgsIGxpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB7IGVycm9yRGF0YSB9ID0gbW9kaWZpY2F0aW9uO1xuICAgICAgICAgIHRoaXMucmVtb3RlUXVlcnlTZXQuc2V0KG1vZGlmaWNhdGlvbi5xdWVyeUlkLCB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZTogbW9kaWZpY2F0aW9uLmVycm9yTWVzc2FnZSxcbiAgICAgICAgICAgIGVycm9yRGF0YTogZXJyb3JEYXRhICE9PSB2b2lkIDAgPyBqc29uVG9Db252ZXgoZXJyb3JEYXRhKSA6IHZvaWQgMCxcbiAgICAgICAgICAgIGxvZ0xpbmVzOiBtb2RpZmljYXRpb24ubG9nTGluZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiUXVlcnlSZW1vdmVkXCI6IHtcbiAgICAgICAgICB0aGlzLnJlbW90ZVF1ZXJ5U2V0LmRlbGV0ZShtb2RpZmljYXRpb24ucXVlcnlJZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIG1vZGlmaWNhdGlvbjtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbW9kaWZpY2F0aW9uICR7bW9kaWZpY2F0aW9uLnR5cGV9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy52ZXJzaW9uID0gdHJhbnNpdGlvbi5lbmRWZXJzaW9uO1xuICB9XG4gIHJlbW90ZVF1ZXJ5UmVzdWx0cygpIHtcbiAgICByZXR1cm4gdGhpcy5yZW1vdGVRdWVyeVNldDtcbiAgfVxuICB0aW1lc3RhbXAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmVyc2lvbi50cztcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVtb3RlX3F1ZXJ5X3NldC5qcy5tYXBcbiIsImltcG9ydCB7IGpzb25Ub0NvbnZleCB9IGZyb20gXCIuLi8uLi92YWx1ZXMvaW5kZXguanNcIjtcbmltcG9ydCB7IExvbmcgfSBmcm9tIFwiLi4vLi4vdmVuZG9yL2xvbmcuanNcIjtcbmltcG9ydCB7IGxvZ0ZvckZ1bmN0aW9uLCBMb2dnZXIgfSBmcm9tIFwiLi4vbG9nZ2luZy5qc1wiO1xuaW1wb3J0IHsgUXVlcnlJZCwgU3RhdGVWZXJzaW9uLCBUcmFuc2l0aW9uIH0gZnJvbSBcIi4vcHJvdG9jb2wuanNcIjtcbmltcG9ydCB7IEZ1bmN0aW9uUmVzdWx0IH0gZnJvbSBcIi4vZnVuY3Rpb25fcmVzdWx0LmpzXCI7XG5cbi8qKlxuICogQSByZXByZXNlbnRpb24gb2YgdGhlIHF1ZXJ5IHJlc3VsdHMgd2UndmUgcmVjZWl2ZWQgb24gdGhlIGN1cnJlbnQgV2ViU29ja2V0XG4gKiBjb25uZWN0aW9uLlxuICpcbiAqIFF1ZXJpZXMgeW91IHdvbid0IGZpbmQgaGVyZSBpbmNsdWRlOlxuICogLSBxdWVyaWVzIHdoaWNoIGhhdmUgYmVlbiByZXF1ZXN0ZWQsIGJ1dCBubyBxdWVyeSB0cmFuc2l0aW9uIGhhcyBiZWVuIHJlY2VpdmVkIHlldCBmb3JcbiAqIC0gcXVlcmllcyB3aGljaCBhcmUgcG9wdWxhdGVkIG9ubHkgdGhvdWdoIGFjdGl2ZSBvcHRpbWlzdGljIHVwZGF0ZXMsIGJ1dCBhcmUgbm90IHN1YnNjcmliZWQgdG9cbiAqIC0gcXVlcmllcyB3aGljaCBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkIGJ5IHRoZSBzZXJ2ZXIgKHdoaWNoIGl0IHNob3VsZG4ndCBkbyB1bmxlc3MgdGhhdCdzXG4gKiAgIGJlZW4gcmVxdWVzdGVkIGJ5IHRoZSBjbGllbnQpXG4gKi9cbmV4cG9ydCBjbGFzcyBSZW1vdGVRdWVyeVNldCB7XG4gIHByaXZhdGUgdmVyc2lvbjogU3RhdGVWZXJzaW9uO1xuICBwcml2YXRlIHJlYWRvbmx5IHJlbW90ZVF1ZXJ5U2V0OiBNYXA8UXVlcnlJZCwgRnVuY3Rpb25SZXN1bHQ+O1xuICBwcml2YXRlIHJlYWRvbmx5IHF1ZXJ5UGF0aDogKHF1ZXJ5SWQ6IFF1ZXJ5SWQpID0+IHN0cmluZyB8IG51bGw7XG4gIHByaXZhdGUgcmVhZG9ubHkgbG9nZ2VyOiBMb2dnZXI7XG5cbiAgY29uc3RydWN0b3IocXVlcnlQYXRoOiAocXVlcnlJZDogUXVlcnlJZCkgPT4gc3RyaW5nIHwgbnVsbCwgbG9nZ2VyOiBMb2dnZXIpIHtcbiAgICB0aGlzLnZlcnNpb24gPSB7IHF1ZXJ5U2V0OiAwLCB0czogTG9uZy5mcm9tTnVtYmVyKDApLCBpZGVudGl0eTogMCB9O1xuICAgIHRoaXMucmVtb3RlUXVlcnlTZXQgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5xdWVyeVBhdGggPSBxdWVyeVBhdGg7XG4gICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gIH1cblxuICB0cmFuc2l0aW9uKHRyYW5zaXRpb246IFRyYW5zaXRpb24pOiB2b2lkIHtcbiAgICBjb25zdCBzdGFydCA9IHRyYW5zaXRpb24uc3RhcnRWZXJzaW9uO1xuICAgIGlmIChcbiAgICAgIHRoaXMudmVyc2lvbi5xdWVyeVNldCAhPT0gc3RhcnQucXVlcnlTZXQgfHxcbiAgICAgIHRoaXMudmVyc2lvbi50cy5ub3RFcXVhbHMoc3RhcnQudHMpIHx8XG4gICAgICB0aGlzLnZlcnNpb24uaWRlbnRpdHkgIT09IHN0YXJ0LmlkZW50aXR5XG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIHN0YXJ0IHZlcnNpb246ICR7c3RhcnQudHMudG9TdHJpbmcoKX06JHtzdGFydC5xdWVyeVNldH06JHtzdGFydC5pZGVudGl0eX0sIHRyYW5zaXRpb25pbmcgZnJvbSAke3RoaXMudmVyc2lvbi50cy50b1N0cmluZygpfToke3RoaXMudmVyc2lvbi5xdWVyeVNldH06JHt0aGlzLnZlcnNpb24uaWRlbnRpdHl9YCxcbiAgICAgICk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgbW9kaWZpY2F0aW9uIG9mIHRyYW5zaXRpb24ubW9kaWZpY2F0aW9ucykge1xuICAgICAgc3dpdGNoIChtb2RpZmljYXRpb24udHlwZSkge1xuICAgICAgICBjYXNlIFwiUXVlcnlVcGRhdGVkXCI6IHtcbiAgICAgICAgICBjb25zdCBxdWVyeVBhdGggPSB0aGlzLnF1ZXJ5UGF0aChtb2RpZmljYXRpb24ucXVlcnlJZCk7XG4gICAgICAgICAgaWYgKHF1ZXJ5UGF0aCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIG1vZGlmaWNhdGlvbi5sb2dMaW5lcykge1xuICAgICAgICAgICAgICBsb2dGb3JGdW5jdGlvbih0aGlzLmxvZ2dlciwgXCJpbmZvXCIsIFwicXVlcnlcIiwgcXVlcnlQYXRoLCBsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBqc29uVG9Db252ZXgobW9kaWZpY2F0aW9uLnZhbHVlID8/IG51bGwpO1xuICAgICAgICAgIHRoaXMucmVtb3RlUXVlcnlTZXQuc2V0KG1vZGlmaWNhdGlvbi5xdWVyeUlkLCB7XG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBsb2dMaW5lczogbW9kaWZpY2F0aW9uLmxvZ0xpbmVzLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJRdWVyeUZhaWxlZFwiOiB7XG4gICAgICAgICAgY29uc3QgcXVlcnlQYXRoID0gdGhpcy5xdWVyeVBhdGgobW9kaWZpY2F0aW9uLnF1ZXJ5SWQpO1xuICAgICAgICAgIGlmIChxdWVyeVBhdGgpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBtb2RpZmljYXRpb24ubG9nTGluZXMpIHtcbiAgICAgICAgICAgICAgbG9nRm9yRnVuY3Rpb24odGhpcy5sb2dnZXIsIFwiaW5mb1wiLCBcInF1ZXJ5XCIsIHF1ZXJ5UGF0aCwgbGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHsgZXJyb3JEYXRhIH0gPSBtb2RpZmljYXRpb247XG4gICAgICAgICAgdGhpcy5yZW1vdGVRdWVyeVNldC5zZXQobW9kaWZpY2F0aW9uLnF1ZXJ5SWQsIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlOiBtb2RpZmljYXRpb24uZXJyb3JNZXNzYWdlLFxuICAgICAgICAgICAgZXJyb3JEYXRhOlxuICAgICAgICAgICAgICBlcnJvckRhdGEgIT09IHVuZGVmaW5lZCA/IGpzb25Ub0NvbnZleChlcnJvckRhdGEpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbG9nTGluZXM6IG1vZGlmaWNhdGlvbi5sb2dMaW5lcyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiUXVlcnlSZW1vdmVkXCI6IHtcbiAgICAgICAgICB0aGlzLnJlbW90ZVF1ZXJ5U2V0LmRlbGV0ZShtb2RpZmljYXRpb24ucXVlcnlJZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIC8vIEVuZm9yY2UgdGhhdCB0aGUgc3dpdGNoLWNhc2UgaXMgZXhoYXVzdGl2ZS5cbiAgICAgICAgICBtb2RpZmljYXRpb24gc2F0aXNmaWVzIG5ldmVyO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBtb2RpZmljYXRpb24gJHsobW9kaWZpY2F0aW9uIGFzIGFueSkudHlwZX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnZlcnNpb24gPSB0cmFuc2l0aW9uLmVuZFZlcnNpb247XG4gIH1cblxuICByZW1vdGVRdWVyeVJlc3VsdHMoKTogTWFwPFF1ZXJ5SWQsIEZ1bmN0aW9uUmVzdWx0PiB7XG4gICAgcmV0dXJuIHRoaXMucmVtb3RlUXVlcnlTZXQ7XG4gIH1cblxuICB0aW1lc3RhbXAoKTogTG9uZyB7XG4gICAgcmV0dXJuIHRoaXMudmVyc2lvbi50cztcbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuZXhwb3J0IGNsYXNzIExvbmcge1xuICBjb25zdHJ1Y3Rvcihsb3csIGhpZ2gpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibG93XCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJoaWdoXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfX2lzVW5zaWduZWRMb25nX19cIik7XG4gICAgdGhpcy5sb3cgPSBsb3cgfCAwO1xuICAgIHRoaXMuaGlnaCA9IGhpZ2ggfCAwO1xuICAgIHRoaXMuX19pc1Vuc2lnbmVkTG9uZ19fID0gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgaXNMb25nKG9iaikge1xuICAgIHJldHVybiAob2JqICYmIG9iai5fX2lzVW5zaWduZWRMb25nX18pID09PSB0cnVlO1xuICB9XG4gIC8vIHByZXR0aWVyLWlnbm9yZVxuICBzdGF0aWMgZnJvbUJ5dGVzTEUoYnl0ZXMpIHtcbiAgICByZXR1cm4gbmV3IExvbmcoXG4gICAgICBieXRlc1swXSB8IGJ5dGVzWzFdIDw8IDggfCBieXRlc1syXSA8PCAxNiB8IGJ5dGVzWzNdIDw8IDI0LFxuICAgICAgYnl0ZXNbNF0gfCBieXRlc1s1XSA8PCA4IHwgYnl0ZXNbNl0gPDwgMTYgfCBieXRlc1s3XSA8PCAyNFxuICAgICk7XG4gIH1cbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIHRvQnl0ZXNMRSgpIHtcbiAgICBjb25zdCBoaSA9IHRoaXMuaGlnaDtcbiAgICBjb25zdCBsbyA9IHRoaXMubG93O1xuICAgIHJldHVybiBbXG4gICAgICBsbyAmIDI1NSxcbiAgICAgIGxvID4+PiA4ICYgMjU1LFxuICAgICAgbG8gPj4+IDE2ICYgMjU1LFxuICAgICAgbG8gPj4+IDI0LFxuICAgICAgaGkgJiAyNTUsXG4gICAgICBoaSA+Pj4gOCAmIDI1NSxcbiAgICAgIGhpID4+PiAxNiAmIDI1NSxcbiAgICAgIGhpID4+PiAyNFxuICAgIF07XG4gIH1cbiAgc3RhdGljIGZyb21OdW1iZXIodmFsdWUpIHtcbiAgICBpZiAoaXNOYU4odmFsdWUpKSByZXR1cm4gVVpFUk87XG4gICAgaWYgKHZhbHVlIDwgMCkgcmV0dXJuIFVaRVJPO1xuICAgIGlmICh2YWx1ZSA+PSBUV09fUFdSXzY0X0RCTCkgcmV0dXJuIE1BWF9VTlNJR05FRF9WQUxVRTtcbiAgICByZXR1cm4gbmV3IExvbmcodmFsdWUgJSBUV09fUFdSXzMyX0RCTCB8IDAsIHZhbHVlIC8gVFdPX1BXUl8zMl9EQkwgfCAwKTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gKEJpZ0ludCh0aGlzLmhpZ2gpICogQmlnSW50KFRXT19QV1JfMzJfREJMKSArIEJpZ0ludCh0aGlzLmxvdykpLnRvU3RyaW5nKCk7XG4gIH1cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgaWYgKCFMb25nLmlzTG9uZyhvdGhlcikpIG90aGVyID0gTG9uZy5mcm9tVmFsdWUob3RoZXIpO1xuICAgIGlmICh0aGlzLmhpZ2ggPj4+IDMxID09PSAxICYmIG90aGVyLmhpZ2ggPj4+IDMxID09PSAxKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMuaGlnaCA9PT0gb3RoZXIuaGlnaCAmJiB0aGlzLmxvdyA9PT0gb3RoZXIubG93O1xuICB9XG4gIG5vdEVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiAhdGhpcy5lcXVhbHMob3RoZXIpO1xuICB9XG4gIGNvbXAob3RoZXIpIHtcbiAgICBpZiAoIUxvbmcuaXNMb25nKG90aGVyKSkgb3RoZXIgPSBMb25nLmZyb21WYWx1ZShvdGhlcik7XG4gICAgaWYgKHRoaXMuZXF1YWxzKG90aGVyKSkgcmV0dXJuIDA7XG4gICAgcmV0dXJuIG90aGVyLmhpZ2ggPj4+IDAgPiB0aGlzLmhpZ2ggPj4+IDAgfHwgb3RoZXIuaGlnaCA9PT0gdGhpcy5oaWdoICYmIG90aGVyLmxvdyA+Pj4gMCA+IHRoaXMubG93ID4+PiAwID8gLTEgOiAxO1xuICB9XG4gIGxlc3NUaGFuT3JFcXVhbChvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmNvbXAoXG4gICAgICAvKiB2YWxpZGF0ZXMgKi9cbiAgICAgIG90aGVyXG4gICAgKSA8PSAwO1xuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWUodmFsKSB7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIpIHJldHVybiBMb25nLmZyb21OdW1iZXIodmFsKTtcbiAgICByZXR1cm4gbmV3IExvbmcodmFsLmxvdywgdmFsLmhpZ2gpO1xuICB9XG59XG5jb25zdCBVWkVSTyA9IG5ldyBMb25nKDAsIDApO1xuY29uc3QgVFdPX1BXUl8xNl9EQkwgPSAxIDw8IDE2O1xuY29uc3QgVFdPX1BXUl8zMl9EQkwgPSBUV09fUFdSXzE2X0RCTCAqIFRXT19QV1JfMTZfREJMO1xuY29uc3QgVFdPX1BXUl82NF9EQkwgPSBUV09fUFdSXzMyX0RCTCAqIFRXT19QV1JfMzJfREJMO1xuY29uc3QgTUFYX1VOU0lHTkVEX1ZBTFVFID0gbmV3IExvbmcoNDI5NDk2NzI5NSB8IDAsIDQyOTQ5NjcyOTUgfCAwKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvbmcuanMubWFwXG4iLCIvLyBJbXBsZW1lbnRzIGFuIHVuc2lnbmVkIGxvbmcuXG4vLyBUaGlzIGlzIGEgc3Vic2V0IG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9kY29kZUlPL0xvbmcuanMsXG4vLyB2ZW5kb3JlZCB0byBkZWNyZWFzZSBidW5kbGUgc2l6ZS5cbi8vIENvcHlyaWdodCBEYW5pZWwgV2lydHogPGRjb2RlQGRjb2RlLmlvPlxuLy8gTGljZW5zZTogQXBhY2hlIFZlcnNpb24gMi4wXG4vKlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcGFjaGUgTGljZW5zZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgVmVyc2lvbiAyLjAsIEphbnVhcnkgMjAwNFxuICAgICAgICAgICAgICAgICAgICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL1xuXG4gICBURVJNUyBBTkQgQ09ORElUSU9OUyBGT1IgVVNFLCBSRVBST0RVQ1RJT04sIEFORCBESVNUUklCVVRJT05cblxuICAgMS4gRGVmaW5pdGlvbnMuXG5cbiAgICAgIFwiTGljZW5zZVwiIHNoYWxsIG1lYW4gdGhlIHRlcm1zIGFuZCBjb25kaXRpb25zIGZvciB1c2UsIHJlcHJvZHVjdGlvbixcbiAgICAgIGFuZCBkaXN0cmlidXRpb24gYXMgZGVmaW5lZCBieSBTZWN0aW9ucyAxIHRocm91Z2ggOSBvZiB0aGlzIGRvY3VtZW50LlxuXG4gICAgICBcIkxpY2Vuc29yXCIgc2hhbGwgbWVhbiB0aGUgY29weXJpZ2h0IG93bmVyIG9yIGVudGl0eSBhdXRob3JpemVkIGJ5XG4gICAgICB0aGUgY29weXJpZ2h0IG93bmVyIHRoYXQgaXMgZ3JhbnRpbmcgdGhlIExpY2Vuc2UuXG5cbiAgICAgIFwiTGVnYWwgRW50aXR5XCIgc2hhbGwgbWVhbiB0aGUgdW5pb24gb2YgdGhlIGFjdGluZyBlbnRpdHkgYW5kIGFsbFxuICAgICAgb3RoZXIgZW50aXRpZXMgdGhhdCBjb250cm9sLCBhcmUgY29udHJvbGxlZCBieSwgb3IgYXJlIHVuZGVyIGNvbW1vblxuICAgICAgY29udHJvbCB3aXRoIHRoYXQgZW50aXR5LiBGb3IgdGhlIHB1cnBvc2VzIG9mIHRoaXMgZGVmaW5pdGlvbixcbiAgICAgIFwiY29udHJvbFwiIG1lYW5zIChpKSB0aGUgcG93ZXIsIGRpcmVjdCBvciBpbmRpcmVjdCwgdG8gY2F1c2UgdGhlXG4gICAgICBkaXJlY3Rpb24gb3IgbWFuYWdlbWVudCBvZiBzdWNoIGVudGl0eSwgd2hldGhlciBieSBjb250cmFjdCBvclxuICAgICAgb3RoZXJ3aXNlLCBvciAoaWkpIG93bmVyc2hpcCBvZiBmaWZ0eSBwZXJjZW50ICg1MCUpIG9yIG1vcmUgb2YgdGhlXG4gICAgICBvdXRzdGFuZGluZyBzaGFyZXMsIG9yIChpaWkpIGJlbmVmaWNpYWwgb3duZXJzaGlwIG9mIHN1Y2ggZW50aXR5LlxuXG4gICAgICBcIllvdVwiIChvciBcIllvdXJcIikgc2hhbGwgbWVhbiBhbiBpbmRpdmlkdWFsIG9yIExlZ2FsIEVudGl0eVxuICAgICAgZXhlcmNpc2luZyBwZXJtaXNzaW9ucyBncmFudGVkIGJ5IHRoaXMgTGljZW5zZS5cblxuICAgICAgXCJTb3VyY2VcIiBmb3JtIHNoYWxsIG1lYW4gdGhlIHByZWZlcnJlZCBmb3JtIGZvciBtYWtpbmcgbW9kaWZpY2F0aW9ucyxcbiAgICAgIGluY2x1ZGluZyBidXQgbm90IGxpbWl0ZWQgdG8gc29mdHdhcmUgc291cmNlIGNvZGUsIGRvY3VtZW50YXRpb25cbiAgICAgIHNvdXJjZSwgYW5kIGNvbmZpZ3VyYXRpb24gZmlsZXMuXG5cbiAgICAgIFwiT2JqZWN0XCIgZm9ybSBzaGFsbCBtZWFuIGFueSBmb3JtIHJlc3VsdGluZyBmcm9tIG1lY2hhbmljYWxcbiAgICAgIHRyYW5zZm9ybWF0aW9uIG9yIHRyYW5zbGF0aW9uIG9mIGEgU291cmNlIGZvcm0sIGluY2x1ZGluZyBidXRcbiAgICAgIG5vdCBsaW1pdGVkIHRvIGNvbXBpbGVkIG9iamVjdCBjb2RlLCBnZW5lcmF0ZWQgZG9jdW1lbnRhdGlvbixcbiAgICAgIGFuZCBjb252ZXJzaW9ucyB0byBvdGhlciBtZWRpYSB0eXBlcy5cblxuICAgICAgXCJXb3JrXCIgc2hhbGwgbWVhbiB0aGUgd29yayBvZiBhdXRob3JzaGlwLCB3aGV0aGVyIGluIFNvdXJjZSBvclxuICAgICAgT2JqZWN0IGZvcm0sIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZSBMaWNlbnNlLCBhcyBpbmRpY2F0ZWQgYnkgYVxuICAgICAgY29weXJpZ2h0IG5vdGljZSB0aGF0IGlzIGluY2x1ZGVkIGluIG9yIGF0dGFjaGVkIHRvIHRoZSB3b3JrXG4gICAgICAoYW4gZXhhbXBsZSBpcyBwcm92aWRlZCBpbiB0aGUgQXBwZW5kaXggYmVsb3cpLlxuXG4gICAgICBcIkRlcml2YXRpdmUgV29ya3NcIiBzaGFsbCBtZWFuIGFueSB3b3JrLCB3aGV0aGVyIGluIFNvdXJjZSBvciBPYmplY3RcbiAgICAgIGZvcm0sIHRoYXQgaXMgYmFzZWQgb24gKG9yIGRlcml2ZWQgZnJvbSkgdGhlIFdvcmsgYW5kIGZvciB3aGljaCB0aGVcbiAgICAgIGVkaXRvcmlhbCByZXZpc2lvbnMsIGFubm90YXRpb25zLCBlbGFib3JhdGlvbnMsIG9yIG90aGVyIG1vZGlmaWNhdGlvbnNcbiAgICAgIHJlcHJlc2VudCwgYXMgYSB3aG9sZSwgYW4gb3JpZ2luYWwgd29yayBvZiBhdXRob3JzaGlwLiBGb3IgdGhlIHB1cnBvc2VzXG4gICAgICBvZiB0aGlzIExpY2Vuc2UsIERlcml2YXRpdmUgV29ya3Mgc2hhbGwgbm90IGluY2x1ZGUgd29ya3MgdGhhdCByZW1haW5cbiAgICAgIHNlcGFyYWJsZSBmcm9tLCBvciBtZXJlbHkgbGluayAob3IgYmluZCBieSBuYW1lKSB0byB0aGUgaW50ZXJmYWNlcyBvZixcbiAgICAgIHRoZSBXb3JrIGFuZCBEZXJpdmF0aXZlIFdvcmtzIHRoZXJlb2YuXG5cbiAgICAgIFwiQ29udHJpYnV0aW9uXCIgc2hhbGwgbWVhbiBhbnkgd29yayBvZiBhdXRob3JzaGlwLCBpbmNsdWRpbmdcbiAgICAgIHRoZSBvcmlnaW5hbCB2ZXJzaW9uIG9mIHRoZSBXb3JrIGFuZCBhbnkgbW9kaWZpY2F0aW9ucyBvciBhZGRpdGlvbnNcbiAgICAgIHRvIHRoYXQgV29yayBvciBEZXJpdmF0aXZlIFdvcmtzIHRoZXJlb2YsIHRoYXQgaXMgaW50ZW50aW9uYWxseVxuICAgICAgc3VibWl0dGVkIHRvIExpY2Vuc29yIGZvciBpbmNsdXNpb24gaW4gdGhlIFdvcmsgYnkgdGhlIGNvcHlyaWdodCBvd25lclxuICAgICAgb3IgYnkgYW4gaW5kaXZpZHVhbCBvciBMZWdhbCBFbnRpdHkgYXV0aG9yaXplZCB0byBzdWJtaXQgb24gYmVoYWxmIG9mXG4gICAgICB0aGUgY29weXJpZ2h0IG93bmVyLiBGb3IgdGhlIHB1cnBvc2VzIG9mIHRoaXMgZGVmaW5pdGlvbiwgXCJzdWJtaXR0ZWRcIlxuICAgICAgbWVhbnMgYW55IGZvcm0gb2YgZWxlY3Ryb25pYywgdmVyYmFsLCBvciB3cml0dGVuIGNvbW11bmljYXRpb24gc2VudFxuICAgICAgdG8gdGhlIExpY2Vuc29yIG9yIGl0cyByZXByZXNlbnRhdGl2ZXMsIGluY2x1ZGluZyBidXQgbm90IGxpbWl0ZWQgdG9cbiAgICAgIGNvbW11bmljYXRpb24gb24gZWxlY3Ryb25pYyBtYWlsaW5nIGxpc3RzLCBzb3VyY2UgY29kZSBjb250cm9sIHN5c3RlbXMsXG4gICAgICBhbmQgaXNzdWUgdHJhY2tpbmcgc3lzdGVtcyB0aGF0IGFyZSBtYW5hZ2VkIGJ5LCBvciBvbiBiZWhhbGYgb2YsIHRoZVxuICAgICAgTGljZW5zb3IgZm9yIHRoZSBwdXJwb3NlIG9mIGRpc2N1c3NpbmcgYW5kIGltcHJvdmluZyB0aGUgV29yaywgYnV0XG4gICAgICBleGNsdWRpbmcgY29tbXVuaWNhdGlvbiB0aGF0IGlzIGNvbnNwaWN1b3VzbHkgbWFya2VkIG9yIG90aGVyd2lzZVxuICAgICAgZGVzaWduYXRlZCBpbiB3cml0aW5nIGJ5IHRoZSBjb3B5cmlnaHQgb3duZXIgYXMgXCJOb3QgYSBDb250cmlidXRpb24uXCJcblxuICAgICAgXCJDb250cmlidXRvclwiIHNoYWxsIG1lYW4gTGljZW5zb3IgYW5kIGFueSBpbmRpdmlkdWFsIG9yIExlZ2FsIEVudGl0eVxuICAgICAgb24gYmVoYWxmIG9mIHdob20gYSBDb250cmlidXRpb24gaGFzIGJlZW4gcmVjZWl2ZWQgYnkgTGljZW5zb3IgYW5kXG4gICAgICBzdWJzZXF1ZW50bHkgaW5jb3Jwb3JhdGVkIHdpdGhpbiB0aGUgV29yay5cblxuICAgMi4gR3JhbnQgb2YgQ29weXJpZ2h0IExpY2Vuc2UuIFN1YmplY3QgdG8gdGhlIHRlcm1zIGFuZCBjb25kaXRpb25zIG9mXG4gICAgICB0aGlzIExpY2Vuc2UsIGVhY2ggQ29udHJpYnV0b3IgaGVyZWJ5IGdyYW50cyB0byBZb3UgYSBwZXJwZXR1YWwsXG4gICAgICB3b3JsZHdpZGUsIG5vbi1leGNsdXNpdmUsIG5vLWNoYXJnZSwgcm95YWx0eS1mcmVlLCBpcnJldm9jYWJsZVxuICAgICAgY29weXJpZ2h0IGxpY2Vuc2UgdG8gcmVwcm9kdWNlLCBwcmVwYXJlIERlcml2YXRpdmUgV29ya3Mgb2YsXG4gICAgICBwdWJsaWNseSBkaXNwbGF5LCBwdWJsaWNseSBwZXJmb3JtLCBzdWJsaWNlbnNlLCBhbmQgZGlzdHJpYnV0ZSB0aGVcbiAgICAgIFdvcmsgYW5kIHN1Y2ggRGVyaXZhdGl2ZSBXb3JrcyBpbiBTb3VyY2Ugb3IgT2JqZWN0IGZvcm0uXG5cbiAgIDMuIEdyYW50IG9mIFBhdGVudCBMaWNlbnNlLiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhbmQgY29uZGl0aW9ucyBvZlxuICAgICAgdGhpcyBMaWNlbnNlLCBlYWNoIENvbnRyaWJ1dG9yIGhlcmVieSBncmFudHMgdG8gWW91IGEgcGVycGV0dWFsLFxuICAgICAgd29ybGR3aWRlLCBub24tZXhjbHVzaXZlLCBuby1jaGFyZ2UsIHJveWFsdHktZnJlZSwgaXJyZXZvY2FibGVcbiAgICAgIChleGNlcHQgYXMgc3RhdGVkIGluIHRoaXMgc2VjdGlvbikgcGF0ZW50IGxpY2Vuc2UgdG8gbWFrZSwgaGF2ZSBtYWRlLFxuICAgICAgdXNlLCBvZmZlciB0byBzZWxsLCBzZWxsLCBpbXBvcnQsIGFuZCBvdGhlcndpc2UgdHJhbnNmZXIgdGhlIFdvcmssXG4gICAgICB3aGVyZSBzdWNoIGxpY2Vuc2UgYXBwbGllcyBvbmx5IHRvIHRob3NlIHBhdGVudCBjbGFpbXMgbGljZW5zYWJsZVxuICAgICAgYnkgc3VjaCBDb250cmlidXRvciB0aGF0IGFyZSBuZWNlc3NhcmlseSBpbmZyaW5nZWQgYnkgdGhlaXJcbiAgICAgIENvbnRyaWJ1dGlvbihzKSBhbG9uZSBvciBieSBjb21iaW5hdGlvbiBvZiB0aGVpciBDb250cmlidXRpb24ocylcbiAgICAgIHdpdGggdGhlIFdvcmsgdG8gd2hpY2ggc3VjaCBDb250cmlidXRpb24ocykgd2FzIHN1Ym1pdHRlZC4gSWYgWW91XG4gICAgICBpbnN0aXR1dGUgcGF0ZW50IGxpdGlnYXRpb24gYWdhaW5zdCBhbnkgZW50aXR5IChpbmNsdWRpbmcgYVxuICAgICAgY3Jvc3MtY2xhaW0gb3IgY291bnRlcmNsYWltIGluIGEgbGF3c3VpdCkgYWxsZWdpbmcgdGhhdCB0aGUgV29ya1xuICAgICAgb3IgYSBDb250cmlidXRpb24gaW5jb3Jwb3JhdGVkIHdpdGhpbiB0aGUgV29yayBjb25zdGl0dXRlcyBkaXJlY3RcbiAgICAgIG9yIGNvbnRyaWJ1dG9yeSBwYXRlbnQgaW5mcmluZ2VtZW50LCB0aGVuIGFueSBwYXRlbnQgbGljZW5zZXNcbiAgICAgIGdyYW50ZWQgdG8gWW91IHVuZGVyIHRoaXMgTGljZW5zZSBmb3IgdGhhdCBXb3JrIHNoYWxsIHRlcm1pbmF0ZVxuICAgICAgYXMgb2YgdGhlIGRhdGUgc3VjaCBsaXRpZ2F0aW9uIGlzIGZpbGVkLlxuXG4gICA0LiBSZWRpc3RyaWJ1dGlvbi4gWW91IG1heSByZXByb2R1Y2UgYW5kIGRpc3RyaWJ1dGUgY29waWVzIG9mIHRoZVxuICAgICAgV29yayBvciBEZXJpdmF0aXZlIFdvcmtzIHRoZXJlb2YgaW4gYW55IG1lZGl1bSwgd2l0aCBvciB3aXRob3V0XG4gICAgICBtb2RpZmljYXRpb25zLCBhbmQgaW4gU291cmNlIG9yIE9iamVjdCBmb3JtLCBwcm92aWRlZCB0aGF0IFlvdVxuICAgICAgbWVldCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgICAgIChhKSBZb3UgbXVzdCBnaXZlIGFueSBvdGhlciByZWNpcGllbnRzIG9mIHRoZSBXb3JrIG9yXG4gICAgICAgICAgRGVyaXZhdGl2ZSBXb3JrcyBhIGNvcHkgb2YgdGhpcyBMaWNlbnNlOyBhbmRcblxuICAgICAgKGIpIFlvdSBtdXN0IGNhdXNlIGFueSBtb2RpZmllZCBmaWxlcyB0byBjYXJyeSBwcm9taW5lbnQgbm90aWNlc1xuICAgICAgICAgIHN0YXRpbmcgdGhhdCBZb3UgY2hhbmdlZCB0aGUgZmlsZXM7IGFuZFxuXG4gICAgICAoYykgWW91IG11c3QgcmV0YWluLCBpbiB0aGUgU291cmNlIGZvcm0gb2YgYW55IERlcml2YXRpdmUgV29ya3NcbiAgICAgICAgICB0aGF0IFlvdSBkaXN0cmlidXRlLCBhbGwgY29weXJpZ2h0LCBwYXRlbnQsIHRyYWRlbWFyaywgYW5kXG4gICAgICAgICAgYXR0cmlidXRpb24gbm90aWNlcyBmcm9tIHRoZSBTb3VyY2UgZm9ybSBvZiB0aGUgV29yayxcbiAgICAgICAgICBleGNsdWRpbmcgdGhvc2Ugbm90aWNlcyB0aGF0IGRvIG5vdCBwZXJ0YWluIHRvIGFueSBwYXJ0IG9mXG4gICAgICAgICAgdGhlIERlcml2YXRpdmUgV29ya3M7IGFuZFxuXG4gICAgICAoZCkgSWYgdGhlIFdvcmsgaW5jbHVkZXMgYSBcIk5PVElDRVwiIHRleHQgZmlsZSBhcyBwYXJ0IG9mIGl0c1xuICAgICAgICAgIGRpc3RyaWJ1dGlvbiwgdGhlbiBhbnkgRGVyaXZhdGl2ZSBXb3JrcyB0aGF0IFlvdSBkaXN0cmlidXRlIG11c3RcbiAgICAgICAgICBpbmNsdWRlIGEgcmVhZGFibGUgY29weSBvZiB0aGUgYXR0cmlidXRpb24gbm90aWNlcyBjb250YWluZWRcbiAgICAgICAgICB3aXRoaW4gc3VjaCBOT1RJQ0UgZmlsZSwgZXhjbHVkaW5nIHRob3NlIG5vdGljZXMgdGhhdCBkbyBub3RcbiAgICAgICAgICBwZXJ0YWluIHRvIGFueSBwYXJ0IG9mIHRoZSBEZXJpdmF0aXZlIFdvcmtzLCBpbiBhdCBsZWFzdCBvbmVcbiAgICAgICAgICBvZiB0aGUgZm9sbG93aW5nIHBsYWNlczogd2l0aGluIGEgTk9USUNFIHRleHQgZmlsZSBkaXN0cmlidXRlZFxuICAgICAgICAgIGFzIHBhcnQgb2YgdGhlIERlcml2YXRpdmUgV29ya3M7IHdpdGhpbiB0aGUgU291cmNlIGZvcm0gb3JcbiAgICAgICAgICBkb2N1bWVudGF0aW9uLCBpZiBwcm92aWRlZCBhbG9uZyB3aXRoIHRoZSBEZXJpdmF0aXZlIFdvcmtzOyBvcixcbiAgICAgICAgICB3aXRoaW4gYSBkaXNwbGF5IGdlbmVyYXRlZCBieSB0aGUgRGVyaXZhdGl2ZSBXb3JrcywgaWYgYW5kXG4gICAgICAgICAgd2hlcmV2ZXIgc3VjaCB0aGlyZC1wYXJ0eSBub3RpY2VzIG5vcm1hbGx5IGFwcGVhci4gVGhlIGNvbnRlbnRzXG4gICAgICAgICAgb2YgdGhlIE5PVElDRSBmaWxlIGFyZSBmb3IgaW5mb3JtYXRpb25hbCBwdXJwb3NlcyBvbmx5IGFuZFxuICAgICAgICAgIGRvIG5vdCBtb2RpZnkgdGhlIExpY2Vuc2UuIFlvdSBtYXkgYWRkIFlvdXIgb3duIGF0dHJpYnV0aW9uXG4gICAgICAgICAgbm90aWNlcyB3aXRoaW4gRGVyaXZhdGl2ZSBXb3JrcyB0aGF0IFlvdSBkaXN0cmlidXRlLCBhbG9uZ3NpZGVcbiAgICAgICAgICBvciBhcyBhbiBhZGRlbmR1bSB0byB0aGUgTk9USUNFIHRleHQgZnJvbSB0aGUgV29yaywgcHJvdmlkZWRcbiAgICAgICAgICB0aGF0IHN1Y2ggYWRkaXRpb25hbCBhdHRyaWJ1dGlvbiBub3RpY2VzIGNhbm5vdCBiZSBjb25zdHJ1ZWRcbiAgICAgICAgICBhcyBtb2RpZnlpbmcgdGhlIExpY2Vuc2UuXG5cbiAgICAgIFlvdSBtYXkgYWRkIFlvdXIgb3duIGNvcHlyaWdodCBzdGF0ZW1lbnQgdG8gWW91ciBtb2RpZmljYXRpb25zIGFuZFxuICAgICAgbWF5IHByb3ZpZGUgYWRkaXRpb25hbCBvciBkaWZmZXJlbnQgbGljZW5zZSB0ZXJtcyBhbmQgY29uZGl0aW9uc1xuICAgICAgZm9yIHVzZSwgcmVwcm9kdWN0aW9uLCBvciBkaXN0cmlidXRpb24gb2YgWW91ciBtb2RpZmljYXRpb25zLCBvclxuICAgICAgZm9yIGFueSBzdWNoIERlcml2YXRpdmUgV29ya3MgYXMgYSB3aG9sZSwgcHJvdmlkZWQgWW91ciB1c2UsXG4gICAgICByZXByb2R1Y3Rpb24sIGFuZCBkaXN0cmlidXRpb24gb2YgdGhlIFdvcmsgb3RoZXJ3aXNlIGNvbXBsaWVzIHdpdGhcbiAgICAgIHRoZSBjb25kaXRpb25zIHN0YXRlZCBpbiB0aGlzIExpY2Vuc2UuXG5cbiAgIDUuIFN1Ym1pc3Npb24gb2YgQ29udHJpYnV0aW9ucy4gVW5sZXNzIFlvdSBleHBsaWNpdGx5IHN0YXRlIG90aGVyd2lzZSxcbiAgICAgIGFueSBDb250cmlidXRpb24gaW50ZW50aW9uYWxseSBzdWJtaXR0ZWQgZm9yIGluY2x1c2lvbiBpbiB0aGUgV29ya1xuICAgICAgYnkgWW91IHRvIHRoZSBMaWNlbnNvciBzaGFsbCBiZSB1bmRlciB0aGUgdGVybXMgYW5kIGNvbmRpdGlvbnMgb2ZcbiAgICAgIHRoaXMgTGljZW5zZSwgd2l0aG91dCBhbnkgYWRkaXRpb25hbCB0ZXJtcyBvciBjb25kaXRpb25zLlxuICAgICAgTm90d2l0aHN0YW5kaW5nIHRoZSBhYm92ZSwgbm90aGluZyBoZXJlaW4gc2hhbGwgc3VwZXJzZWRlIG9yIG1vZGlmeVxuICAgICAgdGhlIHRlcm1zIG9mIGFueSBzZXBhcmF0ZSBsaWNlbnNlIGFncmVlbWVudCB5b3UgbWF5IGhhdmUgZXhlY3V0ZWRcbiAgICAgIHdpdGggTGljZW5zb3IgcmVnYXJkaW5nIHN1Y2ggQ29udHJpYnV0aW9ucy5cblxuICAgNi4gVHJhZGVtYXJrcy4gVGhpcyBMaWNlbnNlIGRvZXMgbm90IGdyYW50IHBlcm1pc3Npb24gdG8gdXNlIHRoZSB0cmFkZVxuICAgICAgbmFtZXMsIHRyYWRlbWFya3MsIHNlcnZpY2UgbWFya3MsIG9yIHByb2R1Y3QgbmFtZXMgb2YgdGhlIExpY2Vuc29yLFxuICAgICAgZXhjZXB0IGFzIHJlcXVpcmVkIGZvciByZWFzb25hYmxlIGFuZCBjdXN0b21hcnkgdXNlIGluIGRlc2NyaWJpbmcgdGhlXG4gICAgICBvcmlnaW4gb2YgdGhlIFdvcmsgYW5kIHJlcHJvZHVjaW5nIHRoZSBjb250ZW50IG9mIHRoZSBOT1RJQ0UgZmlsZS5cblxuICAgNy4gRGlzY2xhaW1lciBvZiBXYXJyYW50eS4gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yXG4gICAgICBhZ3JlZWQgdG8gaW4gd3JpdGluZywgTGljZW5zb3IgcHJvdmlkZXMgdGhlIFdvcmsgKGFuZCBlYWNoXG4gICAgICBDb250cmlidXRvciBwcm92aWRlcyBpdHMgQ29udHJpYnV0aW9ucykgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yXG4gICAgICBpbXBsaWVkLCBpbmNsdWRpbmcsIHdpdGhvdXQgbGltaXRhdGlvbiwgYW55IHdhcnJhbnRpZXMgb3IgY29uZGl0aW9uc1xuICAgICAgb2YgVElUTEUsIE5PTi1JTkZSSU5HRU1FTlQsIE1FUkNIQU5UQUJJTElUWSwgb3IgRklUTkVTUyBGT1IgQVxuICAgICAgUEFSVElDVUxBUiBQVVJQT1NFLiBZb3UgYXJlIHNvbGVseSByZXNwb25zaWJsZSBmb3IgZGV0ZXJtaW5pbmcgdGhlXG4gICAgICBhcHByb3ByaWF0ZW5lc3Mgb2YgdXNpbmcgb3IgcmVkaXN0cmlidXRpbmcgdGhlIFdvcmsgYW5kIGFzc3VtZSBhbnlcbiAgICAgIHJpc2tzIGFzc29jaWF0ZWQgd2l0aCBZb3VyIGV4ZXJjaXNlIG9mIHBlcm1pc3Npb25zIHVuZGVyIHRoaXMgTGljZW5zZS5cblxuICAgOC4gTGltaXRhdGlvbiBvZiBMaWFiaWxpdHkuIEluIG5vIGV2ZW50IGFuZCB1bmRlciBubyBsZWdhbCB0aGVvcnksXG4gICAgICB3aGV0aGVyIGluIHRvcnQgKGluY2x1ZGluZyBuZWdsaWdlbmNlKSwgY29udHJhY3QsIG9yIG90aGVyd2lzZSxcbiAgICAgIHVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyAoc3VjaCBhcyBkZWxpYmVyYXRlIGFuZCBncm9zc2x5XG4gICAgICBuZWdsaWdlbnQgYWN0cykgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNoYWxsIGFueSBDb250cmlidXRvciBiZVxuICAgICAgbGlhYmxlIHRvIFlvdSBmb3IgZGFtYWdlcywgaW5jbHVkaW5nIGFueSBkaXJlY3QsIGluZGlyZWN0LCBzcGVjaWFsLFxuICAgICAgaW5jaWRlbnRhbCwgb3IgY29uc2VxdWVudGlhbCBkYW1hZ2VzIG9mIGFueSBjaGFyYWN0ZXIgYXJpc2luZyBhcyBhXG4gICAgICByZXN1bHQgb2YgdGhpcyBMaWNlbnNlIG9yIG91dCBvZiB0aGUgdXNlIG9yIGluYWJpbGl0eSB0byB1c2UgdGhlXG4gICAgICBXb3JrIChpbmNsdWRpbmcgYnV0IG5vdCBsaW1pdGVkIHRvIGRhbWFnZXMgZm9yIGxvc3Mgb2YgZ29vZHdpbGwsXG4gICAgICB3b3JrIHN0b3BwYWdlLCBjb21wdXRlciBmYWlsdXJlIG9yIG1hbGZ1bmN0aW9uLCBvciBhbnkgYW5kIGFsbFxuICAgICAgb3RoZXIgY29tbWVyY2lhbCBkYW1hZ2VzIG9yIGxvc3NlcyksIGV2ZW4gaWYgc3VjaCBDb250cmlidXRvclxuICAgICAgaGFzIGJlZW4gYWR2aXNlZCBvZiB0aGUgcG9zc2liaWxpdHkgb2Ygc3VjaCBkYW1hZ2VzLlxuXG4gICA5LiBBY2NlcHRpbmcgV2FycmFudHkgb3IgQWRkaXRpb25hbCBMaWFiaWxpdHkuIFdoaWxlIHJlZGlzdHJpYnV0aW5nXG4gICAgICB0aGUgV29yayBvciBEZXJpdmF0aXZlIFdvcmtzIHRoZXJlb2YsIFlvdSBtYXkgY2hvb3NlIHRvIG9mZmVyLFxuICAgICAgYW5kIGNoYXJnZSBhIGZlZSBmb3IsIGFjY2VwdGFuY2Ugb2Ygc3VwcG9ydCwgd2FycmFudHksIGluZGVtbml0eSxcbiAgICAgIG9yIG90aGVyIGxpYWJpbGl0eSBvYmxpZ2F0aW9ucyBhbmQvb3IgcmlnaHRzIGNvbnNpc3RlbnQgd2l0aCB0aGlzXG4gICAgICBMaWNlbnNlLiBIb3dldmVyLCBpbiBhY2NlcHRpbmcgc3VjaCBvYmxpZ2F0aW9ucywgWW91IG1heSBhY3Qgb25seVxuICAgICAgb24gWW91ciBvd24gYmVoYWxmIGFuZCBvbiBZb3VyIHNvbGUgcmVzcG9uc2liaWxpdHksIG5vdCBvbiBiZWhhbGZcbiAgICAgIG9mIGFueSBvdGhlciBDb250cmlidXRvciwgYW5kIG9ubHkgaWYgWW91IGFncmVlIHRvIGluZGVtbmlmeSxcbiAgICAgIGRlZmVuZCwgYW5kIGhvbGQgZWFjaCBDb250cmlidXRvciBoYXJtbGVzcyBmb3IgYW55IGxpYWJpbGl0eVxuICAgICAgaW5jdXJyZWQgYnksIG9yIGNsYWltcyBhc3NlcnRlZCBhZ2FpbnN0LCBzdWNoIENvbnRyaWJ1dG9yIGJ5IHJlYXNvblxuICAgICAgb2YgeW91ciBhY2NlcHRpbmcgYW55IHN1Y2ggd2FycmFudHkgb3IgYWRkaXRpb25hbCBsaWFiaWxpdHkuXG5cbiAgIEVORCBPRiBURVJNUyBBTkQgQ09ORElUSU9OU1xuXG4gICBBUFBFTkRJWDogSG93IHRvIGFwcGx5IHRoZSBBcGFjaGUgTGljZW5zZSB0byB5b3VyIHdvcmsuXG5cbiAgICAgIFRvIGFwcGx5IHRoZSBBcGFjaGUgTGljZW5zZSB0byB5b3VyIHdvcmssIGF0dGFjaCB0aGUgZm9sbG93aW5nXG4gICAgICBib2lsZXJwbGF0ZSBub3RpY2UsIHdpdGggdGhlIGZpZWxkcyBlbmNsb3NlZCBieSBicmFja2V0cyBcIltdXCJcbiAgICAgIHJlcGxhY2VkIHdpdGggeW91ciBvd24gaWRlbnRpZnlpbmcgaW5mb3JtYXRpb24uIChEb24ndCBpbmNsdWRlXG4gICAgICB0aGUgYnJhY2tldHMhKSAgVGhlIHRleHQgc2hvdWxkIGJlIGVuY2xvc2VkIGluIHRoZSBhcHByb3ByaWF0ZVxuICAgICAgY29tbWVudCBzeW50YXggZm9yIHRoZSBmaWxlIGZvcm1hdC4gV2UgYWxzbyByZWNvbW1lbmQgdGhhdCBhXG4gICAgICBmaWxlIG9yIGNsYXNzIG5hbWUgYW5kIGRlc2NyaXB0aW9uIG9mIHB1cnBvc2UgYmUgaW5jbHVkZWQgb24gdGhlXG4gICAgICBzYW1lIFwicHJpbnRlZCBwYWdlXCIgYXMgdGhlIGNvcHlyaWdodCBub3RpY2UgZm9yIGVhc2llclxuICAgICAgaWRlbnRpZmljYXRpb24gd2l0aGluIHRoaXJkLXBhcnR5IGFyY2hpdmVzLlxuXG4gICBDb3B5cmlnaHQgMjAyMyBEYW5pZWwgV2lydHogPGRjb2RlQGRjb2RlLmlvPlxuXG4gICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbi8vIFRoaXMgd29ya3MuLi4gYnV0IGRvbid0IHRyeSB0byBjb21wYXJlIG9uZSB0byBhIHJlYWwgTG9uZy5qcyBMb25nIVxuLy8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuLy8gYHwgMGAgYXNzdXJlcyB0aGUgcnVudGltZSB0aGF0IHdlIGFyZSB1c2luZyBpbnRlZ2VyIGFyaXRobWV0aWNcbmV4cG9ydCBjbGFzcyBMb25nIHtcbiAgbG93OiBudW1iZXI7XG4gIGhpZ2g6IG51bWJlcjtcbiAgX19pc1Vuc2lnbmVkTG9uZ19fOiBib29sZWFuO1xuXG4gIHN0YXRpYyBpc0xvbmcob2JqOiBMb25nKSB7XG4gICAgcmV0dXJuIChvYmogJiYgb2JqLl9faXNVbnNpZ25lZExvbmdfXykgPT09IHRydWU7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyKSB7XG4gICAgdGhpcy5sb3cgPSBsb3cgfCAwO1xuICAgIHRoaXMuaGlnaCA9IGhpZ2ggfCAwO1xuICAgIHRoaXMuX19pc1Vuc2lnbmVkTG9uZ19fID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIHByZXR0aWVyLWlnbm9yZVxuICBzdGF0aWMgZnJvbUJ5dGVzTEUoYnl0ZXM6IG51bWJlcltdKTogTG9uZyB7XG4gICAgcmV0dXJuIG5ldyBMb25nKFxuICAgICAgYnl0ZXNbMF0gfFxuICAgICAgYnl0ZXNbMV0gPDwgOCB8XG4gICAgICBieXRlc1syXSA8PCAxNiB8XG4gICAgICBieXRlc1szXSA8PCAyNCxcbiAgICAgIGJ5dGVzWzRdIHxcbiAgICAgIGJ5dGVzWzVdIDw8IDggfFxuICAgICAgYnl0ZXNbNl0gPDwgMTYgfFxuICAgICAgYnl0ZXNbN10gPDwgMjQsXG4gICAgKTtcbiAgfVxuXG4gIC8vIHByZXR0aWVyLWlnbm9yZVxuICB0b0J5dGVzTEUoKSB7XG4gICAgY29uc3QgaGkgPSB0aGlzLmhpZ2g7XG4gICAgY29uc3QgbG8gPSB0aGlzLmxvdztcbiAgICByZXR1cm4gW1xuICAgICAgbG8gJiAweGZmLFxuICAgICAgbG8gPj4+IDggJiAweGZmLFxuICAgICAgbG8gPj4+IDE2ICYgMHhmZixcbiAgICAgIGxvID4+PiAyNCxcbiAgICAgIGhpICYgMHhmZixcbiAgICAgIGhpID4+PiA4ICYgMHhmZixcbiAgICAgIGhpID4+PiAxNiAmIDB4ZmYsXG4gICAgICBoaSA+Pj4gMjRcbiAgICBdO1xuICB9XG5cbiAgc3RhdGljIGZyb21OdW1iZXIodmFsdWU6IG51bWJlcikge1xuICAgIGlmIChpc05hTih2YWx1ZSkpIHJldHVybiBVWkVSTztcbiAgICBpZiAodmFsdWUgPCAwKSByZXR1cm4gVVpFUk87XG4gICAgaWYgKHZhbHVlID49IFRXT19QV1JfNjRfREJMKSByZXR1cm4gTUFYX1VOU0lHTkVEX1ZBTFVFO1xuICAgIHJldHVybiBuZXcgTG9uZyh2YWx1ZSAlIFRXT19QV1JfMzJfREJMIHwgMCwgKHZhbHVlIC8gVFdPX1BXUl8zMl9EQkwpIHwgMCk7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gKFxuICAgICAgQmlnSW50KHRoaXMuaGlnaCkgKiBCaWdJbnQoVFdPX1BXUl8zMl9EQkwpICtcbiAgICAgIEJpZ0ludCh0aGlzLmxvdylcbiAgICApLnRvU3RyaW5nKCk7XG4gIH1cblxuICBlcXVhbHMob3RoZXI6IExvbmcpIHtcbiAgICBpZiAoIUxvbmcuaXNMb25nKG90aGVyKSkgb3RoZXIgPSBMb25nLmZyb21WYWx1ZShvdGhlcik7XG4gICAgaWYgKHRoaXMuaGlnaCA+Pj4gMzEgPT09IDEgJiYgb3RoZXIuaGlnaCA+Pj4gMzEgPT09IDEpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5oaWdoID09PSBvdGhlci5oaWdoICYmIHRoaXMubG93ID09PSBvdGhlci5sb3c7XG4gIH1cblxuICBub3RFcXVhbHMob3RoZXI6IExvbmcpIHtcbiAgICByZXR1cm4gIXRoaXMuZXF1YWxzKG90aGVyKTtcbiAgfVxuXG4gIGNvbXAob3RoZXI6IExvbmcpIHtcbiAgICBpZiAoIUxvbmcuaXNMb25nKG90aGVyKSkgb3RoZXIgPSBMb25nLmZyb21WYWx1ZShvdGhlcik7XG4gICAgaWYgKHRoaXMuZXF1YWxzKG90aGVyKSkgcmV0dXJuIDA7XG4gICAgcmV0dXJuIG90aGVyLmhpZ2ggPj4+IDAgPiB0aGlzLmhpZ2ggPj4+IDAgfHxcbiAgICAgIChvdGhlci5oaWdoID09PSB0aGlzLmhpZ2ggJiYgb3RoZXIubG93ID4+PiAwID4gdGhpcy5sb3cgPj4+IDApXG4gICAgICA/IC0xXG4gICAgICA6IDE7XG4gIH1cblxuICBsZXNzVGhhbk9yRXF1YWwob3RoZXI6IExvbmcpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPD0gMDtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tVmFsdWUodmFsOiBhbnkpIHtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIExvbmcuZnJvbU51bWJlcih2YWwpO1xuICAgIC8vIFRocm93cyBmb3Igbm9uLW9iamVjdHMsIGNvbnZlcnRzIG5vbi1pbnN0YW5jZW9mIExvbmc6XG4gICAgcmV0dXJuIG5ldyBMb25nKHZhbC5sb3csIHZhbC5oaWdoKTtcbiAgfVxufVxuXG5jb25zdCBVWkVSTyA9IG5ldyBMb25nKDAsIDApO1xuY29uc3QgVFdPX1BXUl8xNl9EQkwgPSAxIDw8IDE2O1xuY29uc3QgVFdPX1BXUl8zMl9EQkwgPSBUV09fUFdSXzE2X0RCTCAqIFRXT19QV1JfMTZfREJMO1xuY29uc3QgVFdPX1BXUl82NF9EQkwgPSBUV09fUFdSXzMyX0RCTCAqIFRXT19QV1JfMzJfREJMO1xuY29uc3QgTUFYX1VOU0lHTkVEX1ZBTFVFID0gbmV3IExvbmcoMHhmZmZmZmZmZiB8IDAsIDB4ZmZmZmZmZmYgfCAwKTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4gX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbmltcG9ydCB7XG4gIGVuY29kZUNsaWVudE1lc3NhZ2UsXG4gIHBhcnNlU2VydmVyTWVzc2FnZVxufSBmcm9tIFwiLi9wcm90b2NvbC5qc1wiO1xuY29uc3QgQ0xPU0VfTk9STUFMID0gMWUzO1xuY29uc3QgQ0xPU0VfR09JTkdfQVdBWSA9IDEwMDE7XG5jb25zdCBDTE9TRV9OT19TVEFUVVMgPSAxMDA1O1xuY29uc3QgQ0xPU0VfTk9UX0ZPVU5EID0gNDA0MDtcbmxldCBmaXJzdFRpbWU7XG5mdW5jdGlvbiBtb25vdG9uaWNNaWxsaXMoKSB7XG4gIGlmIChmaXJzdFRpbWUgPT09IHZvaWQgMCkge1xuICAgIGZpcnN0VGltZSA9IERhdGUubm93KCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhcGVyZm9ybWFuY2Uubm93KSB7XG4gICAgcmV0dXJuIERhdGUubm93KCk7XG4gIH1cbiAgcmV0dXJuIE1hdGgucm91bmQoZmlyc3RUaW1lICsgcGVyZm9ybWFuY2Uubm93KCkpO1xufVxuZnVuY3Rpb24gcHJldHR5Tm93KCkge1xuICByZXR1cm4gYHQ9JHtNYXRoLnJvdW5kKChtb25vdG9uaWNNaWxsaXMoKSAtIGZpcnN0VGltZSkgLyAxMDApIC8gMTB9c2A7XG59XG5jb25zdCBzZXJ2ZXJEaXNjb25uZWN0RXJyb3JzID0ge1xuICAvLyBBIGtub3duIGVycm9yLCBlLmcuIGR1cmluZyBhIHJlc3RhcnQgb3IgcHVzaFxuICBJbnRlcm5hbFNlcnZlckVycm9yOiB7IHRpbWVvdXQ6IDFlMyB9LFxuICAvLyBFcnJvck1ldGFkYXRhOjpvdmVybG9hZGVkKCkgbWVzc2FnZXMgdGhhdCB3ZSByZWFseSBzaG91bGQgYmFjayBvZmZcbiAgU3Vic2NyaXB0aW9uc1dvcmtlckZ1bGxFcnJvcjogeyB0aW1lb3V0OiAzZTMgfSxcbiAgVG9vTWFueUNvbmN1cnJlbnRSZXF1ZXN0czogeyB0aW1lb3V0OiAzZTMgfSxcbiAgQ29tbWl0dGVyRnVsbEVycm9yOiB7IHRpbWVvdXQ6IDNlMyB9LFxuICBBd3NUb29NYW55UmVxdWVzdHNFeGNlcHRpb246IHsgdGltZW91dDogM2UzIH0sXG4gIEV4ZWN1dGVGdWxsRXJyb3I6IHsgdGltZW91dDogM2UzIH0sXG4gIFN5c3RlbVRpbWVvdXRFcnJvcjogeyB0aW1lb3V0OiAzZTMgfSxcbiAgRXhwaXJlZEluUXVldWU6IHsgdGltZW91dDogM2UzIH0sXG4gIC8vIEVycm9yTWV0YWRhdGE6OmZlYXR1cmVfdGVtcG9yYXJpbHlfdW5hdmFpbGFibGUoKSB0aGF0IHR5cGljYWxseSBpbmRpY2F0ZSBhIGRlcGxveSBqdXN0IGhhcHBlbmVkXG4gIFZlY3RvckluZGV4ZXNVbmF2YWlsYWJsZTogeyB0aW1lb3V0OiAxZTMgfSxcbiAgU2VhcmNoSW5kZXhlc1VuYXZhaWxhYmxlOiB7IHRpbWVvdXQ6IDFlMyB9LFxuICBUYWJsZVN1bW1hcmllc1VuYXZhaWxhYmxlOiB7IHRpbWVvdXQ6IDFlMyB9LFxuICAvLyBNb3JlIEVycm9yTWV0YWRhdGE6Om92ZXJsb2FkZWQoKVxuICBWZWN0b3JJbmRleFRvb0xhcmdlOiB7IHRpbWVvdXQ6IDNlMyB9LFxuICBTZWFyY2hJbmRleFRvb0xhcmdlOiB7IHRpbWVvdXQ6IDNlMyB9LFxuICBUb29NYW55V3JpdGVzSW5UaW1lUGVyaW9kOiB7IHRpbWVvdXQ6IDNlMyB9XG59O1xuZnVuY3Rpb24gY2xhc3NpZnlEaXNjb25uZWN0RXJyb3Iocykge1xuICBpZiAocyA9PT0gdm9pZCAwKSByZXR1cm4gXCJVbmtub3duXCI7XG4gIGZvciAoY29uc3QgcHJlZml4IG9mIE9iamVjdC5rZXlzKFxuICAgIHNlcnZlckRpc2Nvbm5lY3RFcnJvcnNcbiAgKSkge1xuICAgIGlmIChzLnN0YXJ0c1dpdGgocHJlZml4KSkge1xuICAgICAgcmV0dXJuIHByZWZpeDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFwiVW5rbm93blwiO1xufVxuZXhwb3J0IGNsYXNzIFdlYlNvY2tldE1hbmFnZXIge1xuICBjb25zdHJ1Y3Rvcih1cmksIGNhbGxiYWNrcywgd2ViU29ja2V0Q29uc3RydWN0b3IsIGxvZ2dlciwgbWFya0Nvbm5lY3Rpb25TdGF0ZURpcnR5LCBkZWJ1Zykge1xuICAgIHRoaXMubWFya0Nvbm5lY3Rpb25TdGF0ZURpcnR5ID0gbWFya0Nvbm5lY3Rpb25TdGF0ZURpcnR5O1xuICAgIHRoaXMuZGVidWcgPSBkZWJ1ZztcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic29ja2V0XCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjb25uZWN0aW9uQ291bnRcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9oYXNFdmVyQ29ubmVjdGVkXCIsIGZhbHNlKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibGFzdENsb3NlUmVhc29uXCIpO1xuICAgIC8vIFN0YXRlIGZvciBhc3NlbWJsaW5nIHRoZSBzcGxpdC11cCBUcmFuc2l0aW9uIGN1cnJlbnRseSBiZWluZyByZWNlaXZlZC5cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidHJhbnNpdGlvbkNodW5rQnVmZmVyXCIsIG51bGwpO1xuICAgIC8qKiBVcG9uIEhUVFBTL1dTUyBmYWlsdXJlLCB0aGUgZmlyc3Qgaml0dGVyZWQgYmFja29mZiBkdXJhdGlvbiwgaW4gbXMuICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImRlZmF1bHRJbml0aWFsQmFja29mZlwiKTtcbiAgICAvKiogV2UgYmFja29mZiBleHBvbmVudGlhbGx5LCBidXQgd2UgbmVlZCB0byBjYXAgdGhhdC0tdGhpcyBpcyB0aGUgaml0dGVyZWQgbWF4LiAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtYXhCYWNrb2ZmXCIpO1xuICAgIC8qKiBIb3cgbWFueSB0aW1lcyBoYXZlIHdlIGZhaWxlZCBjb25zZWN1dGl2ZWx5PyAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyZXRyaWVzXCIpO1xuICAgIC8qKiBIb3cgbG9uZyBiZWZvcmUgbGFjayBvZiBzZXJ2ZXIgcmVzcG9uc2UgY2F1c2VzIHVzIHRvIGluaXRpYXRlIGEgcmVjb25uZWN0LFxuICAgICAqIGluIG1zICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNlcnZlckluYWN0aXZpdHlUaHJlc2hvbGRcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJlY29ubmVjdER1ZVRvU2VydmVySW5hY3Rpdml0eVRpbWVvdXRcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInVyaVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwib25PcGVuXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJvblJlc3VtZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwib25NZXNzYWdlXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ3ZWJTb2NrZXRDb25zdHJ1Y3RvclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibG9nZ2VyXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJvblNlcnZlckRpc2Nvbm5lY3RFcnJvclwiKTtcbiAgICB0aGlzLndlYlNvY2tldENvbnN0cnVjdG9yID0gd2ViU29ja2V0Q29uc3RydWN0b3I7XG4gICAgdGhpcy5zb2NrZXQgPSB7IHN0YXRlOiBcImRpc2Nvbm5lY3RlZFwiIH07XG4gICAgdGhpcy5jb25uZWN0aW9uQ291bnQgPSAwO1xuICAgIHRoaXMubGFzdENsb3NlUmVhc29uID0gXCJJbml0aWFsQ29ubmVjdFwiO1xuICAgIHRoaXMuZGVmYXVsdEluaXRpYWxCYWNrb2ZmID0gMWUzO1xuICAgIHRoaXMubWF4QmFja29mZiA9IDE2ZTM7XG4gICAgdGhpcy5yZXRyaWVzID0gMDtcbiAgICB0aGlzLnNlcnZlckluYWN0aXZpdHlUaHJlc2hvbGQgPSA2ZTQ7XG4gICAgdGhpcy5yZWNvbm5lY3REdWVUb1NlcnZlckluYWN0aXZpdHlUaW1lb3V0ID0gbnVsbDtcbiAgICB0aGlzLnVyaSA9IHVyaTtcbiAgICB0aGlzLm9uT3BlbiA9IGNhbGxiYWNrcy5vbk9wZW47XG4gICAgdGhpcy5vblJlc3VtZSA9IGNhbGxiYWNrcy5vblJlc3VtZTtcbiAgICB0aGlzLm9uTWVzc2FnZSA9IGNhbGxiYWNrcy5vbk1lc3NhZ2U7XG4gICAgdGhpcy5vblNlcnZlckRpc2Nvbm5lY3RFcnJvciA9IGNhbGxiYWNrcy5vblNlcnZlckRpc2Nvbm5lY3RFcnJvcjtcbiAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICB0aGlzLmNvbm5lY3QoKTtcbiAgfVxuICBzZXRTb2NrZXRTdGF0ZShzdGF0ZSkge1xuICAgIHRoaXMuc29ja2V0ID0gc3RhdGU7XG4gICAgdGhpcy5fbG9nVmVyYm9zZShcbiAgICAgIGBzb2NrZXQgc3RhdGUgY2hhbmdlZDogJHt0aGlzLnNvY2tldC5zdGF0ZX0sIHBhdXNlZDogJHtcInBhdXNlZFwiIGluIHRoaXMuc29ja2V0ID8gdGhpcy5zb2NrZXQucGF1c2VkIDogdm9pZCAwfWBcbiAgICApO1xuICAgIHRoaXMubWFya0Nvbm5lY3Rpb25TdGF0ZURpcnR5KCk7XG4gIH1cbiAgYXNzZW1ibGVUcmFuc2l0aW9uKGNodW5rKSB7XG4gICAgaWYgKGNodW5rLnBhcnROdW1iZXIgPCAwIHx8IGNodW5rLnBhcnROdW1iZXIgPj0gY2h1bmsudG90YWxQYXJ0cyB8fCBjaHVuay50b3RhbFBhcnRzID09PSAwIHx8IHRoaXMudHJhbnNpdGlvbkNodW5rQnVmZmVyICYmICh0aGlzLnRyYW5zaXRpb25DaHVua0J1ZmZlci50b3RhbFBhcnRzICE9PSBjaHVuay50b3RhbFBhcnRzIHx8IHRoaXMudHJhbnNpdGlvbkNodW5rQnVmZmVyLnRyYW5zaXRpb25JZCAhPT0gY2h1bmsudHJhbnNpdGlvbklkKSkge1xuICAgICAgdGhpcy50cmFuc2l0aW9uQ2h1bmtCdWZmZXIgPSBudWxsO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBUcmFuc2l0aW9uQ2h1bmtcIik7XG4gICAgfVxuICAgIGlmICh0aGlzLnRyYW5zaXRpb25DaHVua0J1ZmZlciA9PT0gbnVsbCkge1xuICAgICAgdGhpcy50cmFuc2l0aW9uQ2h1bmtCdWZmZXIgPSB7XG4gICAgICAgIGNodW5rczogW10sXG4gICAgICAgIHRvdGFsUGFydHM6IGNodW5rLnRvdGFsUGFydHMsXG4gICAgICAgIHRyYW5zaXRpb25JZDogY2h1bmsudHJhbnNpdGlvbklkXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoY2h1bmsucGFydE51bWJlciAhPT0gdGhpcy50cmFuc2l0aW9uQ2h1bmtCdWZmZXIuY2h1bmtzLmxlbmd0aCkge1xuICAgICAgY29uc3QgZXhwZWN0ZWRMZW5ndGggPSB0aGlzLnRyYW5zaXRpb25DaHVua0J1ZmZlci5jaHVua3MubGVuZ3RoO1xuICAgICAgdGhpcy50cmFuc2l0aW9uQ2h1bmtCdWZmZXIgPSBudWxsO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVHJhbnNpdGlvbkNodW5rIHJlY2VpdmVkIG91dCBvZiBvcmRlcjogZXhwZWN0ZWQgcGFydCAke2V4cGVjdGVkTGVuZ3RofSwgZ290ICR7Y2h1bmsucGFydE51bWJlcn1gXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLnRyYW5zaXRpb25DaHVua0J1ZmZlci5jaHVua3MucHVzaChjaHVuay5jaHVuayk7XG4gICAgaWYgKHRoaXMudHJhbnNpdGlvbkNodW5rQnVmZmVyLmNodW5rcy5sZW5ndGggPT09IGNodW5rLnRvdGFsUGFydHMpIHtcbiAgICAgIGNvbnN0IGZ1bGxKc29uID0gdGhpcy50cmFuc2l0aW9uQ2h1bmtCdWZmZXIuY2h1bmtzLmpvaW4oXCJcIik7XG4gICAgICB0aGlzLnRyYW5zaXRpb25DaHVua0J1ZmZlciA9IG51bGw7XG4gICAgICBjb25zdCB0cmFuc2l0aW9uID0gcGFyc2VTZXJ2ZXJNZXNzYWdlKEpTT04ucGFyc2UoZnVsbEpzb24pKTtcbiAgICAgIGlmICh0cmFuc2l0aW9uLnR5cGUgIT09IFwiVHJhbnNpdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgRXhwZWN0ZWQgVHJhbnNpdGlvbiwgZ290ICR7dHJhbnNpdGlvbi50eXBlfSBhZnRlciBhc3NlbWJsaW5nIGNodW5rc2BcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cmFuc2l0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25uZWN0KCkge1xuICAgIGlmICh0aGlzLnNvY2tldC5zdGF0ZSA9PT0gXCJ0ZXJtaW5hdGVkXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuc29ja2V0LnN0YXRlICE9PSBcImRpc2Nvbm5lY3RlZFwiICYmIHRoaXMuc29ja2V0LnN0YXRlICE9PSBcInN0b3BwZWRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkRpZG4ndCBzdGFydCBjb25uZWN0aW9uIGZyb20gZGlzY29ubmVjdGVkIHN0YXRlOiBcIiArIHRoaXMuc29ja2V0LnN0YXRlXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCB3cyA9IG5ldyB0aGlzLndlYlNvY2tldENvbnN0cnVjdG9yKHRoaXMudXJpKTtcbiAgICB0aGlzLl9sb2dWZXJib3NlKFwiY29uc3RydWN0ZWQgV2ViU29ja2V0XCIpO1xuICAgIHRoaXMuc2V0U29ja2V0U3RhdGUoe1xuICAgICAgc3RhdGU6IFwiY29ubmVjdGluZ1wiLFxuICAgICAgd3MsXG4gICAgICBwYXVzZWQ6IFwibm9cIlxuICAgIH0pO1xuICAgIHRoaXMucmVzZXRTZXJ2ZXJJbmFjdGl2aXR5VGltZW91dCgpO1xuICAgIHdzLm9ub3BlbiA9ICgpID0+IHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZ1ZlcmJvc2UoXCJiZWdpbiB3cy5vbm9wZW5cIik7XG4gICAgICBpZiAodGhpcy5zb2NrZXQuc3RhdGUgIT09IFwiY29ubmVjdGluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm9ub3BlbiBjYWxsZWQgd2l0aCBzb2NrZXQgbm90IGluIGNvbm5lY3Rpbmcgc3RhdGVcIik7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFNvY2tldFN0YXRlKHtcbiAgICAgICAgc3RhdGU6IFwicmVhZHlcIixcbiAgICAgICAgd3MsXG4gICAgICAgIHBhdXNlZDogdGhpcy5zb2NrZXQucGF1c2VkID09PSBcInllc1wiID8gXCJ1bmluaXRpYWxpemVkXCIgOiBcIm5vXCJcbiAgICAgIH0pO1xuICAgICAgdGhpcy5yZXNldFNlcnZlckluYWN0aXZpdHlUaW1lb3V0KCk7XG4gICAgICBpZiAodGhpcy5zb2NrZXQucGF1c2VkID09PSBcIm5vXCIpIHtcbiAgICAgICAgdGhpcy5faGFzRXZlckNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgIHRoaXMub25PcGVuKHtcbiAgICAgICAgICBjb25uZWN0aW9uQ291bnQ6IHRoaXMuY29ubmVjdGlvbkNvdW50LFxuICAgICAgICAgIGxhc3RDbG9zZVJlYXNvbjogdGhpcy5sYXN0Q2xvc2VSZWFzb24sXG4gICAgICAgICAgY2xpZW50VHM6IG1vbm90b25pY01pbGxpcygpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubGFzdENsb3NlUmVhc29uICE9PSBcIkluaXRpYWxDb25uZWN0XCIpIHtcbiAgICAgICAgaWYgKHRoaXMubGFzdENsb3NlUmVhc29uKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIubG9nKFxuICAgICAgICAgICAgXCJXZWJTb2NrZXQgcmVjb25uZWN0ZWQgYXRcIixcbiAgICAgICAgICAgIHByZXR0eU5vdygpLFxuICAgICAgICAgICAgXCJhZnRlciBkaXNjb25uZWN0IGR1ZSB0b1wiLFxuICAgICAgICAgICAgdGhpcy5sYXN0Q2xvc2VSZWFzb25cbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIldlYlNvY2tldCByZWNvbm5lY3RlZCBhdFwiLCBwcmV0dHlOb3coKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuY29ubmVjdGlvbkNvdW50ICs9IDE7XG4gICAgICB0aGlzLmxhc3RDbG9zZVJlYXNvbiA9IG51bGw7XG4gICAgfTtcbiAgICB3cy5vbmVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICB0aGlzLnRyYW5zaXRpb25DaHVua0J1ZmZlciA9IG51bGw7XG4gICAgICBjb25zdCBtZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhgV2ViU29ja2V0IGVycm9yIG1lc3NhZ2U6ICR7bWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdzLm9ubWVzc2FnZSA9IChtZXNzYWdlKSA9PiB7XG4gICAgICB0aGlzLnJlc2V0U2VydmVySW5hY3Rpdml0eVRpbWVvdXQoKTtcbiAgICAgIGNvbnN0IG1lc3NhZ2VMZW5ndGggPSBtZXNzYWdlLmRhdGEubGVuZ3RoO1xuICAgICAgbGV0IHNlcnZlck1lc3NhZ2UgPSBwYXJzZVNlcnZlck1lc3NhZ2UoSlNPTi5wYXJzZShtZXNzYWdlLmRhdGEpKTtcbiAgICAgIHRoaXMuX2xvZ1ZlcmJvc2UoYHJlY2VpdmVkIHdzIG1lc3NhZ2Ugd2l0aCB0eXBlICR7c2VydmVyTWVzc2FnZS50eXBlfWApO1xuICAgICAgaWYgKHNlcnZlck1lc3NhZ2UudHlwZSA9PT0gXCJQaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHNlcnZlck1lc3NhZ2UudHlwZSA9PT0gXCJUcmFuc2l0aW9uQ2h1bmtcIikge1xuICAgICAgICBjb25zdCB0cmFuc2l0aW9uID0gdGhpcy5hc3NlbWJsZVRyYW5zaXRpb24oc2VydmVyTWVzc2FnZSk7XG4gICAgICAgIGlmICghdHJhbnNpdGlvbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZXJ2ZXJNZXNzYWdlID0gdHJhbnNpdGlvbjtcbiAgICAgICAgdGhpcy5fbG9nVmVyYm9zZShcbiAgICAgICAgICBgYXNzZW1ibGVkIGZ1bGwgd3MgbWVzc2FnZSBvZiB0eXBlICR7c2VydmVyTWVzc2FnZS50eXBlfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnRyYW5zaXRpb25DaHVua0J1ZmZlciAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnRyYW5zaXRpb25DaHVua0J1ZmZlciA9IG51bGw7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcbiAgICAgICAgICBgUmVjZWl2ZWQgdW5leHBlY3RlZCAke3NlcnZlck1lc3NhZ2UudHlwZX0gd2hpbGUgYnVmZmVyaW5nIFRyYW5zaXRpb25DaHVua3NgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoc2VydmVyTWVzc2FnZS50eXBlID09PSBcIlRyYW5zaXRpb25cIikge1xuICAgICAgICB0aGlzLnJlcG9ydExhcmdlVHJhbnNpdGlvbih7XG4gICAgICAgICAgbWVzc2FnZUxlbmd0aCxcbiAgICAgICAgICB0cmFuc2l0aW9uOiBzZXJ2ZXJNZXNzYWdlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzcG9uc2UgPSB0aGlzLm9uTWVzc2FnZShzZXJ2ZXJNZXNzYWdlKTtcbiAgICAgIGlmIChyZXNwb25zZS5oYXNTeW5jZWRQYXN0TGFzdFJlY29ubmVjdCkge1xuICAgICAgICB0aGlzLnJldHJpZXMgPSAwO1xuICAgICAgICB0aGlzLm1hcmtDb25uZWN0aW9uU3RhdGVEaXJ0eSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgd3Mub25jbG9zZSA9IChldmVudCkgPT4ge1xuICAgICAgdGhpcy5fbG9nVmVyYm9zZShcImJlZ2luIHdzLm9uY2xvc2VcIik7XG4gICAgICB0aGlzLnRyYW5zaXRpb25DaHVua0J1ZmZlciA9IG51bGw7XG4gICAgICBpZiAodGhpcy5sYXN0Q2xvc2VSZWFzb24gPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5sYXN0Q2xvc2VSZWFzb24gPSBldmVudC5yZWFzb24gfHwgYGNsb3NlZCB3aXRoIGNvZGUgJHtldmVudC5jb2RlfWA7XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQuY29kZSAhPT0gQ0xPU0VfTk9STUFMICYmIGV2ZW50LmNvZGUgIT09IENMT1NFX0dPSU5HX0FXQVkgJiYgLy8gVGhpcyBjb21tb25seSBnZXRzIGZpcmVkIG9uIG1vYmlsZSBhcHBzIHdoZW4gdGhlIGFwcCBpcyBiYWNrZ3JvdW5kZWRcbiAgICAgIGV2ZW50LmNvZGUgIT09IENMT1NFX05PX1NUQVRVUyAmJiBldmVudC5jb2RlICE9PSBDTE9TRV9OT1RfRk9VTkQpIHtcbiAgICAgICAgbGV0IG1zZyA9IGBXZWJTb2NrZXQgY2xvc2VkIHdpdGggY29kZSAke2V2ZW50LmNvZGV9YDtcbiAgICAgICAgaWYgKGV2ZW50LnJlYXNvbikge1xuICAgICAgICAgIG1zZyArPSBgOiAke2V2ZW50LnJlYXNvbn1gO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhtc2cpO1xuICAgICAgICBpZiAodGhpcy5vblNlcnZlckRpc2Nvbm5lY3RFcnJvciAmJiBldmVudC5yZWFzb24pIHtcbiAgICAgICAgICB0aGlzLm9uU2VydmVyRGlzY29ubmVjdEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlYXNvbiA9IGNsYXNzaWZ5RGlzY29ubmVjdEVycm9yKGV2ZW50LnJlYXNvbik7XG4gICAgICB0aGlzLnNjaGVkdWxlUmVjb25uZWN0KHJlYXNvbik7XG4gICAgICByZXR1cm47XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQHJldHVybnMgVGhlIHN0YXRlIG9mIHRoZSB7QGxpbmsgU29ja2V0fS5cbiAgICovXG4gIHNvY2tldFN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLnNvY2tldC5zdGF0ZTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIG1lc3NhZ2UgLSBBIENsaWVudE1lc3NhZ2UgdG8gc2VuZC5cbiAgICogQHJldHVybnMgV2hldGhlciB0aGUgbWVzc2FnZSAobWlnaHQgaGF2ZSBiZWVuKSBzZW50LlxuICAgKi9cbiAgc2VuZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGNvbnN0IG1lc3NhZ2VGb3JMb2cgPSB7XG4gICAgICB0eXBlOiBtZXNzYWdlLnR5cGUsXG4gICAgICAuLi5tZXNzYWdlLnR5cGUgPT09IFwiQXV0aGVudGljYXRlXCIgJiYgbWVzc2FnZS50b2tlblR5cGUgPT09IFwiVXNlclwiID8ge1xuICAgICAgICB2YWx1ZTogYC4uLiR7bWVzc2FnZS52YWx1ZS5zbGljZSgtNyl9YFxuICAgICAgfSA6IHt9XG4gICAgfTtcbiAgICBpZiAodGhpcy5zb2NrZXQuc3RhdGUgPT09IFwicmVhZHlcIiAmJiB0aGlzLnNvY2tldC5wYXVzZWQgPT09IFwibm9cIikge1xuICAgICAgY29uc3QgZW5jb2RlZE1lc3NhZ2UgPSBlbmNvZGVDbGllbnRNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgY29uc3QgcmVxdWVzdCA9IEpTT04uc3RyaW5naWZ5KGVuY29kZWRNZXNzYWdlKTtcbiAgICAgIGxldCBzZW50ID0gZmFsc2U7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnNvY2tldC53cy5zZW5kKHJlcXVlc3QpO1xuICAgICAgICBzZW50ID0gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcbiAgICAgICAgICBgRmFpbGVkIHRvIHNlbmQgbWVzc2FnZSBvbiBXZWJTb2NrZXQsIHJlY29ubmVjdGluZzogJHtlcnJvcn1gXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuY2xvc2VBbmRSZWNvbm5lY3QoXCJGYWlsZWRUb1NlbmRNZXNzYWdlXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbG9nVmVyYm9zZShcbiAgICAgICAgYCR7c2VudCA/IFwic2VudFwiIDogXCJmYWlsZWQgdG8gc2VuZFwifSBtZXNzYWdlIHdpdGggdHlwZSAke21lc3NhZ2UudHlwZX06ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgbWVzc2FnZUZvckxvZ1xuICAgICAgICApfWBcbiAgICAgICk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fbG9nVmVyYm9zZShcbiAgICAgIGBtZXNzYWdlIG5vdCBzZW50IChzb2NrZXQgc3RhdGU6ICR7dGhpcy5zb2NrZXQuc3RhdGV9LCBwYXVzZWQ6ICR7XCJwYXVzZWRcIiBpbiB0aGlzLnNvY2tldCA/IHRoaXMuc29ja2V0LnBhdXNlZCA6IHZvaWQgMH0pOiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICBtZXNzYWdlRm9yTG9nXG4gICAgICApfWBcbiAgICApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXNldFNlcnZlckluYWN0aXZpdHlUaW1lb3V0KCkge1xuICAgIGlmICh0aGlzLnNvY2tldC5zdGF0ZSA9PT0gXCJ0ZXJtaW5hdGVkXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMucmVjb25uZWN0RHVlVG9TZXJ2ZXJJbmFjdGl2aXR5VGltZW91dCAhPT0gbnVsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVjb25uZWN0RHVlVG9TZXJ2ZXJJbmFjdGl2aXR5VGltZW91dCk7XG4gICAgICB0aGlzLnJlY29ubmVjdER1ZVRvU2VydmVySW5hY3Rpdml0eVRpbWVvdXQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLnJlY29ubmVjdER1ZVRvU2VydmVySW5hY3Rpdml0eVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuY2xvc2VBbmRSZWNvbm5lY3QoXCJJbmFjdGl2ZVNlcnZlclwiKTtcbiAgICB9LCB0aGlzLnNlcnZlckluYWN0aXZpdHlUaHJlc2hvbGQpO1xuICB9XG4gIHNjaGVkdWxlUmVjb25uZWN0KHJlYXNvbikge1xuICAgIHRoaXMuc29ja2V0ID0geyBzdGF0ZTogXCJkaXNjb25uZWN0ZWRcIiB9O1xuICAgIGNvbnN0IGJhY2tvZmYgPSB0aGlzLm5leHRCYWNrb2ZmKHJlYXNvbik7XG4gICAgdGhpcy5tYXJrQ29ubmVjdGlvblN0YXRlRGlydHkoKTtcbiAgICB0aGlzLmxvZ2dlci5sb2coYEF0dGVtcHRpbmcgcmVjb25uZWN0IGluICR7TWF0aC5yb3VuZChiYWNrb2ZmKX1tc2ApO1xuICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5jb25uZWN0KCksIGJhY2tvZmYpO1xuICB9XG4gIC8qKlxuICAgKiBDbG9zZSB0aGUgV2ViU29ja2V0IGFuZCBzY2hlZHVsZSBhIHJlY29ubmVjdC5cbiAgICpcbiAgICogVGhpcyBzaG91bGQgYmUgdXNlZCB3aGVuIHdlIGhpdCBhbiBlcnJvciBhbmQgd291bGQgbGlrZSB0byByZXN0YXJ0IHRoZSBzZXNzaW9uLlxuICAgKi9cbiAgY2xvc2VBbmRSZWNvbm5lY3QoY2xvc2VSZWFzb24pIHtcbiAgICB0aGlzLl9sb2dWZXJib3NlKGBiZWdpbiBjbG9zZUFuZFJlY29ubmVjdCB3aXRoIHJlYXNvbiAke2Nsb3NlUmVhc29ufWApO1xuICAgIHN3aXRjaCAodGhpcy5zb2NrZXQuc3RhdGUpIHtcbiAgICAgIGNhc2UgXCJkaXNjb25uZWN0ZWRcIjpcbiAgICAgIGNhc2UgXCJ0ZXJtaW5hdGVkXCI6XG4gICAgICBjYXNlIFwic3RvcHBlZFwiOlxuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiY29ubmVjdGluZ1wiOlxuICAgICAgY2FzZSBcInJlYWR5XCI6IHtcbiAgICAgICAgdGhpcy5sYXN0Q2xvc2VSZWFzb24gPSBjbG9zZVJlYXNvbjtcbiAgICAgICAgdm9pZCB0aGlzLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVSZWNvbm5lY3QoXCJjbGllbnRcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgdGhpcy5zb2NrZXQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDbG9zZSB0aGUgV2ViU29ja2V0LCBiZWluZyBjYXJlZnVsIHRvIGNsZWFyIHRoZSBvbmNsb3NlIGhhbmRsZXIgdG8gYXZvaWQgcmUtZW50cmFudFxuICAgKiBjYWxscy4gVXNlIHRoaXMgaW5zdGVhZCBvZiBkaXJlY3RseSBjYWxsaW5nIGB3cy5jbG9zZSgpYFxuICAgKlxuICAgKiBJdCBpcyB0aGUgY2FsbGVycyByZXNwb25zaWJpbGl0eSB0byB1cGRhdGUgdGhlIHN0YXRlIGFmdGVyIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBzbyB0aGF0IHRoZVxuICAgKiBjbG9zZWQgc29ja2V0IGlzIG5vdCBhY2Nlc3NpYmxlIG9yIHVzZWQgYWdhaW4gYWZ0ZXIgdGhpcyBtZXRob2QgaXMgY2FsbGVkXG4gICAqL1xuICBjbG9zZSgpIHtcbiAgICB0aGlzLnRyYW5zaXRpb25DaHVua0J1ZmZlciA9IG51bGw7XG4gICAgc3dpdGNoICh0aGlzLnNvY2tldC5zdGF0ZSkge1xuICAgICAgY2FzZSBcImRpc2Nvbm5lY3RlZFwiOlxuICAgICAgY2FzZSBcInRlcm1pbmF0ZWRcIjpcbiAgICAgIGNhc2UgXCJzdG9wcGVkXCI6XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIGNhc2UgXCJjb25uZWN0aW5nXCI6IHtcbiAgICAgICAgY29uc3Qgd3MgPSB0aGlzLnNvY2tldC53cztcbiAgICAgICAgd3Mub25tZXNzYWdlID0gKF9tZXNzYWdlKSA9PiB7XG4gICAgICAgICAgdGhpcy5fbG9nVmVyYm9zZShcIklnbm9yaW5nIG1lc3NhZ2UgcmVjZWl2ZWQgYWZ0ZXIgY2xvc2VcIik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocikgPT4ge1xuICAgICAgICAgIHdzLm9uY2xvc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9sb2dWZXJib3NlKFwiQ2xvc2VkIGFmdGVyIGNvbm5lY3RpbmdcIik7XG4gICAgICAgICAgICByKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB3cy5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9sb2dWZXJib3NlKFwiT3BlbmVkIGFmdGVyIGNvbm5lY3RpbmdcIik7XG4gICAgICAgICAgICB3cy5jbG9zZSgpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY2FzZSBcInJlYWR5XCI6IHtcbiAgICAgICAgdGhpcy5fbG9nVmVyYm9zZShcIndzLmNsb3NlIGNhbGxlZFwiKTtcbiAgICAgICAgY29uc3Qgd3MgPSB0aGlzLnNvY2tldC53cztcbiAgICAgICAgd3Mub25tZXNzYWdlID0gKF9tZXNzYWdlKSA9PiB7XG4gICAgICAgICAgdGhpcy5fbG9nVmVyYm9zZShcIklnbm9yaW5nIG1lc3NhZ2UgcmVjZWl2ZWQgYWZ0ZXIgY2xvc2VcIik7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBQcm9taXNlKChyKSA9PiB7XG4gICAgICAgICAgd3Mub25jbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHIoKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgd3MuY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgdGhpcy5zb2NrZXQ7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENsb3NlIHRoZSBXZWJTb2NrZXQgYW5kIGRvIG5vdCByZWNvbm5lY3QuXG4gICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIFdlYlNvY2tldCBgb25DbG9zZWAgY2FsbGJhY2sgaXMgY2FsbGVkLlxuICAgKi9cbiAgdGVybWluYXRlKCkge1xuICAgIGlmICh0aGlzLnJlY29ubmVjdER1ZVRvU2VydmVySW5hY3Rpdml0eVRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlY29ubmVjdER1ZVRvU2VydmVySW5hY3Rpdml0eVRpbWVvdXQpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHRoaXMuc29ja2V0LnN0YXRlKSB7XG4gICAgICBjYXNlIFwidGVybWluYXRlZFwiOlxuICAgICAgY2FzZSBcInN0b3BwZWRcIjpcbiAgICAgIGNhc2UgXCJkaXNjb25uZWN0ZWRcIjpcbiAgICAgIGNhc2UgXCJjb25uZWN0aW5nXCI6XG4gICAgICBjYXNlIFwicmVhZHlcIjoge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuc2V0U29ja2V0U3RhdGUoeyBzdGF0ZTogXCJ0ZXJtaW5hdGVkXCIgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIHRoaXMuc29ja2V0O1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEludmFsaWQgd2Vic29ja2V0IHN0YXRlOiAke3RoaXMuc29ja2V0LnN0YXRlfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3RvcCgpIHtcbiAgICBzd2l0Y2ggKHRoaXMuc29ja2V0LnN0YXRlKSB7XG4gICAgICBjYXNlIFwidGVybWluYXRlZFwiOlxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICBjYXNlIFwiY29ubmVjdGluZ1wiOlxuICAgICAgY2FzZSBcInN0b3BwZWRcIjpcbiAgICAgIGNhc2UgXCJkaXNjb25uZWN0ZWRcIjpcbiAgICAgIGNhc2UgXCJyZWFkeVwiOiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5zb2NrZXQgPSB7IHN0YXRlOiBcInN0b3BwZWRcIiB9O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICB0aGlzLnNvY2tldDtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFdlYlNvY2tldCBhZnRlciBhIHByZXZpb3VzIGBzdG9wKClgLCB1bmxlc3MgYHRlcm1pbmF0ZSgpYCB3YXNcbiAgICogY2FsbGVkIGJlZm9yZS5cbiAgICovXG4gIHRyeVJlc3RhcnQoKSB7XG4gICAgc3dpdGNoICh0aGlzLnNvY2tldC5zdGF0ZSkge1xuICAgICAgY2FzZSBcInN0b3BwZWRcIjpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwidGVybWluYXRlZFwiOlxuICAgICAgY2FzZSBcImNvbm5lY3RpbmdcIjpcbiAgICAgIGNhc2UgXCJyZWFkeVwiOlxuICAgICAgY2FzZSBcImRpc2Nvbm5lY3RlZFwiOlxuICAgICAgICB0aGlzLmxvZ2dlci5sb2dWZXJib3NlKFwiUmVzdGFydCBjYWxsZWQgd2l0aG91dCBzdG9wcGluZyBmaXJzdFwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZGVmYXVsdDoge1xuICAgICAgICB0aGlzLnNvY2tldDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jb25uZWN0KCk7XG4gIH1cbiAgcGF1c2UoKSB7XG4gICAgc3dpdGNoICh0aGlzLnNvY2tldC5zdGF0ZSkge1xuICAgICAgY2FzZSBcImRpc2Nvbm5lY3RlZFwiOlxuICAgICAgY2FzZSBcInN0b3BwZWRcIjpcbiAgICAgIGNhc2UgXCJ0ZXJtaW5hdGVkXCI6XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJjb25uZWN0aW5nXCI6XG4gICAgICBjYXNlIFwicmVhZHlcIjoge1xuICAgICAgICB0aGlzLnNvY2tldCA9IHsgLi4udGhpcy5zb2NrZXQsIHBhdXNlZDogXCJ5ZXNcIiB9O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIHRoaXMuc29ja2V0O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXN1bWUgdGhlIHN0YXRlIG1hY2hpbmUgaWYgcHJldmlvdXNseSBwYXVzZWQuXG4gICAqL1xuICByZXN1bWUoKSB7XG4gICAgc3dpdGNoICh0aGlzLnNvY2tldC5zdGF0ZSkge1xuICAgICAgY2FzZSBcImNvbm5lY3RpbmdcIjpcbiAgICAgICAgdGhpcy5zb2NrZXQgPSB7IC4uLnRoaXMuc29ja2V0LCBwYXVzZWQ6IFwibm9cIiB9O1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwicmVhZHlcIjpcbiAgICAgICAgaWYgKHRoaXMuc29ja2V0LnBhdXNlZCA9PT0gXCJ1bmluaXRpYWxpemVkXCIpIHtcbiAgICAgICAgICB0aGlzLnNvY2tldCA9IHsgLi4udGhpcy5zb2NrZXQsIHBhdXNlZDogXCJub1wiIH07XG4gICAgICAgICAgdGhpcy5vbk9wZW4oe1xuICAgICAgICAgICAgY29ubmVjdGlvbkNvdW50OiB0aGlzLmNvbm5lY3Rpb25Db3VudCxcbiAgICAgICAgICAgIGxhc3RDbG9zZVJlYXNvbjogdGhpcy5sYXN0Q2xvc2VSZWFzb24sXG4gICAgICAgICAgICBjbGllbnRUczogbW9ub3RvbmljTWlsbGlzKClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNvY2tldC5wYXVzZWQgPT09IFwieWVzXCIpIHtcbiAgICAgICAgICB0aGlzLnNvY2tldCA9IHsgLi4udGhpcy5zb2NrZXQsIHBhdXNlZDogXCJub1wiIH07XG4gICAgICAgICAgdGhpcy5vblJlc3VtZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJ0ZXJtaW5hdGVkXCI6XG4gICAgICBjYXNlIFwic3RvcHBlZFwiOlxuICAgICAgY2FzZSBcImRpc2Nvbm5lY3RlZFwiOlxuICAgICAgICByZXR1cm47XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIHRoaXMuc29ja2V0O1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNvbm5lY3QoKTtcbiAgfVxuICBjb25uZWN0aW9uU3RhdGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzQ29ubmVjdGVkOiB0aGlzLnNvY2tldC5zdGF0ZSA9PT0gXCJyZWFkeVwiLFxuICAgICAgaGFzRXZlckNvbm5lY3RlZDogdGhpcy5faGFzRXZlckNvbm5lY3RlZCxcbiAgICAgIGNvbm5lY3Rpb25Db3VudDogdGhpcy5jb25uZWN0aW9uQ291bnQsXG4gICAgICBjb25uZWN0aW9uUmV0cmllczogdGhpcy5yZXRyaWVzXG4gICAgfTtcbiAgfVxuICBfbG9nVmVyYm9zZShtZXNzYWdlKSB7XG4gICAgdGhpcy5sb2dnZXIubG9nVmVyYm9zZShtZXNzYWdlKTtcbiAgfVxuICBuZXh0QmFja29mZihyZWFzb24pIHtcbiAgICBjb25zdCBpbml0aWFsQmFja29mZiA9IHJlYXNvbiA9PT0gXCJjbGllbnRcIiA/IDEwMCA6IHJlYXNvbiA9PT0gXCJVbmtub3duXCIgPyB0aGlzLmRlZmF1bHRJbml0aWFsQmFja29mZiA6IHNlcnZlckRpc2Nvbm5lY3RFcnJvcnNbcmVhc29uXS50aW1lb3V0O1xuICAgIGNvbnN0IGJhc2VCYWNrb2ZmID0gaW5pdGlhbEJhY2tvZmYgKiBNYXRoLnBvdygyLCB0aGlzLnJldHJpZXMpO1xuICAgIHRoaXMucmV0cmllcyArPSAxO1xuICAgIGNvbnN0IGFjdHVhbEJhY2tvZmYgPSBNYXRoLm1pbihiYXNlQmFja29mZiwgdGhpcy5tYXhCYWNrb2ZmKTtcbiAgICBjb25zdCBqaXR0ZXIgPSBhY3R1YWxCYWNrb2ZmICogKE1hdGgucmFuZG9tKCkgLSAwLjUpO1xuICAgIHJldHVybiBhY3R1YWxCYWNrb2ZmICsgaml0dGVyO1xuICB9XG4gIHJlcG9ydExhcmdlVHJhbnNpdGlvbih7XG4gICAgdHJhbnNpdGlvbixcbiAgICBtZXNzYWdlTGVuZ3RoXG4gIH0pIHtcbiAgICBpZiAodHJhbnNpdGlvbi5jbGllbnRDbG9ja1NrZXcgPT09IHZvaWQgMCB8fCB0cmFuc2l0aW9uLnNlcnZlclRzID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdHJhbnNpdGlvblRyYW5zaXRUaW1lID0gbW9ub3RvbmljTWlsbGlzKCkgLSAvLyBjbGllbnQgdGltZSBub3dcbiAgICAvLyBjbGllbnRDbG9ja1NrZXcgPSAoc2VydmVyIHRpbWUgKyB1cHN0cmVhbSBsYXRlbmN5KSAtIGNsaWVudCB0aW1lXG4gICAgLy8gY2xpZW50Q2xvY2tTa2V3IGlzIFwiaG93IG1hbnkgbWlsbGlzZWNvbmRzIGJlaGluZCAoc2xvdykgaXMgdGhlIGNsaWVudCBjbG9ja1wiXG4gICAgLy8gYnV0IHRoZSBsYXRlbmN5IG9mIHRoZSBDb25uZWN0IG1lc3NhZ2UgaW5mbGF0ZXMgdGhpcywgbWFraW5nIGl0IGFwcGVhciBmdXJ0aGVyIGJlaGluZFxuICAgIHRyYW5zaXRpb24uY2xpZW50Q2xvY2tTa2V3IC0gdHJhbnNpdGlvbi5zZXJ2ZXJUcyAvIDFlNjtcbiAgICBjb25zdCBwcmV0dHlUcmFuc2l0aW9uVGltZSA9IGAke01hdGgucm91bmQodHJhbnNpdGlvblRyYW5zaXRUaW1lKX1tc2A7XG4gICAgY29uc3QgcHJldHR5TWVzc2FnZU1CID0gYCR7TWF0aC5yb3VuZChtZXNzYWdlTGVuZ3RoIC8gMWU0KSAvIDEwMH1NQmA7XG4gICAgY29uc3QgYnl0ZXNQZXJTZWNvbmQgPSBtZXNzYWdlTGVuZ3RoIC8gKHRyYW5zaXRpb25UcmFuc2l0VGltZSAvIDFlMyk7XG4gICAgY29uc3QgcHJldHR5Qnl0ZXNQZXJTZWNvbmQgPSBgJHtNYXRoLnJvdW5kKGJ5dGVzUGVyU2Vjb25kIC8gMWU0KSAvIDEwMH1NQiBwZXIgc2Vjb25kYDtcbiAgICB0aGlzLl9sb2dWZXJib3NlKFxuICAgICAgYHJlY2VpdmVkICR7cHJldHR5TWVzc2FnZU1CfSB0cmFuc2l0aW9uIGluICR7cHJldHR5VHJhbnNpdGlvblRpbWV9IGF0ICR7cHJldHR5Qnl0ZXNQZXJTZWNvbmR9YFxuICAgICk7XG4gICAgaWYgKG1lc3NhZ2VMZW5ndGggPiAyZTcpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZyhcbiAgICAgICAgYHJlY2VpdmVkIHF1ZXJ5IHJlc3VsdHMgdG90YWxpbmcgbW9yZSB0aGF0IDIwTUIgKCR7cHJldHR5TWVzc2FnZU1CfSkgd2hpY2ggd2lsbCB0YWtlIGEgbG9uZyB0aW1lIHRvIGRvd25sb2FkIG9uIHNsb3dlciBjb25uZWN0aW9uc2BcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICh0cmFuc2l0aW9uVHJhbnNpdFRpbWUgPiAyZTQpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZyhcbiAgICAgICAgYHJlY2VpdmVkIHF1ZXJ5IHJlc3VsdHMgdG90YWxpbmcgJHtwcmV0dHlNZXNzYWdlTUJ9IHdoaWNoIHRvb2sgbW9yZSB0aGFuIDIwcyB0byBhcnJpdmUgKCR7cHJldHR5VHJhbnNpdGlvblRpbWV9KWBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICB0aGlzLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgdHlwZTogXCJFdmVudFwiLFxuICAgICAgICBldmVudFR5cGU6IFwiQ2xpZW50UmVjZWl2ZWRUcmFuc2l0aW9uXCIsXG4gICAgICAgIGV2ZW50OiB7IHRyYW5zaXRpb25UcmFuc2l0VGltZSwgbWVzc2FnZUxlbmd0aCB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlYl9zb2NrZXRfbWFuYWdlci5qcy5tYXBcbiIsImltcG9ydCB7IExvZ2dlciB9IGZyb20gXCIuLi9sb2dnaW5nLmpzXCI7XG5pbXBvcnQge1xuICBDbGllbnRNZXNzYWdlLFxuICBlbmNvZGVDbGllbnRNZXNzYWdlLFxuICBwYXJzZVNlcnZlck1lc3NhZ2UsXG4gIFNlcnZlck1lc3NhZ2UsXG4gIFRyYW5zaXRpb24sXG4gIFRyYW5zaXRpb25DaHVuayxcbn0gZnJvbSBcIi4vcHJvdG9jb2wuanNcIjtcblxuY29uc3QgQ0xPU0VfTk9STUFMID0gMTAwMDtcbmNvbnN0IENMT1NFX0dPSU5HX0FXQVkgPSAxMDAxO1xuY29uc3QgQ0xPU0VfTk9fU1RBVFVTID0gMTAwNTtcbi8qKiBDb252ZXgtc3BlY2lmaWMgY2xvc2UgY29kZSByZXByZXNlbnRpbmcgYSBcIjQwNCBOb3QgRm91bmRcIi5cbiAqIFRoZSBlZGdlIE9ucmFtcCBhY2NlcHRzIHdlYnNvY2tldCB1cGdyYWRlcyBiZWZvcmUgY29uZmlybWluZyB0aGF0IHRoZVxuICogaW50ZW5kZWQgZGVzdGluYXRpb24gZXhpc3RzLCBzbyB0aGlzIGNvZGUgaXMgc2VudCBvbmNlIHdlJ3ZlIGRpc2NvdmVyZWQgdGhhdFxuICogdGhlIGRlc3RpbmF0aW9uIGRvZXMgbm90IGV4aXN0LlxuICovXG5jb25zdCBDTE9TRV9OT1RfRk9VTkQgPSA0MDQwO1xuXG4vKipcbiAqIFRoZSB2YXJpb3VzIHN0YXRlcyBvdXIgV2ViU29ja2V0IGNhbiBiZSBpbjpcbiAqXG4gKiAtIFwiZGlzY29ubmVjdGVkXCI6IFdlIGRvbid0IGhhdmUgYSBXZWJTb2NrZXQsIGJ1dCBwbGFuIHRvIGNyZWF0ZSBvbmUuXG4gKiAtIFwiY29ubmVjdGluZ1wiOiBXZSBoYXZlIGNyZWF0ZWQgdGhlIFdlYlNvY2tldCBhbmQgYXJlIHdhaXRpbmcgZm9yIHRoZVxuICogICBgb25PcGVuYCBjYWxsYmFjay5cbiAqIC0gXCJyZWFkeVwiOiBXZSBoYXZlIGFuIG9wZW4gV2ViU29ja2V0LlxuICogLSBcInN0b3BwZWRcIjogVGhlIFdlYlNvY2tldCB3YXMgY2xvc2VkIGFuZCBhIG5ldyBvbmUgY2FuIGJlIGNyZWF0ZWQgdmlhIGAucmVzdGFydCgpYC5cbiAqIC0gXCJ0ZXJtaW5hdGVkXCI6IFdlIGhhdmUgY2xvc2VkIHRoZSBXZWJTb2NrZXQgYW5kIHdpbGwgbmV2ZXIgY3JlYXRlIGEgbmV3IG9uZS5cbiAqXG4gKlxuICogV2ViU29ja2V0IFN0YXRlIE1hY2hpbmVcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBpbml0aWFsU3RhdGU6IGRpc2Nvbm5lY3RlZFxuICogdmFsaWRUcmFuc2l0aW9uczpcbiAqICAgZGlzY29ubmVjdGVkOlxuICogICAgIG5ldyBXZWJTb2NrZXQoKSAtPiBjb25uZWN0aW5nXG4gKiAgICAgdGVybWluYXRlKCkgLT4gdGVybWluYXRlZFxuICogICBjb25uZWN0aW5nOlxuICogICAgIG9ub3BlbiAtPiByZWFkeVxuICogICAgIGNsb3NlKCkgLT4gZGlzY29ubmVjdGVkXG4gKiAgICAgdGVybWluYXRlKCkgLT4gdGVybWluYXRlZFxuICogICByZWFkeTpcbiAqICAgICBjbG9zZSgpIC0+IGRpc2Nvbm5lY3RlZFxuICogICAgIHN0b3AoKSAtPiBzdG9wcGVkXG4gKiAgICAgdGVybWluYXRlKCkgLT4gdGVybWluYXRlZFxuICogICBzdG9wcGVkOlxuICogICAgIHJlc3RhcnQoKSAtPiBjb25uZWN0aW5nXG4gKiAgICAgdGVybWluYXRlKCkgLT4gdGVybWluYXRlZFxuICogdGVybWluYWxTdGF0ZXM6XG4gKiAgIHRlcm1pbmF0ZWRcbiAqXG4gKlxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuICogICAgICAgICAgICAgICAg4pSM4pSA4pSA4pSA4pSAdGVybWluYXRlKCnilIDilIDilIDilIDilIDilIDilIDilIDilIIgIGRpc2Nvbm5lY3RlZCAg4pSC4peA4pSA4pSQXG4gKiAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmCAg4pSCXG4gKiAgICAgICAgICAgICAgICDilrwgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgIOKWsiAgICAgIOKUglxuICogICAgICAg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQICAgICAgICAgICBuZXcgV2ViU29ja2V0KCkgIOKUgiAgICAgIOKUglxuICogICAg4pSM4pSA4pa24pSCICAgdGVybWluYXRlZCAgIOKUguKXgOKUgOKUgOKUgOKUgOKUgOKUgOKUkCAgICAgICAgICAgIOKUgiAgICAgICDilIIgICAgICDilIJcbiAqICAgIOKUgiAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYICAgICAgIOKUgiAgICAgICAgICAgIOKUgiAgICAgICDilIIgICAgICDilIJcbiAqICAgIOKUgiAgICAgICAgICAg4payICAgICAgICAgIHRlcm1pbmF0ZSgpICAgICAgIOKUgiAgICBjbG9zZSgpIGNsb3NlKClcbiAqICAgIOKUgiAgICAgIHRlcm1pbmF0ZSgpICAgICAgICAgIOKUgiAgICAgICAgICAgIOKUgiAgICAgICDilIIgICAgICDilIJcbiAqICAgIOKUgiAgICAgICAgICAg4pSCICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAg4pa8ICAgICAgIOKUgiAgICAgIOKUglxuICogICAg4pSCICDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJAgICAgICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQICDilIJcbiAqICAgIOKUgiAg4pSCICAgIHN0b3BwZWQgICAgIOKUguKUgOKUgHJlc3RhcnQoKeKUgOKUgOKUgOKWtuKUgiAgIGNvbm5lY3RpbmcgICDilIIgIOKUglxuICogICAg4pSCICDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJggICAgICAgICAgICAgICDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJggIOKUglxuICogICAg4pSCICAgICAgICAgICDilrIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICDilIJcbiAqICAgIOKUgiAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ub3BlbiAgICAgIOKUglxuICogICAg4pSCICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICDilIJcbiAqICAgIOKUgiAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilrwgICAgICAgICAg4pSCXG4gKiB0ZXJtaW5hdGUoKSAgICDilIIgICAgICAgICAgICAgICAgICAgICAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkCAg4pSCXG4gKiAgICDilIIgICAgICAgICAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgHN0b3AoKeKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgiAgICAgcmVhZHkgICAgICDilILilIDilIDilJhcbiAqICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG4gKiAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuICogICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAqICAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuICpcbiAqIFRoZSBgY29ubmVjdGluZ2AgYW5kIGByZWFkeWAgc3RhdGUgaGF2ZSBhIHN1Yi1zdGF0ZS1tYWNoaW5lIGZvciBwYXVzaW5nLlxuICovXG5cbnR5cGUgU29ja2V0ID1cbiAgfCB7IHN0YXRlOiBcImRpc2Nvbm5lY3RlZFwiIH1cbiAgfCB7IHN0YXRlOiBcImNvbm5lY3RpbmdcIjsgd3M6IFdlYlNvY2tldDsgcGF1c2VkOiBcInllc1wiIHwgXCJub1wiIH1cbiAgfCB7IHN0YXRlOiBcInJlYWR5XCI7IHdzOiBXZWJTb2NrZXQ7IHBhdXNlZDogXCJ5ZXNcIiB8IFwibm9cIiB8IFwidW5pbml0aWFsaXplZFwiIH1cbiAgfCB7IHN0YXRlOiBcInN0b3BwZWRcIiB9XG4gIHwgeyBzdGF0ZTogXCJ0ZXJtaW5hdGVkXCIgfTtcblxuZXhwb3J0IHR5cGUgUmVjb25uZWN0TWV0YWRhdGEgPSB7XG4gIGNvbm5lY3Rpb25Db3VudDogbnVtYmVyO1xuICBsYXN0Q2xvc2VSZWFzb246IHN0cmluZyB8IG51bGw7XG4gIGNsaWVudFRzOiBudW1iZXI7XG59O1xuXG5leHBvcnQgdHlwZSBPbk1lc3NhZ2VSZXNwb25zZSA9IHtcbiAgaGFzU3luY2VkUGFzdExhc3RSZWNvbm5lY3Q6IGJvb2xlYW47XG59O1xuXG5sZXQgZmlyc3RUaW1lOiBudW1iZXIgfCB1bmRlZmluZWQ7XG5mdW5jdGlvbiBtb25vdG9uaWNNaWxsaXMoKSB7XG4gIGlmIChmaXJzdFRpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIGZpcnN0VGltZSA9IERhdGUubm93KCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhcGVyZm9ybWFuY2Uubm93KSB7XG4gICAgcmV0dXJuIERhdGUubm93KCk7XG4gIH1cbiAgcmV0dXJuIE1hdGgucm91bmQoZmlyc3RUaW1lICsgcGVyZm9ybWFuY2Uubm93KCkpO1xufVxuXG5mdW5jdGlvbiBwcmV0dHlOb3coKSB7XG4gIHJldHVybiBgdD0ke01hdGgucm91bmQoKG1vbm90b25pY01pbGxpcygpIC0gZmlyc3RUaW1lISkgLyAxMDApIC8gMTB9c2A7XG59XG5cbmNvbnN0IHNlcnZlckRpc2Nvbm5lY3RFcnJvcnMgPSB7XG4gIC8vIEEga25vd24gZXJyb3IsIGUuZy4gZHVyaW5nIGEgcmVzdGFydCBvciBwdXNoXG4gIEludGVybmFsU2VydmVyRXJyb3I6IHsgdGltZW91dDogMTAwMCB9LFxuICAvLyBFcnJvck1ldGFkYXRhOjpvdmVybG9hZGVkKCkgbWVzc2FnZXMgdGhhdCB3ZSByZWFseSBzaG91bGQgYmFjayBvZmZcbiAgU3Vic2NyaXB0aW9uc1dvcmtlckZ1bGxFcnJvcjogeyB0aW1lb3V0OiAzMDAwIH0sXG4gIFRvb01hbnlDb25jdXJyZW50UmVxdWVzdHM6IHsgdGltZW91dDogMzAwMCB9LFxuICBDb21taXR0ZXJGdWxsRXJyb3I6IHsgdGltZW91dDogMzAwMCB9LFxuICBBd3NUb29NYW55UmVxdWVzdHNFeGNlcHRpb246IHsgdGltZW91dDogMzAwMCB9LFxuICBFeGVjdXRlRnVsbEVycm9yOiB7IHRpbWVvdXQ6IDMwMDAgfSxcbiAgU3lzdGVtVGltZW91dEVycm9yOiB7IHRpbWVvdXQ6IDMwMDAgfSxcbiAgRXhwaXJlZEluUXVldWU6IHsgdGltZW91dDogMzAwMCB9LFxuICAvLyBFcnJvck1ldGFkYXRhOjpmZWF0dXJlX3RlbXBvcmFyaWx5X3VuYXZhaWxhYmxlKCkgdGhhdCB0eXBpY2FsbHkgaW5kaWNhdGUgYSBkZXBsb3kganVzdCBoYXBwZW5lZFxuICBWZWN0b3JJbmRleGVzVW5hdmFpbGFibGU6IHsgdGltZW91dDogMTAwMCB9LFxuICBTZWFyY2hJbmRleGVzVW5hdmFpbGFibGU6IHsgdGltZW91dDogMTAwMCB9LFxuICBUYWJsZVN1bW1hcmllc1VuYXZhaWxhYmxlOiB7IHRpbWVvdXQ6IDEwMDAgfSxcbiAgLy8gTW9yZSBFcnJvck1ldGFkYXRhOjpvdmVybG9hZGVkKClcbiAgVmVjdG9ySW5kZXhUb29MYXJnZTogeyB0aW1lb3V0OiAzMDAwIH0sXG4gIFNlYXJjaEluZGV4VG9vTGFyZ2U6IHsgdGltZW91dDogMzAwMCB9LFxuICBUb29NYW55V3JpdGVzSW5UaW1lUGVyaW9kOiB7IHRpbWVvdXQ6IDMwMDAgfSxcbn0gYXMgY29uc3Qgc2F0aXNmaWVzIFJlY29yZDxzdHJpbmcsIHsgdGltZW91dDogbnVtYmVyIH0+O1xuXG50eXBlIFNlcnZlckRpc2Nvbm5lY3RFcnJvciA9IGtleW9mIHR5cGVvZiBzZXJ2ZXJEaXNjb25uZWN0RXJyb3JzIHwgXCJVbmtub3duXCI7XG5cbmZ1bmN0aW9uIGNsYXNzaWZ5RGlzY29ubmVjdEVycm9yKHM/OiBzdHJpbmcpOiBTZXJ2ZXJEaXNjb25uZWN0RXJyb3Ige1xuICBpZiAocyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gXCJVbmtub3duXCI7XG4gIC8vIHN0YXJ0c1dpdGggc28gbW9yZSBpbmZvIGNvdWxkIGJlIGF0IHRoZSBlbmQgKGFsdGhvdWdoIGN1cnJlbnRseSB0aGVyZSBpc24ndClcblxuICBmb3IgKGNvbnN0IHByZWZpeCBvZiBPYmplY3Qua2V5cyhcbiAgICBzZXJ2ZXJEaXNjb25uZWN0RXJyb3JzLFxuICApIGFzIFNlcnZlckRpc2Nvbm5lY3RFcnJvcltdKSB7XG4gICAgaWYgKHMuc3RhcnRzV2l0aChwcmVmaXgpKSB7XG4gICAgICByZXR1cm4gcHJlZml4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gXCJVbmtub3duXCI7XG59XG5cbi8qKlxuICogQSB3cmFwcGVyIGFyb3VuZCBhIHdlYnNvY2tldCB0aGF0IGhhbmRsZXMgZXJyb3JzLCByZWNvbm5lY3Rpb24sIGFuZCBtZXNzYWdlXG4gKiBwYXJzaW5nLlxuICovXG5leHBvcnQgY2xhc3MgV2ViU29ja2V0TWFuYWdlciB7XG4gIHByaXZhdGUgc29ja2V0OiBTb2NrZXQ7XG5cbiAgcHJpdmF0ZSBjb25uZWN0aW9uQ291bnQ6IG51bWJlcjtcbiAgcHJpdmF0ZSBfaGFzRXZlckNvbm5lY3RlZDogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIGxhc3RDbG9zZVJlYXNvbjpcbiAgICB8IFwiSW5pdGlhbENvbm5lY3RcIlxuICAgIHwgXCJPbkNsb3NlSW52b2tlZFwiXG4gICAgfCAoc3RyaW5nICYge30pIC8vIGEgZnVsbCBzZXJ2ZXJFcnJvclJlYXNvbiAobm90IGp1c3QgdGhlIHByZWZpeCkgb3IgYSBuZXcgb25lXG4gICAgfCBudWxsO1xuXG4gIC8vIFN0YXRlIGZvciBhc3NlbWJsaW5nIHRoZSBzcGxpdC11cCBUcmFuc2l0aW9uIGN1cnJlbnRseSBiZWluZyByZWNlaXZlZC5cbiAgcHJpdmF0ZSB0cmFuc2l0aW9uQ2h1bmtCdWZmZXI6IHtcbiAgICBjaHVua3M6IHN0cmluZ1tdO1xuICAgIHRvdGFsUGFydHM6IG51bWJlcjtcbiAgICB0cmFuc2l0aW9uSWQ6IHN0cmluZztcbiAgfSB8IG51bGwgPSBudWxsO1xuXG4gIC8qKiBVcG9uIEhUVFBTL1dTUyBmYWlsdXJlLCB0aGUgZmlyc3Qgaml0dGVyZWQgYmFja29mZiBkdXJhdGlvbiwgaW4gbXMuICovXG4gIHByaXZhdGUgcmVhZG9ubHkgZGVmYXVsdEluaXRpYWxCYWNrb2ZmOiBudW1iZXI7XG5cbiAgLyoqIFdlIGJhY2tvZmYgZXhwb25lbnRpYWxseSwgYnV0IHdlIG5lZWQgdG8gY2FwIHRoYXQtLXRoaXMgaXMgdGhlIGppdHRlcmVkIG1heC4gKi9cbiAgcHJpdmF0ZSByZWFkb25seSBtYXhCYWNrb2ZmOiBudW1iZXI7XG5cbiAgLyoqIEhvdyBtYW55IHRpbWVzIGhhdmUgd2UgZmFpbGVkIGNvbnNlY3V0aXZlbHk/ICovXG4gIHByaXZhdGUgcmV0cmllczogbnVtYmVyO1xuXG4gIC8qKiBIb3cgbG9uZyBiZWZvcmUgbGFjayBvZiBzZXJ2ZXIgcmVzcG9uc2UgY2F1c2VzIHVzIHRvIGluaXRpYXRlIGEgcmVjb25uZWN0LFxuICAgKiBpbiBtcyAqL1xuICBwcml2YXRlIHJlYWRvbmx5IHNlcnZlckluYWN0aXZpdHlUaHJlc2hvbGQ6IG51bWJlcjtcblxuICBwcml2YXRlIHJlY29ubmVjdER1ZVRvU2VydmVySW5hY3Rpdml0eVRpbWVvdXQ6IFJldHVyblR5cGU8XG4gICAgdHlwZW9mIHNldFRpbWVvdXRcbiAgPiB8IG51bGw7XG5cbiAgcHJpdmF0ZSByZWFkb25seSB1cmk6IHN0cmluZztcbiAgcHJpdmF0ZSByZWFkb25seSBvbk9wZW46IChyZWNvbm5lY3RNZXRhZGF0YTogUmVjb25uZWN0TWV0YWRhdGEpID0+IHZvaWQ7XG4gIHByaXZhdGUgcmVhZG9ubHkgb25SZXN1bWU6ICgpID0+IHZvaWQ7XG4gIHByaXZhdGUgcmVhZG9ubHkgb25NZXNzYWdlOiAobWVzc2FnZTogU2VydmVyTWVzc2FnZSkgPT4gT25NZXNzYWdlUmVzcG9uc2U7XG4gIHByaXZhdGUgcmVhZG9ubHkgd2ViU29ja2V0Q29uc3RydWN0b3I6IHR5cGVvZiBXZWJTb2NrZXQ7XG4gIHByaXZhdGUgcmVhZG9ubHkgbG9nZ2VyOiBMb2dnZXI7XG4gIHByaXZhdGUgcmVhZG9ubHkgb25TZXJ2ZXJEaXNjb25uZWN0RXJyb3I6XG4gICAgfCAoKG1lc3NhZ2U6IHN0cmluZykgPT4gdm9pZClcbiAgICB8IHVuZGVmaW5lZDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICB1cmk6IHN0cmluZyxcbiAgICBjYWxsYmFja3M6IHtcbiAgICAgIG9uT3BlbjogKHJlY29ubmVjdE1ldGFkYXRhOiBSZWNvbm5lY3RNZXRhZGF0YSkgPT4gdm9pZDtcbiAgICAgIG9uUmVzdW1lOiAoKSA9PiB2b2lkO1xuICAgICAgb25NZXNzYWdlOiAobWVzc2FnZTogU2VydmVyTWVzc2FnZSkgPT4gT25NZXNzYWdlUmVzcG9uc2U7XG4gICAgICBvblNlcnZlckRpc2Nvbm5lY3RFcnJvcj86ICgobWVzc2FnZTogc3RyaW5nKSA9PiB2b2lkKSB8IHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIHdlYlNvY2tldENvbnN0cnVjdG9yOiB0eXBlb2YgV2ViU29ja2V0LFxuICAgIGxvZ2dlcjogTG9nZ2VyLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgbWFya0Nvbm5lY3Rpb25TdGF0ZURpcnR5OiAoKSA9PiB2b2lkLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZGVidWc6IGJvb2xlYW4sXG4gICkge1xuICAgIHRoaXMud2ViU29ja2V0Q29uc3RydWN0b3IgPSB3ZWJTb2NrZXRDb25zdHJ1Y3RvcjtcbiAgICB0aGlzLnNvY2tldCA9IHsgc3RhdGU6IFwiZGlzY29ubmVjdGVkXCIgfTtcbiAgICB0aGlzLmNvbm5lY3Rpb25Db3VudCA9IDA7XG4gICAgdGhpcy5sYXN0Q2xvc2VSZWFzb24gPSBcIkluaXRpYWxDb25uZWN0XCI7XG5cbiAgICAvLyBiYWNrb2ZmIGZvciB1bmtub3duIGVycm9yc1xuICAgIHRoaXMuZGVmYXVsdEluaXRpYWxCYWNrb2ZmID0gMTAwMDtcbiAgICB0aGlzLm1heEJhY2tvZmYgPSAxNjAwMDtcbiAgICB0aGlzLnJldHJpZXMgPSAwO1xuXG4gICAgLy8gUGluZyBtZXNzYWdlcyAoc3luYyBwcm90b2NvbCBQaW5ncywgbm90IFdlYlNvY2tldCBwcm90b2NvbCBQaW5ncykgYXJlXG4gICAgLy8gc2VudCBldmVyeSAxNXMgaW4gdGhlIGFic2VuY2Ugb2Ygb3RoZXIgbWVzc2FnZXMuIEJ1dCBhIHNpbmdsZSBsYXJnZVxuICAgIC8vIFRyYW5zaXRpb24gb3Igb3RoZXIgZG93bnN0cmVhbSBtZXNzYWdlIGNhbiBob2cgdGhlIGxpbmUgc28gdGhpc1xuICAgIC8vIHRocmVzaG9sZCBpcyBzZXQgaGlnaGVyIHRvIHByZXZlbnQgY2xpZW50cyBmcm9tIGdpdmluZyB1cC5cbiAgICB0aGlzLnNlcnZlckluYWN0aXZpdHlUaHJlc2hvbGQgPSA2MDAwMDtcbiAgICB0aGlzLnJlY29ubmVjdER1ZVRvU2VydmVySW5hY3Rpdml0eVRpbWVvdXQgPSBudWxsO1xuXG4gICAgdGhpcy51cmkgPSB1cmk7XG4gICAgdGhpcy5vbk9wZW4gPSBjYWxsYmFja3Mub25PcGVuO1xuICAgIHRoaXMub25SZXN1bWUgPSBjYWxsYmFja3Mub25SZXN1bWU7XG4gICAgdGhpcy5vbk1lc3NhZ2UgPSBjYWxsYmFja3Mub25NZXNzYWdlO1xuICAgIHRoaXMub25TZXJ2ZXJEaXNjb25uZWN0RXJyb3IgPSBjYWxsYmFja3Mub25TZXJ2ZXJEaXNjb25uZWN0RXJyb3I7XG4gICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG5cbiAgICB0aGlzLmNvbm5lY3QoKTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0U29ja2V0U3RhdGUoc3RhdGU6IFNvY2tldCkge1xuICAgIHRoaXMuc29ja2V0ID0gc3RhdGU7XG4gICAgdGhpcy5fbG9nVmVyYm9zZShcbiAgICAgIGBzb2NrZXQgc3RhdGUgY2hhbmdlZDogJHt0aGlzLnNvY2tldC5zdGF0ZX0sIHBhdXNlZDogJHtcbiAgICAgICAgXCJwYXVzZWRcIiBpbiB0aGlzLnNvY2tldCA/IHRoaXMuc29ja2V0LnBhdXNlZCA6IHVuZGVmaW5lZFxuICAgICAgfWAsXG4gICAgKTtcbiAgICB0aGlzLm1hcmtDb25uZWN0aW9uU3RhdGVEaXJ0eSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3NlbWJsZVRyYW5zaXRpb24oY2h1bms6IFRyYW5zaXRpb25DaHVuayk6IFRyYW5zaXRpb24gfCBudWxsIHtcbiAgICBpZiAoXG4gICAgICBjaHVuay5wYXJ0TnVtYmVyIDwgMCB8fFxuICAgICAgY2h1bmsucGFydE51bWJlciA+PSBjaHVuay50b3RhbFBhcnRzIHx8XG4gICAgICBjaHVuay50b3RhbFBhcnRzID09PSAwIHx8XG4gICAgICAodGhpcy50cmFuc2l0aW9uQ2h1bmtCdWZmZXIgJiZcbiAgICAgICAgKHRoaXMudHJhbnNpdGlvbkNodW5rQnVmZmVyLnRvdGFsUGFydHMgIT09IGNodW5rLnRvdGFsUGFydHMgfHxcbiAgICAgICAgICB0aGlzLnRyYW5zaXRpb25DaHVua0J1ZmZlci50cmFuc2l0aW9uSWQgIT09IGNodW5rLnRyYW5zaXRpb25JZCkpXG4gICAgKSB7XG4gICAgICAvLyBUaHJvd2luZyBhbiBlcnJvciBkb2Vzbid0IGNyYXNoIHRoZSBjbGllbnQsIHNvIGNsZWFyIHRoZSBidWZmZXIuXG4gICAgICB0aGlzLnRyYW5zaXRpb25DaHVua0J1ZmZlciA9IG51bGw7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFRyYW5zaXRpb25DaHVua1wiKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50cmFuc2l0aW9uQ2h1bmtCdWZmZXIgPT09IG51bGwpIHtcbiAgICAgIHRoaXMudHJhbnNpdGlvbkNodW5rQnVmZmVyID0ge1xuICAgICAgICBjaHVua3M6IFtdLFxuICAgICAgICB0b3RhbFBhcnRzOiBjaHVuay50b3RhbFBhcnRzLFxuICAgICAgICB0cmFuc2l0aW9uSWQ6IGNodW5rLnRyYW5zaXRpb25JZCxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKGNodW5rLnBhcnROdW1iZXIgIT09IHRoaXMudHJhbnNpdGlvbkNodW5rQnVmZmVyLmNodW5rcy5sZW5ndGgpIHtcbiAgICAgIC8vIFRocm93aW5nIGFuIGVycm9yIGRvZXNuJ3QgY3Jhc2ggdGhlIGNsaWVudCwgc28gY2xlYXIgdGhlIGJ1ZmZlci5cbiAgICAgIGNvbnN0IGV4cGVjdGVkTGVuZ3RoID0gdGhpcy50cmFuc2l0aW9uQ2h1bmtCdWZmZXIuY2h1bmtzLmxlbmd0aDtcbiAgICAgIHRoaXMudHJhbnNpdGlvbkNodW5rQnVmZmVyID0gbnVsbDtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFRyYW5zaXRpb25DaHVuayByZWNlaXZlZCBvdXQgb2Ygb3JkZXI6IGV4cGVjdGVkIHBhcnQgJHtleHBlY3RlZExlbmd0aH0sIGdvdCAke2NodW5rLnBhcnROdW1iZXJ9YCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy50cmFuc2l0aW9uQ2h1bmtCdWZmZXIuY2h1bmtzLnB1c2goY2h1bmsuY2h1bmspO1xuXG4gICAgaWYgKHRoaXMudHJhbnNpdGlvbkNodW5rQnVmZmVyLmNodW5rcy5sZW5ndGggPT09IGNodW5rLnRvdGFsUGFydHMpIHtcbiAgICAgIGNvbnN0IGZ1bGxKc29uID0gdGhpcy50cmFuc2l0aW9uQ2h1bmtCdWZmZXIuY2h1bmtzLmpvaW4oXCJcIik7XG4gICAgICB0aGlzLnRyYW5zaXRpb25DaHVua0J1ZmZlciA9IG51bGw7XG5cbiAgICAgIGNvbnN0IHRyYW5zaXRpb24gPSBwYXJzZVNlcnZlck1lc3NhZ2UoSlNPTi5wYXJzZShmdWxsSnNvbikpO1xuICAgICAgaWYgKHRyYW5zaXRpb24udHlwZSAhPT0gXCJUcmFuc2l0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBFeHBlY3RlZCBUcmFuc2l0aW9uLCBnb3QgJHt0cmFuc2l0aW9uLnR5cGV9IGFmdGVyIGFzc2VtYmxpbmcgY2h1bmtzYCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cmFuc2l0aW9uO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcHJpdmF0ZSBjb25uZWN0KCkge1xuICAgIGlmICh0aGlzLnNvY2tldC5zdGF0ZSA9PT0gXCJ0ZXJtaW5hdGVkXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgdGhpcy5zb2NrZXQuc3RhdGUgIT09IFwiZGlzY29ubmVjdGVkXCIgJiZcbiAgICAgIHRoaXMuc29ja2V0LnN0YXRlICE9PSBcInN0b3BwZWRcIlxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkRpZG4ndCBzdGFydCBjb25uZWN0aW9uIGZyb20gZGlzY29ubmVjdGVkIHN0YXRlOiBcIiArIHRoaXMuc29ja2V0LnN0YXRlLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCB3cyA9IG5ldyB0aGlzLndlYlNvY2tldENvbnN0cnVjdG9yKHRoaXMudXJpKTtcbiAgICB0aGlzLl9sb2dWZXJib3NlKFwiY29uc3RydWN0ZWQgV2ViU29ja2V0XCIpO1xuICAgIHRoaXMuc2V0U29ja2V0U3RhdGUoe1xuICAgICAgc3RhdGU6IFwiY29ubmVjdGluZ1wiLFxuICAgICAgd3MsXG4gICAgICBwYXVzZWQ6IFwibm9cIixcbiAgICB9KTtcblxuICAgIC8vIEtpY2sgb2ZmIHNlcnZlciBpbmFjdGl2aXR5IHRpbWVyIGJlZm9yZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZFxuICAgIC8vIHNvIHdlIGNhbiBkZXRlY3QgY2FzZXMgd2hlcmUgaGFuZHNoYWtlIGZhaWxzLlxuICAgIC8vIFRoZSBgb25vcGVuYCBldmVudCBvbmx5IGZpcmVzIGFmdGVyIHRoZSBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkOlxuICAgIC8vIFNvdXJjZTogaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2NDU1I3BhZ2UtMTk6fjp0ZXh0PV9UaGUlMjBXZWJTb2NrZXQlMjBDb25uZWN0aW9uJTIwaXMlMjBFc3RhYmxpc2hlZF8sLWFuZFxuICAgIHRoaXMucmVzZXRTZXJ2ZXJJbmFjdGl2aXR5VGltZW91dCgpO1xuXG4gICAgd3Mub25vcGVuID0gKCkgPT4ge1xuICAgICAgdGhpcy5sb2dnZXIubG9nVmVyYm9zZShcImJlZ2luIHdzLm9ub3BlblwiKTtcbiAgICAgIGlmICh0aGlzLnNvY2tldC5zdGF0ZSAhPT0gXCJjb25uZWN0aW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib25vcGVuIGNhbGxlZCB3aXRoIHNvY2tldCBub3QgaW4gY29ubmVjdGluZyBzdGF0ZVwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0U29ja2V0U3RhdGUoe1xuICAgICAgICBzdGF0ZTogXCJyZWFkeVwiLFxuICAgICAgICB3cyxcbiAgICAgICAgcGF1c2VkOiB0aGlzLnNvY2tldC5wYXVzZWQgPT09IFwieWVzXCIgPyBcInVuaW5pdGlhbGl6ZWRcIiA6IFwibm9cIixcbiAgICAgIH0pO1xuICAgICAgdGhpcy5yZXNldFNlcnZlckluYWN0aXZpdHlUaW1lb3V0KCk7XG4gICAgICBpZiAodGhpcy5zb2NrZXQucGF1c2VkID09PSBcIm5vXCIpIHtcbiAgICAgICAgdGhpcy5faGFzRXZlckNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgIHRoaXMub25PcGVuKHtcbiAgICAgICAgICBjb25uZWN0aW9uQ291bnQ6IHRoaXMuY29ubmVjdGlvbkNvdW50LFxuICAgICAgICAgIGxhc3RDbG9zZVJlYXNvbjogdGhpcy5sYXN0Q2xvc2VSZWFzb24sXG4gICAgICAgICAgY2xpZW50VHM6IG1vbm90b25pY01pbGxpcygpLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubGFzdENsb3NlUmVhc29uICE9PSBcIkluaXRpYWxDb25uZWN0XCIpIHtcbiAgICAgICAgaWYgKHRoaXMubGFzdENsb3NlUmVhc29uKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIubG9nKFxuICAgICAgICAgICAgXCJXZWJTb2NrZXQgcmVjb25uZWN0ZWQgYXRcIixcbiAgICAgICAgICAgIHByZXR0eU5vdygpLFxuICAgICAgICAgICAgXCJhZnRlciBkaXNjb25uZWN0IGR1ZSB0b1wiLFxuICAgICAgICAgICAgdGhpcy5sYXN0Q2xvc2VSZWFzb24sXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJXZWJTb2NrZXQgcmVjb25uZWN0ZWQgYXRcIiwgcHJldHR5Tm93KCkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29ubmVjdGlvbkNvdW50ICs9IDE7XG4gICAgICB0aGlzLmxhc3RDbG9zZVJlYXNvbiA9IG51bGw7XG4gICAgfTtcbiAgICAvLyBOQjogVGhlIFdlYlNvY2tldCBBUEkgY2FsbHMgYG9uY2xvc2VgIGV2ZW4gaWYgY29ubmVjdGlvbiBmYWlscywgc28gd2UgY2FuIHJvdXRlIGFsbCBlcnJvciBwYXRocyB0aHJvdWdoIGBvbmNsb3NlYC5cbiAgICB3cy5vbmVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICB0aGlzLnRyYW5zaXRpb25DaHVua0J1ZmZlciA9IG51bGw7XG4gICAgICBjb25zdCBtZXNzYWdlID0gKGVycm9yIGFzIEVycm9yRXZlbnQpLm1lc3NhZ2U7XG4gICAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coYFdlYlNvY2tldCBlcnJvciBtZXNzYWdlOiAke21lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB3cy5vbm1lc3NhZ2UgPSAobWVzc2FnZSkgPT4ge1xuICAgICAgdGhpcy5yZXNldFNlcnZlckluYWN0aXZpdHlUaW1lb3V0KCk7XG4gICAgICBjb25zdCBtZXNzYWdlTGVuZ3RoID0gbWVzc2FnZS5kYXRhLmxlbmd0aDtcbiAgICAgIGxldCBzZXJ2ZXJNZXNzYWdlID0gcGFyc2VTZXJ2ZXJNZXNzYWdlKEpTT04ucGFyc2UobWVzc2FnZS5kYXRhKSk7XG4gICAgICB0aGlzLl9sb2dWZXJib3NlKGByZWNlaXZlZCB3cyBtZXNzYWdlIHdpdGggdHlwZSAke3NlcnZlck1lc3NhZ2UudHlwZX1gKTtcblxuICAgICAgLy8gUGluZydzIG9ubHkgcHVycG9zZSBpcyB0byByZXNldCB0aGUgc2VydmVyIGluYWN0aXZpdHkgdGltZXIuXG4gICAgICBpZiAoc2VydmVyTWVzc2FnZS50eXBlID09PSBcIlBpbmdcIikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFRyYW5zaXRpb25DaHVua3MgbmV2ZXIgcmVhY2ggdGhlIG1haW4gY2xpZW50IGxvZ2ljLlxuICAgICAgaWYgKHNlcnZlck1lc3NhZ2UudHlwZSA9PT0gXCJUcmFuc2l0aW9uQ2h1bmtcIikge1xuICAgICAgICBjb25zdCB0cmFuc2l0aW9uID0gdGhpcy5hc3NlbWJsZVRyYW5zaXRpb24oc2VydmVyTWVzc2FnZSk7XG4gICAgICAgIGlmICghdHJhbnNpdGlvbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZXJ2ZXJNZXNzYWdlID0gdHJhbnNpdGlvbjtcbiAgICAgICAgdGhpcy5fbG9nVmVyYm9zZShcbiAgICAgICAgICBgYXNzZW1ibGVkIGZ1bGwgd3MgbWVzc2FnZSBvZiB0eXBlICR7c2VydmVyTWVzc2FnZS50eXBlfWAsXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnRyYW5zaXRpb25DaHVua0J1ZmZlciAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnRyYW5zaXRpb25DaHVua0J1ZmZlciA9IG51bGw7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcbiAgICAgICAgICBgUmVjZWl2ZWQgdW5leHBlY3RlZCAke3NlcnZlck1lc3NhZ2UudHlwZX0gd2hpbGUgYnVmZmVyaW5nIFRyYW5zaXRpb25DaHVua3NgLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VydmVyTWVzc2FnZS50eXBlID09PSBcIlRyYW5zaXRpb25cIikge1xuICAgICAgICB0aGlzLnJlcG9ydExhcmdlVHJhbnNpdGlvbih7XG4gICAgICAgICAgbWVzc2FnZUxlbmd0aCxcbiAgICAgICAgICB0cmFuc2l0aW9uOiBzZXJ2ZXJNZXNzYWdlLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gdGhpcy5vbk1lc3NhZ2Uoc2VydmVyTWVzc2FnZSk7XG4gICAgICBpZiAocmVzcG9uc2UuaGFzU3luY2VkUGFzdExhc3RSZWNvbm5lY3QpIHtcbiAgICAgICAgLy8gUmVzZXQgYmFja29mZiB0byAwIG9uY2UgYWxsIG91dHN0YW5kaW5nIHJlcXVlc3RzIGFyZSBjb21wbGV0ZS5cbiAgICAgICAgdGhpcy5yZXRyaWVzID0gMDtcbiAgICAgICAgdGhpcy5tYXJrQ29ubmVjdGlvblN0YXRlRGlydHkoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdzLm9uY2xvc2UgPSAoZXZlbnQpID0+IHtcbiAgICAgIHRoaXMuX2xvZ1ZlcmJvc2UoXCJiZWdpbiB3cy5vbmNsb3NlXCIpO1xuICAgICAgdGhpcy50cmFuc2l0aW9uQ2h1bmtCdWZmZXIgPSBudWxsO1xuICAgICAgaWYgKHRoaXMubGFzdENsb3NlUmVhc29uID09PSBudWxsKSB7XG4gICAgICAgIC8vIGV2ZW50LnJlYXNvbiBpcyBvZnRlbiBhbiBlbXB0eSBzdHJpbmdcbiAgICAgICAgdGhpcy5sYXN0Q2xvc2VSZWFzb24gPSBldmVudC5yZWFzb24gfHwgYGNsb3NlZCB3aXRoIGNvZGUgJHtldmVudC5jb2RlfWA7XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIGV2ZW50LmNvZGUgIT09IENMT1NFX05PUk1BTCAmJlxuICAgICAgICBldmVudC5jb2RlICE9PSBDTE9TRV9HT0lOR19BV0FZICYmIC8vIFRoaXMgY29tbW9ubHkgZ2V0cyBmaXJlZCBvbiBtb2JpbGUgYXBwcyB3aGVuIHRoZSBhcHAgaXMgYmFja2dyb3VuZGVkXG4gICAgICAgIGV2ZW50LmNvZGUgIT09IENMT1NFX05PX1NUQVRVUyAmJlxuICAgICAgICBldmVudC5jb2RlICE9PSBDTE9TRV9OT1RfRk9VTkQgLy8gTm90ZSB0aGF0IHdlIHdhbnQgdG8gcmV0cnkgb24gYSA0MDQsIGFzIGl0IGNhbiBiZSB0cmFuc2llbnQgZHVyaW5nIGEgcHVzaC5cbiAgICAgICkge1xuICAgICAgICBsZXQgbXNnID0gYFdlYlNvY2tldCBjbG9zZWQgd2l0aCBjb2RlICR7ZXZlbnQuY29kZX1gO1xuICAgICAgICBpZiAoZXZlbnQucmVhc29uKSB7XG4gICAgICAgICAgbXNnICs9IGA6ICR7ZXZlbnQucmVhc29ufWA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKG1zZyk7XG4gICAgICAgIGlmICh0aGlzLm9uU2VydmVyRGlzY29ubmVjdEVycm9yICYmIGV2ZW50LnJlYXNvbikge1xuICAgICAgICAgIC8vIFRoaXMgY2FsbGJhY2sgaXMgYSB1bnN0YWJsZSBBUEksIEludGVybmFsU2VydmVyRXJyb3JzIGluIHBhcnRpY3VsYXIgbWF5IGJlIHJlbW92ZWRcbiAgICAgICAgICAvLyBzaW5jZSB0aGV5IHJlZmxlY3QgZXhwZWN0ZWQgdGVtcG9yYXJ5IGRvd250aW1lLiBCdXQgdW50aWwgYSBxdWFudGl0YXRpdmUgbWVhc3VyZVxuICAgICAgICAgIC8vIG9mIHVwdGltZSBpcyByZXBvcnRlZCB0aGlzIHVuc3RhYmxlIEFQSSBlcnJzIG9uIHRoZSBpbmNsdXNpdmUgc2lkZS5cbiAgICAgICAgICB0aGlzLm9uU2VydmVyRGlzY29ubmVjdEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlYXNvbiA9IGNsYXNzaWZ5RGlzY29ubmVjdEVycm9yKGV2ZW50LnJlYXNvbik7XG4gICAgICB0aGlzLnNjaGVkdWxlUmVjb25uZWN0KHJlYXNvbik7XG4gICAgICByZXR1cm47XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBUaGUgc3RhdGUgb2YgdGhlIHtAbGluayBTb2NrZXR9LlxuICAgKi9cbiAgc29ja2V0U3RhdGUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5zb2NrZXQuc3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIG1lc3NhZ2UgLSBBIENsaWVudE1lc3NhZ2UgdG8gc2VuZC5cbiAgICogQHJldHVybnMgV2hldGhlciB0aGUgbWVzc2FnZSAobWlnaHQgaGF2ZSBiZWVuKSBzZW50LlxuICAgKi9cbiAgc2VuZE1lc3NhZ2UobWVzc2FnZTogQ2xpZW50TWVzc2FnZSkge1xuICAgIGNvbnN0IG1lc3NhZ2VGb3JMb2cgPSB7XG4gICAgICB0eXBlOiBtZXNzYWdlLnR5cGUsXG4gICAgICAuLi4obWVzc2FnZS50eXBlID09PSBcIkF1dGhlbnRpY2F0ZVwiICYmIG1lc3NhZ2UudG9rZW5UeXBlID09PSBcIlVzZXJcIlxuICAgICAgICA/IHtcbiAgICAgICAgICAgIHZhbHVlOiBgLi4uJHttZXNzYWdlLnZhbHVlLnNsaWNlKC03KX1gLFxuICAgICAgICAgIH1cbiAgICAgICAgOiB7fSksXG4gICAgfTtcbiAgICBpZiAodGhpcy5zb2NrZXQuc3RhdGUgPT09IFwicmVhZHlcIiAmJiB0aGlzLnNvY2tldC5wYXVzZWQgPT09IFwibm9cIikge1xuICAgICAgY29uc3QgZW5jb2RlZE1lc3NhZ2UgPSBlbmNvZGVDbGllbnRNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgY29uc3QgcmVxdWVzdCA9IEpTT04uc3RyaW5naWZ5KGVuY29kZWRNZXNzYWdlKTtcbiAgICAgIGxldCBzZW50ID0gZmFsc2U7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnNvY2tldC53cy5zZW5kKHJlcXVlc3QpO1xuICAgICAgICBzZW50ID0gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFxuICAgICAgICAgIGBGYWlsZWQgdG8gc2VuZCBtZXNzYWdlIG9uIFdlYlNvY2tldCwgcmVjb25uZWN0aW5nOiAke2Vycm9yfWAsXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuY2xvc2VBbmRSZWNvbm5lY3QoXCJGYWlsZWRUb1NlbmRNZXNzYWdlXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbG9nVmVyYm9zZShcbiAgICAgICAgYCR7c2VudCA/IFwic2VudFwiIDogXCJmYWlsZWQgdG8gc2VuZFwifSBtZXNzYWdlIHdpdGggdHlwZSAke21lc3NhZ2UudHlwZX06ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgbWVzc2FnZUZvckxvZyxcbiAgICAgICAgKX1gLFxuICAgICAgKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9sb2dWZXJib3NlKFxuICAgICAgYG1lc3NhZ2Ugbm90IHNlbnQgKHNvY2tldCBzdGF0ZTogJHt0aGlzLnNvY2tldC5zdGF0ZX0sIHBhdXNlZDogJHtcInBhdXNlZFwiIGluIHRoaXMuc29ja2V0ID8gdGhpcy5zb2NrZXQucGF1c2VkIDogdW5kZWZpbmVkfSk6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgIG1lc3NhZ2VGb3JMb2csXG4gICAgICApfWAsXG4gICAgKTtcblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHByaXZhdGUgcmVzZXRTZXJ2ZXJJbmFjdGl2aXR5VGltZW91dCgpIHtcbiAgICBpZiAodGhpcy5zb2NrZXQuc3RhdGUgPT09IFwidGVybWluYXRlZFwiKSB7XG4gICAgICAvLyBEb24ndCByZXNldCBhbnkgdGltZXJzIGlmIHdlIHdlcmUgdHJ5aW5nIHRvIHRlcm1pbmF0ZS5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMucmVjb25uZWN0RHVlVG9TZXJ2ZXJJbmFjdGl2aXR5VGltZW91dCAhPT0gbnVsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVjb25uZWN0RHVlVG9TZXJ2ZXJJbmFjdGl2aXR5VGltZW91dCk7XG4gICAgICB0aGlzLnJlY29ubmVjdER1ZVRvU2VydmVySW5hY3Rpdml0eVRpbWVvdXQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLnJlY29ubmVjdER1ZVRvU2VydmVySW5hY3Rpdml0eVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuY2xvc2VBbmRSZWNvbm5lY3QoXCJJbmFjdGl2ZVNlcnZlclwiKTtcbiAgICB9LCB0aGlzLnNlcnZlckluYWN0aXZpdHlUaHJlc2hvbGQpO1xuICB9XG5cbiAgcHJpdmF0ZSBzY2hlZHVsZVJlY29ubmVjdChyZWFzb246IFwiY2xpZW50XCIgfCBTZXJ2ZXJEaXNjb25uZWN0RXJyb3IpIHtcbiAgICB0aGlzLnNvY2tldCA9IHsgc3RhdGU6IFwiZGlzY29ubmVjdGVkXCIgfTtcbiAgICBjb25zdCBiYWNrb2ZmID0gdGhpcy5uZXh0QmFja29mZihyZWFzb24pO1xuICAgIHRoaXMubWFya0Nvbm5lY3Rpb25TdGF0ZURpcnR5KCk7XG4gICAgdGhpcy5sb2dnZXIubG9nKGBBdHRlbXB0aW5nIHJlY29ubmVjdCBpbiAke01hdGgucm91bmQoYmFja29mZil9bXNgKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuY29ubmVjdCgpLCBiYWNrb2ZmKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZSB0aGUgV2ViU29ja2V0IGFuZCBzY2hlZHVsZSBhIHJlY29ubmVjdC5cbiAgICpcbiAgICogVGhpcyBzaG91bGQgYmUgdXNlZCB3aGVuIHdlIGhpdCBhbiBlcnJvciBhbmQgd291bGQgbGlrZSB0byByZXN0YXJ0IHRoZSBzZXNzaW9uLlxuICAgKi9cbiAgcHJpdmF0ZSBjbG9zZUFuZFJlY29ubmVjdChjbG9zZVJlYXNvbjogc3RyaW5nKSB7XG4gICAgdGhpcy5fbG9nVmVyYm9zZShgYmVnaW4gY2xvc2VBbmRSZWNvbm5lY3Qgd2l0aCByZWFzb24gJHtjbG9zZVJlYXNvbn1gKTtcbiAgICBzd2l0Y2ggKHRoaXMuc29ja2V0LnN0YXRlKSB7XG4gICAgICBjYXNlIFwiZGlzY29ubmVjdGVkXCI6XG4gICAgICBjYXNlIFwidGVybWluYXRlZFwiOlxuICAgICAgY2FzZSBcInN0b3BwZWRcIjpcbiAgICAgICAgLy8gTm90aGluZyB0byBkbyBpZiB3ZSBkb24ndCBoYXZlIGEgV2ViU29ja2V0LlxuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiY29ubmVjdGluZ1wiOlxuICAgICAgY2FzZSBcInJlYWR5XCI6IHtcbiAgICAgICAgdGhpcy5sYXN0Q2xvc2VSZWFzb24gPSBjbG9zZVJlYXNvbjtcbiAgICAgICAgLy8gQ2xvc2UgdGhlIG9sZCBzb2NrZXQgYXN5bmNocm9ub3VzbHksIHdlJ2xsIG9wZW4gYSBuZXcgc29ja2V0IGluIHJlY29ubmVjdC5cbiAgICAgICAgdm9pZCB0aGlzLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVSZWNvbm5lY3QoXCJjbGllbnRcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgLy8gRW5mb3JjZSB0aGF0IHRoZSBzd2l0Y2gtY2FzZSBpcyBleGhhdXN0aXZlLlxuICAgICAgICB0aGlzLnNvY2tldCBzYXRpc2ZpZXMgbmV2ZXI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlIHRoZSBXZWJTb2NrZXQsIGJlaW5nIGNhcmVmdWwgdG8gY2xlYXIgdGhlIG9uY2xvc2UgaGFuZGxlciB0byBhdm9pZCByZS1lbnRyYW50XG4gICAqIGNhbGxzLiBVc2UgdGhpcyBpbnN0ZWFkIG9mIGRpcmVjdGx5IGNhbGxpbmcgYHdzLmNsb3NlKClgXG4gICAqXG4gICAqIEl0IGlzIHRoZSBjYWxsZXJzIHJlc3BvbnNpYmlsaXR5IHRvIHVwZGF0ZSB0aGUgc3RhdGUgYWZ0ZXIgdGhpcyBtZXRob2QgaXMgY2FsbGVkIHNvIHRoYXQgdGhlXG4gICAqIGNsb3NlZCBzb2NrZXQgaXMgbm90IGFjY2Vzc2libGUgb3IgdXNlZCBhZ2FpbiBhZnRlciB0aGlzIG1ldGhvZCBpcyBjYWxsZWRcbiAgICovXG4gIHByaXZhdGUgY2xvc2UoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy50cmFuc2l0aW9uQ2h1bmtCdWZmZXIgPSBudWxsO1xuICAgIHN3aXRjaCAodGhpcy5zb2NrZXQuc3RhdGUpIHtcbiAgICAgIGNhc2UgXCJkaXNjb25uZWN0ZWRcIjpcbiAgICAgIGNhc2UgXCJ0ZXJtaW5hdGVkXCI6XG4gICAgICBjYXNlIFwic3RvcHBlZFwiOlxuICAgICAgICAvLyBOb3RoaW5nIHRvIGRvIGlmIHdlIGRvbid0IGhhdmUgYSBXZWJTb2NrZXQuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIGNhc2UgXCJjb25uZWN0aW5nXCI6IHtcbiAgICAgICAgY29uc3Qgd3MgPSB0aGlzLnNvY2tldC53cztcbiAgICAgICAgLy8gTWVzc2FnZXMgY2FuIHN0aWxsIGJlIHJlY2VpdmVkIGFmdGVyIGNsb3NlIGJ1dCB3ZSdyZSBub3QgaW50ZXJlc3RlZC5cbiAgICAgICAgd3Mub25tZXNzYWdlID0gKF9tZXNzYWdlKSA9PiB7XG4gICAgICAgICAgdGhpcy5fbG9nVmVyYm9zZShcIklnbm9yaW5nIG1lc3NhZ2UgcmVjZWl2ZWQgYWZ0ZXIgY2xvc2VcIik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocikgPT4ge1xuICAgICAgICAgIHdzLm9uY2xvc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9sb2dWZXJib3NlKFwiQ2xvc2VkIGFmdGVyIGNvbm5lY3RpbmdcIik7XG4gICAgICAgICAgICByKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB3cy5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9sb2dWZXJib3NlKFwiT3BlbmVkIGFmdGVyIGNvbm5lY3RpbmdcIik7XG4gICAgICAgICAgICB3cy5jbG9zZSgpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY2FzZSBcInJlYWR5XCI6IHtcbiAgICAgICAgdGhpcy5fbG9nVmVyYm9zZShcIndzLmNsb3NlIGNhbGxlZFwiKTtcbiAgICAgICAgY29uc3Qgd3MgPSB0aGlzLnNvY2tldC53cztcbiAgICAgICAgLy8gTWVzc2FnZXMgY2FuIHN0aWxsIGJlIHJlY2VpdmVkIGFmdGVyIGNsb3NlIGJ1dCB3ZSdyZSBub3QgaW50ZXJlc3RlZC5cbiAgICAgICAgd3Mub25tZXNzYWdlID0gKF9tZXNzYWdlKSA9PiB7XG4gICAgICAgICAgdGhpcy5fbG9nVmVyYm9zZShcIklnbm9yaW5nIG1lc3NhZ2UgcmVjZWl2ZWQgYWZ0ZXIgY2xvc2VcIik7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3VsdDogUHJvbWlzZTx2b2lkPiA9IG5ldyBQcm9taXNlKChyKSA9PiB7XG4gICAgICAgICAgd3Mub25jbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHIoKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgd3MuY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgLy8gRW5mb3JjZSB0aGF0IHRoZSBzd2l0Y2gtY2FzZSBpcyBleGhhdXN0aXZlLlxuICAgICAgICB0aGlzLnNvY2tldCBzYXRpc2ZpZXMgbmV2ZXI7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2UgdGhlIFdlYlNvY2tldCBhbmQgZG8gbm90IHJlY29ubmVjdC5cbiAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgV2ViU29ja2V0IGBvbkNsb3NlYCBjYWxsYmFjayBpcyBjYWxsZWQuXG4gICAqL1xuICB0ZXJtaW5hdGUoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMucmVjb25uZWN0RHVlVG9TZXJ2ZXJJbmFjdGl2aXR5VGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVjb25uZWN0RHVlVG9TZXJ2ZXJJbmFjdGl2aXR5VGltZW91dCk7XG4gICAgfVxuICAgIHN3aXRjaCAodGhpcy5zb2NrZXQuc3RhdGUpIHtcbiAgICAgIGNhc2UgXCJ0ZXJtaW5hdGVkXCI6XG4gICAgICBjYXNlIFwic3RvcHBlZFwiOlxuICAgICAgY2FzZSBcImRpc2Nvbm5lY3RlZFwiOlxuICAgICAgY2FzZSBcImNvbm5lY3RpbmdcIjpcbiAgICAgIGNhc2UgXCJyZWFkeVwiOiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5zZXRTb2NrZXRTdGF0ZSh7IHN0YXRlOiBcInRlcm1pbmF0ZWRcIiB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgLy8gRW5mb3JjZSB0aGF0IHRoZSBzd2l0Y2gtY2FzZSBpcyBleGhhdXN0aXZlLlxuICAgICAgICB0aGlzLnNvY2tldCBzYXRpc2ZpZXMgbmV2ZXI7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgSW52YWxpZCB3ZWJzb2NrZXQgc3RhdGU6ICR7KHRoaXMuc29ja2V0IGFzIGFueSkuc3RhdGV9YCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdG9wKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHN3aXRjaCAodGhpcy5zb2NrZXQuc3RhdGUpIHtcbiAgICAgIGNhc2UgXCJ0ZXJtaW5hdGVkXCI6XG4gICAgICAgIC8vIElmIHdlJ3JlIHRlcm1pbmF0aW5nIHdlIGlnbm9yZSBzdG9wXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIGNhc2UgXCJjb25uZWN0aW5nXCI6XG4gICAgICBjYXNlIFwic3RvcHBlZFwiOlxuICAgICAgY2FzZSBcImRpc2Nvbm5lY3RlZFwiOlxuICAgICAgY2FzZSBcInJlYWR5XCI6IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5jbG9zZSgpO1xuICAgICAgICB0aGlzLnNvY2tldCA9IHsgc3RhdGU6IFwic3RvcHBlZFwiIH07XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIC8vIEVuZm9yY2UgdGhhdCB0aGUgc3dpdGNoLWNhc2UgaXMgZXhoYXVzdGl2ZS5cbiAgICAgICAgdGhpcy5zb2NrZXQgc2F0aXNmaWVzIG5ldmVyO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBXZWJTb2NrZXQgYWZ0ZXIgYSBwcmV2aW91cyBgc3RvcCgpYCwgdW5sZXNzIGB0ZXJtaW5hdGUoKWAgd2FzXG4gICAqIGNhbGxlZCBiZWZvcmUuXG4gICAqL1xuICB0cnlSZXN0YXJ0KCk6IHZvaWQge1xuICAgIHN3aXRjaCAodGhpcy5zb2NrZXQuc3RhdGUpIHtcbiAgICAgIGNhc2UgXCJzdG9wcGVkXCI6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInRlcm1pbmF0ZWRcIjpcbiAgICAgIGNhc2UgXCJjb25uZWN0aW5nXCI6XG4gICAgICBjYXNlIFwicmVhZHlcIjpcbiAgICAgIGNhc2UgXCJkaXNjb25uZWN0ZWRcIjpcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nVmVyYm9zZShcIlJlc3RhcnQgY2FsbGVkIHdpdGhvdXQgc3RvcHBpbmcgZmlyc3RcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgLy8gRW5mb3JjZSB0aGF0IHRoZSBzd2l0Y2gtY2FzZSBpcyBleGhhdXN0aXZlLlxuICAgICAgICB0aGlzLnNvY2tldCBzYXRpc2ZpZXMgbmV2ZXI7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY29ubmVjdCgpO1xuICB9XG5cbiAgcGF1c2UoKTogdm9pZCB7XG4gICAgc3dpdGNoICh0aGlzLnNvY2tldC5zdGF0ZSkge1xuICAgICAgY2FzZSBcImRpc2Nvbm5lY3RlZFwiOlxuICAgICAgY2FzZSBcInN0b3BwZWRcIjpcbiAgICAgIGNhc2UgXCJ0ZXJtaW5hdGVkXCI6XG4gICAgICAgIC8vIElmIGFscmVhZHkgc3RvcHBlZCBvciBzdG9wcGluZyBpZ25vcmUuXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJjb25uZWN0aW5nXCI6XG4gICAgICBjYXNlIFwicmVhZHlcIjoge1xuICAgICAgICB0aGlzLnNvY2tldCA9IHsgLi4udGhpcy5zb2NrZXQsIHBhdXNlZDogXCJ5ZXNcIiB9O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIC8vIEVuZm9yY2UgdGhhdCB0aGUgc3dpdGNoLWNhc2UgaXMgZXhoYXVzdGl2ZS5cbiAgICAgICAgdGhpcy5zb2NrZXQgc2F0aXNmaWVzIG5ldmVyO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlc3VtZSB0aGUgc3RhdGUgbWFjaGluZSBpZiBwcmV2aW91c2x5IHBhdXNlZC5cbiAgICovXG4gIHJlc3VtZSgpOiB2b2lkIHtcbiAgICBzd2l0Y2ggKHRoaXMuc29ja2V0LnN0YXRlKSB7XG4gICAgICBjYXNlIFwiY29ubmVjdGluZ1wiOlxuICAgICAgICB0aGlzLnNvY2tldCA9IHsgLi4udGhpcy5zb2NrZXQsIHBhdXNlZDogXCJub1wiIH07XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJyZWFkeVwiOlxuICAgICAgICBpZiAodGhpcy5zb2NrZXQucGF1c2VkID09PSBcInVuaW5pdGlhbGl6ZWRcIikge1xuICAgICAgICAgIHRoaXMuc29ja2V0ID0geyAuLi50aGlzLnNvY2tldCwgcGF1c2VkOiBcIm5vXCIgfTtcbiAgICAgICAgICB0aGlzLm9uT3Blbih7XG4gICAgICAgICAgICBjb25uZWN0aW9uQ291bnQ6IHRoaXMuY29ubmVjdGlvbkNvdW50LFxuICAgICAgICAgICAgbGFzdENsb3NlUmVhc29uOiB0aGlzLmxhc3RDbG9zZVJlYXNvbixcbiAgICAgICAgICAgIGNsaWVudFRzOiBtb25vdG9uaWNNaWxsaXMoKSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNvY2tldC5wYXVzZWQgPT09IFwieWVzXCIpIHtcbiAgICAgICAgICB0aGlzLnNvY2tldCA9IHsgLi4udGhpcy5zb2NrZXQsIHBhdXNlZDogXCJub1wiIH07XG4gICAgICAgICAgdGhpcy5vblJlc3VtZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJ0ZXJtaW5hdGVkXCI6XG4gICAgICBjYXNlIFwic3RvcHBlZFwiOlxuICAgICAgY2FzZSBcImRpc2Nvbm5lY3RlZFwiOlxuICAgICAgICAvLyBJZ25vcmUgcmVzdW1lIGlmIG5vdCBwYXVzZWQsIHBlcmhhcHMgd2UgYWxyZWFkeSByZXN1bWVkLlxuICAgICAgICByZXR1cm47XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIC8vIEVuZm9yY2UgdGhhdCB0aGUgc3dpdGNoLWNhc2UgaXMgZXhoYXVzdGl2ZS5cbiAgICAgICAgdGhpcy5zb2NrZXQgc2F0aXNmaWVzIG5ldmVyO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNvbm5lY3QoKTtcbiAgfVxuXG4gIGNvbm5lY3Rpb25TdGF0ZSgpOiB7XG4gICAgaXNDb25uZWN0ZWQ6IGJvb2xlYW47XG4gICAgaGFzRXZlckNvbm5lY3RlZDogYm9vbGVhbjtcbiAgICBjb25uZWN0aW9uQ291bnQ6IG51bWJlcjtcbiAgICBjb25uZWN0aW9uUmV0cmllczogbnVtYmVyO1xuICB9IHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNDb25uZWN0ZWQ6IHRoaXMuc29ja2V0LnN0YXRlID09PSBcInJlYWR5XCIsXG4gICAgICBoYXNFdmVyQ29ubmVjdGVkOiB0aGlzLl9oYXNFdmVyQ29ubmVjdGVkLFxuICAgICAgY29ubmVjdGlvbkNvdW50OiB0aGlzLmNvbm5lY3Rpb25Db3VudCxcbiAgICAgIGNvbm5lY3Rpb25SZXRyaWVzOiB0aGlzLnJldHJpZXMsXG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgX2xvZ1ZlcmJvc2UobWVzc2FnZTogc3RyaW5nKSB7XG4gICAgdGhpcy5sb2dnZXIubG9nVmVyYm9zZShtZXNzYWdlKTtcbiAgfVxuXG4gIHByaXZhdGUgbmV4dEJhY2tvZmYocmVhc29uOiBcImNsaWVudFwiIHwgU2VydmVyRGlzY29ubmVjdEVycm9yKTogbnVtYmVyIHtcbiAgICBjb25zdCBpbml0aWFsQmFja29mZjogbnVtYmVyID1cbiAgICAgIHJlYXNvbiA9PT0gXCJjbGllbnRcIlxuICAgICAgICA/IDEwMCAvLyBUaGVyZSdzIG5vIGV2aWRlbmNlIG9mIGEgc2VydmVyIHByb2JsZW0sIHJldHJ5IHF1aWNrbHlcbiAgICAgICAgOiByZWFzb24gPT09IFwiVW5rbm93blwiXG4gICAgICAgICAgPyB0aGlzLmRlZmF1bHRJbml0aWFsQmFja29mZlxuICAgICAgICAgIDogc2VydmVyRGlzY29ubmVjdEVycm9yc1tyZWFzb25dLnRpbWVvdXQ7XG5cbiAgICBjb25zdCBiYXNlQmFja29mZiA9IGluaXRpYWxCYWNrb2ZmICogTWF0aC5wb3coMiwgdGhpcy5yZXRyaWVzKTtcbiAgICB0aGlzLnJldHJpZXMgKz0gMTtcbiAgICBjb25zdCBhY3R1YWxCYWNrb2ZmID0gTWF0aC5taW4oYmFzZUJhY2tvZmYsIHRoaXMubWF4QmFja29mZik7XG4gICAgY29uc3Qgaml0dGVyID0gYWN0dWFsQmFja29mZiAqIChNYXRoLnJhbmRvbSgpIC0gMC41KTtcbiAgICByZXR1cm4gYWN0dWFsQmFja29mZiArIGppdHRlcjtcbiAgfVxuXG4gIHByaXZhdGUgcmVwb3J0TGFyZ2VUcmFuc2l0aW9uKHtcbiAgICB0cmFuc2l0aW9uLFxuICAgIG1lc3NhZ2VMZW5ndGgsXG4gIH06IHtcbiAgICB0cmFuc2l0aW9uOiBUcmFuc2l0aW9uO1xuICAgIG1lc3NhZ2VMZW5ndGg6IG51bWJlcjtcbiAgfSkge1xuICAgIGlmIChcbiAgICAgIHRyYW5zaXRpb24uY2xpZW50Q2xvY2tTa2V3ID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHRyYW5zaXRpb24uc2VydmVyVHMgPT09IHVuZGVmaW5lZFxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHRyYW5zaXRpb25UcmFuc2l0VGltZSA9XG4gICAgICBtb25vdG9uaWNNaWxsaXMoKSAtIC8vIGNsaWVudCB0aW1lIG5vd1xuICAgICAgLy8gY2xpZW50Q2xvY2tTa2V3ID0gKHNlcnZlciB0aW1lICsgdXBzdHJlYW0gbGF0ZW5jeSkgLSBjbGllbnQgdGltZVxuICAgICAgLy8gY2xpZW50Q2xvY2tTa2V3IGlzIFwiaG93IG1hbnkgbWlsbGlzZWNvbmRzIGJlaGluZCAoc2xvdykgaXMgdGhlIGNsaWVudCBjbG9ja1wiXG4gICAgICAvLyBidXQgdGhlIGxhdGVuY3kgb2YgdGhlIENvbm5lY3QgbWVzc2FnZSBpbmZsYXRlcyB0aGlzLCBtYWtpbmcgaXQgYXBwZWFyIGZ1cnRoZXIgYmVoaW5kXG4gICAgICB0cmFuc2l0aW9uLmNsaWVudENsb2NrU2tldyAtXG4gICAgICB0cmFuc2l0aW9uLnNlcnZlclRzIC8gMV8wMDBfMDAwOyAvLyBzZXJ2ZXIgdGltZSB3aGVuIHRyYW5zaXRpb24gd2FzIHNlbnRcbiAgICBjb25zdCBwcmV0dHlUcmFuc2l0aW9uVGltZSA9IGAke01hdGgucm91bmQodHJhbnNpdGlvblRyYW5zaXRUaW1lKX1tc2A7XG4gICAgY29uc3QgcHJldHR5TWVzc2FnZU1CID0gYCR7TWF0aC5yb3VuZChtZXNzYWdlTGVuZ3RoIC8gMTBfMDAwKSAvIDEwMH1NQmA7XG4gICAgY29uc3QgYnl0ZXNQZXJTZWNvbmQgPSBtZXNzYWdlTGVuZ3RoIC8gKHRyYW5zaXRpb25UcmFuc2l0VGltZSAvIDEwMDApO1xuICAgIGNvbnN0IHByZXR0eUJ5dGVzUGVyU2Vjb25kID0gYCR7TWF0aC5yb3VuZChieXRlc1BlclNlY29uZCAvIDEwXzAwMCkgLyAxMDB9TUIgcGVyIHNlY29uZGA7XG4gICAgdGhpcy5fbG9nVmVyYm9zZShcbiAgICAgIGByZWNlaXZlZCAke3ByZXR0eU1lc3NhZ2VNQn0gdHJhbnNpdGlvbiBpbiAke3ByZXR0eVRyYW5zaXRpb25UaW1lfSBhdCAke3ByZXR0eUJ5dGVzUGVyU2Vjb25kfWAsXG4gICAgKTtcblxuICAgIC8vIFdhcm5pbmdzIHRoYXQgd2lsbCBzaG93IHVwIGZvciAqYWxsIHVzZXJzKiwgc28gZG9uJ3QgYmUgdG9vIGFnZ3Jlc3NpdmUuXG4gICAgLy8gVGhlc2UgY2FuIGJlIHNpbGVuY2VkIChhbG9uZyB3aXRoIHJlY29ubmVjdGlvbiBtZXNzYWdlcykgYnkgc2V0dGluZyBgbG9nZ2VyOiBmYWxzZWAgaW4gY2xpZW50IG9wdGlvbnMuXG4gICAgaWYgKG1lc3NhZ2VMZW5ndGggPiAyMF8wMDBfMDAwKSB7XG4gICAgICAvLyBCaWcgZW5vdWdoIHRoYXQgdGhlIGRldmVsb3BlciBzaG91bGQgYmUgbWFkZSBhd2FyZSBvZiB0aGlzLlxuICAgICAgdGhpcy5sb2dnZXIubG9nKFxuICAgICAgICBgcmVjZWl2ZWQgcXVlcnkgcmVzdWx0cyB0b3RhbGluZyBtb3JlIHRoYXQgMjBNQiAoJHtwcmV0dHlNZXNzYWdlTUJ9KSB3aGljaCB3aWxsIHRha2UgYSBsb25nIHRpbWUgdG8gZG93bmxvYWQgb24gc2xvd2VyIGNvbm5lY3Rpb25zYCxcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICh0cmFuc2l0aW9uVHJhbnNpdFRpbWUgPiAyMF8wMDApIHtcbiAgICAgIC8vIExvbmcgZW5vdWdoIHRoYXQgYSBwYXR0ZXJuIG9mIHRoZXNlIHNob3VsZCBiZSBpbnRlcmVzdGluZyB0byBhIGRldmVsb3BlciwgYnV0IGJlIGF3YXJlIHRoYXRcbiAgICAgIC8vIHdlYWsgY29ubmVjdGlvbnMsIHB1dHRpbmcgY2xpZW50cyB0byBzbGVlcCwgYmFja2dyb3VuZGluZyBldGMuIGNvdWxkIGFsbCBjYXVzZSB0aGlzIHRvby5cbiAgICAgIHRoaXMubG9nZ2VyLmxvZyhcbiAgICAgICAgYHJlY2VpdmVkIHF1ZXJ5IHJlc3VsdHMgdG90YWxpbmcgJHtwcmV0dHlNZXNzYWdlTUJ9IHdoaWNoIHRvb2sgbW9yZSB0aGFuIDIwcyB0byBhcnJpdmUgKCR7cHJldHR5VHJhbnNpdGlvblRpbWV9KWAsXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAvLyBkZWJ1ZyBtZWFucyBcInJlcG9ydERlYnVnSW5mb1RvQ29udmV4XCIgaXMgc2V0IHNvIHRoaXMgY2FuIGJlIGFnZ3Jlc3NpdmUuXG4gICAgICB0aGlzLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgdHlwZTogXCJFdmVudFwiLFxuICAgICAgICBldmVudFR5cGU6IFwiQ2xpZW50UmVjZWl2ZWRUcmFuc2l0aW9uXCIsXG4gICAgICAgIGV2ZW50OiB7IHRyYW5zaXRpb25UcmFuc2l0VGltZSwgbWVzc2FnZUxlbmd0aCB9LFxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IEJhc2U2NCB9IGZyb20gXCIuLi8uLi92YWx1ZXMvaW5kZXguanNcIjtcbmltcG9ydCB7IExvbmcgfSBmcm9tIFwiLi4vLi4vdmVuZG9yL2xvbmcuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiB1NjRUb0xvbmcoZW5jb2RlZCkge1xuICBjb25zdCBpbnRlZ2VyQnl0ZXMgPSBCYXNlNjQudG9CeXRlQXJyYXkoZW5jb2RlZCk7XG4gIHJldHVybiBMb25nLmZyb21CeXRlc0xFKEFycmF5LmZyb20oaW50ZWdlckJ5dGVzKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbG9uZ1RvVTY0KHJhdykge1xuICBjb25zdCBpbnRlZ2VyQnl0ZXMgPSBuZXcgVWludDhBcnJheShyYXcudG9CeXRlc0xFKCkpO1xuICByZXR1cm4gQmFzZTY0LmZyb21CeXRlQXJyYXkoaW50ZWdlckJ5dGVzKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVNlcnZlck1lc3NhZ2UoZW5jb2RlZCkge1xuICBzd2l0Y2ggKGVuY29kZWQudHlwZSkge1xuICAgIGNhc2UgXCJGYXRhbEVycm9yXCI6XG4gICAgY2FzZSBcIkF1dGhFcnJvclwiOlxuICAgIGNhc2UgXCJBY3Rpb25SZXNwb25zZVwiOlxuICAgIGNhc2UgXCJUcmFuc2l0aW9uQ2h1bmtcIjpcbiAgICBjYXNlIFwiUGluZ1wiOiB7XG4gICAgICByZXR1cm4geyAuLi5lbmNvZGVkIH07XG4gICAgfVxuICAgIGNhc2UgXCJNdXRhdGlvblJlc3BvbnNlXCI6IHtcbiAgICAgIGlmIChlbmNvZGVkLnN1Y2Nlc3MpIHtcbiAgICAgICAgcmV0dXJuIHsgLi4uZW5jb2RlZCwgdHM6IHU2NFRvTG9uZyhlbmNvZGVkLnRzKSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgLi4uZW5jb2RlZCB9O1xuICAgICAgfVxuICAgIH1cbiAgICBjYXNlIFwiVHJhbnNpdGlvblwiOiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5lbmNvZGVkLFxuICAgICAgICBzdGFydFZlcnNpb246IHtcbiAgICAgICAgICAuLi5lbmNvZGVkLnN0YXJ0VmVyc2lvbixcbiAgICAgICAgICB0czogdTY0VG9Mb25nKGVuY29kZWQuc3RhcnRWZXJzaW9uLnRzKVxuICAgICAgICB9LFxuICAgICAgICBlbmRWZXJzaW9uOiB7XG4gICAgICAgICAgLi4uZW5jb2RlZC5lbmRWZXJzaW9uLFxuICAgICAgICAgIHRzOiB1NjRUb0xvbmcoZW5jb2RlZC5lbmRWZXJzaW9uLnRzKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBlbmNvZGVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUNsaWVudE1lc3NhZ2UobWVzc2FnZSkge1xuICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgIGNhc2UgXCJBdXRoZW50aWNhdGVcIjpcbiAgICBjYXNlIFwiTW9kaWZ5UXVlcnlTZXRcIjpcbiAgICBjYXNlIFwiTXV0YXRpb25cIjpcbiAgICBjYXNlIFwiQWN0aW9uXCI6XG4gICAgY2FzZSBcIkV2ZW50XCI6IHtcbiAgICAgIHJldHVybiB7IC4uLm1lc3NhZ2UgfTtcbiAgICB9XG4gICAgY2FzZSBcIkNvbm5lY3RcIjoge1xuICAgICAgaWYgKG1lc3NhZ2UubWF4T2JzZXJ2ZWRUaW1lc3RhbXAgIT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLm1lc3NhZ2UsXG4gICAgICAgICAgbWF4T2JzZXJ2ZWRUaW1lc3RhbXA6IGxvbmdUb1U2NChtZXNzYWdlLm1heE9ic2VydmVkVGltZXN0YW1wKVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgLi4ubWVzc2FnZSwgbWF4T2JzZXJ2ZWRUaW1lc3RhbXA6IHZvaWQgMCB9O1xuICAgICAgfVxuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBtZXNzYWdlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdG9jb2wuanMubWFwXG4iLCJpbXBvcnQgdHlwZSB7IFVzZXJJZGVudGl0eUF0dHJpYnV0ZXMgfSBmcm9tIFwiLi4vLi4vc2VydmVyL2F1dGhlbnRpY2F0aW9uLmpzXCI7XG5leHBvcnQgdHlwZSB7IFVzZXJJZGVudGl0eUF0dHJpYnV0ZXMgfSBmcm9tIFwiLi4vLi4vc2VydmVyL2F1dGhlbnRpY2F0aW9uLmpzXCI7XG5pbXBvcnQgeyBKU09OVmFsdWUsIEJhc2U2NCB9IGZyb20gXCIuLi8uLi92YWx1ZXMvaW5kZXguanNcIjtcbmltcG9ydCB7IExvbmcgfSBmcm9tIFwiLi4vLi4vdmVuZG9yL2xvbmcuanNcIjtcblxuLyoqXG4gKiBTaGFyZWQgc2NoZW1hXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHU2NFRvTG9uZyhlbmNvZGVkOiBFbmNvZGVkVTY0KTogVTY0IHtcbiAgY29uc3QgaW50ZWdlckJ5dGVzID0gQmFzZTY0LnRvQnl0ZUFycmF5KGVuY29kZWQpO1xuICByZXR1cm4gTG9uZy5mcm9tQnl0ZXNMRShBcnJheS5mcm9tKGludGVnZXJCeXRlcykpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9uZ1RvVTY0KHJhdzogVTY0KTogRW5jb2RlZFU2NCB7XG4gIGNvbnN0IGludGVnZXJCeXRlcyA9IG5ldyBVaW50OEFycmF5KHJhdy50b0J5dGVzTEUoKSk7XG4gIHJldHVybiBCYXNlNjQuZnJvbUJ5dGVBcnJheShpbnRlZ2VyQnl0ZXMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VTZXJ2ZXJNZXNzYWdlKFxuICBlbmNvZGVkOiBFbmNvZGVkU2VydmVyTWVzc2FnZSxcbik6IFdpcmVTZXJ2ZXJNZXNzYWdlIHtcbiAgc3dpdGNoIChlbmNvZGVkLnR5cGUpIHtcbiAgICBjYXNlIFwiRmF0YWxFcnJvclwiOlxuICAgIGNhc2UgXCJBdXRoRXJyb3JcIjpcbiAgICBjYXNlIFwiQWN0aW9uUmVzcG9uc2VcIjpcbiAgICBjYXNlIFwiVHJhbnNpdGlvbkNodW5rXCI6XG4gICAgY2FzZSBcIlBpbmdcIjoge1xuICAgICAgcmV0dXJuIHsgLi4uZW5jb2RlZCB9O1xuICAgIH1cbiAgICBjYXNlIFwiTXV0YXRpb25SZXNwb25zZVwiOiB7XG4gICAgICBpZiAoZW5jb2RlZC5zdWNjZXNzKSB7XG4gICAgICAgIHJldHVybiB7IC4uLmVuY29kZWQsIHRzOiB1NjRUb0xvbmcoZW5jb2RlZC50cykgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7IC4uLmVuY29kZWQgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgY2FzZSBcIlRyYW5zaXRpb25cIjoge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZW5jb2RlZCxcbiAgICAgICAgc3RhcnRWZXJzaW9uOiB7XG4gICAgICAgICAgLi4uZW5jb2RlZC5zdGFydFZlcnNpb24sXG4gICAgICAgICAgdHM6IHU2NFRvTG9uZyhlbmNvZGVkLnN0YXJ0VmVyc2lvbi50cyksXG4gICAgICAgIH0sXG4gICAgICAgIGVuZFZlcnNpb246IHtcbiAgICAgICAgICAuLi5lbmNvZGVkLmVuZFZlcnNpb24sXG4gICAgICAgICAgdHM6IHU2NFRvTG9uZyhlbmNvZGVkLmVuZFZlcnNpb24udHMpLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgZW5jb2RlZCBzYXRpc2ZpZXMgbmV2ZXI7XG4gICAgfVxuICB9XG4gIHJldHVybiB1bmRlZmluZWQgYXMgbmV2ZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVDbGllbnRNZXNzYWdlKFxuICBtZXNzYWdlOiBDbGllbnRNZXNzYWdlLFxuKTogRW5jb2RlZENsaWVudE1lc3NhZ2Uge1xuICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgIGNhc2UgXCJBdXRoZW50aWNhdGVcIjpcbiAgICBjYXNlIFwiTW9kaWZ5UXVlcnlTZXRcIjpcbiAgICBjYXNlIFwiTXV0YXRpb25cIjpcbiAgICBjYXNlIFwiQWN0aW9uXCI6XG4gICAgY2FzZSBcIkV2ZW50XCI6IHtcbiAgICAgIHJldHVybiB7IC4uLm1lc3NhZ2UgfTtcbiAgICB9XG4gICAgY2FzZSBcIkNvbm5lY3RcIjoge1xuICAgICAgaWYgKG1lc3NhZ2UubWF4T2JzZXJ2ZWRUaW1lc3RhbXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLm1lc3NhZ2UsXG4gICAgICAgICAgbWF4T2JzZXJ2ZWRUaW1lc3RhbXA6IGxvbmdUb1U2NChtZXNzYWdlLm1heE9ic2VydmVkVGltZXN0YW1wKSxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7IC4uLm1lc3NhZ2UsIG1heE9ic2VydmVkVGltZXN0YW1wOiB1bmRlZmluZWQgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgbWVzc2FnZSBzYXRpc2ZpZXMgbmV2ZXI7XG4gICAgfVxuICB9XG4gIHJldHVybiB1bmRlZmluZWQgYXMgbmV2ZXI7XG59XG5cbnR5cGUgVTY0ID0gTG9uZztcbnR5cGUgRW5jb2RlZFU2NCA9IHN0cmluZztcblxuLyoqXG4gKiBVbmlxdWUgbm9ubmVnYXRpdmUgaW50ZWdlciBpZGVudGlmeWluZyBhIHNpbmdsZSBxdWVyeS5cbiAqL1xuZXhwb3J0IHR5cGUgUXVlcnlJZCA9IG51bWJlcjsgLy8gbm9ubmVnYXRpdmUgaW50XG5cbmV4cG9ydCB0eXBlIFF1ZXJ5U2V0VmVyc2lvbiA9IG51bWJlcjsgLy8gbm9ubmVnYXRpdmUgaW50XG5cbmV4cG9ydCB0eXBlIFJlcXVlc3RJZCA9IG51bWJlcjsgLy8gbm9ubmVnYXRpdmUgaW50XG5cbmV4cG9ydCB0eXBlIElkZW50aXR5VmVyc2lvbiA9IG51bWJlcjsgLy8gbm9ubmVnYXRpdmUgaW50XG5cbi8qKlxuICogQSBzZXJpYWxpemVkIHJlcHJlc2VudGF0aW9uIG9mIGRlY2lzaW9ucyBtYWRlIGR1cmluZyBhIHF1ZXJ5J3MgZXhlY3V0aW9uLlxuICpcbiAqIEEgam91cm5hbCBpcyBwcm9kdWNlZCB3aGVuIGEgcXVlcnkgZnVuY3Rpb24gZmlyc3QgZXhlY3V0ZXMgYW5kIGlzIHJlLXVzZWRcbiAqIHdoZW4gYSBxdWVyeSBpcyByZS1leGVjdXRlZC5cbiAqXG4gKiBDdXJyZW50bHkgdGhpcyBpcyB1c2VkIHRvIHN0b3JlIHBhZ2luYXRpb24gZW5kIGN1cnNvcnMgdG8gZW5zdXJlXG4gKiB0aGF0IHBhZ2VzIG9mIHBhZ2luYXRlZCBxdWVyaWVzIHdpbGwgYWx3YXlzIGVuZCBhdCB0aGUgc2FtZSBjdXJzb3IuIFRoaXNcbiAqIGVuYWJsZXMgZ2FwbGVzcywgcmVhY3RpdmUgcGFnaW5hdGlvbi5cbiAqXG4gKiBgbnVsbGAgaXMgdXNlZCB0byByZXByZXNlbnQgZW1wdHkgam91cm5hbHMuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCB0eXBlIFF1ZXJ5Sm91cm5hbCA9IHN0cmluZyB8IG51bGw7XG5cbi8qKlxuICogQ2xpZW50IG1lc3NhZ2Ugc2NoZW1hXG4gKi9cblxudHlwZSBDb25uZWN0ID0ge1xuICB0eXBlOiBcIkNvbm5lY3RcIjtcbiAgc2Vzc2lvbklkOiBzdHJpbmc7XG4gIGNvbm5lY3Rpb25Db3VudDogbnVtYmVyO1xuICBsYXN0Q2xvc2VSZWFzb246IHN0cmluZyB8IG51bGw7XG4gIG1heE9ic2VydmVkVGltZXN0YW1wPzogVFMgfCB1bmRlZmluZWQ7XG4gIGNsaWVudFRzOiBudW1iZXI7XG59O1xuXG5leHBvcnQgdHlwZSBBZGRRdWVyeSA9IHtcbiAgdHlwZTogXCJBZGRcIjtcbiAgcXVlcnlJZDogUXVlcnlJZDtcbiAgdWRmUGF0aDogc3RyaW5nO1xuICBhcmdzOiBKU09OVmFsdWVbXTtcbiAgam91cm5hbD86IFF1ZXJ5Sm91cm5hbCB8IHVuZGVmaW5lZDtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29tcG9uZW50UGF0aD86IHN0cmluZyB8IHVuZGVmaW5lZDtcbn07XG5cbmV4cG9ydCB0eXBlIFJlbW92ZVF1ZXJ5ID0ge1xuICB0eXBlOiBcIlJlbW92ZVwiO1xuICBxdWVyeUlkOiBRdWVyeUlkO1xufTtcblxuZXhwb3J0IHR5cGUgUXVlcnlTZXRNb2RpZmljYXRpb24gPSB7XG4gIHR5cGU6IFwiTW9kaWZ5UXVlcnlTZXRcIjtcbiAgYmFzZVZlcnNpb246IFF1ZXJ5U2V0VmVyc2lvbjtcbiAgbmV3VmVyc2lvbjogUXVlcnlTZXRWZXJzaW9uO1xuICBtb2RpZmljYXRpb25zOiAoQWRkUXVlcnkgfCBSZW1vdmVRdWVyeSlbXTtcbn07XG5cbmV4cG9ydCB0eXBlIE11dGF0aW9uUmVxdWVzdCA9IHtcbiAgdHlwZTogXCJNdXRhdGlvblwiO1xuICByZXF1ZXN0SWQ6IFJlcXVlc3RJZDtcbiAgdWRmUGF0aDogc3RyaW5nO1xuICBhcmdzOiBKU09OVmFsdWVbXTtcbiAgLy8gRXhlY3V0ZSB0aGUgbXV0YXRpb24gb24gYSBzcGVjaWZpYyBjb21wb25lbnQuXG4gIC8vIE9ubHkgYWRtaW4gYXV0aCBpcyBhbGxvd2VkIHRvIHJ1biBtdXRhdGlvbnMgb24gbm9uLXJvb3QgY29tcG9uZW50cy5cbiAgY29tcG9uZW50UGF0aD86IHN0cmluZyB8IHVuZGVmaW5lZDtcbn07XG5cbmV4cG9ydCB0eXBlIEFjdGlvblJlcXVlc3QgPSB7XG4gIHR5cGU6IFwiQWN0aW9uXCI7XG4gIHJlcXVlc3RJZDogUmVxdWVzdElkO1xuICB1ZGZQYXRoOiBzdHJpbmc7XG4gIGFyZ3M6IEpTT05WYWx1ZVtdO1xuICAvLyBFeGVjdXRlIHRoZSBhY3Rpb24gb24gYSBzcGVjaWZpYyBjb21wb25lbnQuXG4gIC8vIE9ubHkgYWRtaW4gYXV0aCBpcyBhbGxvd2VkIHRvIHJ1biBhY3Rpb25zIG9uIG5vbi1yb290IGNvbXBvbmVudHMuXG4gIGNvbXBvbmVudFBhdGg/OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG59O1xuXG5leHBvcnQgdHlwZSBBZG1pbkF1dGhlbnRpY2F0aW9uID0ge1xuICB0eXBlOiBcIkF1dGhlbnRpY2F0ZVwiO1xuICB0b2tlblR5cGU6IFwiQWRtaW5cIjtcbiAgdmFsdWU6IHN0cmluZztcbiAgYmFzZVZlcnNpb246IElkZW50aXR5VmVyc2lvbjtcbiAgaW1wZXJzb25hdGluZz86IFVzZXJJZGVudGl0eUF0dHJpYnV0ZXMgfCB1bmRlZmluZWQ7XG59O1xuXG5leHBvcnQgdHlwZSBBdXRoZW50aWNhdGUgPVxuICB8IEFkbWluQXV0aGVudGljYXRpb25cbiAgfCB7XG4gICAgICB0eXBlOiBcIkF1dGhlbnRpY2F0ZVwiO1xuICAgICAgdG9rZW5UeXBlOiBcIlVzZXJcIjtcbiAgICAgIHZhbHVlOiBzdHJpbmc7XG4gICAgICBiYXNlVmVyc2lvbjogSWRlbnRpdHlWZXJzaW9uO1xuICAgIH1cbiAgfCB7XG4gICAgICB0eXBlOiBcIkF1dGhlbnRpY2F0ZVwiO1xuICAgICAgdG9rZW5UeXBlOiBcIk5vbmVcIjtcbiAgICAgIGJhc2VWZXJzaW9uOiBJZGVudGl0eVZlcnNpb247XG4gICAgfTtcblxuZXhwb3J0IHR5cGUgRXZlbnQgPSB7XG4gIHR5cGU6IFwiRXZlbnRcIjtcbiAgZXZlbnRUeXBlOiBzdHJpbmc7XG4gIGV2ZW50OiBhbnk7XG59O1xuZXhwb3J0IHR5cGUgQ2xpZW50TWVzc2FnZSA9XG4gIHwgQ29ubmVjdFxuICB8IEF1dGhlbnRpY2F0ZVxuICB8IFF1ZXJ5U2V0TW9kaWZpY2F0aW9uXG4gIHwgTXV0YXRpb25SZXF1ZXN0XG4gIHwgQWN0aW9uUmVxdWVzdFxuICB8IEV2ZW50O1xuXG50eXBlIEVuY29kZWRDb25uZWN0ID0gT21pdDxDb25uZWN0LCBcIm1heE9ic2VydmVkVGltZXN0YW1wXCI+ICYge1xuICBtYXhPYnNlcnZlZFRpbWVzdGFtcD86IEVuY29kZWRUUyB8IHVuZGVmaW5lZDtcbn07XG5cbi8vIEl0J3Mgbm90IGEgYmlnIGRlYWwgdG8gYWRkIGB8IHVuZGVmaW5lZGAgdG8gYW55IG9wdGlvbmFsIHByb3BlcnRpZXMgaGVyZSBiZWNhdXNlXG4vLyB0aGVzZSBtZXNzYWdlcyBhcmUgYm91bmQgZm9yIEpTT04uc3RyaW5naWZ5KCkgc2VyaWFsaXphdGlvbiwgd2hpY2ggcmVtb3ZlcyBwcm9wZXJ0aWVzXG4vLyB0aGF0IGFyZSB1bmRlZmluZWQuXG50eXBlIEVuY29kZWRDbGllbnRNZXNzYWdlID1cbiAgfCBFbmNvZGVkQ29ubmVjdFxuICB8IEF1dGhlbnRpY2F0ZVxuICB8IFF1ZXJ5U2V0TW9kaWZpY2F0aW9uXG4gIHwgTXV0YXRpb25SZXF1ZXN0XG4gIHwgQWN0aW9uUmVxdWVzdFxuICB8IEV2ZW50O1xuXG4vKipcbiAqIFNlcnZlciBtZXNzYWdlIHNjaGVtYVxuICovXG5leHBvcnQgdHlwZSBUUyA9IFU2NDtcbnR5cGUgRW5jb2RlZFRTID0gRW5jb2RlZFU2NDtcbnR5cGUgTG9nTGluZXMgPSBzdHJpbmdbXTtcblxuZXhwb3J0IHR5cGUgU3RhdGVWZXJzaW9uID0ge1xuICBxdWVyeVNldDogUXVlcnlTZXRWZXJzaW9uO1xuICB0czogVFM7XG4gIGlkZW50aXR5OiBJZGVudGl0eVZlcnNpb247XG59O1xudHlwZSBFbmNvZGVkU3RhdGVWZXJzaW9uID0gT21pdDxTdGF0ZVZlcnNpb24sIFwidHNcIj4gJiB7IHRzOiBFbmNvZGVkVFMgfTtcblxudHlwZSBTdGF0ZU1vZGlmaWNhdGlvbiA9XG4gIHwge1xuICAgICAgdHlwZTogXCJRdWVyeVVwZGF0ZWRcIjtcbiAgICAgIHF1ZXJ5SWQ6IFF1ZXJ5SWQ7XG4gICAgICB2YWx1ZTogSlNPTlZhbHVlO1xuICAgICAgbG9nTGluZXM6IExvZ0xpbmVzO1xuICAgICAgam91cm5hbDogUXVlcnlKb3VybmFsO1xuICAgIH1cbiAgfCB7XG4gICAgICB0eXBlOiBcIlF1ZXJ5RmFpbGVkXCI7XG4gICAgICBxdWVyeUlkOiBRdWVyeUlkO1xuICAgICAgZXJyb3JNZXNzYWdlOiBzdHJpbmc7XG4gICAgICBsb2dMaW5lczogTG9nTGluZXM7XG4gICAgICBlcnJvckRhdGE6IEpTT05WYWx1ZTtcbiAgICAgIGpvdXJuYWw6IFF1ZXJ5Sm91cm5hbDtcbiAgICB9XG4gIHwge1xuICAgICAgdHlwZTogXCJRdWVyeVJlbW92ZWRcIjtcbiAgICAgIHF1ZXJ5SWQ6IFF1ZXJ5SWQ7XG4gICAgfTtcblxuZXhwb3J0IHR5cGUgVHJhbnNpdGlvbiA9IHtcbiAgdHlwZTogXCJUcmFuc2l0aW9uXCI7XG4gIHN0YXJ0VmVyc2lvbjogU3RhdGVWZXJzaW9uO1xuICBlbmRWZXJzaW9uOiBTdGF0ZVZlcnNpb247XG4gIG1vZGlmaWNhdGlvbnM6IFN0YXRlTW9kaWZpY2F0aW9uW107XG4gIGNsaWVudENsb2NrU2tldz86IG51bWJlcjtcbiAgc2VydmVyVHM/OiBudW1iZXI7XG59O1xuXG5leHBvcnQgdHlwZSBUcmFuc2l0aW9uQ2h1bmsgPSB7XG4gIHR5cGU6IFwiVHJhbnNpdGlvbkNodW5rXCI7XG4gIGNodW5rOiBzdHJpbmc7XG4gIHBhcnROdW1iZXI6IG51bWJlcjtcbiAgdG90YWxQYXJ0czogbnVtYmVyO1xuICB0cmFuc2l0aW9uSWQ6IHN0cmluZztcbn07XG5cbnR5cGUgTXV0YXRpb25TdWNjZXNzID0ge1xuICB0eXBlOiBcIk11dGF0aW9uUmVzcG9uc2VcIjtcbiAgcmVxdWVzdElkOiBSZXF1ZXN0SWQ7XG4gIHN1Y2Nlc3M6IHRydWU7XG4gIHJlc3VsdDogSlNPTlZhbHVlO1xuICB0czogVFM7XG4gIGxvZ0xpbmVzOiBMb2dMaW5lcztcbn07XG50eXBlIE11dGF0aW9uRmFpbGVkID0ge1xuICB0eXBlOiBcIk11dGF0aW9uUmVzcG9uc2VcIjtcbiAgcmVxdWVzdElkOiBSZXF1ZXN0SWQ7XG4gIHN1Y2Nlc3M6IGZhbHNlO1xuICByZXN1bHQ6IHN0cmluZztcbiAgbG9nTGluZXM6IExvZ0xpbmVzO1xuICBlcnJvckRhdGE/OiBKU09OVmFsdWU7XG59O1xuZXhwb3J0IHR5cGUgTXV0YXRpb25SZXNwb25zZSA9IE11dGF0aW9uU3VjY2VzcyB8IE11dGF0aW9uRmFpbGVkO1xudHlwZSBBY3Rpb25TdWNjZXNzID0ge1xuICB0eXBlOiBcIkFjdGlvblJlc3BvbnNlXCI7XG4gIHJlcXVlc3RJZDogUmVxdWVzdElkO1xuICBzdWNjZXNzOiB0cnVlO1xuICByZXN1bHQ6IEpTT05WYWx1ZTtcbiAgbG9nTGluZXM6IExvZ0xpbmVzO1xufTtcbnR5cGUgQWN0aW9uRmFpbGVkID0ge1xuICB0eXBlOiBcIkFjdGlvblJlc3BvbnNlXCI7XG4gIHJlcXVlc3RJZDogUmVxdWVzdElkO1xuICBzdWNjZXNzOiBmYWxzZTtcbiAgcmVzdWx0OiBzdHJpbmc7XG4gIGxvZ0xpbmVzOiBMb2dMaW5lcztcbiAgZXJyb3JEYXRhPzogSlNPTlZhbHVlO1xufTtcbmV4cG9ydCB0eXBlIEFjdGlvblJlc3BvbnNlID0gQWN0aW9uU3VjY2VzcyB8IEFjdGlvbkZhaWxlZDtcbmV4cG9ydCB0eXBlIEF1dGhFcnJvciA9IHtcbiAgdHlwZTogXCJBdXRoRXJyb3JcIjtcbiAgZXJyb3I6IHN0cmluZztcbiAgYmFzZVZlcnNpb246IElkZW50aXR5VmVyc2lvbjtcbiAgLy8gVHJ1ZSBpZiB0aGlzIGVycm9yIGlzIGluIHJlc3BvbnNlIHRvIHByb2Nlc3NpbmcgYSBuZXcgYEF1dGhlbnRpY2F0ZWAgbWVzc2FnZS5cbiAgLy8gT3RoZXIgQXV0aEVycm9ycyBtYXkgb2NjdXIgZHVlIHRvIGV4ZWN1dGluZyBhIGZ1bmN0aW9uIHdpdGggZXhwaXJlZCBhdXRoIGFuZFxuICAvLyBzaG91bGQgYmUgaGFuZGxlZCBkaWZmZXJlbnRseS5cbiAgYXV0aFVwZGF0ZUF0dGVtcHRlZDogYm9vbGVhbjtcbn07XG50eXBlIEZhdGFsRXJyb3IgPSB7XG4gIHR5cGU6IFwiRmF0YWxFcnJvclwiO1xuICBlcnJvcjogc3RyaW5nO1xufTtcbnR5cGUgUGluZyA9IHtcbiAgdHlwZTogXCJQaW5nXCI7XG59O1xuXG4vLyBTZXJ2ZXIgTWVzc2FnZXMgd2l0aG91dCB0aGUgbWVzc2FnZXMgb25seSB2aXNpYmxlIHRvIFdlYlNvY2tldE1hbmFnZXJcbmV4cG9ydCB0eXBlIFNlcnZlck1lc3NhZ2UgPVxuICB8IFRyYW5zaXRpb25cbiAgfCBNdXRhdGlvblJlc3BvbnNlXG4gIHwgQWN0aW9uUmVzcG9uc2VcbiAgfCBGYXRhbEVycm9yXG4gIHwgQXV0aEVycm9yO1xuXG5leHBvcnQgdHlwZSBXaXJlU2VydmVyTWVzc2FnZSA9XG4gIHwgVHJhbnNpdGlvblxuICB8IFRyYW5zaXRpb25DaHVua1xuICB8IE11dGF0aW9uUmVzcG9uc2VcbiAgfCBBY3Rpb25SZXNwb25zZVxuICB8IEZhdGFsRXJyb3JcbiAgfCBBdXRoRXJyb3JcbiAgfCBQaW5nO1xuXG50eXBlIEVuY29kZWRUcmFuc2l0aW9uID0gT21pdDxUcmFuc2l0aW9uLCBcInN0YXJ0VmVyc2lvblwiIHwgXCJlbmRWZXJzaW9uXCI+ICYge1xuICBzdGFydFZlcnNpb246IEVuY29kZWRTdGF0ZVZlcnNpb247XG4gIGVuZFZlcnNpb246IEVuY29kZWRTdGF0ZVZlcnNpb247XG59O1xudHlwZSBFbmNvZGVkTXV0YXRpb25TdWNjZXNzID0gT21pdDxNdXRhdGlvblN1Y2Nlc3MsIFwidHNcIj4gJiB7IHRzOiBFbmNvZGVkVFMgfTtcbnR5cGUgRW5jb2RlZE11dGF0aW9uUmVzcG9uc2UgPSBNdXRhdGlvbkZhaWxlZCB8IEVuY29kZWRNdXRhdGlvblN1Y2Nlc3M7XG5cbnR5cGUgRW5jb2RlZFNlcnZlck1lc3NhZ2UgPVxuICB8IEVuY29kZWRUcmFuc2l0aW9uXG4gIHwgVHJhbnNpdGlvbkNodW5rXG4gIHwgRW5jb2RlZE11dGF0aW9uUmVzcG9uc2VcbiAgfCBBY3Rpb25SZXNwb25zZVxuICB8IEZhdGFsRXJyb3JcbiAgfCBBdXRoRXJyb3JcbiAgfCBQaW5nO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnQgZnVuY3Rpb24gbmV3U2Vzc2lvbklkKCkge1xuICByZXR1cm4gdXVpZHY0KCk7XG59XG5mdW5jdGlvbiB1dWlkdjQoKSB7XG4gIHJldHVybiBcInh4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eFwiLnJlcGxhY2UoL1t4eV0vZywgKGMpID0+IHtcbiAgICBjb25zdCByID0gTWF0aC5yYW5kb20oKSAqIDE2IHwgMCwgdiA9IGMgPT09IFwieFwiID8gciA6IHIgJiAzIHwgODtcbiAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2Vzc2lvbi5qcy5tYXBcbiIsImV4cG9ydCBmdW5jdGlvbiBuZXdTZXNzaW9uSWQoKSB7XG4gIHJldHVybiB1dWlkdjQoKTtcbn1cblxuLy8gRnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjExNzUyM1xuZnVuY3Rpb24gdXVpZHY0KCkge1xuICByZXR1cm4gXCJ4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHhcIi5yZXBsYWNlKC9beHldL2csIChjKSA9PiB7XG4gICAgY29uc3QgciA9IChNYXRoLnJhbmRvbSgpICogMTYpIHwgMCxcbiAgICAgIHYgPSBjID09PSBcInhcIiA/IHIgOiAociAmIDB4MykgfCAweDg7XG4gICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICB9KTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4gX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbmltcG9ydCB7IGp3dERlY29kZSB9IGZyb20gXCIuLi8uLi92ZW5kb3Ivand0LWRlY29kZS9pbmRleC5qc1wiO1xuY29uc3QgTUFYSU1VTV9SRUZSRVNIX0RFTEFZID0gMjAgKiAyNCAqIDYwICogNjAgKiAxZTM7XG5jb25zdCBNQVhfVE9LRU5fQ09ORklSTUFUSU9OX0FUVEVNUFRTID0gMjtcbmV4cG9ydCBjbGFzcyBBdXRoZW50aWNhdGlvbk1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihzeW5jU3RhdGUsIGNhbGxiYWNrcywgY29uZmlnKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImF1dGhTdGF0ZVwiLCB7IHN0YXRlOiBcIm5vQXV0aFwiIH0pO1xuICAgIC8vIFVzZWQgdG8gZGV0ZWN0IHJhY2VzIGludm9sdmluZyBgc2V0Q29uZmlnYCBjYWxsc1xuICAgIC8vIHdoaWxlIGEgdG9rZW4gaXMgYmVpbmcgZmV0Y2hlZC5cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiY29uZmlnVmVyc2lvblwiLCAwKTtcbiAgICAvLyBTaGFyZWQgYnkgdGhlIEJhc2VDbGllbnQgc28gdGhhdCB0aGUgYXV0aCBtYW5hZ2VyIGNhbiBlYXNpbHkgaW5zcGVjdCBpdFxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzeW5jU3RhdGVcIik7XG4gICAgLy8gUGFzc2VkIGRvd24gYnkgQmFzZUNsaWVudCwgc2VuZHMgYSBtZXNzYWdlIHRvIHRoZSBzZXJ2ZXJcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYXV0aGVudGljYXRlXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzdG9wU29ja2V0XCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ0cnlSZXN0YXJ0U29ja2V0XCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJwYXVzZVNvY2tldFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVzdW1lU29ja2V0XCIpO1xuICAgIC8vIFBhc3NlZCBkb3duIGJ5IEJhc2VDbGllbnQsIHNlbmRzIGEgbWVzc2FnZSB0byB0aGUgc2VydmVyXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNsZWFyQXV0aFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibG9nZ2VyXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyZWZyZXNoVG9rZW5MZWV3YXlTZWNvbmRzXCIpO1xuICAgIC8vIE51bWJlciBvZiB0aW1lcyB3ZSBoYXZlIGF0dGVtcHRlZCB0byBjb25maXJtIHRoZSBsYXRlc3QgdG9rZW4uIFdlIHJldHJ5IHVwXG4gICAgLy8gdG8gYE1BWF9UT0tFTl9DT05GSVJNQVRJT05fQVRURU1QVFNgIHRpbWVzLlxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ0b2tlbkNvbmZpcm1hdGlvbkF0dGVtcHRzXCIsIDApO1xuICAgIHRoaXMuc3luY1N0YXRlID0gc3luY1N0YXRlO1xuICAgIHRoaXMuYXV0aGVudGljYXRlID0gY2FsbGJhY2tzLmF1dGhlbnRpY2F0ZTtcbiAgICB0aGlzLnN0b3BTb2NrZXQgPSBjYWxsYmFja3Muc3RvcFNvY2tldDtcbiAgICB0aGlzLnRyeVJlc3RhcnRTb2NrZXQgPSBjYWxsYmFja3MudHJ5UmVzdGFydFNvY2tldDtcbiAgICB0aGlzLnBhdXNlU29ja2V0ID0gY2FsbGJhY2tzLnBhdXNlU29ja2V0O1xuICAgIHRoaXMucmVzdW1lU29ja2V0ID0gY2FsbGJhY2tzLnJlc3VtZVNvY2tldDtcbiAgICB0aGlzLmNsZWFyQXV0aCA9IGNhbGxiYWNrcy5jbGVhckF1dGg7XG4gICAgdGhpcy5sb2dnZXIgPSBjb25maWcubG9nZ2VyO1xuICAgIHRoaXMucmVmcmVzaFRva2VuTGVld2F5U2Vjb25kcyA9IGNvbmZpZy5yZWZyZXNoVG9rZW5MZWV3YXlTZWNvbmRzO1xuICB9XG4gIGFzeW5jIHNldENvbmZpZyhmZXRjaFRva2VuLCBvbkNoYW5nZSkge1xuICAgIHRoaXMucmVzZXRBdXRoU3RhdGUoKTtcbiAgICB0aGlzLl9sb2dWZXJib3NlKFwicGF1c2luZyBXUyBmb3IgYXV0aCB0b2tlbiBmZXRjaFwiKTtcbiAgICB0aGlzLnBhdXNlU29ja2V0KCk7XG4gICAgY29uc3QgdG9rZW4gPSBhd2FpdCB0aGlzLmZldGNoVG9rZW5BbmRHdWFyZEFnYWluc3RSYWNlKGZldGNoVG9rZW4sIHtcbiAgICAgIGZvcmNlUmVmcmVzaFRva2VuOiBmYWxzZVxuICAgIH0pO1xuICAgIGlmICh0b2tlbi5pc0Zyb21PdXRkYXRlZENvbmZpZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodG9rZW4udmFsdWUpIHtcbiAgICAgIHRoaXMuc2V0QXV0aFN0YXRlKHtcbiAgICAgICAgc3RhdGU6IFwid2FpdGluZ0ZvclNlcnZlckNvbmZpcm1hdGlvbk9mQ2FjaGVkVG9rZW5cIixcbiAgICAgICAgY29uZmlnOiB7IGZldGNoVG9rZW4sIG9uQXV0aENoYW5nZTogb25DaGFuZ2UgfSxcbiAgICAgICAgaGFzUmV0cmllZDogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgdGhpcy5hdXRoZW50aWNhdGUodG9rZW4udmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldEF1dGhTdGF0ZSh7XG4gICAgICAgIHN0YXRlOiBcImluaXRpYWxSZWZldGNoXCIsXG4gICAgICAgIGNvbmZpZzogeyBmZXRjaFRva2VuLCBvbkF1dGhDaGFuZ2U6IG9uQ2hhbmdlIH1cbiAgICAgIH0pO1xuICAgICAgYXdhaXQgdGhpcy5yZWZldGNoVG9rZW4oKTtcbiAgICB9XG4gICAgdGhpcy5fbG9nVmVyYm9zZShcInJlc3VtaW5nIFdTIGFmdGVyIGF1dGggdG9rZW4gZmV0Y2hcIik7XG4gICAgdGhpcy5yZXN1bWVTb2NrZXQoKTtcbiAgfVxuICBvblRyYW5zaXRpb24oc2VydmVyTWVzc2FnZSkge1xuICAgIGlmICghdGhpcy5zeW5jU3RhdGUuaXNDdXJyZW50T3JOZXdlckF1dGhWZXJzaW9uKFxuICAgICAgc2VydmVyTWVzc2FnZS5lbmRWZXJzaW9uLmlkZW50aXR5XG4gICAgKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc2VydmVyTWVzc2FnZS5lbmRWZXJzaW9uLmlkZW50aXR5IDw9IHNlcnZlck1lc3NhZ2Uuc3RhcnRWZXJzaW9uLmlkZW50aXR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmF1dGhTdGF0ZS5zdGF0ZSA9PT0gXCJ3YWl0aW5nRm9yU2VydmVyQ29uZmlybWF0aW9uT2ZDYWNoZWRUb2tlblwiKSB7XG4gICAgICB0aGlzLl9sb2dWZXJib3NlKFwic2VydmVyIGNvbmZpcm1lZCBhdXRoIHRva2VuIGlzIHZhbGlkXCIpO1xuICAgICAgdm9pZCB0aGlzLnJlZmV0Y2hUb2tlbigpO1xuICAgICAgdGhpcy5hdXRoU3RhdGUuY29uZmlnLm9uQXV0aENoYW5nZSh0cnVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuYXV0aFN0YXRlLnN0YXRlID09PSBcIndhaXRpbmdGb3JTZXJ2ZXJDb25maXJtYXRpb25PZkZyZXNoVG9rZW5cIikge1xuICAgICAgdGhpcy5fbG9nVmVyYm9zZShcInNlcnZlciBjb25maXJtZWQgbmV3IGF1dGggdG9rZW4gaXMgdmFsaWRcIik7XG4gICAgICB0aGlzLnNjaGVkdWxlVG9rZW5SZWZldGNoKHRoaXMuYXV0aFN0YXRlLnRva2VuKTtcbiAgICAgIHRoaXMudG9rZW5Db25maXJtYXRpb25BdHRlbXB0cyA9IDA7XG4gICAgICBpZiAoIXRoaXMuYXV0aFN0YXRlLmhhZEF1dGgpIHtcbiAgICAgICAgdGhpcy5hdXRoU3RhdGUuY29uZmlnLm9uQXV0aENoYW5nZSh0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgb25BdXRoRXJyb3Ioc2VydmVyTWVzc2FnZSkge1xuICAgIGlmIChzZXJ2ZXJNZXNzYWdlLmF1dGhVcGRhdGVBdHRlbXB0ZWQgPT09IGZhbHNlICYmICh0aGlzLmF1dGhTdGF0ZS5zdGF0ZSA9PT0gXCJ3YWl0aW5nRm9yU2VydmVyQ29uZmlybWF0aW9uT2ZGcmVzaFRva2VuXCIgfHwgdGhpcy5hdXRoU3RhdGUuc3RhdGUgPT09IFwid2FpdGluZ0ZvclNlcnZlckNvbmZpcm1hdGlvbk9mQ2FjaGVkVG9rZW5cIikpIHtcbiAgICAgIHRoaXMuX2xvZ1ZlcmJvc2UoXCJpZ25vcmluZyBub24tYXV0aCB0b2tlbiBleHBpcmVkIGVycm9yXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGJhc2VWZXJzaW9uIH0gPSBzZXJ2ZXJNZXNzYWdlO1xuICAgIGlmICghdGhpcy5zeW5jU3RhdGUuaXNDdXJyZW50T3JOZXdlckF1dGhWZXJzaW9uKGJhc2VWZXJzaW9uICsgMSkpIHtcbiAgICAgIHRoaXMuX2xvZ1ZlcmJvc2UoXCJpZ25vcmluZyBhdXRoIGVycm9yIGZvciBwcmV2aW91cyBhdXRoIGF0dGVtcHRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZvaWQgdGhpcy50cnlUb1JlYXV0aGVudGljYXRlKHNlcnZlck1lc3NhZ2UpO1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBUaGlzIGlzIHNpbWlsYXIgdG8gYHJlZmV0Y2hUb2tlbmAgZGVmaW5lZCBiZWxvdywgaW4gZmFjdCB3ZVxuICAvLyBkb24ndCByZXByZXNlbnQgdGhlbSBhcyBkaWZmZXJlbnQgc3RhdGVzLCBidXQgaXQgaXMgZGlmZmVyZW50XG4gIC8vIGluIHRoYXQgd2UgcGF1c2UgdGhlIFdlYlNvY2tldCBzbyB0aGF0IG11dGF0aW9uc1xuICAvLyBkb24ndCByZXRyeSB3aXRoIGJhZCBhdXRoLlxuICBhc3luYyB0cnlUb1JlYXV0aGVudGljYXRlKHNlcnZlck1lc3NhZ2UpIHtcbiAgICB0aGlzLl9sb2dWZXJib3NlKGBhdHRlbXB0aW5nIHRvIHJlYXV0aGVudGljYXRlOiAke3NlcnZlck1lc3NhZ2UuZXJyb3J9YCk7XG4gICAgaWYgKFxuICAgICAgLy8gTm8gd2F5IHRvIGZldGNoIGFub3RoZXIgdG9rZW4sIGthYm9vbVxuICAgICAgdGhpcy5hdXRoU3RhdGUuc3RhdGUgPT09IFwibm9BdXRoXCIgfHwgLy8gV2UgZmFpbGVkIG9uIGEgZnJlc2ggdG9rZW4uIEFmdGVyIGEgc21hbGwgbnVtYmVyIG9mIHJldHJpZXMsIHdlIGdpdmUgdXBcbiAgICAgIC8vIGFuZCBjbGVhciB0aGUgYXV0aCBzdGF0ZSB0byBhdm9pZCBpbmZpbml0ZSByZXRyaWVzLlxuICAgICAgdGhpcy5hdXRoU3RhdGUuc3RhdGUgPT09IFwid2FpdGluZ0ZvclNlcnZlckNvbmZpcm1hdGlvbk9mRnJlc2hUb2tlblwiICYmIHRoaXMudG9rZW5Db25maXJtYXRpb25BdHRlbXB0cyA+PSBNQVhfVE9LRU5fQ09ORklSTUFUSU9OX0FUVEVNUFRTXG4gICAgKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihcbiAgICAgICAgYEZhaWxlZCB0byBhdXRoZW50aWNhdGU6IFwiJHtzZXJ2ZXJNZXNzYWdlLmVycm9yfVwiLCBjaGVjayB5b3VyIHNlcnZlciBhdXRoIGNvbmZpZ2BcbiAgICAgICk7XG4gICAgICBpZiAodGhpcy5zeW5jU3RhdGUuaGFzQXV0aCgpKSB7XG4gICAgICAgIHRoaXMuc3luY1N0YXRlLmNsZWFyQXV0aCgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuYXV0aFN0YXRlLnN0YXRlICE9PSBcIm5vQXV0aFwiKSB7XG4gICAgICAgIHRoaXMuc2V0QW5kUmVwb3J0QXV0aEZhaWxlZCh0aGlzLmF1dGhTdGF0ZS5jb25maWcub25BdXRoQ2hhbmdlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuYXV0aFN0YXRlLnN0YXRlID09PSBcIndhaXRpbmdGb3JTZXJ2ZXJDb25maXJtYXRpb25PZkZyZXNoVG9rZW5cIikge1xuICAgICAgdGhpcy50b2tlbkNvbmZpcm1hdGlvbkF0dGVtcHRzKys7XG4gICAgICB0aGlzLl9sb2dWZXJib3NlKFxuICAgICAgICBgcmV0cnlpbmcgcmVhdXRoZW50aWNhdGlvbiwgJHtNQVhfVE9LRU5fQ09ORklSTUFUSU9OX0FUVEVNUFRTIC0gdGhpcy50b2tlbkNvbmZpcm1hdGlvbkF0dGVtcHRzfSBhdHRlbXB0cyByZW1haW5pbmdgXG4gICAgICApO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLnN0b3BTb2NrZXQoKTtcbiAgICBjb25zdCB0b2tlbiA9IGF3YWl0IHRoaXMuZmV0Y2hUb2tlbkFuZEd1YXJkQWdhaW5zdFJhY2UoXG4gICAgICB0aGlzLmF1dGhTdGF0ZS5jb25maWcuZmV0Y2hUb2tlbixcbiAgICAgIHtcbiAgICAgICAgZm9yY2VSZWZyZXNoVG9rZW46IHRydWVcbiAgICAgIH1cbiAgICApO1xuICAgIGlmICh0b2tlbi5pc0Zyb21PdXRkYXRlZENvbmZpZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodG9rZW4udmFsdWUgJiYgdGhpcy5zeW5jU3RhdGUuaXNOZXdBdXRoKHRva2VuLnZhbHVlKSkge1xuICAgICAgdGhpcy5hdXRoZW50aWNhdGUodG9rZW4udmFsdWUpO1xuICAgICAgdGhpcy5zZXRBdXRoU3RhdGUoe1xuICAgICAgICBzdGF0ZTogXCJ3YWl0aW5nRm9yU2VydmVyQ29uZmlybWF0aW9uT2ZGcmVzaFRva2VuXCIsXG4gICAgICAgIGNvbmZpZzogdGhpcy5hdXRoU3RhdGUuY29uZmlnLFxuICAgICAgICB0b2tlbjogdG9rZW4udmFsdWUsXG4gICAgICAgIGhhZEF1dGg6IHRoaXMuYXV0aFN0YXRlLnN0YXRlID09PSBcIm5vdFJlZmV0Y2hpbmdcIiB8fCB0aGlzLmF1dGhTdGF0ZS5zdGF0ZSA9PT0gXCJ3YWl0aW5nRm9yU2NoZWR1bGVkUmVmZXRjaFwiXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbG9nVmVyYm9zZShcInJlYXV0aGVudGljYXRpb24gZmFpbGVkLCBjb3VsZCBub3QgZmV0Y2ggYSBuZXcgdG9rZW5cIik7XG4gICAgICBpZiAodGhpcy5zeW5jU3RhdGUuaGFzQXV0aCgpKSB7XG4gICAgICAgIHRoaXMuc3luY1N0YXRlLmNsZWFyQXV0aCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRBbmRSZXBvcnRBdXRoRmFpbGVkKHRoaXMuYXV0aFN0YXRlLmNvbmZpZy5vbkF1dGhDaGFuZ2UpO1xuICAgIH1cbiAgICB0aGlzLnRyeVJlc3RhcnRTb2NrZXQoKTtcbiAgfVxuICAvLyBGb3JjZSByZWZldGNoIHRoZSB0b2tlbiBhbmQgc2NoZWR1bGUgYW5vdGhlciByZWZldGNoXG4gIC8vIGJlZm9yZSB0aGUgdG9rZW4gZXhwaXJlcyAtIGFuIGFjdGl2ZSBjbGllbnQgc2hvdWxkIG5ldmVyXG4gIC8vIG5lZWQgdG8gcmVhdXRoZW50aWNhdGUuXG4gIGFzeW5jIHJlZmV0Y2hUb2tlbigpIHtcbiAgICBpZiAodGhpcy5hdXRoU3RhdGUuc3RhdGUgPT09IFwibm9BdXRoXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fbG9nVmVyYm9zZShcInJlZmV0Y2hpbmcgYXV0aCB0b2tlblwiKTtcbiAgICBjb25zdCB0b2tlbiA9IGF3YWl0IHRoaXMuZmV0Y2hUb2tlbkFuZEd1YXJkQWdhaW5zdFJhY2UoXG4gICAgICB0aGlzLmF1dGhTdGF0ZS5jb25maWcuZmV0Y2hUb2tlbixcbiAgICAgIHtcbiAgICAgICAgZm9yY2VSZWZyZXNoVG9rZW46IHRydWVcbiAgICAgIH1cbiAgICApO1xuICAgIGlmICh0b2tlbi5pc0Zyb21PdXRkYXRlZENvbmZpZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodG9rZW4udmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLnN5bmNTdGF0ZS5pc05ld0F1dGgodG9rZW4udmFsdWUpKSB7XG4gICAgICAgIHRoaXMuc2V0QXV0aFN0YXRlKHtcbiAgICAgICAgICBzdGF0ZTogXCJ3YWl0aW5nRm9yU2VydmVyQ29uZmlybWF0aW9uT2ZGcmVzaFRva2VuXCIsXG4gICAgICAgICAgaGFkQXV0aDogdGhpcy5zeW5jU3RhdGUuaGFzQXV0aCgpLFxuICAgICAgICAgIHRva2VuOiB0b2tlbi52YWx1ZSxcbiAgICAgICAgICBjb25maWc6IHRoaXMuYXV0aFN0YXRlLmNvbmZpZ1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hdXRoZW50aWNhdGUodG9rZW4udmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRBdXRoU3RhdGUoe1xuICAgICAgICAgIHN0YXRlOiBcIm5vdFJlZmV0Y2hpbmdcIixcbiAgICAgICAgICBjb25maWc6IHRoaXMuYXV0aFN0YXRlLmNvbmZpZ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbG9nVmVyYm9zZShcInJlZmV0Y2hpbmcgdG9rZW4gZmFpbGVkXCIpO1xuICAgICAgaWYgKHRoaXMuc3luY1N0YXRlLmhhc0F1dGgoKSkge1xuICAgICAgICB0aGlzLmNsZWFyQXV0aCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRBbmRSZXBvcnRBdXRoRmFpbGVkKHRoaXMuYXV0aFN0YXRlLmNvbmZpZy5vbkF1dGhDaGFuZ2UpO1xuICAgIH1cbiAgICB0aGlzLl9sb2dWZXJib3NlKFxuICAgICAgXCJyZXN0YXJ0aW5nIFdTIGFmdGVyIGF1dGggdG9rZW4gZmV0Y2ggKGlmIGN1cnJlbnRseSBzdG9wcGVkKVwiXG4gICAgKTtcbiAgICB0aGlzLnRyeVJlc3RhcnRTb2NrZXQoKTtcbiAgfVxuICBzY2hlZHVsZVRva2VuUmVmZXRjaCh0b2tlbikge1xuICAgIGlmICh0aGlzLmF1dGhTdGF0ZS5zdGF0ZSA9PT0gXCJub0F1dGhcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkZWNvZGVkVG9rZW4gPSB0aGlzLmRlY29kZVRva2VuKHRva2VuKTtcbiAgICBpZiAoIWRlY29kZWRUb2tlbikge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXG4gICAgICAgIFwiQXV0aCB0b2tlbiBpcyBub3QgYSB2YWxpZCBKV1QsIGNhbm5vdCByZWZldGNoIHRoZSB0b2tlblwiXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGlhdCwgZXhwIH0gPSBkZWNvZGVkVG9rZW47XG4gICAgaWYgKCFpYXQgfHwgIWV4cCkge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXG4gICAgICAgIFwiQXV0aCB0b2tlbiBkb2VzIG5vdCBoYXZlIHJlcXVpcmVkIGZpZWxkcywgY2Fubm90IHJlZmV0Y2ggdGhlIHRva2VuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRva2VuVmFsaWRpdHlTZWNvbmRzID0gZXhwIC0gaWF0O1xuICAgIGlmICh0b2tlblZhbGlkaXR5U2Vjb25kcyA8PSAyKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihcbiAgICAgICAgXCJBdXRoIHRva2VuIGRvZXMgbm90IGxpdmUgbG9uZyBlbm91Z2gsIGNhbm5vdCByZWZldGNoIHRoZSB0b2tlblwiXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgZGVsYXkgPSBNYXRoLm1pbihcbiAgICAgIE1BWElNVU1fUkVGUkVTSF9ERUxBWSxcbiAgICAgICh0b2tlblZhbGlkaXR5U2Vjb25kcyAtIHRoaXMucmVmcmVzaFRva2VuTGVld2F5U2Vjb25kcykgKiAxZTNcbiAgICApO1xuICAgIGlmIChkZWxheSA8PSAwKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKFxuICAgICAgICBgUmVmZXRjaGluZyBhdXRoIHRva2VuIGltbWVkaWF0ZWx5LCBjb25maWd1cmVkIGxlZXdheSAke3RoaXMucmVmcmVzaFRva2VuTGVld2F5U2Vjb25kc31zIGlzIGxhcmdlciB0aGFuIHRoZSB0b2tlbidzIGxpZmV0aW1lICR7dG9rZW5WYWxpZGl0eVNlY29uZHN9c2BcbiAgICAgICk7XG4gICAgICBkZWxheSA9IDA7XG4gICAgfVxuICAgIGNvbnN0IHJlZmV0Y2hUb2tlblRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fbG9nVmVyYm9zZShcInJ1bm5pbmcgc2NoZWR1bGVkIHRva2VuIHJlZmV0Y2hcIik7XG4gICAgICB2b2lkIHRoaXMucmVmZXRjaFRva2VuKCk7XG4gICAgfSwgZGVsYXkpO1xuICAgIHRoaXMuc2V0QXV0aFN0YXRlKHtcbiAgICAgIHN0YXRlOiBcIndhaXRpbmdGb3JTY2hlZHVsZWRSZWZldGNoXCIsXG4gICAgICByZWZldGNoVG9rZW5UaW1lb3V0SWQsXG4gICAgICBjb25maWc6IHRoaXMuYXV0aFN0YXRlLmNvbmZpZ1xuICAgIH0pO1xuICAgIHRoaXMuX2xvZ1ZlcmJvc2UoXG4gICAgICBgc2NoZWR1bGVkIHByZWVtcHRpdmUgYXV0aCB0b2tlbiByZWZldGNoaW5nIGluICR7ZGVsYXl9bXNgXG4gICAgKTtcbiAgfVxuICAvLyBQcm90ZWN0cyBhZ2FpbnN0IHNpbXVsdGFuZW91cyBjYWxscyB0byBgc2V0Q29uZmlnYFxuICAvLyB3aGlsZSB3ZSdyZSBmZXRjaGluZyBhIHRva2VuXG4gIGFzeW5jIGZldGNoVG9rZW5BbmRHdWFyZEFnYWluc3RSYWNlKGZldGNoVG9rZW4sIGZldGNoQXJncykge1xuICAgIGNvbnN0IG9yaWdpbmFsQ29uZmlnVmVyc2lvbiA9ICsrdGhpcy5jb25maWdWZXJzaW9uO1xuICAgIHRoaXMuX2xvZ1ZlcmJvc2UoXG4gICAgICBgZmV0Y2hpbmcgdG9rZW4gd2l0aCBjb25maWcgdmVyc2lvbiAke29yaWdpbmFsQ29uZmlnVmVyc2lvbn1gXG4gICAgKTtcbiAgICBjb25zdCB0b2tlbiA9IGF3YWl0IGZldGNoVG9rZW4oZmV0Y2hBcmdzKTtcbiAgICBpZiAodGhpcy5jb25maWdWZXJzaW9uICE9PSBvcmlnaW5hbENvbmZpZ1ZlcnNpb24pIHtcbiAgICAgIHRoaXMuX2xvZ1ZlcmJvc2UoXG4gICAgICAgIGBzdGFsZSBjb25maWcgdmVyc2lvbiwgZXhwZWN0ZWQgJHtvcmlnaW5hbENvbmZpZ1ZlcnNpb259LCBnb3QgJHt0aGlzLmNvbmZpZ1ZlcnNpb259YFxuICAgICAgKTtcbiAgICAgIHJldHVybiB7IGlzRnJvbU91dGRhdGVkQ29uZmlnOiB0cnVlIH07XG4gICAgfVxuICAgIHJldHVybiB7IGlzRnJvbU91dGRhdGVkQ29uZmlnOiBmYWxzZSwgdmFsdWU6IHRva2VuIH07XG4gIH1cbiAgc3RvcCgpIHtcbiAgICB0aGlzLnJlc2V0QXV0aFN0YXRlKCk7XG4gICAgdGhpcy5jb25maWdWZXJzaW9uKys7XG4gICAgdGhpcy5fbG9nVmVyYm9zZShgY29uZmlnIHZlcnNpb24gYnVtcGVkIHRvICR7dGhpcy5jb25maWdWZXJzaW9ufWApO1xuICB9XG4gIHNldEFuZFJlcG9ydEF1dGhGYWlsZWQob25BdXRoQ2hhbmdlKSB7XG4gICAgb25BdXRoQ2hhbmdlKGZhbHNlKTtcbiAgICB0aGlzLnJlc2V0QXV0aFN0YXRlKCk7XG4gIH1cbiAgcmVzZXRBdXRoU3RhdGUoKSB7XG4gICAgdGhpcy5zZXRBdXRoU3RhdGUoeyBzdGF0ZTogXCJub0F1dGhcIiB9KTtcbiAgfVxuICBzZXRBdXRoU3RhdGUobmV3QXV0aCkge1xuICAgIGNvbnN0IGF1dGhTdGF0ZUZvckxvZyA9IG5ld0F1dGguc3RhdGUgPT09IFwid2FpdGluZ0ZvclNlcnZlckNvbmZpcm1hdGlvbk9mRnJlc2hUb2tlblwiID8ge1xuICAgICAgaGFkQXV0aDogbmV3QXV0aC5oYWRBdXRoLFxuICAgICAgc3RhdGU6IG5ld0F1dGguc3RhdGUsXG4gICAgICB0b2tlbjogYC4uLiR7bmV3QXV0aC50b2tlbi5zbGljZSgtNyl9YFxuICAgIH0gOiB7IHN0YXRlOiBuZXdBdXRoLnN0YXRlIH07XG4gICAgdGhpcy5fbG9nVmVyYm9zZShcbiAgICAgIGBzZXR0aW5nIGF1dGggc3RhdGUgdG8gJHtKU09OLnN0cmluZ2lmeShhdXRoU3RhdGVGb3JMb2cpfWBcbiAgICApO1xuICAgIHN3aXRjaCAobmV3QXV0aC5zdGF0ZSkge1xuICAgICAgY2FzZSBcIndhaXRpbmdGb3JTY2hlZHVsZWRSZWZldGNoXCI6XG4gICAgICBjYXNlIFwibm90UmVmZXRjaGluZ1wiOlxuICAgICAgY2FzZSBcIm5vQXV0aFwiOlxuICAgICAgICB0aGlzLnRva2VuQ29uZmlybWF0aW9uQXR0ZW1wdHMgPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ3YWl0aW5nRm9yU2VydmVyQ29uZmlybWF0aW9uT2ZGcmVzaFRva2VuXCI6XG4gICAgICBjYXNlIFwid2FpdGluZ0ZvclNlcnZlckNvbmZpcm1hdGlvbk9mQ2FjaGVkVG9rZW5cIjpcbiAgICAgIGNhc2UgXCJpbml0aWFsUmVmZXRjaFwiOlxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgbmV3QXV0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuYXV0aFN0YXRlLnN0YXRlID09PSBcIndhaXRpbmdGb3JTY2hlZHVsZWRSZWZldGNoXCIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmF1dGhTdGF0ZS5yZWZldGNoVG9rZW5UaW1lb3V0SWQpO1xuICAgICAgdGhpcy5zeW5jU3RhdGUubWFya0F1dGhDb21wbGV0aW9uKCk7XG4gICAgfVxuICAgIHRoaXMuYXV0aFN0YXRlID0gbmV3QXV0aDtcbiAgfVxuICBkZWNvZGVUb2tlbih0b2tlbikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gand0RGVjb2RlKHRva2VuKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLl9sb2dWZXJib3NlKFxuICAgICAgICBgRXJyb3IgZGVjb2RpbmcgdG9rZW46ICR7ZSBpbnN0YW5jZW9mIEVycm9yID8gZS5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCJ9YFxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBfbG9nVmVyYm9zZShtZXNzYWdlKSB7XG4gICAgdGhpcy5sb2dnZXIubG9nVmVyYm9zZShgJHttZXNzYWdlfSBbdiR7dGhpcy5jb25maWdWZXJzaW9ufV1gKTtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0aGVudGljYXRpb25fbWFuYWdlci5qcy5tYXBcbiIsImltcG9ydCB7IExvZ2dlciB9IGZyb20gXCIuLi9sb2dnaW5nLmpzXCI7XG5pbXBvcnQgeyBMb2NhbFN5bmNTdGF0ZSB9IGZyb20gXCIuL2xvY2FsX3N0YXRlLmpzXCI7XG5pbXBvcnQgeyBBdXRoRXJyb3IsIElkZW50aXR5VmVyc2lvbiwgVHJhbnNpdGlvbiB9IGZyb20gXCIuL3Byb3RvY29sLmpzXCI7XG5pbXBvcnQgeyBqd3REZWNvZGUgfSBmcm9tIFwiLi4vLi4vdmVuZG9yL2p3dC1kZWNvZGUvaW5kZXguanNcIjtcblxuLy8gc2V0VGltb3V0IHVzZXMgMzIgYml0IGludGVnZXIsIHNvIGl0IGNhbiBvbmx5XG4vLyBzY2hlZHVsZSBhYm91dCAyNCBkYXlzIGluIHRoZSBmdXR1cmUuXG5jb25zdCBNQVhJTVVNX1JFRlJFU0hfREVMQVkgPSAyMCAqIDI0ICogNjAgKiA2MCAqIDEwMDA7IC8vIDIwIGRheXNcblxuY29uc3QgTUFYX1RPS0VOX0NPTkZJUk1BVElPTl9BVFRFTVBUUyA9IDI7XG5cbi8qKlxuICogQW4gYXN5bmMgZnVuY3Rpb24gcmV0dXJuaW5nIGEgSldULiBEZXBlbmRpbmcgb24gdGhlIGF1dGggcHJvdmlkZXJzXG4gKiBjb25maWd1cmVkIGluIGNvbnZleC9hdXRoLmNvbmZpZy50cywgdGhpcyBtYXkgYmUgYSBKV1QtZW5jb2RlZCBPcGVuSURcbiAqIENvbm5lY3QgSWRlbnRpdHkgVG9rZW4gb3IgYSB0cmFkaXRpb25hbCBKV1QuXG4gKlxuICogYGZvcmNlUmVmcmVzaFRva2VuYCBpcyBgdHJ1ZWAgaWYgdGhlIHNlcnZlciByZWplY3RlZCBhIHByZXZpb3VzbHlcbiAqIHJldHVybmVkIHRva2VuIG9yIHRoZSB0b2tlbiBpcyBhbnRpY2lwYXRlZCB0byBleHBpcmluZyBzb29uXG4gKiBiYXNlZCBvbiBpdHMgYGV4cGAgdGltZS5cbiAqXG4gKiBTZWUge0BsaW5rIENvbnZleFJlYWN0Q2xpZW50LnNldEF1dGh9LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IHR5cGUgQXV0aFRva2VuRmV0Y2hlciA9IChhcmdzOiB7XG4gIGZvcmNlUmVmcmVzaFRva2VuOiBib29sZWFuO1xufSkgPT4gUHJvbWlzZTxzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkPjtcblxuLyoqXG4gKiBXaGF0IGlzIHByb3ZpZGVkIHRvIHRoZSBjbGllbnQuXG4gKi9cbnR5cGUgQXV0aENvbmZpZyA9IHtcbiAgZmV0Y2hUb2tlbjogQXV0aFRva2VuRmV0Y2hlcjtcbiAgb25BdXRoQ2hhbmdlOiAoaXNBdXRoZW50aWNhdGVkOiBib29sZWFuKSA9PiB2b2lkO1xufTtcblxuLyoqXG4gKiBJbiBnZW5lcmFsIHdlIHRha2UgMyBzdGVwczpcbiAqICAgMS4gRmV0Y2ggYSBwb3NzaWJseSBjYWNoZWQgdG9rZW5cbiAqICAgMi4gSW1tZWRpYXRlbHkgZmV0Y2ggYSBmcmVzaCB0b2tlbiB3aXRob3V0IHVzaW5nIGEgY2FjaGVcbiAqICAgMy4gUmVwZWF0IHN0ZXAgMiBiZWZvcmUgdGhlIGVuZCBvZiB0aGUgZnJlc2ggdG9rZW4ncyBsaWZldGltZVxuICpcbiAqIFdoZW4gd2UgZmV0Y2ggd2l0aG91dCB1c2luZyBhIGNhY2hlIHdlIGtub3cgd2hlbiB0aGUgdG9rZW5cbiAqIHdpbGwgZXhwaXJlLCBhbmQgY2FuIHNjaGVkdWxlIHJlZmV0Y2hpbmcgaXQuXG4gKlxuICogSWYgd2UgZ2V0IGFuIGVycm9yIGJlZm9yZSBhIHNjaGVkdWxlZCByZWZldGNoLCB3ZSBnbyBiYWNrXG4gKiB0byBzdGVwIDIuXG4gKi9cbnR5cGUgQXV0aFN0YXRlID1cbiAgfCB7IHN0YXRlOiBcIm5vQXV0aFwiIH1cbiAgfCB7XG4gICAgICBzdGF0ZTogXCJ3YWl0aW5nRm9yU2VydmVyQ29uZmlybWF0aW9uT2ZDYWNoZWRUb2tlblwiO1xuICAgICAgY29uZmlnOiBBdXRoQ29uZmlnO1xuICAgICAgaGFzUmV0cmllZDogYm9vbGVhbjtcbiAgICB9XG4gIHwge1xuICAgICAgc3RhdGU6IFwiaW5pdGlhbFJlZmV0Y2hcIjtcbiAgICAgIGNvbmZpZzogQXV0aENvbmZpZztcbiAgICB9XG4gIHwge1xuICAgICAgc3RhdGU6IFwid2FpdGluZ0ZvclNlcnZlckNvbmZpcm1hdGlvbk9mRnJlc2hUb2tlblwiO1xuICAgICAgY29uZmlnOiBBdXRoQ29uZmlnO1xuICAgICAgaGFkQXV0aDogYm9vbGVhbjtcbiAgICAgIHRva2VuOiBzdHJpbmc7XG4gICAgfVxuICB8IHtcbiAgICAgIHN0YXRlOiBcIndhaXRpbmdGb3JTY2hlZHVsZWRSZWZldGNoXCI7XG4gICAgICBjb25maWc6IEF1dGhDb25maWc7XG4gICAgICByZWZldGNoVG9rZW5UaW1lb3V0SWQ6IFJldHVyblR5cGU8dHlwZW9mIHNldFRpbWVvdXQ+O1xuICAgIH1cbiAgLy8gU3BlY2lhbC93ZWlyZCBzdGF0ZSB3aGVuIHdlIGdvdCBhIHZhbGlkIHRva2VuXG4gIC8vIGJ1dCBjb3VsZCBub3QgZmV0Y2ggYSBuZXcgb25lLlxuICB8IHtcbiAgICAgIHN0YXRlOiBcIm5vdFJlZmV0Y2hpbmdcIjtcbiAgICAgIGNvbmZpZzogQXV0aENvbmZpZztcbiAgICB9O1xuXG4vKipcbiAqIEhhbmRsZXMgdGhlIHN0YXRlIHRyYW5zaXRpb25zIGZvciBhdXRoLiBUaGUgc2VydmVyIGlzIHRoZSBzb3VyY2VcbiAqIG9mIHRydXRoLlxuICovXG5leHBvcnQgY2xhc3MgQXV0aGVudGljYXRpb25NYW5hZ2VyIHtcbiAgcHJpdmF0ZSBhdXRoU3RhdGU6IEF1dGhTdGF0ZSA9IHsgc3RhdGU6IFwibm9BdXRoXCIgfTtcbiAgLy8gVXNlZCB0byBkZXRlY3QgcmFjZXMgaW52b2x2aW5nIGBzZXRDb25maWdgIGNhbGxzXG4gIC8vIHdoaWxlIGEgdG9rZW4gaXMgYmVpbmcgZmV0Y2hlZC5cbiAgcHJpdmF0ZSBjb25maWdWZXJzaW9uID0gMDtcbiAgLy8gU2hhcmVkIGJ5IHRoZSBCYXNlQ2xpZW50IHNvIHRoYXQgdGhlIGF1dGggbWFuYWdlciBjYW4gZWFzaWx5IGluc3BlY3QgaXRcbiAgcHJpdmF0ZSByZWFkb25seSBzeW5jU3RhdGU6IExvY2FsU3luY1N0YXRlO1xuICAvLyBQYXNzZWQgZG93biBieSBCYXNlQ2xpZW50LCBzZW5kcyBhIG1lc3NhZ2UgdG8gdGhlIHNlcnZlclxuICBwcml2YXRlIHJlYWRvbmx5IGF1dGhlbnRpY2F0ZTogKHRva2VuOiBzdHJpbmcpID0+IElkZW50aXR5VmVyc2lvbjtcbiAgcHJpdmF0ZSByZWFkb25seSBzdG9wU29ja2V0OiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBwcml2YXRlIHJlYWRvbmx5IHRyeVJlc3RhcnRTb2NrZXQ6ICgpID0+IHZvaWQ7XG4gIHByaXZhdGUgcmVhZG9ubHkgcGF1c2VTb2NrZXQ6ICgpID0+IHZvaWQ7XG4gIHByaXZhdGUgcmVhZG9ubHkgcmVzdW1lU29ja2V0OiAoKSA9PiB2b2lkO1xuICAvLyBQYXNzZWQgZG93biBieSBCYXNlQ2xpZW50LCBzZW5kcyBhIG1lc3NhZ2UgdG8gdGhlIHNlcnZlclxuICBwcml2YXRlIHJlYWRvbmx5IGNsZWFyQXV0aDogKCkgPT4gdm9pZDtcbiAgcHJpdmF0ZSByZWFkb25seSBsb2dnZXI6IExvZ2dlcjtcbiAgcHJpdmF0ZSByZWFkb25seSByZWZyZXNoVG9rZW5MZWV3YXlTZWNvbmRzOiBudW1iZXI7XG4gIC8vIE51bWJlciBvZiB0aW1lcyB3ZSBoYXZlIGF0dGVtcHRlZCB0byBjb25maXJtIHRoZSBsYXRlc3QgdG9rZW4uIFdlIHJldHJ5IHVwXG4gIC8vIHRvIGBNQVhfVE9LRU5fQ09ORklSTUFUSU9OX0FUVEVNUFRTYCB0aW1lcy5cbiAgcHJpdmF0ZSB0b2tlbkNvbmZpcm1hdGlvbkF0dGVtcHRzID0gMDtcbiAgY29uc3RydWN0b3IoXG4gICAgc3luY1N0YXRlOiBMb2NhbFN5bmNTdGF0ZSxcbiAgICBjYWxsYmFja3M6IHtcbiAgICAgIGF1dGhlbnRpY2F0ZTogKHRva2VuOiBzdHJpbmcpID0+IElkZW50aXR5VmVyc2lvbjtcbiAgICAgIHN0b3BTb2NrZXQ6ICgpID0+IFByb21pc2U8dm9pZD47XG4gICAgICB0cnlSZXN0YXJ0U29ja2V0OiAoKSA9PiB2b2lkO1xuICAgICAgcGF1c2VTb2NrZXQ6ICgpID0+IHZvaWQ7XG4gICAgICByZXN1bWVTb2NrZXQ6ICgpID0+IHZvaWQ7XG4gICAgICBjbGVhckF1dGg6ICgpID0+IHZvaWQ7XG4gICAgfSxcbiAgICBjb25maWc6IHtcbiAgICAgIHJlZnJlc2hUb2tlbkxlZXdheVNlY29uZHM6IG51bWJlcjtcbiAgICAgIGxvZ2dlcjogTG9nZ2VyO1xuICAgIH0sXG4gICkge1xuICAgIHRoaXMuc3luY1N0YXRlID0gc3luY1N0YXRlO1xuICAgIHRoaXMuYXV0aGVudGljYXRlID0gY2FsbGJhY2tzLmF1dGhlbnRpY2F0ZTtcbiAgICB0aGlzLnN0b3BTb2NrZXQgPSBjYWxsYmFja3Muc3RvcFNvY2tldDtcbiAgICB0aGlzLnRyeVJlc3RhcnRTb2NrZXQgPSBjYWxsYmFja3MudHJ5UmVzdGFydFNvY2tldDtcbiAgICB0aGlzLnBhdXNlU29ja2V0ID0gY2FsbGJhY2tzLnBhdXNlU29ja2V0O1xuICAgIHRoaXMucmVzdW1lU29ja2V0ID0gY2FsbGJhY2tzLnJlc3VtZVNvY2tldDtcbiAgICB0aGlzLmNsZWFyQXV0aCA9IGNhbGxiYWNrcy5jbGVhckF1dGg7XG4gICAgdGhpcy5sb2dnZXIgPSBjb25maWcubG9nZ2VyO1xuICAgIHRoaXMucmVmcmVzaFRva2VuTGVld2F5U2Vjb25kcyA9IGNvbmZpZy5yZWZyZXNoVG9rZW5MZWV3YXlTZWNvbmRzO1xuICB9XG5cbiAgYXN5bmMgc2V0Q29uZmlnKFxuICAgIGZldGNoVG9rZW46IEF1dGhUb2tlbkZldGNoZXIsXG4gICAgb25DaGFuZ2U6IChpc0F1dGhlbnRpY2F0ZWQ6IGJvb2xlYW4pID0+IHZvaWQsXG4gICkge1xuICAgIHRoaXMucmVzZXRBdXRoU3RhdGUoKTtcbiAgICB0aGlzLl9sb2dWZXJib3NlKFwicGF1c2luZyBXUyBmb3IgYXV0aCB0b2tlbiBmZXRjaFwiKTtcbiAgICB0aGlzLnBhdXNlU29ja2V0KCk7XG4gICAgY29uc3QgdG9rZW4gPSBhd2FpdCB0aGlzLmZldGNoVG9rZW5BbmRHdWFyZEFnYWluc3RSYWNlKGZldGNoVG9rZW4sIHtcbiAgICAgIGZvcmNlUmVmcmVzaFRva2VuOiBmYWxzZSxcbiAgICB9KTtcbiAgICBpZiAodG9rZW4uaXNGcm9tT3V0ZGF0ZWRDb25maWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRva2VuLnZhbHVlKSB7XG4gICAgICB0aGlzLnNldEF1dGhTdGF0ZSh7XG4gICAgICAgIHN0YXRlOiBcIndhaXRpbmdGb3JTZXJ2ZXJDb25maXJtYXRpb25PZkNhY2hlZFRva2VuXCIsXG4gICAgICAgIGNvbmZpZzogeyBmZXRjaFRva2VuLCBvbkF1dGhDaGFuZ2U6IG9uQ2hhbmdlIH0sXG4gICAgICAgIGhhc1JldHJpZWQ6IGZhbHNlLFxuICAgICAgfSk7XG4gICAgICB0aGlzLmF1dGhlbnRpY2F0ZSh0b2tlbi52YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0QXV0aFN0YXRlKHtcbiAgICAgICAgc3RhdGU6IFwiaW5pdGlhbFJlZmV0Y2hcIixcbiAgICAgICAgY29uZmlnOiB7IGZldGNoVG9rZW4sIG9uQXV0aENoYW5nZTogb25DaGFuZ2UgfSxcbiAgICAgIH0pO1xuICAgICAgLy8gVHJ5IGFnYWluIHdpdGggYGZvcmNlUmVmcmVzaFRva2VuOiB0cnVlYFxuICAgICAgYXdhaXQgdGhpcy5yZWZldGNoVG9rZW4oKTtcbiAgICB9XG4gICAgdGhpcy5fbG9nVmVyYm9zZShcInJlc3VtaW5nIFdTIGFmdGVyIGF1dGggdG9rZW4gZmV0Y2hcIik7XG4gICAgdGhpcy5yZXN1bWVTb2NrZXQoKTtcbiAgfVxuXG4gIG9uVHJhbnNpdGlvbihzZXJ2ZXJNZXNzYWdlOiBUcmFuc2l0aW9uKSB7XG4gICAgaWYgKFxuICAgICAgIXRoaXMuc3luY1N0YXRlLmlzQ3VycmVudE9yTmV3ZXJBdXRoVmVyc2lvbihcbiAgICAgICAgc2VydmVyTWVzc2FnZS5lbmRWZXJzaW9uLmlkZW50aXR5LFxuICAgICAgKVxuICAgICkge1xuICAgICAgLy8gVGhpcyBpcyBhIHN0YWxlIHRyYW5zaXRpb24gLSBjbGllbnQgaGFzIG1vdmVkIG9uIHRvXG4gICAgICAvLyBhIG5ld2VyIGF1dGggdmVyc2lvbi5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgc2VydmVyTWVzc2FnZS5lbmRWZXJzaW9uLmlkZW50aXR5IDw9IHNlcnZlck1lc3NhZ2Uuc3RhcnRWZXJzaW9uLmlkZW50aXR5XG4gICAgKSB7XG4gICAgICAvLyBUaGlzIHRyYW5zaXRpb24gZGlkIG5vdCBjaGFuZ2UgYXV0aCAtIGl0IGlzIG5vdCBhIHJlc3BvbnNlIHRvIEF1dGhlbnRpY2F0ZS5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hdXRoU3RhdGUuc3RhdGUgPT09IFwid2FpdGluZ0ZvclNlcnZlckNvbmZpcm1hdGlvbk9mQ2FjaGVkVG9rZW5cIikge1xuICAgICAgdGhpcy5fbG9nVmVyYm9zZShcInNlcnZlciBjb25maXJtZWQgYXV0aCB0b2tlbiBpcyB2YWxpZFwiKTtcbiAgICAgIHZvaWQgdGhpcy5yZWZldGNoVG9rZW4oKTtcbiAgICAgIHRoaXMuYXV0aFN0YXRlLmNvbmZpZy5vbkF1dGhDaGFuZ2UodHJ1ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmF1dGhTdGF0ZS5zdGF0ZSA9PT0gXCJ3YWl0aW5nRm9yU2VydmVyQ29uZmlybWF0aW9uT2ZGcmVzaFRva2VuXCIpIHtcbiAgICAgIHRoaXMuX2xvZ1ZlcmJvc2UoXCJzZXJ2ZXIgY29uZmlybWVkIG5ldyBhdXRoIHRva2VuIGlzIHZhbGlkXCIpO1xuICAgICAgdGhpcy5zY2hlZHVsZVRva2VuUmVmZXRjaCh0aGlzLmF1dGhTdGF0ZS50b2tlbik7XG4gICAgICB0aGlzLnRva2VuQ29uZmlybWF0aW9uQXR0ZW1wdHMgPSAwO1xuICAgICAgaWYgKCF0aGlzLmF1dGhTdGF0ZS5oYWRBdXRoKSB7XG4gICAgICAgIHRoaXMuYXV0aFN0YXRlLmNvbmZpZy5vbkF1dGhDaGFuZ2UodHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25BdXRoRXJyb3Ioc2VydmVyTWVzc2FnZTogQXV0aEVycm9yKSB7XG4gICAgLy8gSWYgdGhlIEF1dGhFcnJvciBpcyBub3QgZHVlIHRvIHVwZGF0aW5nIHRoZSB0b2tlbiwgYW5kIHdlJ3JlIGN1cnJlbnRseVxuICAgIC8vIHdhaXRpbmcgb24gdGhlIHJlc3VsdCBvZiBhIHRva2VuIHVwZGF0ZSwgaWdub3JlLlxuICAgIGlmIChcbiAgICAgIHNlcnZlck1lc3NhZ2UuYXV0aFVwZGF0ZUF0dGVtcHRlZCA9PT0gZmFsc2UgJiZcbiAgICAgICh0aGlzLmF1dGhTdGF0ZS5zdGF0ZSA9PT0gXCJ3YWl0aW5nRm9yU2VydmVyQ29uZmlybWF0aW9uT2ZGcmVzaFRva2VuXCIgfHxcbiAgICAgICAgdGhpcy5hdXRoU3RhdGUuc3RhdGUgPT09IFwid2FpdGluZ0ZvclNlcnZlckNvbmZpcm1hdGlvbk9mQ2FjaGVkVG9rZW5cIilcbiAgICApIHtcbiAgICAgIHRoaXMuX2xvZ1ZlcmJvc2UoXCJpZ25vcmluZyBub24tYXV0aCB0b2tlbiBleHBpcmVkIGVycm9yXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGJhc2VWZXJzaW9uIH0gPSBzZXJ2ZXJNZXNzYWdlO1xuICAgIC8vIFZlcnNpb25lZCBBdXRoRXJyb3JzIGFyZSBpZ25vcmVkIGlmIHRoZSBjbGllbnQgYWR2YW5jZWQgdG9cbiAgICAvLyBhIG5ld2VyIGF1dGggaWRlbnRpdHlcbiAgICAvLyBFcnJvciBhcmUgcmVwb3J0aW5nIHRoZSBwcmV2aW91cyB2ZXJzaW9uLCBzaW5jZSB0aGUgc2VydmVyXG4gICAgLy8gZGlkbid0IGFkdmFuY2UsIGhlbmNlIGArIDFgLlxuICAgIGlmICghdGhpcy5zeW5jU3RhdGUuaXNDdXJyZW50T3JOZXdlckF1dGhWZXJzaW9uKGJhc2VWZXJzaW9uICsgMSkpIHtcbiAgICAgIHRoaXMuX2xvZ1ZlcmJvc2UoXCJpZ25vcmluZyBhdXRoIGVycm9yIGZvciBwcmV2aW91cyBhdXRoIGF0dGVtcHRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZvaWQgdGhpcy50cnlUb1JlYXV0aGVudGljYXRlKHNlcnZlck1lc3NhZ2UpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRoaXMgaXMgc2ltaWxhciB0byBgcmVmZXRjaFRva2VuYCBkZWZpbmVkIGJlbG93LCBpbiBmYWN0IHdlXG4gIC8vIGRvbid0IHJlcHJlc2VudCB0aGVtIGFzIGRpZmZlcmVudCBzdGF0ZXMsIGJ1dCBpdCBpcyBkaWZmZXJlbnRcbiAgLy8gaW4gdGhhdCB3ZSBwYXVzZSB0aGUgV2ViU29ja2V0IHNvIHRoYXQgbXV0YXRpb25zXG4gIC8vIGRvbid0IHJldHJ5IHdpdGggYmFkIGF1dGguXG4gIHByaXZhdGUgYXN5bmMgdHJ5VG9SZWF1dGhlbnRpY2F0ZShzZXJ2ZXJNZXNzYWdlOiBBdXRoRXJyb3IpIHtcbiAgICB0aGlzLl9sb2dWZXJib3NlKGBhdHRlbXB0aW5nIHRvIHJlYXV0aGVudGljYXRlOiAke3NlcnZlck1lc3NhZ2UuZXJyb3J9YCk7XG4gICAgaWYgKFxuICAgICAgLy8gTm8gd2F5IHRvIGZldGNoIGFub3RoZXIgdG9rZW4sIGthYm9vbVxuICAgICAgdGhpcy5hdXRoU3RhdGUuc3RhdGUgPT09IFwibm9BdXRoXCIgfHxcbiAgICAgIC8vIFdlIGZhaWxlZCBvbiBhIGZyZXNoIHRva2VuLiBBZnRlciBhIHNtYWxsIG51bWJlciBvZiByZXRyaWVzLCB3ZSBnaXZlIHVwXG4gICAgICAvLyBhbmQgY2xlYXIgdGhlIGF1dGggc3RhdGUgdG8gYXZvaWQgaW5maW5pdGUgcmV0cmllcy5cbiAgICAgICh0aGlzLmF1dGhTdGF0ZS5zdGF0ZSA9PT0gXCJ3YWl0aW5nRm9yU2VydmVyQ29uZmlybWF0aW9uT2ZGcmVzaFRva2VuXCIgJiZcbiAgICAgICAgdGhpcy50b2tlbkNvbmZpcm1hdGlvbkF0dGVtcHRzID49IE1BWF9UT0tFTl9DT05GSVJNQVRJT05fQVRURU1QVFMpXG4gICAgKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihcbiAgICAgICAgYEZhaWxlZCB0byBhdXRoZW50aWNhdGU6IFwiJHtzZXJ2ZXJNZXNzYWdlLmVycm9yfVwiLCBjaGVjayB5b3VyIHNlcnZlciBhdXRoIGNvbmZpZ2AsXG4gICAgICApO1xuICAgICAgaWYgKHRoaXMuc3luY1N0YXRlLmhhc0F1dGgoKSkge1xuICAgICAgICB0aGlzLnN5bmNTdGF0ZS5jbGVhckF1dGgoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmF1dGhTdGF0ZS5zdGF0ZSAhPT0gXCJub0F1dGhcIikge1xuICAgICAgICB0aGlzLnNldEFuZFJlcG9ydEF1dGhGYWlsZWQodGhpcy5hdXRoU3RhdGUuY29uZmlnLm9uQXV0aENoYW5nZSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmF1dGhTdGF0ZS5zdGF0ZSA9PT0gXCJ3YWl0aW5nRm9yU2VydmVyQ29uZmlybWF0aW9uT2ZGcmVzaFRva2VuXCIpIHtcbiAgICAgIHRoaXMudG9rZW5Db25maXJtYXRpb25BdHRlbXB0cysrO1xuICAgICAgdGhpcy5fbG9nVmVyYm9zZShcbiAgICAgICAgYHJldHJ5aW5nIHJlYXV0aGVudGljYXRpb24sICR7TUFYX1RPS0VOX0NPTkZJUk1BVElPTl9BVFRFTVBUUyAtIHRoaXMudG9rZW5Db25maXJtYXRpb25BdHRlbXB0c30gYXR0ZW1wdHMgcmVtYWluaW5nYCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgYXdhaXQgdGhpcy5zdG9wU29ja2V0KCk7XG4gICAgY29uc3QgdG9rZW4gPSBhd2FpdCB0aGlzLmZldGNoVG9rZW5BbmRHdWFyZEFnYWluc3RSYWNlKFxuICAgICAgdGhpcy5hdXRoU3RhdGUuY29uZmlnLmZldGNoVG9rZW4sXG4gICAgICB7XG4gICAgICAgIGZvcmNlUmVmcmVzaFRva2VuOiB0cnVlLFxuICAgICAgfSxcbiAgICApO1xuICAgIGlmICh0b2tlbi5pc0Zyb21PdXRkYXRlZENvbmZpZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0b2tlbi52YWx1ZSAmJiB0aGlzLnN5bmNTdGF0ZS5pc05ld0F1dGgodG9rZW4udmFsdWUpKSB7XG4gICAgICB0aGlzLmF1dGhlbnRpY2F0ZSh0b2tlbi52YWx1ZSk7XG4gICAgICB0aGlzLnNldEF1dGhTdGF0ZSh7XG4gICAgICAgIHN0YXRlOiBcIndhaXRpbmdGb3JTZXJ2ZXJDb25maXJtYXRpb25PZkZyZXNoVG9rZW5cIixcbiAgICAgICAgY29uZmlnOiB0aGlzLmF1dGhTdGF0ZS5jb25maWcsXG4gICAgICAgIHRva2VuOiB0b2tlbi52YWx1ZSxcbiAgICAgICAgaGFkQXV0aDpcbiAgICAgICAgICB0aGlzLmF1dGhTdGF0ZS5zdGF0ZSA9PT0gXCJub3RSZWZldGNoaW5nXCIgfHxcbiAgICAgICAgICB0aGlzLmF1dGhTdGF0ZS5zdGF0ZSA9PT0gXCJ3YWl0aW5nRm9yU2NoZWR1bGVkUmVmZXRjaFwiLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2xvZ1ZlcmJvc2UoXCJyZWF1dGhlbnRpY2F0aW9uIGZhaWxlZCwgY291bGQgbm90IGZldGNoIGEgbmV3IHRva2VuXCIpO1xuICAgICAgaWYgKHRoaXMuc3luY1N0YXRlLmhhc0F1dGgoKSkge1xuICAgICAgICB0aGlzLnN5bmNTdGF0ZS5jbGVhckF1dGgoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0QW5kUmVwb3J0QXV0aEZhaWxlZCh0aGlzLmF1dGhTdGF0ZS5jb25maWcub25BdXRoQ2hhbmdlKTtcbiAgICB9XG4gICAgdGhpcy50cnlSZXN0YXJ0U29ja2V0KCk7XG4gIH1cblxuICAvLyBGb3JjZSByZWZldGNoIHRoZSB0b2tlbiBhbmQgc2NoZWR1bGUgYW5vdGhlciByZWZldGNoXG4gIC8vIGJlZm9yZSB0aGUgdG9rZW4gZXhwaXJlcyAtIGFuIGFjdGl2ZSBjbGllbnQgc2hvdWxkIG5ldmVyXG4gIC8vIG5lZWQgdG8gcmVhdXRoZW50aWNhdGUuXG4gIHByaXZhdGUgYXN5bmMgcmVmZXRjaFRva2VuKCkge1xuICAgIGlmICh0aGlzLmF1dGhTdGF0ZS5zdGF0ZSA9PT0gXCJub0F1dGhcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9sb2dWZXJib3NlKFwicmVmZXRjaGluZyBhdXRoIHRva2VuXCIpO1xuICAgIGNvbnN0IHRva2VuID0gYXdhaXQgdGhpcy5mZXRjaFRva2VuQW5kR3VhcmRBZ2FpbnN0UmFjZShcbiAgICAgIHRoaXMuYXV0aFN0YXRlLmNvbmZpZy5mZXRjaFRva2VuLFxuICAgICAge1xuICAgICAgICBmb3JjZVJlZnJlc2hUb2tlbjogdHJ1ZSxcbiAgICAgIH0sXG4gICAgKTtcbiAgICBpZiAodG9rZW4uaXNGcm9tT3V0ZGF0ZWRDb25maWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodG9rZW4udmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLnN5bmNTdGF0ZS5pc05ld0F1dGgodG9rZW4udmFsdWUpKSB7XG4gICAgICAgIHRoaXMuc2V0QXV0aFN0YXRlKHtcbiAgICAgICAgICBzdGF0ZTogXCJ3YWl0aW5nRm9yU2VydmVyQ29uZmlybWF0aW9uT2ZGcmVzaFRva2VuXCIsXG4gICAgICAgICAgaGFkQXV0aDogdGhpcy5zeW5jU3RhdGUuaGFzQXV0aCgpLFxuICAgICAgICAgIHRva2VuOiB0b2tlbi52YWx1ZSxcbiAgICAgICAgICBjb25maWc6IHRoaXMuYXV0aFN0YXRlLmNvbmZpZyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYXV0aGVudGljYXRlKHRva2VuLnZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0QXV0aFN0YXRlKHtcbiAgICAgICAgICBzdGF0ZTogXCJub3RSZWZldGNoaW5nXCIsXG4gICAgICAgICAgY29uZmlnOiB0aGlzLmF1dGhTdGF0ZS5jb25maWcsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9sb2dWZXJib3NlKFwicmVmZXRjaGluZyB0b2tlbiBmYWlsZWRcIik7XG4gICAgICBpZiAodGhpcy5zeW5jU3RhdGUuaGFzQXV0aCgpKSB7XG4gICAgICAgIHRoaXMuY2xlYXJBdXRoKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldEFuZFJlcG9ydEF1dGhGYWlsZWQodGhpcy5hdXRoU3RhdGUuY29uZmlnLm9uQXV0aENoYW5nZSk7XG4gICAgfVxuICAgIC8vIFJlc3RhcnQgaW4gY2FzZSB0aGlzIHJlZmV0Y2ggd2FzIHRyaWdnZXJlZCB2aWEgc2NoZWR1bGUgZHVyaW5nXG4gICAgLy8gYSByZWF1dGhlbnRpY2F0aW9uIGF0dGVtcHQuXG4gICAgdGhpcy5fbG9nVmVyYm9zZShcbiAgICAgIFwicmVzdGFydGluZyBXUyBhZnRlciBhdXRoIHRva2VuIGZldGNoIChpZiBjdXJyZW50bHkgc3RvcHBlZClcIixcbiAgICApO1xuICAgIHRoaXMudHJ5UmVzdGFydFNvY2tldCgpO1xuICB9XG5cbiAgcHJpdmF0ZSBzY2hlZHVsZVRva2VuUmVmZXRjaCh0b2tlbjogc3RyaW5nKSB7XG4gICAgaWYgKHRoaXMuYXV0aFN0YXRlLnN0YXRlID09PSBcIm5vQXV0aFwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRlY29kZWRUb2tlbiA9IHRoaXMuZGVjb2RlVG9rZW4odG9rZW4pO1xuICAgIGlmICghZGVjb2RlZFRva2VuKSB7XG4gICAgICAvLyBUaGlzIGlzIG5vIGxvbmdlciByZWFsbHkgcG9zc2libGUsIGJlY2F1c2VcbiAgICAgIC8vIHdlIHdhaXQgb24gc2VydmVyIHJlc3BvbnNlIGJlZm9yZSBzY2hlZHVsaW5nIHRva2VuIHJlZmV0Y2gsXG4gICAgICAvLyBhbmQgdGhlIHNlcnZlciBjdXJyZW50bHkgcmVxdWlyZXMgSldUIHRva2Vucy5cbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFxuICAgICAgICBcIkF1dGggdG9rZW4gaXMgbm90IGEgdmFsaWQgSldULCBjYW5ub3QgcmVmZXRjaCB0aGUgdG9rZW5cIixcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGlhdDogaXNzdWVkIGF0IHRpbWUsIFVUQyBzZWNvbmRzIHRpbWVzdGFtcCBhdCB3aGljaCB0aGUgSldUIHdhcyBpc3N1ZWRcbiAgICAvLyBleHA6IGV4cGlyYXRpb24gdGltZSwgVVRDIHNlY29uZHMgdGltZXN0YW1wIGF0IHdoaWNoIHRoZSBKV1Qgd2lsbCBleHBpcmVcbiAgICBjb25zdCB7IGlhdCwgZXhwIH0gPSBkZWNvZGVkVG9rZW4gYXMgeyBpYXQ/OiBudW1iZXI7IGV4cD86IG51bWJlciB9O1xuICAgIGlmICghaWF0IHx8ICFleHApIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFxuICAgICAgICBcIkF1dGggdG9rZW4gZG9lcyBub3QgaGF2ZSByZXF1aXJlZCBmaWVsZHMsIGNhbm5vdCByZWZldGNoIHRoZSB0b2tlblwiLFxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gQmVjYXVzZSB0aGUgY2xpZW50IGFuZCBzZXJ2ZXIgY2xvY2tzIG1heSBiZSBvdXQgb2Ygc3luYyxcbiAgICAvLyB3ZSBvbmx5IGtub3cgdGhhdCB0aGUgdG9rZW4gd2lsbCBleHBpcmUgYWZ0ZXIgYGV4cCAtIGlhdGAsXG4gICAgLy8gYW5kIHNpbmNlIHdlIGp1c3QgZmV0Y2hlZCBhIGZyZXNoIG9uZSB3ZSBrbm93IHdoZW4gdGhhdFxuICAgIC8vIHdpbGwgaGFwcGVuLlxuICAgIGNvbnN0IHRva2VuVmFsaWRpdHlTZWNvbmRzID0gZXhwIC0gaWF0O1xuICAgIGlmICh0b2tlblZhbGlkaXR5U2Vjb25kcyA8PSAyKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihcbiAgICAgICAgXCJBdXRoIHRva2VuIGRvZXMgbm90IGxpdmUgbG9uZyBlbm91Z2gsIGNhbm5vdCByZWZldGNoIHRoZSB0b2tlblwiLFxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gQXR0ZW1wdCB0byByZWZyZXNoIHRoZSB0b2tlbiBgcmVmcmVzaFRva2VuTGVld2F5U2Vjb25kc2AgYmVmb3JlIGl0IGV4cGlyZXMsXG4gICAgLy8gb3IgaW1tZWRpYXRlbHkgaWYgdGhlIHRva2VuIGlzIGFscmVhZHkgZXhwaXJpbmcgc29vbi5cbiAgICBsZXQgZGVsYXkgPSBNYXRoLm1pbihcbiAgICAgIE1BWElNVU1fUkVGUkVTSF9ERUxBWSxcbiAgICAgICh0b2tlblZhbGlkaXR5U2Vjb25kcyAtIHRoaXMucmVmcmVzaFRva2VuTGVld2F5U2Vjb25kcykgKiAxMDAwLFxuICAgICk7XG4gICAgaWYgKGRlbGF5IDw9IDApIHtcbiAgICAgIC8vIFJlZmV0Y2ggaW1tZWRpYXRlbHksIGJ1dCB0aGlzIG1pZ2h0IGJlIGR1ZSB0byBjb25maWd1cmluZyBhIGByZWZyZXNoVG9rZW5MZWV3YXlTZWNvbmRzYFxuICAgICAgLy8gdGhhdCBpcyB0b28gbGFyZ2UgY29tcGFyZWQgdG8gdGhlIHRva2VuJ3MgYWN0dWFsIGxpZmV0aW1lLlxuICAgICAgdGhpcy5sb2dnZXIud2FybihcbiAgICAgICAgYFJlZmV0Y2hpbmcgYXV0aCB0b2tlbiBpbW1lZGlhdGVseSwgY29uZmlndXJlZCBsZWV3YXkgJHt0aGlzLnJlZnJlc2hUb2tlbkxlZXdheVNlY29uZHN9cyBpcyBsYXJnZXIgdGhhbiB0aGUgdG9rZW4ncyBsaWZldGltZSAke3Rva2VuVmFsaWRpdHlTZWNvbmRzfXNgLFxuICAgICAgKTtcbiAgICAgIGRlbGF5ID0gMDtcbiAgICB9XG4gICAgY29uc3QgcmVmZXRjaFRva2VuVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9sb2dWZXJib3NlKFwicnVubmluZyBzY2hlZHVsZWQgdG9rZW4gcmVmZXRjaFwiKTtcbiAgICAgIHZvaWQgdGhpcy5yZWZldGNoVG9rZW4oKTtcbiAgICB9LCBkZWxheSk7XG4gICAgdGhpcy5zZXRBdXRoU3RhdGUoe1xuICAgICAgc3RhdGU6IFwid2FpdGluZ0ZvclNjaGVkdWxlZFJlZmV0Y2hcIixcbiAgICAgIHJlZmV0Y2hUb2tlblRpbWVvdXRJZCxcbiAgICAgIGNvbmZpZzogdGhpcy5hdXRoU3RhdGUuY29uZmlnLFxuICAgIH0pO1xuICAgIHRoaXMuX2xvZ1ZlcmJvc2UoXG4gICAgICBgc2NoZWR1bGVkIHByZWVtcHRpdmUgYXV0aCB0b2tlbiByZWZldGNoaW5nIGluICR7ZGVsYXl9bXNgLFxuICAgICk7XG4gIH1cblxuICAvLyBQcm90ZWN0cyBhZ2FpbnN0IHNpbXVsdGFuZW91cyBjYWxscyB0byBgc2V0Q29uZmlnYFxuICAvLyB3aGlsZSB3ZSdyZSBmZXRjaGluZyBhIHRva2VuXG4gIHByaXZhdGUgYXN5bmMgZmV0Y2hUb2tlbkFuZEd1YXJkQWdhaW5zdFJhY2UoXG4gICAgZmV0Y2hUb2tlbjogQXV0aFRva2VuRmV0Y2hlcixcbiAgICBmZXRjaEFyZ3M6IHtcbiAgICAgIGZvcmNlUmVmcmVzaFRva2VuOiBib29sZWFuO1xuICAgIH0sXG4gICkge1xuICAgIGNvbnN0IG9yaWdpbmFsQ29uZmlnVmVyc2lvbiA9ICsrdGhpcy5jb25maWdWZXJzaW9uO1xuICAgIHRoaXMuX2xvZ1ZlcmJvc2UoXG4gICAgICBgZmV0Y2hpbmcgdG9rZW4gd2l0aCBjb25maWcgdmVyc2lvbiAke29yaWdpbmFsQ29uZmlnVmVyc2lvbn1gLFxuICAgICk7XG4gICAgY29uc3QgdG9rZW4gPSBhd2FpdCBmZXRjaFRva2VuKGZldGNoQXJncyk7XG4gICAgaWYgKHRoaXMuY29uZmlnVmVyc2lvbiAhPT0gb3JpZ2luYWxDb25maWdWZXJzaW9uKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgc3RhbGUgY29uZmlnXG4gICAgICB0aGlzLl9sb2dWZXJib3NlKFxuICAgICAgICBgc3RhbGUgY29uZmlnIHZlcnNpb24sIGV4cGVjdGVkICR7b3JpZ2luYWxDb25maWdWZXJzaW9ufSwgZ290ICR7dGhpcy5jb25maWdWZXJzaW9ufWAsXG4gICAgICApO1xuICAgICAgcmV0dXJuIHsgaXNGcm9tT3V0ZGF0ZWRDb25maWc6IHRydWUgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgaXNGcm9tT3V0ZGF0ZWRDb25maWc6IGZhbHNlLCB2YWx1ZTogdG9rZW4gfTtcbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgdGhpcy5yZXNldEF1dGhTdGF0ZSgpO1xuICAgIC8vIEJ1bXAgdGhpcyBpbiBjYXNlIHdlIGFyZSBtaWQtdG9rZW4tZmV0Y2ggd2hlbiB3ZSBnZXQgc3RvcHBlZFxuICAgIHRoaXMuY29uZmlnVmVyc2lvbisrO1xuICAgIHRoaXMuX2xvZ1ZlcmJvc2UoYGNvbmZpZyB2ZXJzaW9uIGJ1bXBlZCB0byAke3RoaXMuY29uZmlnVmVyc2lvbn1gKTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0QW5kUmVwb3J0QXV0aEZhaWxlZChcbiAgICBvbkF1dGhDaGFuZ2U6IChhdXRoZW50aWNhdGVkOiBib29sZWFuKSA9PiB2b2lkLFxuICApIHtcbiAgICBvbkF1dGhDaGFuZ2UoZmFsc2UpO1xuICAgIHRoaXMucmVzZXRBdXRoU3RhdGUoKTtcbiAgfVxuXG4gIHByaXZhdGUgcmVzZXRBdXRoU3RhdGUoKSB7XG4gICAgdGhpcy5zZXRBdXRoU3RhdGUoeyBzdGF0ZTogXCJub0F1dGhcIiB9KTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0QXV0aFN0YXRlKG5ld0F1dGg6IEF1dGhTdGF0ZSkge1xuICAgIGNvbnN0IGF1dGhTdGF0ZUZvckxvZyA9XG4gICAgICBuZXdBdXRoLnN0YXRlID09PSBcIndhaXRpbmdGb3JTZXJ2ZXJDb25maXJtYXRpb25PZkZyZXNoVG9rZW5cIlxuICAgICAgICA/IHtcbiAgICAgICAgICAgIGhhZEF1dGg6IG5ld0F1dGguaGFkQXV0aCxcbiAgICAgICAgICAgIHN0YXRlOiBuZXdBdXRoLnN0YXRlLFxuICAgICAgICAgICAgdG9rZW46IGAuLi4ke25ld0F1dGgudG9rZW4uc2xpY2UoLTcpfWAsXG4gICAgICAgICAgfVxuICAgICAgICA6IHsgc3RhdGU6IG5ld0F1dGguc3RhdGUgfTtcbiAgICB0aGlzLl9sb2dWZXJib3NlKFxuICAgICAgYHNldHRpbmcgYXV0aCBzdGF0ZSB0byAke0pTT04uc3RyaW5naWZ5KGF1dGhTdGF0ZUZvckxvZyl9YCxcbiAgICApO1xuICAgIHN3aXRjaCAobmV3QXV0aC5zdGF0ZSkge1xuICAgICAgY2FzZSBcIndhaXRpbmdGb3JTY2hlZHVsZWRSZWZldGNoXCI6XG4gICAgICBjYXNlIFwibm90UmVmZXRjaGluZ1wiOlxuICAgICAgY2FzZSBcIm5vQXV0aFwiOlxuICAgICAgICB0aGlzLnRva2VuQ29uZmlybWF0aW9uQXR0ZW1wdHMgPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ3YWl0aW5nRm9yU2VydmVyQ29uZmlybWF0aW9uT2ZGcmVzaFRva2VuXCI6XG4gICAgICBjYXNlIFwid2FpdGluZ0ZvclNlcnZlckNvbmZpcm1hdGlvbk9mQ2FjaGVkVG9rZW5cIjpcbiAgICAgIGNhc2UgXCJpbml0aWFsUmVmZXRjaFwiOlxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgbmV3QXV0aCBzYXRpc2ZpZXMgbmV2ZXI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmF1dGhTdGF0ZS5zdGF0ZSA9PT0gXCJ3YWl0aW5nRm9yU2NoZWR1bGVkUmVmZXRjaFwiKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5hdXRoU3RhdGUucmVmZXRjaFRva2VuVGltZW91dElkKTtcblxuICAgICAgLy8gVGhlIHdhaXRpbmdGb3JTY2hlZHVsZWRSZWZldGNoIHN0YXRlIGlzIHRoZSBtb3N0IHF1aWVzY2VkIGF1dGhlZCBzdGF0ZS5cbiAgICAgIC8vIExldCB0aGUgc3luY1N0YXRlIGtub3cgdGhhdCBhdXRoIGlzIGluIGEgZ29vZCBzdGF0ZSwgc28gaXQgY2FuIHJlc2V0IGZhaWx1cmUgYmFja29mZnNcbiAgICAgIHRoaXMuc3luY1N0YXRlLm1hcmtBdXRoQ29tcGxldGlvbigpO1xuICAgIH1cbiAgICB0aGlzLmF1dGhTdGF0ZSA9IG5ld0F1dGg7XG4gIH1cblxuICBwcml2YXRlIGRlY29kZVRva2VuKHRva2VuOiBzdHJpbmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGp3dERlY29kZSh0b2tlbik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5fbG9nVmVyYm9zZShcbiAgICAgICAgYEVycm9yIGRlY29kaW5nIHRva2VuOiAke2UgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwifWAsXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfbG9nVmVyYm9zZShtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICB0aGlzLmxvZ2dlci5sb2dWZXJib3NlKGAke21lc3NhZ2V9IFt2JHt0aGlzLmNvbmZpZ1ZlcnNpb259XWApO1xuICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydCBjbGFzcyBJbnZhbGlkVG9rZW5FcnJvciBleHRlbmRzIEVycm9yIHtcbn1cbkludmFsaWRUb2tlbkVycm9yLnByb3RvdHlwZS5uYW1lID0gXCJJbnZhbGlkVG9rZW5FcnJvclwiO1xuZnVuY3Rpb24gYjY0RGVjb2RlVW5pY29kZShzdHIpIHtcbiAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChcbiAgICBhdG9iKHN0cikucmVwbGFjZSgvKC4pL2csIChfbSwgcCkgPT4ge1xuICAgICAgbGV0IGNvZGUgPSBwLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgICBpZiAoY29kZS5sZW5ndGggPCAyKSB7XG4gICAgICAgIGNvZGUgPSBcIjBcIiArIGNvZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCIlXCIgKyBjb2RlO1xuICAgIH0pXG4gICk7XG59XG5mdW5jdGlvbiBiYXNlNjRVcmxEZWNvZGUoc3RyKSB7XG4gIGxldCBvdXRwdXQgPSBzdHIucmVwbGFjZSgvLS9nLCBcIitcIikucmVwbGFjZSgvXy9nLCBcIi9cIik7XG4gIHN3aXRjaCAob3V0cHV0Lmxlbmd0aCAlIDQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI6XG4gICAgICBvdXRwdXQgKz0gXCI9PVwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOlxuICAgICAgb3V0cHV0ICs9IFwiPVwiO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImJhc2U2NCBzdHJpbmcgaXMgbm90IG9mIHRoZSBjb3JyZWN0IGxlbmd0aFwiKTtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBiNjREZWNvZGVVbmljb2RlKG91dHB1dCk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBhdG9iKG91dHB1dCk7XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBqd3REZWNvZGUodG9rZW4sIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiB0b2tlbiAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBJbnZhbGlkVG9rZW5FcnJvcihcIkludmFsaWQgdG9rZW4gc3BlY2lmaWVkOiBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICB9XG4gIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gIGNvbnN0IHBvcyA9IG9wdGlvbnMuaGVhZGVyID09PSB0cnVlID8gMCA6IDE7XG4gIGNvbnN0IHBhcnQgPSB0b2tlbi5zcGxpdChcIi5cIilbcG9zXTtcbiAgaWYgKHR5cGVvZiBwYXJ0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRUb2tlbkVycm9yKFxuICAgICAgYEludmFsaWQgdG9rZW4gc3BlY2lmaWVkOiBtaXNzaW5nIHBhcnQgIyR7cG9zICsgMX1gXG4gICAgKTtcbiAgfVxuICBsZXQgZGVjb2RlZDtcbiAgdHJ5IHtcbiAgICBkZWNvZGVkID0gYmFzZTY0VXJsRGVjb2RlKHBhcnQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRUb2tlbkVycm9yKFxuICAgICAgYEludmFsaWQgdG9rZW4gc3BlY2lmaWVkOiBpbnZhbGlkIGJhc2U2NCBmb3IgcGFydCAjJHtwb3MgKyAxfSAoJHtlLm1lc3NhZ2V9KWBcbiAgICApO1xuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZGVjb2RlZCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFRva2VuRXJyb3IoXG4gICAgICBgSW52YWxpZCB0b2tlbiBzcGVjaWZpZWQ6IGludmFsaWQganNvbiBmb3IgcGFydCAjJHtwb3MgKyAxfSAoJHtlLm1lc3NhZ2V9KWBcbiAgICApO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsImV4cG9ydCBpbnRlcmZhY2UgSnd0RGVjb2RlT3B0aW9ucyB7XG4gIGhlYWRlcj86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSnd0SGVhZGVyIHtcbiAgdHlwPzogc3RyaW5nO1xuICBhbGc/OiBzdHJpbmc7XG4gIGtpZD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBKd3RQYXlsb2FkIHtcbiAgaXNzPzogc3RyaW5nO1xuICBzdWI/OiBzdHJpbmc7XG4gIGF1ZD86IHN0cmluZ1tdIHwgc3RyaW5nO1xuICBleHA/OiBudW1iZXI7XG4gIG5iZj86IG51bWJlcjtcbiAgaWF0PzogbnVtYmVyO1xuICBqdGk/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjbGFzcyBJbnZhbGlkVG9rZW5FcnJvciBleHRlbmRzIEVycm9yIHt9XG5cbkludmFsaWRUb2tlbkVycm9yLnByb3RvdHlwZS5uYW1lID0gXCJJbnZhbGlkVG9rZW5FcnJvclwiO1xuXG5mdW5jdGlvbiBiNjREZWNvZGVVbmljb2RlKHN0cjogc3RyaW5nKSB7XG4gIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoXG4gICAgYXRvYihzdHIpLnJlcGxhY2UoLyguKS9nLCAoX20sIHApID0+IHtcbiAgICAgIGxldCBjb2RlID0gKHAgYXMgc3RyaW5nKS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgICAgaWYgKGNvZGUubGVuZ3RoIDwgMikge1xuICAgICAgICBjb2RlID0gXCIwXCIgKyBjb2RlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiJVwiICsgY29kZTtcbiAgICB9KSxcbiAgKTtcbn1cblxuZnVuY3Rpb24gYmFzZTY0VXJsRGVjb2RlKHN0cjogc3RyaW5nKSB7XG4gIGxldCBvdXRwdXQgPSBzdHIucmVwbGFjZSgvLS9nLCBcIitcIikucmVwbGFjZSgvXy9nLCBcIi9cIik7XG4gIHN3aXRjaCAob3V0cHV0Lmxlbmd0aCAlIDQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI6XG4gICAgICBvdXRwdXQgKz0gXCI9PVwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOlxuICAgICAgb3V0cHV0ICs9IFwiPVwiO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImJhc2U2NCBzdHJpbmcgaXMgbm90IG9mIHRoZSBjb3JyZWN0IGxlbmd0aFwiKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGI2NERlY29kZVVuaWNvZGUob3V0cHV0KTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGF0b2Iob3V0cHV0KTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gand0RGVjb2RlPFQgPSBKd3RIZWFkZXI+KFxuICB0b2tlbjogc3RyaW5nLFxuICBvcHRpb25zOiBKd3REZWNvZGVPcHRpb25zICYgeyBoZWFkZXI6IHRydWUgfSxcbik6IFQ7XG5leHBvcnQgZnVuY3Rpb24gand0RGVjb2RlPFQgPSBKd3RQYXlsb2FkPihcbiAgdG9rZW46IHN0cmluZyxcbiAgb3B0aW9ucz86IEp3dERlY29kZU9wdGlvbnMsXG4pOiBUO1xuZXhwb3J0IGZ1bmN0aW9uIGp3dERlY29kZTxUID0gSnd0SGVhZGVyIHwgSnd0UGF5bG9hZD4oXG4gIHRva2VuOiBzdHJpbmcsXG4gIG9wdGlvbnM/OiBKd3REZWNvZGVPcHRpb25zLFxuKTogVCB7XG4gIGlmICh0eXBlb2YgdG9rZW4gIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFRva2VuRXJyb3IoXCJJbnZhbGlkIHRva2VuIHNwZWNpZmllZDogbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgfVxuXG4gIG9wdGlvbnMgfHw9IHt9O1xuXG4gIGNvbnN0IHBvcyA9IG9wdGlvbnMuaGVhZGVyID09PSB0cnVlID8gMCA6IDE7XG4gIGNvbnN0IHBhcnQgPSB0b2tlbi5zcGxpdChcIi5cIilbcG9zXTtcblxuICBpZiAodHlwZW9mIHBhcnQgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFRva2VuRXJyb3IoXG4gICAgICBgSW52YWxpZCB0b2tlbiBzcGVjaWZpZWQ6IG1pc3NpbmcgcGFydCAjJHtwb3MgKyAxfWAsXG4gICAgKTtcbiAgfVxuXG4gIGxldCBkZWNvZGVkOiBzdHJpbmc7XG4gIHRyeSB7XG4gICAgZGVjb2RlZCA9IGJhc2U2NFVybERlY29kZShwYXJ0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkVG9rZW5FcnJvcihcbiAgICAgIGBJbnZhbGlkIHRva2VuIHNwZWNpZmllZDogaW52YWxpZCBiYXNlNjQgZm9yIHBhcnQgIyR7cG9zICsgMX0gKCR7KGUgYXMgRXJyb3IpLm1lc3NhZ2V9KWAsXG4gICAgKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZGVjb2RlZCkgYXMgVDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkVG9rZW5FcnJvcihcbiAgICAgIGBJbnZhbGlkIHRva2VuIHNwZWNpZmllZDogaW52YWxpZCBqc29uIGZvciBwYXJ0ICMke3BvcyArIDF9ICgkeyhlIGFzIEVycm9yKS5tZXNzYWdlfSlgLFxuICAgICk7XG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuY29uc3QgbWFya05hbWVzID0gW1xuICBcImNvbnZleENsaWVudENvbnN0cnVjdGVkXCIsXG4gIFwiY29udmV4V2ViU29ja2V0T3BlblwiLFxuICBcImNvbnZleEZpcnN0TWVzc2FnZVJlY2VpdmVkXCJcbl07XG5leHBvcnQgZnVuY3Rpb24gbWFyayhuYW1lLCBzZXNzaW9uSWQpIHtcbiAgY29uc3QgZGV0YWlsID0geyBzZXNzaW9uSWQgfTtcbiAgaWYgKHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhcGVyZm9ybWFuY2UubWFyaykgcmV0dXJuO1xuICBwZXJmb3JtYW5jZS5tYXJrKG5hbWUsIHsgZGV0YWlsIH0pO1xufVxuZnVuY3Rpb24gcGVyZm9ybWFuY2VNYXJrVG9Kc29uKG1hcmsyKSB7XG4gIGxldCBuYW1lID0gbWFyazIubmFtZS5zbGljZShcImNvbnZleFwiLmxlbmd0aCk7XG4gIG5hbWUgPSBuYW1lLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgbmFtZS5zbGljZSgxKTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lLFxuICAgIHN0YXJ0VGltZTogbWFyazIuc3RhcnRUaW1lXG4gIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0TWFya3NSZXBvcnQoc2Vzc2lvbklkKSB7XG4gIGlmICh0eXBlb2YgcGVyZm9ybWFuY2UgPT09IFwidW5kZWZpbmVkXCIgfHwgIXBlcmZvcm1hbmNlLmdldEVudHJpZXNCeU5hbWUpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3QgYWxsTWFya3MgPSBbXTtcbiAgZm9yIChjb25zdCBuYW1lIG9mIG1hcmtOYW1lcykge1xuICAgIGNvbnN0IG1hcmtzID0gcGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZShuYW1lKS5maWx0ZXIoKGVudHJ5KSA9PiBlbnRyeS5lbnRyeVR5cGUgPT09IFwibWFya1wiKS5maWx0ZXIoKG1hcmsyKSA9PiBtYXJrMi5kZXRhaWwuc2Vzc2lvbklkID09PSBzZXNzaW9uSWQpO1xuICAgIGFsbE1hcmtzLnB1c2goLi4ubWFya3MpO1xuICB9XG4gIHJldHVybiBhbGxNYXJrcy5tYXAocGVyZm9ybWFuY2VNYXJrVG9Kc29uKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ldHJpY3MuanMubWFwXG4iLCIvLyBNYXJrcyBzaGFyZSBhIGdsb2JhbCBuYW1lc3BhY2Ugd2l0aCBvdGhlciBkZXZlbG9wZXIgY29kZS5cbmNvbnN0IG1hcmtOYW1lcyA9IFtcbiAgXCJjb252ZXhDbGllbnRDb25zdHJ1Y3RlZFwiLFxuICBcImNvbnZleFdlYlNvY2tldE9wZW5cIixcbiAgXCJjb252ZXhGaXJzdE1lc3NhZ2VSZWNlaXZlZFwiLFxuXSBhcyBjb25zdDtcbmV4cG9ydCB0eXBlIE1hcmtOYW1lID0gKHR5cGVvZiBtYXJrTmFtZXMpW251bWJlcl07XG5cbi8vIE1hcmsgZGV0YWlscyBhcmUgbm90IHJlcG9ydGVkIHRvIHRoZSBzZXJ2ZXIuXG50eXBlIE1hcmtEZXRhaWwgPSB7XG4gIHNlc3Npb25JZDogc3RyaW5nO1xufTtcblxuLy8gYFBlcmZvcm1hbmNlTWFya2BzIGFyZSBlZmZpY2llbnQgYW5kIHNob3cgdXAgaW4gYnJvd3NlcidzIHBlcmZvcm1hbmNlXG4vLyB0aW1lbGluZS4gVGhleSBjYW4gYmUgY2xlYXJlZCB3aXRoIGBwZXJmb3JtYW5jZS5jbGVhck1hcmtzKClgLlxuLy8gVGhpcyBpcyBhIG1lbW9yeSBsZWFrLCBidXQgYSB3b3J0aHdoaWxlIG9uZTogYXV0b21hdGljXG4vLyBjbGVhbnVwIHdvdWxkIG1ha2UgaW4tYnJvd3NlciBkZWJ1Z2dpbmcgbW9yZSBkaWZmaWN1bHQuXG5leHBvcnQgZnVuY3Rpb24gbWFyayhuYW1lOiBNYXJrTmFtZSwgc2Vzc2lvbklkOiBzdHJpbmcpIHtcbiAgY29uc3QgZGV0YWlsOiBNYXJrRGV0YWlsID0geyBzZXNzaW9uSWQgfTtcbiAgLy8gYHBlcmZvcm1hbmNlYCBBUElzIGV4aXN0cyBpbiBicm93c2VycywgTm9kZS5qcywgRGVubywgYW5kIG1vcmUgYnV0IGl0XG4gIC8vIGlzIG5vdCByZXF1aXJlZCBieSB0aGUgQ29udmV4IGNsaWVudC5cbiAgaWYgKHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhcGVyZm9ybWFuY2UubWFyaykgcmV0dXJuO1xuICBwZXJmb3JtYW5jZS5tYXJrKG5hbWUsIHsgZGV0YWlsIH0pO1xufVxuXG4vLyBgUGVyZm9tYW5jZU1hcmtgIGhhcyBhIGJ1aWx0LWluIHRvSlNPTigpIGJ1dCB0aGUgcmV0dXJuIHR5cGUgdmFyaWVzXG4vLyBiZXR3ZWVuIGltcGxlbWVudGF0aW9ucywgZS5nLiBOb2RlLmpzIHJldHVybnMgZGV0YWlscyBidXQgQ2hyb21lIGRvZXMgbm90LlxuZnVuY3Rpb24gcGVyZm9ybWFuY2VNYXJrVG9Kc29uKG1hcms6IFBlcmZvcm1hbmNlTWFyayk6IE1hcmtKc29uIHtcbiAgLy8gUmVtb3ZlIFwiY29udmV4XCIgcHJlZml4XG4gIGxldCBuYW1lID0gbWFyay5uYW1lLnNsaWNlKFwiY29udmV4XCIubGVuZ3RoKTtcbiAgLy8gbG93ZXJjYXNlIHRoZSBmaXJzdCBsZXR0ZXJcbiAgbmFtZSA9IG5hbWUuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpO1xuICByZXR1cm4ge1xuICAgIG5hbWUsXG4gICAgc3RhcnRUaW1lOiBtYXJrLnN0YXJ0VGltZSxcbiAgfTtcbn1cblxuLy8gU2ltaWxhciB0byB0aGUgcmV0dXJuIHR5cGUgb2YgYFBlcmZvcm1hbmNlTWFyay50b0pzb24oKWAuXG5leHBvcnQgdHlwZSBNYXJrSnNvbiA9IHtcbiAgbmFtZTogc3RyaW5nO1xuICAvLyBgc3RhcnRUaW1lYCBpcyBpbiBtaWxsaXNlY29uZHMgc2luY2UgdGhlIHRpbWUgb3JpZ2luIGxpa2UgYHBlcmZvcm1hbmNlLm5vdygpYC5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0RPTUhpZ2hSZXNUaW1lU3RhbXAjdGhlX3RpbWVfb3JpZ2luXG4gIHN0YXJ0VGltZTogbnVtYmVyO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1hcmtzUmVwb3J0KHNlc3Npb25JZDogc3RyaW5nKTogTWFya0pzb25bXSB7XG4gIGlmICh0eXBlb2YgcGVyZm9ybWFuY2UgPT09IFwidW5kZWZpbmVkXCIgfHwgIXBlcmZvcm1hbmNlLmdldEVudHJpZXNCeU5hbWUpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3QgYWxsTWFya3M6IFBlcmZvcm1hbmNlTWFya1tdID0gW107XG4gIGZvciAoY29uc3QgbmFtZSBvZiBtYXJrTmFtZXMpIHtcbiAgICBjb25zdCBtYXJrcyA9IChcbiAgICAgIHBlcmZvcm1hbmNlXG4gICAgICAgIC5nZXRFbnRyaWVzQnlOYW1lKG5hbWUpXG4gICAgICAgIC5maWx0ZXIoKGVudHJ5KSA9PiBlbnRyeS5lbnRyeVR5cGUgPT09IFwibWFya1wiKSBhcyBQZXJmb3JtYW5jZU1hcmtbXVxuICAgICkuZmlsdGVyKChtYXJrKSA9PiBtYXJrLmRldGFpbC5zZXNzaW9uSWQgPT09IHNlc3Npb25JZCk7XG4gICAgYWxsTWFya3MucHVzaCguLi5tYXJrcyk7XG4gIH1cbiAgcmV0dXJuIGFsbE1hcmtzLm1hcChwZXJmb3JtYW5jZU1hcmtUb0pzb24pO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuaW1wb3J0IHsgdmFsaWRhdGVEZXBsb3ltZW50VXJsIH0gZnJvbSBcIi4uL2NvbW1vbi9pbmRleC5qc1wiO1xuaW1wb3J0IHtcbiAgQmFzZUNvbnZleENsaWVudFxufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZ2V0RnVuY3Rpb25OYW1lIH0gZnJvbSBcIi4uL3NlcnZlci9hcGkuanNcIjtcbmltcG9ydCB7XG4gIFBhZ2luYXRlZFF1ZXJ5Q2xpZW50XG59IGZyb20gXCIuL3N5bmMvcGFnaW5hdGVkX3F1ZXJ5X2NsaWVudC5qc1wiO1xuaW1wb3J0IHsgc2VyaWFsaXplZFF1ZXJ5VG9rZW5Jc1BhZ2luYXRlZCB9IGZyb20gXCIuL3N5bmMvdWRmX3BhdGhfdXRpbHMuanNcIjtcbmxldCBkZWZhdWx0V2ViU29ja2V0Q29uc3RydWN0b3I7XG5leHBvcnQgZnVuY3Rpb24gc2V0RGVmYXVsdFdlYlNvY2tldENvbnN0cnVjdG9yKHdzKSB7XG4gIGRlZmF1bHRXZWJTb2NrZXRDb25zdHJ1Y3RvciA9IHdzO1xufVxuZXhwb3J0IGNsYXNzIENvbnZleENsaWVudCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBjbGllbnQgYW5kIGltbWVkaWF0ZWx5IGluaXRpYXRlIGEgV2ViU29ja2V0IGNvbm5lY3Rpb24gdG8gdGhlIHBhc3NlZCBhZGRyZXNzLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBvcHRpb25zID0ge30pIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibGlzdGVuZXJzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfY2xpZW50XCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfcGFnaW5hdGVkQ2xpZW50XCIpO1xuICAgIC8vIEEgc3ludGhldGljIHNlcnZlciBldmVudCB0byBydW4gY2FsbGJhY2tzIHRoZSBmaXJzdCB0aW1lXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNhbGxOZXdMaXN0ZW5lcnNXaXRoQ3VycmVudFZhbHVlc1RpbWVyXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfY2xvc2VkXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfZGlzYWJsZWRcIik7XG4gICAgaWYgKG9wdGlvbnMuc2tpcENvbnZleERlcGxveW1lbnRVcmxDaGVjayAhPT0gdHJ1ZSkge1xuICAgICAgdmFsaWRhdGVEZXBsb3ltZW50VXJsKGFkZHJlc3MpO1xuICAgIH1cbiAgICBjb25zdCB7IGRpc2FibGVkLCAuLi5iYXNlT3B0aW9ucyB9ID0gb3B0aW9ucztcbiAgICB0aGlzLl9jbG9zZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9kaXNhYmxlZCA9ICEhZGlzYWJsZWQ7XG4gICAgaWYgKGRlZmF1bHRXZWJTb2NrZXRDb25zdHJ1Y3RvciAmJiAhKFwid2ViU29ja2V0Q29uc3RydWN0b3JcIiBpbiBiYXNlT3B0aW9ucykgJiYgdHlwZW9mIFdlYlNvY2tldCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgYmFzZU9wdGlvbnMud2ViU29ja2V0Q29uc3RydWN0b3IgPSBkZWZhdWx0V2ViU29ja2V0Q29uc3RydWN0b3I7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiICYmICEoXCJ1bnNhdmVkQ2hhbmdlc1dhcm5pbmdcIiBpbiBiYXNlT3B0aW9ucykpIHtcbiAgICAgIGJhc2VPcHRpb25zLnVuc2F2ZWRDaGFuZ2VzV2FybmluZyA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuX2NsaWVudCA9IG5ldyBCYXNlQ29udmV4Q2xpZW50KFxuICAgICAgICBhZGRyZXNzLFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIE5PUCwgbGV0IHRoZSBwYWdpbmF0ZWQgcXVlcnkgY2xpZW50IGRvIGl0IGFsbFxuICAgICAgICBiYXNlT3B0aW9uc1xuICAgICAgKTtcbiAgICAgIHRoaXMuX3BhZ2luYXRlZENsaWVudCA9IG5ldyBQYWdpbmF0ZWRRdWVyeUNsaWVudChcbiAgICAgICAgdGhpcy5fY2xpZW50LFxuICAgICAgICAodHJhbnNpdGlvbikgPT4gdGhpcy5fdHJhbnNpdGlvbih0cmFuc2l0aW9uKVxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5saXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICB9XG4gIC8qKlxuICAgKiBPbmNlIGNsb3NlZCBubyByZWdpc3RlcmVkIGNhbGxiYWNrcyB3aWxsIGZpcmUgYWdhaW4uXG4gICAqL1xuICBnZXQgY2xvc2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9jbG9zZWQ7XG4gIH1cbiAgZ2V0IGNsaWVudCgpIHtcbiAgICBpZiAodGhpcy5fY2xpZW50KSByZXR1cm4gdGhpcy5fY2xpZW50O1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnZleENsaWVudCBpcyBkaXNhYmxlZFwiKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXQgcGFnaW5hdGVkQ2xpZW50KCkge1xuICAgIGlmICh0aGlzLl9wYWdpbmF0ZWRDbGllbnQpIHJldHVybiB0aGlzLl9wYWdpbmF0ZWRDbGllbnQ7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udmV4Q2xpZW50IGlzIGRpc2FibGVkXCIpO1xuICB9XG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgYSBjYWxsYmFjayB3aGVuZXZlciBhIG5ldyByZXN1bHQgZm9yIGEgcXVlcnkgaXMgcmVjZWl2ZWQuIFRoZSBjYWxsYmFja1xuICAgKiB3aWxsIHJ1biBzb29uIGFmdGVyIGJlaW5nIHJlZ2lzdGVyZWQgaWYgYSByZXN1bHQgZm9yIHRoZSBxdWVyeSBpcyBhbHJlYWR5XG4gICAqIGluIG1lbW9yeS5cbiAgICpcbiAgICogVGhlIHJldHVybiB2YWx1ZSBpcyBhbiB7QGxpbmsgVW5zdWJzY3JpYmV9IG9iamVjdCB3aGljaCBpcyBib3RoIGEgZnVuY3Rpb25cbiAgICogYW4gYW4gb2JqZWN0IHdpdGggcHJvcGVydGllcy4gQm90aCBvZiB0aGUgcGF0dGVybnMgYmVsb3cgd29yayB3aXRoIHRoaXMgb2JqZWN0OlxuICAgKlxuICAgKmBgYHRzXG4gICAqIC8vIGNhbGwgdGhlIHJldHVybiB2YWx1ZSBhcyBhIGZ1bmN0aW9uXG4gICAqIGNvbnN0IHVuc3Vic2NyaWJlID0gY2xpZW50Lm9uVXBkYXRlKGFwaS5tZXNzYWdlcy5saXN0LCB7fSwgKG1lc3NhZ2VzKSA9PiB7XG4gICAqICAgY29uc29sZS5sb2cobWVzc2FnZXMpO1xuICAgKiB9KTtcbiAgICogdW5zdWJzY3JpYmUoKTtcbiAgICpcbiAgICogLy8gdW5wYWNrIHRoZSByZXR1cm4gdmFsdWUgaW50byBpdHMgcHJvcGVydGllc1xuICAgKiBjb25zdCB7XG4gICAqICAgZ2V0Q3VycmVudFZhbHVlLFxuICAgKiAgIHVuc3Vic2NyaWJlLFxuICAgKiB9ID0gY2xpZW50Lm9uVXBkYXRlKGFwaS5tZXNzYWdlcy5saXN0LCB7fSwgKG1lc3NhZ2VzKSA9PiB7XG4gICAqICAgY29uc29sZS5sb2cobWVzc2FnZXMpO1xuICAgKiB9KTtcbiAgICpgYGBcbiAgICpcbiAgICogQHBhcmFtIHF1ZXJ5IC0gQSB7QGxpbmsgc2VydmVyLkZ1bmN0aW9uUmVmZXJlbmNlfSBmb3IgdGhlIHB1YmxpYyBxdWVyeSB0byBydW4uXG4gICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyB0byBydW4gdGhlIHF1ZXJ5IHdpdGguXG4gICAqIEBwYXJhbSBjYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgcXVlcnkgcmVzdWx0IHVwZGF0ZXMuXG4gICAqIEBwYXJhbSBvbkVycm9yIC0gRnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBxdWVyeSByZXN1bHQgdXBkYXRlcyB3aXRoIGFuIGVycm9yLlxuICAgKiBJZiBub3QgcHJvdmlkZWQsIGVycm9ycyB3aWxsIGJlIHRocm93biBpbnN0ZWFkIG9mIGNhbGxpbmcgdGhlIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAcmV0dXJuIGFuIHtAbGluayBVbnN1YnNjcmliZX0gZnVuY3Rpb24gdG8gc3RvcCBjYWxsaW5nIHRoZSBvblVwZGF0ZSBmdW5jdGlvbi5cbiAgICovXG4gIG9uVXBkYXRlKHF1ZXJ5LCBhcmdzLCBjYWxsYmFjaywgb25FcnJvcikge1xuICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVEaXNhYmxlZFVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIGNvbnN0IHsgcXVlcnlUb2tlbiwgdW5zdWJzY3JpYmUgfSA9IHRoaXMuY2xpZW50LnN1YnNjcmliZShcbiAgICAgIGdldEZ1bmN0aW9uTmFtZShxdWVyeSksXG4gICAgICBhcmdzXG4gICAgKTtcbiAgICBjb25zdCBxdWVyeUluZm8gPSB7XG4gICAgICBxdWVyeVRva2VuLFxuICAgICAgY2FsbGJhY2ssXG4gICAgICBvbkVycm9yLFxuICAgICAgdW5zdWJzY3JpYmUsXG4gICAgICBoYXNFdmVyUnVuOiBmYWxzZSxcbiAgICAgIHF1ZXJ5LFxuICAgICAgYXJncyxcbiAgICAgIHBhZ2luYXRpb25PcHRpb25zOiB2b2lkIDBcbiAgICB9O1xuICAgIHRoaXMubGlzdGVuZXJzLmFkZChxdWVyeUluZm8pO1xuICAgIGlmICh0aGlzLnF1ZXJ5UmVzdWx0UmVhZHkocXVlcnlUb2tlbikgJiYgdGhpcy5jYWxsTmV3TGlzdGVuZXJzV2l0aEN1cnJlbnRWYWx1ZXNUaW1lciA9PT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLmNhbGxOZXdMaXN0ZW5lcnNXaXRoQ3VycmVudFZhbHVlc1RpbWVyID0gc2V0VGltZW91dChcbiAgICAgICAgKCkgPT4gdGhpcy5jYWxsTmV3TGlzdGVuZXJzV2l0aEN1cnJlbnRWYWx1ZXMoKSxcbiAgICAgICAgMFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgdW5zdWJzY3JpYmVQcm9wcyA9IHtcbiAgICAgIHVuc3Vic2NyaWJlOiAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpc3RlbmVycy5kZWxldGUocXVlcnlJbmZvKTtcbiAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgIH0sXG4gICAgICBnZXRDdXJyZW50VmFsdWU6ICgpID0+IHRoaXMuY2xpZW50LmxvY2FsUXVlcnlSZXN1bHRCeVRva2VuKHF1ZXJ5VG9rZW4pLFxuICAgICAgZ2V0UXVlcnlMb2dzOiAoKSA9PiB0aGlzLmNsaWVudC5sb2NhbFF1ZXJ5TG9ncyhxdWVyeVRva2VuKVxuICAgIH07XG4gICAgY29uc3QgcmV0ID0gdW5zdWJzY3JpYmVQcm9wcy51bnN1YnNjcmliZTtcbiAgICBPYmplY3QuYXNzaWduKHJldCwgdW5zdWJzY3JpYmVQcm9wcyk7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICAvKipcbiAgICogQ2FsbCBhIGNhbGxiYWNrIHdoZW5ldmVyIGEgbmV3IHJlc3VsdCBmb3IgYSBwYWdpbmF0ZWQgcXVlcnkgaXMgcmVjZWl2ZWQuXG4gICAqXG4gICAqIFRoaXMgaXMgYW4gZXhwZXJpbWVudGFsIHByZXZpZXc6IHRoZSBmaW5hbCBBUEkgbWF5IGNoYW5nZS5cbiAgICogSW4gcGFydGljdWxhciwgY2FjaGluZyBiZWhhdmlvciwgcGFnZSBzcGxpdHRpbmcsIGFuZCByZXF1aXJlZCBwYWdpbmF0ZWQgcXVlcnkgb3B0aW9uc1xuICAgKiBtYXkgY2hhbmdlLlxuICAgKlxuICAgKiBAcGFyYW0gcXVlcnkgLSBBIHtAbGluayBzZXJ2ZXIuRnVuY3Rpb25SZWZlcmVuY2V9IGZvciB0aGUgcHVibGljIHF1ZXJ5IHRvIHJ1bi5cbiAgICogQHBhcmFtIGFyZ3MgLSBUaGUgYXJndW1lbnRzIHRvIHJ1biB0aGUgcXVlcnkgd2l0aC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgcGFnaW5hdGVkIHF1ZXJ5IGluY2x1ZGluZyBpbml0aWFsTnVtSXRlbXMgYW5kIGlkLlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIHF1ZXJ5IHJlc3VsdCB1cGRhdGVzLlxuICAgKiBAcGFyYW0gb25FcnJvciAtIEZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgcXVlcnkgcmVzdWx0IHVwZGF0ZXMgd2l0aCBhbiBlcnJvci5cbiAgICpcbiAgICogQHJldHVybiBhbiB7QGxpbmsgVW5zdWJzY3JpYmV9IGZ1bmN0aW9uIHRvIHN0b3AgY2FsbGluZyB0aGUgY2FsbGJhY2suXG4gICAqL1xuICBvblBhZ2luYXRlZFVwZGF0ZV9leHBlcmltZW50YWwocXVlcnksIGFyZ3MsIG9wdGlvbnMsIGNhbGxiYWNrLCBvbkVycm9yKSB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZURpc2FibGVkVW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgY29uc3QgcGFnaW5hdGlvbk9wdGlvbnMgPSB7XG4gICAgICBpbml0aWFsTnVtSXRlbXM6IG9wdGlvbnMuaW5pdGlhbE51bUl0ZW1zLFxuICAgICAgaWQ6IC0xXG4gICAgfTtcbiAgICBjb25zdCB7IHBhZ2luYXRlZFF1ZXJ5VG9rZW4sIHVuc3Vic2NyaWJlIH0gPSB0aGlzLnBhZ2luYXRlZENsaWVudC5zdWJzY3JpYmUoXG4gICAgICBnZXRGdW5jdGlvbk5hbWUocXVlcnkpLFxuICAgICAgYXJncyxcbiAgICAgIC8vIFNpbXBsZSBjbGllbnQgZG9lc24ndCB1c2UgSURzLCB0aGVyZSdzIG5vIGV4cGVjdGF0aW9uIHRoYXQgdGhlc2UgcXVlcmllcyByZW1haW4gc2VwYXJhdGUuXG4gICAgICBwYWdpbmF0aW9uT3B0aW9uc1xuICAgICk7XG4gICAgY29uc3QgcXVlcnlJbmZvID0ge1xuICAgICAgcXVlcnlUb2tlbjogcGFnaW5hdGVkUXVlcnlUb2tlbixcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgb25FcnJvcixcbiAgICAgIHVuc3Vic2NyaWJlLFxuICAgICAgaGFzRXZlclJ1bjogZmFsc2UsXG4gICAgICBxdWVyeSxcbiAgICAgIGFyZ3MsXG4gICAgICBwYWdpbmF0aW9uT3B0aW9uc1xuICAgIH07XG4gICAgdGhpcy5saXN0ZW5lcnMuYWRkKHF1ZXJ5SW5mbyk7XG4gICAgaWYgKCEhdGhpcy5wYWdpbmF0ZWRDbGllbnQubG9jYWxRdWVyeVJlc3VsdEJ5VG9rZW4ocGFnaW5hdGVkUXVlcnlUb2tlbikgJiYgdGhpcy5jYWxsTmV3TGlzdGVuZXJzV2l0aEN1cnJlbnRWYWx1ZXNUaW1lciA9PT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLmNhbGxOZXdMaXN0ZW5lcnNXaXRoQ3VycmVudFZhbHVlc1RpbWVyID0gc2V0VGltZW91dChcbiAgICAgICAgKCkgPT4gdGhpcy5jYWxsTmV3TGlzdGVuZXJzV2l0aEN1cnJlbnRWYWx1ZXMoKSxcbiAgICAgICAgMFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgdW5zdWJzY3JpYmVQcm9wcyA9IHtcbiAgICAgIHVuc3Vic2NyaWJlOiAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpc3RlbmVycy5kZWxldGUocXVlcnlJbmZvKTtcbiAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgIH0sXG4gICAgICBnZXRDdXJyZW50VmFsdWU6ICgpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5wYWdpbmF0ZWRDbGllbnQubG9jYWxRdWVyeVJlc3VsdChcbiAgICAgICAgICBnZXRGdW5jdGlvbk5hbWUocXVlcnkpLFxuICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgcGFnaW5hdGlvbk9wdGlvbnNcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sXG4gICAgICBnZXRRdWVyeUxvZ3M6ICgpID0+IFtdXG4gICAgICAvLyBQYWdpbmF0ZWQgcXVlcmllcyBkb24ndCBhZ2dyZWdhdGUgdGhlaXIgbG9nc1xuICAgIH07XG4gICAgY29uc3QgcmV0ID0gdW5zdWJzY3JpYmVQcm9wcy51bnN1YnNjcmliZTtcbiAgICBPYmplY3QuYXNzaWduKHJldCwgdW5zdWJzY3JpYmVQcm9wcyk7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICAvLyBSdW4gYWxsIGNhbGxiYWNrcyB0aGF0IGhhdmUgbmV2ZXIgYmVlbiBydW4gYmVmb3JlIGlmIHRoZXkgaGF2ZSBhIHF1ZXJ5XG4gIC8vIHJlc3VsdCBhdmFpbGFibGUgbm93LlxuICBjYWxsTmV3TGlzdGVuZXJzV2l0aEN1cnJlbnRWYWx1ZXMoKSB7XG4gICAgdGhpcy5jYWxsTmV3TGlzdGVuZXJzV2l0aEN1cnJlbnRWYWx1ZXNUaW1lciA9IHZvaWQgMDtcbiAgICB0aGlzLl90cmFuc2l0aW9uKHsgcXVlcmllczogW10sIHBhZ2luYXRlZFF1ZXJpZXM6IFtdIH0sIHRydWUpO1xuICB9XG4gIHF1ZXJ5UmVzdWx0UmVhZHkocXVlcnlUb2tlbikge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5oYXNMb2NhbFF1ZXJ5UmVzdWx0QnlUb2tlbihxdWVyeVRva2VuKTtcbiAgfVxuICBjcmVhdGVEaXNhYmxlZFVuc3Vic2NyaWJlKCkge1xuICAgIGNvbnN0IGRpc2FibGVkVW5zdWJzY3JpYmUgPSAoKSA9PiB7XG4gICAgfTtcbiAgICBjb25zdCB1bnN1YnNjcmliZVByb3BzID0ge1xuICAgICAgdW5zdWJzY3JpYmU6IGRpc2FibGVkVW5zdWJzY3JpYmUsXG4gICAgICBnZXRDdXJyZW50VmFsdWU6ICgpID0+IHZvaWQgMCxcbiAgICAgIGdldFF1ZXJ5TG9nczogKCkgPT4gdm9pZCAwXG4gICAgfTtcbiAgICBPYmplY3QuYXNzaWduKGRpc2FibGVkVW5zdWJzY3JpYmUsIHVuc3Vic2NyaWJlUHJvcHMpO1xuICAgIHJldHVybiBkaXNhYmxlZFVuc3Vic2NyaWJlO1xuICB9XG4gIGFzeW5jIGNsb3NlKCkge1xuICAgIGlmICh0aGlzLmRpc2FibGVkKSByZXR1cm47XG4gICAgdGhpcy5saXN0ZW5lcnMuY2xlYXIoKTtcbiAgICB0aGlzLl9jbG9zZWQgPSB0cnVlO1xuICAgIGlmICh0aGlzLl9wYWdpbmF0ZWRDbGllbnQpIHtcbiAgICAgIHRoaXMuX3BhZ2luYXRlZENsaWVudCA9IHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmNsb3NlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBKV1QgYXV0aCB0b2tlbiBhbmQgZGVjb2RlZCBjbGFpbXMuXG4gICAqL1xuICBnZXRBdXRoKCkge1xuICAgIGlmICh0aGlzLmRpc2FibGVkKSByZXR1cm47XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmdldEN1cnJlbnRBdXRoQ2xhaW1zKCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgYXV0aGVudGljYXRpb24gdG9rZW4gdG8gYmUgdXNlZCBmb3Igc3Vic2VxdWVudCBxdWVyaWVzIGFuZCBtdXRhdGlvbnMuXG4gICAqIGBmZXRjaFRva2VuYCB3aWxsIGJlIGNhbGxlZCBhdXRvbWF0aWNhbGx5IGFnYWluIGlmIGEgdG9rZW4gZXhwaXJlcy5cbiAgICogYGZldGNoVG9rZW5gIHNob3VsZCByZXR1cm4gYG51bGxgIGlmIHRoZSB0b2tlbiBjYW5ub3QgYmUgcmV0cmlldmVkLCBmb3IgZXhhbXBsZVxuICAgKiB3aGVuIHRoZSB1c2VyJ3MgcmlnaHRzIHdlcmUgcGVybWFuZW50bHkgcmV2b2tlZC5cbiAgICogQHBhcmFtIGZldGNoVG9rZW4gLSBhbiBhc3luYyBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIEpXVCAodHlwaWNhbGx5IGFuIE9wZW5JRCBDb25uZWN0IElkZW50aXR5IFRva2VuKVxuICAgKiBAcGFyYW0gb25DaGFuZ2UgLSBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgYXV0aGVudGljYXRpb24gc3RhdHVzIGNoYW5nZXNcbiAgICovXG4gIHNldEF1dGgoZmV0Y2hUb2tlbiwgb25DaGFuZ2UpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkgcmV0dXJuO1xuICAgIHRoaXMuY2xpZW50LnNldEF1dGgoXG4gICAgICBmZXRjaFRva2VuLFxuICAgICAgb25DaGFuZ2UgPz8gKCgpID0+IHtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzZXRBZG1pbkF1dGgodG9rZW4sIGlkZW50aXR5KSB7XG4gICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb252ZXhDbGllbnQgaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQuXCIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5kaXNhYmxlZCkgcmV0dXJuO1xuICAgIHRoaXMuY2xpZW50LnNldEFkbWluQXV0aCh0b2tlbiwgaWRlbnRpdHkpO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF90cmFuc2l0aW9uKHtcbiAgICBxdWVyaWVzLFxuICAgIHBhZ2luYXRlZFF1ZXJpZXNcbiAgfSwgY2FsbE5ld0xpc3RlbmVycyA9IGZhbHNlKSB7XG4gICAgY29uc3QgdXBkYXRlZFF1ZXJpZXMgPSBbXG4gICAgICAuLi5xdWVyaWVzLm1hcCgocSkgPT4gcS50b2tlbiksXG4gICAgICAuLi5wYWdpbmF0ZWRRdWVyaWVzLm1hcCgocSkgPT4gcS50b2tlbilcbiAgICBdO1xuICAgIGZvciAoY29uc3QgcXVlcnlJbmZvIG9mIHRoaXMubGlzdGVuZXJzKSB7XG4gICAgICBjb25zdCB7IGNhbGxiYWNrLCBxdWVyeVRva2VuLCBvbkVycm9yLCBoYXNFdmVyUnVuIH0gPSBxdWVyeUluZm87XG4gICAgICBjb25zdCBpc1BhZ2luYXRlZFF1ZXJ5ID0gc2VyaWFsaXplZFF1ZXJ5VG9rZW5Jc1BhZ2luYXRlZChxdWVyeVRva2VuKTtcbiAgICAgIGNvbnN0IGhhc1Jlc3VsdFJlYWR5ID0gaXNQYWdpbmF0ZWRRdWVyeSA/ICEhdGhpcy5wYWdpbmF0ZWRDbGllbnQubG9jYWxRdWVyeVJlc3VsdEJ5VG9rZW4ocXVlcnlUb2tlbikgOiB0aGlzLmNsaWVudC5oYXNMb2NhbFF1ZXJ5UmVzdWx0QnlUb2tlbihxdWVyeVRva2VuKTtcbiAgICAgIGlmICh1cGRhdGVkUXVlcmllcy5pbmNsdWRlcyhxdWVyeVRva2VuKSB8fCBjYWxsTmV3TGlzdGVuZXJzICYmICFoYXNFdmVyUnVuICYmIGhhc1Jlc3VsdFJlYWR5KSB7XG4gICAgICAgIHF1ZXJ5SW5mby5oYXNFdmVyUnVuID0gdHJ1ZTtcbiAgICAgICAgbGV0IG5ld1ZhbHVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChpc1BhZ2luYXRlZFF1ZXJ5KSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHRoaXMucGFnaW5hdGVkQ2xpZW50LmxvY2FsUXVlcnlSZXN1bHRCeVRva2VuKHF1ZXJ5VG9rZW4pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHRoaXMuY2xpZW50LmxvY2FsUXVlcnlSZXN1bHRCeVRva2VuKHF1ZXJ5VG9rZW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBpZiAoIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSkgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICAgIG9uRXJyb3IoXG4gICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICBcIlNlY29uZCBhcmd1bWVudCB0byBvblVwZGF0ZSBvbkVycm9yIGlzIHJlc2VydmVkIGZvciBsYXRlciB1c2VcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdm9pZCBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKFxuICAgICAgICAgIG5ld1ZhbHVlLFxuICAgICAgICAgIFwiU2Vjb25kIGFyZ3VtZW50IHRvIG9uVXBkYXRlIGNhbGxiYWNrIGlzIHJlc2VydmVkIGZvciBsYXRlciB1c2VcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogRXhlY3V0ZSBhIG11dGF0aW9uIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gbXV0YXRpb24gLSBBIHtAbGluayBzZXJ2ZXIuRnVuY3Rpb25SZWZlcmVuY2V9IGZvciB0aGUgcHVibGljIG11dGF0aW9uXG4gICAqIHRvIHJ1bi5cbiAgICogQHBhcmFtIGFyZ3MgLSBBbiBhcmd1bWVudHMgb2JqZWN0IGZvciB0aGUgbXV0YXRpb24uXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQSB7QGxpbmsgTXV0YXRpb25PcHRpb25zfSBvcHRpb25zIG9iamVjdCBmb3IgdGhlIG11dGF0aW9uLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2Ugb2YgdGhlIG11dGF0aW9uJ3MgcmVzdWx0LlxuICAgKi9cbiAgYXN5bmMgbXV0YXRpb24obXV0YXRpb24sIGFyZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkgdGhyb3cgbmV3IEVycm9yKFwiQ29udmV4Q2xpZW50IGlzIGRpc2FibGVkXCIpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5tdXRhdGlvbihnZXRGdW5jdGlvbk5hbWUobXV0YXRpb24pLCBhcmdzLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogRXhlY3V0ZSBhbiBhY3Rpb24gZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSBhY3Rpb24gLSBBIHtAbGluayBzZXJ2ZXIuRnVuY3Rpb25SZWZlcmVuY2V9IGZvciB0aGUgcHVibGljIGFjdGlvblxuICAgKiB0byBydW4uXG4gICAqIEBwYXJhbSBhcmdzIC0gQW4gYXJndW1lbnRzIG9iamVjdCBmb3IgdGhlIGFjdGlvbi5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIG9mIHRoZSBhY3Rpb24ncyByZXN1bHQuXG4gICAqL1xuICBhc3luYyBhY3Rpb24oYWN0aW9uLCBhcmdzKSB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHRocm93IG5ldyBFcnJvcihcIkNvbnZleENsaWVudCBpcyBkaXNhYmxlZFwiKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuYWN0aW9uKGdldEZ1bmN0aW9uTmFtZShhY3Rpb24pLCBhcmdzKTtcbiAgfVxuICAvKipcbiAgICogRmV0Y2ggYSBxdWVyeSByZXN1bHQgb25jZS5cbiAgICpcbiAgICogQHBhcmFtIHF1ZXJ5IC0gQSB7QGxpbmsgc2VydmVyLkZ1bmN0aW9uUmVmZXJlbmNlfSBmb3IgdGhlIHB1YmxpYyBxdWVyeVxuICAgKiB0byBydW4uXG4gICAqIEBwYXJhbSBhcmdzIC0gQW4gYXJndW1lbnRzIG9iamVjdCBmb3IgdGhlIHF1ZXJ5LlxuICAgKiBAcmV0dXJucyBBIHByb21pc2Ugb2YgdGhlIHF1ZXJ5J3MgcmVzdWx0LlxuICAgKi9cbiAgYXN5bmMgcXVlcnkocXVlcnksIGFyZ3MpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkgdGhyb3cgbmV3IEVycm9yKFwiQ29udmV4Q2xpZW50IGlzIGRpc2FibGVkXCIpO1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5jbGllbnQubG9jYWxRdWVyeVJlc3VsdChnZXRGdW5jdGlvbk5hbWUocXVlcnkpLCBhcmdzKTtcbiAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHsgdW5zdWJzY3JpYmUgfSA9IHRoaXMub25VcGRhdGUoXG4gICAgICAgIHF1ZXJ5LFxuICAgICAgICBhcmdzLFxuICAgICAgICAodmFsdWUyKSA9PiB7XG4gICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICByZXNvbHZlKHZhbHVlMik7XG4gICAgICAgIH0sXG4gICAgICAgIChlKSA9PiB7XG4gICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCB7QGxpbmsgQ29ubmVjdGlvblN0YXRlfSBiZXR3ZWVuIHRoZSBjbGllbnQgYW5kIHRoZSBDb252ZXhcbiAgICogYmFja2VuZC5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIHtAbGluayBDb25uZWN0aW9uU3RhdGV9IHdpdGggdGhlIENvbnZleCBiYWNrZW5kLlxuICAgKi9cbiAgY29ubmVjdGlvblN0YXRlKCkge1xuICAgIGlmICh0aGlzLmRpc2FibGVkKSB0aHJvdyBuZXcgRXJyb3IoXCJDb252ZXhDbGllbnQgaXMgZGlzYWJsZWRcIik7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmNvbm5lY3Rpb25TdGF0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgdG8gdGhlIHtAbGluayBDb25uZWN0aW9uU3RhdGV9IGJldHdlZW4gdGhlIGNsaWVudCBhbmQgdGhlIENvbnZleFxuICAgKiBiYWNrZW5kLCBjYWxsaW5nIGEgY2FsbGJhY2sgZWFjaCB0aW1lIGl0IGNoYW5nZXMuXG4gICAqXG4gICAqIFN1YnNjcmliZWQgY2FsbGJhY2tzIHdpbGwgYmUgY2FsbGVkIHdoZW4gYW55IHBhcnQgb2YgQ29ubmVjdGlvblN0YXRlIGNoYW5nZXMuXG4gICAqIENvbm5lY3Rpb25TdGF0ZSBtYXkgZ3JvdyBpbiBmdXR1cmUgdmVyc2lvbnMgKGUuZy4gdG8gcHJvdmlkZSBhIGFycmF5IG9mXG4gICAqIGluZmxpZ2h0IHJlcXVlc3RzKSBpbiB3aGljaCBjYXNlIGNhbGxiYWNrcyB3b3VsZCBiZSBjYWxsZWQgbW9yZSBmcmVxdWVudGx5LlxuICAgKlxuICAgKiBAcmV0dXJucyBBbiB1bnN1YnNjcmliZSBmdW5jdGlvbiB0byBzdG9wIGxpc3RlbmluZy5cbiAgICovXG4gIHN1YnNjcmliZVRvQ29ubmVjdGlvblN0YXRlKGNiKSB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHJldHVybiAoKSA9PiB7XG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuc3Vic2NyaWJlVG9Db25uZWN0aW9uU3RhdGUoY2IpO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaW1wbGVfY2xpZW50LmpzLm1hcFxuIiwiaW1wb3J0IHsgdmFsaWRhdGVEZXBsb3ltZW50VXJsIH0gZnJvbSBcIi4uL2NvbW1vbi9pbmRleC5qc1wiO1xuaW1wb3J0IHtcbiAgQmFzZUNvbnZleENsaWVudCxcbiAgQmFzZUNvbnZleENsaWVudE9wdGlvbnMsXG4gIE11dGF0aW9uT3B0aW9ucyxcbiAgUGFnaW5hdGVkUXVlcnlUb2tlbixcbiAgUXVlcnlUb2tlbixcbiAgVXNlcklkZW50aXR5QXR0cmlidXRlcyxcbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCB7XG4gIEZ1bmN0aW9uQXJncyxcbiAgRnVuY3Rpb25SZWZlcmVuY2UsXG4gIEZ1bmN0aW9uUmV0dXJuVHlwZSxcbiAgUGFnaW5hdGlvblJlc3VsdCxcbn0gZnJvbSBcIi4uL3NlcnZlci9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZ2V0RnVuY3Rpb25OYW1lIH0gZnJvbSBcIi4uL3NlcnZlci9hcGkuanNcIjtcbmltcG9ydCB7IEF1dGhUb2tlbkZldGNoZXIgfSBmcm9tIFwiLi9zeW5jL2F1dGhlbnRpY2F0aW9uX21hbmFnZXIuanNcIjtcbmltcG9ydCB7IENvbm5lY3Rpb25TdGF0ZSB9IGZyb20gXCIuL3N5bmMvY2xpZW50LmpzXCI7XG5pbXBvcnQge1xuICBFeHRlbmRlZFRyYW5zaXRpb24sXG4gIFBhZ2luYXRlZFF1ZXJ5Q2xpZW50LFxufSBmcm9tIFwiLi9zeW5jL3BhZ2luYXRlZF9xdWVyeV9jbGllbnQuanNcIjtcbmltcG9ydCB7IFBhZ2luYXRlZFF1ZXJ5UmVzdWx0IH0gZnJvbSBcIi4vc3luYy9wYWdpbmF0aW9uLmpzXCI7XG5pbXBvcnQgeyBzZXJpYWxpemVkUXVlcnlUb2tlbklzUGFnaW5hdGVkIH0gZnJvbSBcIi4vc3luYy91ZGZfcGF0aF91dGlscy5qc1wiO1xuXG4vLyBJbiBOb2RlLmpzIGJ1aWxkcyB0aGlzIHBvaW50cyB0byBhIGJ1bmRsZWQgV2ViU29ja2V0IGltcGxlbWVudGF0aW9uLiBJZiBub1xuLy8gV2ViU29ja2V0IGltcGxlbWVudGF0aW9uIGlzIG1hbnVhbGx5IHNwZWNpZmllZCBvciBnbG9iYWxseSBhdmFpbGFibGUsXG4vLyB0aGlzIG9uZSBpcyB1c2VkLlxubGV0IGRlZmF1bHRXZWJTb2NrZXRDb25zdHJ1Y3RvcjogdHlwZW9mIFdlYlNvY2tldCB8IHVuZGVmaW5lZDtcblxuLyoqIGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gc2V0RGVmYXVsdFdlYlNvY2tldENvbnN0cnVjdG9yKHdzOiB0eXBlb2YgV2ViU29ja2V0KSB7XG4gIGRlZmF1bHRXZWJTb2NrZXRDb25zdHJ1Y3RvciA9IHdzO1xufVxuXG5leHBvcnQgdHlwZSBDb252ZXhDbGllbnRPcHRpb25zID0gQmFzZUNvbnZleENsaWVudE9wdGlvbnMgJiB7XG4gIC8qKlxuICAgKiBgZGlzYWJsZWRgIG1ha2VzIG9uVXBkYXRlIGNhbGxiYWNrIHJlZ2lzdHJhdGlvbiBhIG5vLW9wIGFuZCBhY3Rpb25zLFxuICAgKiBtdXRhdGlvbnMgYW5kIG9uZS1zaG90IHF1ZXJpZXMgdGhyb3cuIFNldHRpbmcgZGlzYWJsZWQgdG8gdHJ1ZSBtYXkgYmVcbiAgICogdXNlZnVsIGZvciBzZXJ2ZXItc2lkZSByZW5kZXJpbmcsIHdoZXJlIHN1YnNjcmlwdGlvbnMgZG9uJ3QgbWFrZSBzZW5zZS5cbiAgICovXG4gIGRpc2FibGVkPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gcHJvbXB0IHVzZXJzIGluIGJyb3dzZXJzIGFib3V0IHF1ZXVlZCBvciBpbi1mbGlnaHQgbXV0YXRpb25zLlxuICAgKiBUaGlzIG9ubHkgd29ya3MgaW4gZW52aXJvbm1lbnRzIHdoZXJlIGB3aW5kb3cub25iZWZvcmV1bmxvYWRgIGlzIGF2YWlsYWJsZS5cbiAgICpcbiAgICogRGVmYXVsdHMgdG8gdHJ1ZSB3aGVuIGB3aW5kb3dgIGlzIGRlZmluZWQsIG90aGVyd2lzZSBmYWxzZS5cbiAgICovXG4gIHVuc2F2ZWRDaGFuZ2VzV2FybmluZz86IGJvb2xlYW47XG59O1xuXG4vKipcbiAqIFN0b3BzIGNhbGxiYWNrcyBmcm9tIHJ1bm5pbmcuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgdHlwZSBVbnN1YnNjcmliZTxUPiA9IHtcbiAgLyoqIFN0b3AgY2FsbGluZyBjYWxsYmFjayB3aGVuIHF1ZXJ5IHJlc3VsdHMgY2hhbmdlcy4gSWYgdGhpcyBpcyB0aGUgbGFzdCBsaXN0ZW5lciBvbiB0aGlzIHF1ZXJ5LCBzdG9wIHJlY2VpdmVkIHVwZGF0ZXMuICovXG4gICgpOiB2b2lkO1xuICAvKiogU3RvcCBjYWxsaW5nIGNhbGxiYWNrIHdoZW4gcXVlcnkgcmVzdWx0cyBjaGFuZ2VzLiBJZiB0aGlzIGlzIHRoZSBsYXN0IGxpc3RlbmVyIG9uIHRoaXMgcXVlcnksIHN0b3AgcmVjZWl2ZWQgdXBkYXRlcy4gKi9cbiAgdW5zdWJzY3JpYmUoKTogdm9pZDtcbiAgLyoqIEdldCB0aGUgbGFzdCBrbm93biB2YWx1ZSwgcG9zc2libHkgd2l0aCBsb2NhbCBvcHRpbWlzdGljIHVwZGF0ZXMgYXBwbGllZC4gKi9cbiAgZ2V0Q3VycmVudFZhbHVlKCk6IFQgfCB1bmRlZmluZWQ7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0UXVlcnlMb2dzKCk6IHN0cmluZ1tdIHwgdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBTdWJzY3JpYmVzIHRvIENvbnZleCBxdWVyeSBmdW5jdGlvbnMgYW5kIGV4ZWN1dGVzIG11dGF0aW9ucyBhbmQgYWN0aW9ucyBvdmVyIGEgV2ViU29ja2V0LlxuICpcbiAqIE9wdGltaXN0aWMgdXBkYXRlcyBmb3IgbXV0YXRpb25zIGFyZSBub3QgcHJvdmlkZWQgZm9yIHRoaXMgY2xpZW50LlxuICogVGhpcmQgcGFydHkgY2xpZW50cyBtYXkgY2hvb3NlIHRvIHdyYXAge0BsaW5rIGJyb3dzZXIuQmFzZUNvbnZleENsaWVudH0gZm9yIGFkZGl0aW9uYWwgY29udHJvbC5cbiAqXG4gKiBgYGB0c1xuICogY29uc3QgY2xpZW50ID0gbmV3IENvbnZleENsaWVudChcImh0dHBzOi8vaGFwcHktb3R0ZXItMTIzLmNvbnZleC5jbG91ZFwiKTtcbiAqIGNvbnN0IHVuc3Vic2NyaWJlID0gY2xpZW50Lm9uVXBkYXRlKGFwaS5tZXNzYWdlcy5saXN0LCB7fSwgKG1lc3NhZ2VzKSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKG1lc3NhZ2VzWzBdLmJvZHkpO1xuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBDb252ZXhDbGllbnQge1xuICBwcml2YXRlIGxpc3RlbmVyczogU2V0PFF1ZXJ5SW5mbz47XG4gIHByaXZhdGUgX2NsaWVudDogQmFzZUNvbnZleENsaWVudCB8IHVuZGVmaW5lZDtcbiAgcHJpdmF0ZSBfcGFnaW5hdGVkQ2xpZW50OiBQYWdpbmF0ZWRRdWVyeUNsaWVudCB8IHVuZGVmaW5lZDtcbiAgLy8gQSBzeW50aGV0aWMgc2VydmVyIGV2ZW50IHRvIHJ1biBjYWxsYmFja3MgdGhlIGZpcnN0IHRpbWVcbiAgcHJpdmF0ZSBjYWxsTmV3TGlzdGVuZXJzV2l0aEN1cnJlbnRWYWx1ZXNUaW1lcjpcbiAgICB8IFJldHVyblR5cGU8dHlwZW9mIHNldFRpbWVvdXQ+XG4gICAgfCB1bmRlZmluZWQ7XG4gIHByaXZhdGUgX2Nsb3NlZDogYm9vbGVhbjtcbiAgcHJpdmF0ZSBfZGlzYWJsZWQ6IGJvb2xlYW47XG4gIC8qKlxuICAgKiBPbmNlIGNsb3NlZCBubyByZWdpc3RlcmVkIGNhbGxiYWNrcyB3aWxsIGZpcmUgYWdhaW4uXG4gICAqL1xuICBnZXQgY2xvc2VkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9jbG9zZWQ7XG4gIH1cbiAgZ2V0IGNsaWVudCgpOiBCYXNlQ29udmV4Q2xpZW50IHtcbiAgICBpZiAodGhpcy5fY2xpZW50KSByZXR1cm4gdGhpcy5fY2xpZW50O1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnZleENsaWVudCBpcyBkaXNhYmxlZFwiKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXQgcGFnaW5hdGVkQ2xpZW50KCk6IFBhZ2luYXRlZFF1ZXJ5Q2xpZW50IHtcbiAgICBpZiAodGhpcy5fcGFnaW5hdGVkQ2xpZW50KSByZXR1cm4gdGhpcy5fcGFnaW5hdGVkQ2xpZW50O1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnZleENsaWVudCBpcyBkaXNhYmxlZFwiKTtcbiAgfVxuICBnZXQgZGlzYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIGNsaWVudCBhbmQgaW1tZWRpYXRlbHkgaW5pdGlhdGUgYSBXZWJTb2NrZXQgY29ubmVjdGlvbiB0byB0aGUgcGFzc2VkIGFkZHJlc3MuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkZHJlc3M6IHN0cmluZywgb3B0aW9uczogQ29udmV4Q2xpZW50T3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKG9wdGlvbnMuc2tpcENvbnZleERlcGxveW1lbnRVcmxDaGVjayAhPT0gdHJ1ZSkge1xuICAgICAgdmFsaWRhdGVEZXBsb3ltZW50VXJsKGFkZHJlc3MpO1xuICAgIH1cbiAgICBjb25zdCB7IGRpc2FibGVkLCAuLi5iYXNlT3B0aW9ucyB9ID0gb3B0aW9ucztcbiAgICB0aGlzLl9jbG9zZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9kaXNhYmxlZCA9ICEhZGlzYWJsZWQ7XG4gICAgaWYgKFxuICAgICAgZGVmYXVsdFdlYlNvY2tldENvbnN0cnVjdG9yICYmXG4gICAgICAhKFwid2ViU29ja2V0Q29uc3RydWN0b3JcIiBpbiBiYXNlT3B0aW9ucykgJiZcbiAgICAgIHR5cGVvZiBXZWJTb2NrZXQgPT09IFwidW5kZWZpbmVkXCJcbiAgICApIHtcbiAgICAgIGJhc2VPcHRpb25zLndlYlNvY2tldENvbnN0cnVjdG9yID0gZGVmYXVsdFdlYlNvY2tldENvbnN0cnVjdG9yO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAhKFwidW5zYXZlZENoYW5nZXNXYXJuaW5nXCIgaW4gYmFzZU9wdGlvbnMpXG4gICAgKSB7XG4gICAgICBiYXNlT3B0aW9ucy51bnNhdmVkQ2hhbmdlc1dhcm5pbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICB0aGlzLl9jbGllbnQgPSBuZXcgQmFzZUNvbnZleENsaWVudChcbiAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgKCkgPT4ge30sIC8vIE5PUCwgbGV0IHRoZSBwYWdpbmF0ZWQgcXVlcnkgY2xpZW50IGRvIGl0IGFsbFxuICAgICAgICBiYXNlT3B0aW9ucyxcbiAgICAgICk7XG4gICAgICB0aGlzLl9wYWdpbmF0ZWRDbGllbnQgPSBuZXcgUGFnaW5hdGVkUXVlcnlDbGllbnQoXG4gICAgICAgIHRoaXMuX2NsaWVudCxcbiAgICAgICAgKHRyYW5zaXRpb24pID0+IHRoaXMuX3RyYW5zaXRpb24odHJhbnNpdGlvbiksXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmxpc3RlbmVycyA9IG5ldyBTZXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsIGEgY2FsbGJhY2sgd2hlbmV2ZXIgYSBuZXcgcmVzdWx0IGZvciBhIHF1ZXJ5IGlzIHJlY2VpdmVkLiBUaGUgY2FsbGJhY2tcbiAgICogd2lsbCBydW4gc29vbiBhZnRlciBiZWluZyByZWdpc3RlcmVkIGlmIGEgcmVzdWx0IGZvciB0aGUgcXVlcnkgaXMgYWxyZWFkeVxuICAgKiBpbiBtZW1vcnkuXG4gICAqXG4gICAqIFRoZSByZXR1cm4gdmFsdWUgaXMgYW4ge0BsaW5rIFVuc3Vic2NyaWJlfSBvYmplY3Qgd2hpY2ggaXMgYm90aCBhIGZ1bmN0aW9uXG4gICAqIGFuIGFuIG9iamVjdCB3aXRoIHByb3BlcnRpZXMuIEJvdGggb2YgdGhlIHBhdHRlcm5zIGJlbG93IHdvcmsgd2l0aCB0aGlzIG9iamVjdDpcbiAgICpcbiAgICpgYGB0c1xuICAgKiAvLyBjYWxsIHRoZSByZXR1cm4gdmFsdWUgYXMgYSBmdW5jdGlvblxuICAgKiBjb25zdCB1bnN1YnNjcmliZSA9IGNsaWVudC5vblVwZGF0ZShhcGkubWVzc2FnZXMubGlzdCwge30sIChtZXNzYWdlcykgPT4ge1xuICAgKiAgIGNvbnNvbGUubG9nKG1lc3NhZ2VzKTtcbiAgICogfSk7XG4gICAqIHVuc3Vic2NyaWJlKCk7XG4gICAqXG4gICAqIC8vIHVucGFjayB0aGUgcmV0dXJuIHZhbHVlIGludG8gaXRzIHByb3BlcnRpZXNcbiAgICogY29uc3Qge1xuICAgKiAgIGdldEN1cnJlbnRWYWx1ZSxcbiAgICogICB1bnN1YnNjcmliZSxcbiAgICogfSA9IGNsaWVudC5vblVwZGF0ZShhcGkubWVzc2FnZXMubGlzdCwge30sIChtZXNzYWdlcykgPT4ge1xuICAgKiAgIGNvbnNvbGUubG9nKG1lc3NhZ2VzKTtcbiAgICogfSk7XG4gICAqYGBgXG4gICAqXG4gICAqIEBwYXJhbSBxdWVyeSAtIEEge0BsaW5rIHNlcnZlci5GdW5jdGlvblJlZmVyZW5jZX0gZm9yIHRoZSBwdWJsaWMgcXVlcnkgdG8gcnVuLlxuICAgKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgdG8gcnVuIHRoZSBxdWVyeSB3aXRoLlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIHF1ZXJ5IHJlc3VsdCB1cGRhdGVzLlxuICAgKiBAcGFyYW0gb25FcnJvciAtIEZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgcXVlcnkgcmVzdWx0IHVwZGF0ZXMgd2l0aCBhbiBlcnJvci5cbiAgICogSWYgbm90IHByb3ZpZGVkLCBlcnJvcnMgd2lsbCBiZSB0aHJvd24gaW5zdGVhZCBvZiBjYWxsaW5nIHRoZSBjYWxsYmFjay5cbiAgICpcbiAgICogQHJldHVybiBhbiB7QGxpbmsgVW5zdWJzY3JpYmV9IGZ1bmN0aW9uIHRvIHN0b3AgY2FsbGluZyB0aGUgb25VcGRhdGUgZnVuY3Rpb24uXG4gICAqL1xuICBvblVwZGF0ZTxRdWVyeSBleHRlbmRzIEZ1bmN0aW9uUmVmZXJlbmNlPFwicXVlcnlcIj4+KFxuICAgIHF1ZXJ5OiBRdWVyeSxcbiAgICBhcmdzOiBGdW5jdGlvbkFyZ3M8UXVlcnk+LFxuICAgIGNhbGxiYWNrOiAocmVzdWx0OiBGdW5jdGlvblJldHVyblR5cGU8UXVlcnk+KSA9PiB1bmtub3duLFxuICAgIG9uRXJyb3I/OiAoZTogRXJyb3IpID0+IHVua25vd24sXG4gICk6IFVuc3Vic2NyaWJlPFF1ZXJ5W1wiX3JldHVyblR5cGVcIl0+IHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRGlzYWJsZWRVbnN1YnNjcmliZTxRdWVyeVtcIl9yZXR1cm5UeXBlXCJdPigpO1xuICAgIH1cblxuICAgIC8vIEJhc2VDb252ZXhDbGllbnQgdGFrZXMgY2FyZSBvZiBkZWR1cGxpY2F0aW5nIHF1ZXJpZXMgc3Vic2NyaXB0aW9ucy4uLlxuICAgIGNvbnN0IHsgcXVlcnlUb2tlbiwgdW5zdWJzY3JpYmUgfSA9IHRoaXMuY2xpZW50LnN1YnNjcmliZShcbiAgICAgIGdldEZ1bmN0aW9uTmFtZShxdWVyeSksXG4gICAgICBhcmdzLFxuICAgICk7XG5cbiAgICAvLyAuLi5idXQgd2Ugc3RpbGwgbmVlZCB0byBib29ra2VlcCBjYWxsYmFja3MgdG8gYWN0dWFsbHkgY2FsbCB0aGVtLlxuICAgIGNvbnN0IHF1ZXJ5SW5mbzogUXVlcnlJbmZvID0ge1xuICAgICAgcXVlcnlUb2tlbixcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgb25FcnJvcixcbiAgICAgIHVuc3Vic2NyaWJlLFxuICAgICAgaGFzRXZlclJ1bjogZmFsc2UsXG4gICAgICBxdWVyeSxcbiAgICAgIGFyZ3MsXG4gICAgICBwYWdpbmF0aW9uT3B0aW9uczogdW5kZWZpbmVkLFxuICAgIH07XG4gICAgdGhpcy5saXN0ZW5lcnMuYWRkKHF1ZXJ5SW5mbyk7XG5cbiAgICAvLyBJZiB0aGUgY2FsbGJhY2sgaXMgcmVnaXN0ZXJlZCBmb3IgYSBxdWVyeSB3aXRoIGEgcmVzdWx0IGltbWVkaWF0ZWx5IGF2YWlsYWJsZVxuICAgIC8vIHNjaGVkdWxlIGEgZmFrZSB0cmFuc2l0aW9uIHRvIGNhbGwgdGhlIGNhbGxiYWNrIHNvb24gaW5zdGVhZCBvZiB3YWl0aW5nIGZvclxuICAgIC8vIGEgbmV3IHNlcnZlciB1cGRhdGUgKHdoaWNoIGNvdWxkIHRha2Ugc2Vjb25kcyBvciBkYXlzKS5cbiAgICBpZiAoXG4gICAgICB0aGlzLnF1ZXJ5UmVzdWx0UmVhZHkocXVlcnlUb2tlbikgJiZcbiAgICAgIHRoaXMuY2FsbE5ld0xpc3RlbmVyc1dpdGhDdXJyZW50VmFsdWVzVGltZXIgPT09IHVuZGVmaW5lZFxuICAgICkge1xuICAgICAgdGhpcy5jYWxsTmV3TGlzdGVuZXJzV2l0aEN1cnJlbnRWYWx1ZXNUaW1lciA9IHNldFRpbWVvdXQoXG4gICAgICAgICgpID0+IHRoaXMuY2FsbE5ld0xpc3RlbmVyc1dpdGhDdXJyZW50VmFsdWVzKCksXG4gICAgICAgIDAsXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHVuc3Vic2NyaWJlUHJvcHM6IFJlbW92ZUNhbGxTaWduYXR1cmU8XG4gICAgICBVbnN1YnNjcmliZTxRdWVyeVtcIl9yZXR1cm5UeXBlXCJdPlxuICAgID4gPSB7XG4gICAgICB1bnN1YnNjcmliZTogKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAvLyBhbGwgdW5zdWJzY3JpYmVzIGFscmVhZHkgcmFuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLmRlbGV0ZShxdWVyeUluZm8pO1xuICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgfSxcbiAgICAgIGdldEN1cnJlbnRWYWx1ZTogKCkgPT4gdGhpcy5jbGllbnQubG9jYWxRdWVyeVJlc3VsdEJ5VG9rZW4ocXVlcnlUb2tlbiksXG4gICAgICBnZXRRdWVyeUxvZ3M6ICgpID0+IHRoaXMuY2xpZW50LmxvY2FsUXVlcnlMb2dzKHF1ZXJ5VG9rZW4pLFxuICAgIH07XG4gICAgY29uc3QgcmV0ID0gdW5zdWJzY3JpYmVQcm9wcy51bnN1YnNjcmliZSBhcyBVbnN1YnNjcmliZTxcbiAgICAgIFF1ZXJ5W1wiX3JldHVyblR5cGVcIl1cbiAgICA+O1xuICAgIE9iamVjdC5hc3NpZ24ocmV0LCB1bnN1YnNjcmliZVByb3BzKTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGwgYSBjYWxsYmFjayB3aGVuZXZlciBhIG5ldyByZXN1bHQgZm9yIGEgcGFnaW5hdGVkIHF1ZXJ5IGlzIHJlY2VpdmVkLlxuICAgKlxuICAgKiBUaGlzIGlzIGFuIGV4cGVyaW1lbnRhbCBwcmV2aWV3OiB0aGUgZmluYWwgQVBJIG1heSBjaGFuZ2UuXG4gICAqIEluIHBhcnRpY3VsYXIsIGNhY2hpbmcgYmVoYXZpb3IsIHBhZ2Ugc3BsaXR0aW5nLCBhbmQgcmVxdWlyZWQgcGFnaW5hdGVkIHF1ZXJ5IG9wdGlvbnNcbiAgICogbWF5IGNoYW5nZS5cbiAgICpcbiAgICogQHBhcmFtIHF1ZXJ5IC0gQSB7QGxpbmsgc2VydmVyLkZ1bmN0aW9uUmVmZXJlbmNlfSBmb3IgdGhlIHB1YmxpYyBxdWVyeSB0byBydW4uXG4gICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyB0byBydW4gdGhlIHF1ZXJ5IHdpdGguXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIHBhZ2luYXRlZCBxdWVyeSBpbmNsdWRpbmcgaW5pdGlhbE51bUl0ZW1zIGFuZCBpZC5cbiAgICogQHBhcmFtIGNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBxdWVyeSByZXN1bHQgdXBkYXRlcy5cbiAgICogQHBhcmFtIG9uRXJyb3IgLSBGdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIHF1ZXJ5IHJlc3VsdCB1cGRhdGVzIHdpdGggYW4gZXJyb3IuXG4gICAqXG4gICAqIEByZXR1cm4gYW4ge0BsaW5rIFVuc3Vic2NyaWJlfSBmdW5jdGlvbiB0byBzdG9wIGNhbGxpbmcgdGhlIGNhbGxiYWNrLlxuICAgKi9cbiAgb25QYWdpbmF0ZWRVcGRhdGVfZXhwZXJpbWVudGFsPFF1ZXJ5IGV4dGVuZHMgRnVuY3Rpb25SZWZlcmVuY2U8XCJxdWVyeVwiPj4oXG4gICAgcXVlcnk6IFF1ZXJ5LFxuICAgIGFyZ3M6IEZ1bmN0aW9uQXJnczxRdWVyeT4sXG4gICAgb3B0aW9uczogeyBpbml0aWFsTnVtSXRlbXM6IG51bWJlciB9LFxuICAgIGNhbGxiYWNrOiAocmVzdWx0OiBQYWdpbmF0aW9uUmVzdWx0PEZ1bmN0aW9uUmV0dXJuVHlwZTxRdWVyeT4+KSA9PiB1bmtub3duLFxuICAgIG9uRXJyb3I/OiAoZTogRXJyb3IpID0+IHVua25vd24sXG4gICk6IFVuc3Vic2NyaWJlPFBhZ2luYXRlZFF1ZXJ5UmVzdWx0PEZ1bmN0aW9uUmV0dXJuVHlwZTxRdWVyeT5bXT4+IHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRGlzYWJsZWRVbnN1YnNjcmliZTxcbiAgICAgICAgUGFnaW5hdGVkUXVlcnlSZXN1bHQ8RnVuY3Rpb25SZXR1cm5UeXBlPFF1ZXJ5Pj5cbiAgICAgID4oKTtcbiAgICB9XG5cbiAgICBjb25zdCBwYWdpbmF0aW9uT3B0aW9ucyA9IHtcbiAgICAgIGluaXRpYWxOdW1JdGVtczogb3B0aW9ucy5pbml0aWFsTnVtSXRlbXMsXG4gICAgICBpZDogLTEsXG4gICAgfTtcblxuICAgIGNvbnN0IHsgcGFnaW5hdGVkUXVlcnlUb2tlbiwgdW5zdWJzY3JpYmUgfSA9IHRoaXMucGFnaW5hdGVkQ2xpZW50LnN1YnNjcmliZShcbiAgICAgIGdldEZ1bmN0aW9uTmFtZShxdWVyeSksXG4gICAgICBhcmdzLFxuICAgICAgLy8gU2ltcGxlIGNsaWVudCBkb2Vzbid0IHVzZSBJRHMsIHRoZXJlJ3Mgbm8gZXhwZWN0YXRpb24gdGhhdCB0aGVzZSBxdWVyaWVzIHJlbWFpbiBzZXBhcmF0ZS5cbiAgICAgIHBhZ2luYXRpb25PcHRpb25zLFxuICAgICk7XG5cbiAgICBjb25zdCBxdWVyeUluZm86IFF1ZXJ5SW5mbyA9IHtcbiAgICAgIHF1ZXJ5VG9rZW46IHBhZ2luYXRlZFF1ZXJ5VG9rZW4sXG4gICAgICBjYWxsYmFjayxcbiAgICAgIG9uRXJyb3IsXG4gICAgICB1bnN1YnNjcmliZSxcbiAgICAgIGhhc0V2ZXJSdW46IGZhbHNlLFxuICAgICAgcXVlcnksXG4gICAgICBhcmdzLFxuICAgICAgcGFnaW5hdGlvbk9wdGlvbnMsXG4gICAgfTtcbiAgICB0aGlzLmxpc3RlbmVycy5hZGQocXVlcnlJbmZvKTtcblxuICAgIC8vIElmIHRoZSBjYWxsYmFjayBpcyByZWdpc3RlcmVkIGZvciBhIHF1ZXJ5IHdpdGggYSByZXN1bHQgaW1tZWRpYXRlbHkgYXZhaWxhYmxlXG4gICAgLy8gc2NoZWR1bGUgYSBmYWtlIHRyYW5zaXRpb24gdG8gY2FsbCB0aGUgY2FsbGJhY2sgc29vbiBpbnN0ZWFkIG9mIHdhaXRpbmcgZm9yXG4gICAgLy8gYSBuZXcgc2VydmVyIHVwZGF0ZSAod2hpY2ggY291bGQgdGFrZSBzZWNvbmRzIG9yIGRheXMpLlxuICAgIGlmIChcbiAgICAgICEhdGhpcy5wYWdpbmF0ZWRDbGllbnQubG9jYWxRdWVyeVJlc3VsdEJ5VG9rZW4ocGFnaW5hdGVkUXVlcnlUb2tlbikgJiZcbiAgICAgIHRoaXMuY2FsbE5ld0xpc3RlbmVyc1dpdGhDdXJyZW50VmFsdWVzVGltZXIgPT09IHVuZGVmaW5lZFxuICAgICkge1xuICAgICAgdGhpcy5jYWxsTmV3TGlzdGVuZXJzV2l0aEN1cnJlbnRWYWx1ZXNUaW1lciA9IHNldFRpbWVvdXQoXG4gICAgICAgICgpID0+IHRoaXMuY2FsbE5ld0xpc3RlbmVyc1dpdGhDdXJyZW50VmFsdWVzKCksXG4gICAgICAgIDAsXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHVuc3Vic2NyaWJlUHJvcHM6IFJlbW92ZUNhbGxTaWduYXR1cmU8XG4gICAgICBVbnN1YnNjcmliZTxQYWdpbmF0ZWRRdWVyeVJlc3VsdDxGdW5jdGlvblJldHVyblR5cGU8UXVlcnk+W10+PlxuICAgID4gPSB7XG4gICAgICB1bnN1YnNjcmliZTogKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAvLyBhbGwgdW5zdWJzY3JpYmVzIGFscmVhZHkgcmFuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLmRlbGV0ZShxdWVyeUluZm8pO1xuICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgfSxcbiAgICAgIGdldEN1cnJlbnRWYWx1ZTogKCkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnBhZ2luYXRlZENsaWVudC5sb2NhbFF1ZXJ5UmVzdWx0KFxuICAgICAgICAgIGdldEZ1bmN0aW9uTmFtZShxdWVyeSksXG4gICAgICAgICAgYXJncyxcbiAgICAgICAgICBwYWdpbmF0aW9uT3B0aW9ucyxcbiAgICAgICAgKTtcbiAgICAgICAgLy8gY2FzdCB0byBhcHBseSB0aGUgc3BlY2lmaWMgZnVuY3Rpb24gdHlwZVxuICAgICAgICByZXR1cm4gcmVzdWx0IGFzXG4gICAgICAgICAgfCBQYWdpbmF0ZWRRdWVyeVJlc3VsdDxGdW5jdGlvblJldHVyblR5cGU8UXVlcnk+PlxuICAgICAgICAgIHwgdW5kZWZpbmVkO1xuICAgICAgfSxcbiAgICAgIGdldFF1ZXJ5TG9nczogKCkgPT4gW10sIC8vIFBhZ2luYXRlZCBxdWVyaWVzIGRvbid0IGFnZ3JlZ2F0ZSB0aGVpciBsb2dzXG4gICAgfTtcbiAgICBjb25zdCByZXQgPSB1bnN1YnNjcmliZVByb3BzLnVuc3Vic2NyaWJlIGFzIFVuc3Vic2NyaWJlPFxuICAgICAgUGFnaW5hdGVkUXVlcnlSZXN1bHQ8RnVuY3Rpb25SZXR1cm5UeXBlPFF1ZXJ5Pj5cbiAgICA+O1xuICAgIE9iamVjdC5hc3NpZ24ocmV0LCB1bnN1YnNjcmliZVByb3BzKTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUnVuIGFsbCBjYWxsYmFja3MgdGhhdCBoYXZlIG5ldmVyIGJlZW4gcnVuIGJlZm9yZSBpZiB0aGV5IGhhdmUgYSBxdWVyeVxuICAvLyByZXN1bHQgYXZhaWxhYmxlIG5vdy5cbiAgcHJpdmF0ZSBjYWxsTmV3TGlzdGVuZXJzV2l0aEN1cnJlbnRWYWx1ZXMoKSB7XG4gICAgdGhpcy5jYWxsTmV3TGlzdGVuZXJzV2l0aEN1cnJlbnRWYWx1ZXNUaW1lciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl90cmFuc2l0aW9uKHsgcXVlcmllczogW10sIHBhZ2luYXRlZFF1ZXJpZXM6IFtdIH0sIHRydWUpO1xuICB9XG5cbiAgcHJpdmF0ZSBxdWVyeVJlc3VsdFJlYWR5KHF1ZXJ5VG9rZW46IFF1ZXJ5VG9rZW4pOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuaGFzTG9jYWxRdWVyeVJlc3VsdEJ5VG9rZW4ocXVlcnlUb2tlbik7XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZURpc2FibGVkVW5zdWJzY3JpYmU8VD4oKTogVW5zdWJzY3JpYmU8VD4ge1xuICAgIGNvbnN0IGRpc2FibGVkVW5zdWJzY3JpYmUgPSAoKCkgPT4ge30pIGFzIFVuc3Vic2NyaWJlPFQ+O1xuICAgIGNvbnN0IHVuc3Vic2NyaWJlUHJvcHM6IFJlbW92ZUNhbGxTaWduYXR1cmU8VW5zdWJzY3JpYmU8VD4+ID0ge1xuICAgICAgdW5zdWJzY3JpYmU6IGRpc2FibGVkVW5zdWJzY3JpYmUsXG4gICAgICBnZXRDdXJyZW50VmFsdWU6ICgpID0+IHVuZGVmaW5lZCxcbiAgICAgIGdldFF1ZXJ5TG9nczogKCkgPT4gdW5kZWZpbmVkLFxuICAgIH07XG4gICAgT2JqZWN0LmFzc2lnbihkaXNhYmxlZFVuc3Vic2NyaWJlLCB1bnN1YnNjcmliZVByb3BzKTtcbiAgICByZXR1cm4gZGlzYWJsZWRVbnN1YnNjcmliZTtcbiAgfVxuXG4gIGFzeW5jIGNsb3NlKCkge1xuICAgIGlmICh0aGlzLmRpc2FibGVkKSByZXR1cm47XG4gICAgLy8gcHJldmVudCBwZW5kaW5nIHVwZGF0ZXNcbiAgICB0aGlzLmxpc3RlbmVycy5jbGVhcigpO1xuICAgIHRoaXMuX2Nsb3NlZCA9IHRydWU7XG4gICAgaWYgKHRoaXMuX3BhZ2luYXRlZENsaWVudCkge1xuICAgICAgdGhpcy5fcGFnaW5hdGVkQ2xpZW50ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jbGllbnQuY2xvc2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgSldUIGF1dGggdG9rZW4gYW5kIGRlY29kZWQgY2xhaW1zLlxuICAgKi9cbiAgZ2V0QXV0aCgpOiB7IHRva2VuOiBzdHJpbmc7IGRlY29kZWQ6IFJlY29yZDxzdHJpbmcsIGFueT4gfSB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHJldHVybjtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuZ2V0Q3VycmVudEF1dGhDbGFpbXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGF1dGhlbnRpY2F0aW9uIHRva2VuIHRvIGJlIHVzZWQgZm9yIHN1YnNlcXVlbnQgcXVlcmllcyBhbmQgbXV0YXRpb25zLlxuICAgKiBgZmV0Y2hUb2tlbmAgd2lsbCBiZSBjYWxsZWQgYXV0b21hdGljYWxseSBhZ2FpbiBpZiBhIHRva2VuIGV4cGlyZXMuXG4gICAqIGBmZXRjaFRva2VuYCBzaG91bGQgcmV0dXJuIGBudWxsYCBpZiB0aGUgdG9rZW4gY2Fubm90IGJlIHJldHJpZXZlZCwgZm9yIGV4YW1wbGVcbiAgICogd2hlbiB0aGUgdXNlcidzIHJpZ2h0cyB3ZXJlIHBlcm1hbmVudGx5IHJldm9rZWQuXG4gICAqIEBwYXJhbSBmZXRjaFRva2VuIC0gYW4gYXN5bmMgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBKV1QgKHR5cGljYWxseSBhbiBPcGVuSUQgQ29ubmVjdCBJZGVudGl0eSBUb2tlbilcbiAgICogQHBhcmFtIG9uQ2hhbmdlIC0gYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGF1dGhlbnRpY2F0aW9uIHN0YXR1cyBjaGFuZ2VzXG4gICAqL1xuICBzZXRBdXRoKFxuICAgIGZldGNoVG9rZW46IEF1dGhUb2tlbkZldGNoZXIsXG4gICAgb25DaGFuZ2U/OiAoaXNBdXRoZW50aWNhdGVkOiBib29sZWFuKSA9PiB2b2lkLFxuICApIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkgcmV0dXJuO1xuICAgIHRoaXMuY2xpZW50LnNldEF1dGgoXG4gICAgICBmZXRjaFRva2VuLFxuICAgICAgb25DaGFuZ2UgPz9cbiAgICAgICAgKCgpID0+IHtcbiAgICAgICAgICAvLyBEbyBub3RoaW5nXG4gICAgICAgIH0pLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzZXRBZG1pbkF1dGgodG9rZW46IHN0cmluZywgaWRlbnRpdHk/OiBVc2VySWRlbnRpdHlBdHRyaWJ1dGVzKSB7XG4gICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb252ZXhDbGllbnQgaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQuXCIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5kaXNhYmxlZCkgcmV0dXJuO1xuICAgIHRoaXMuY2xpZW50LnNldEFkbWluQXV0aCh0b2tlbiwgaWRlbnRpdHkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3RyYW5zaXRpb24oXG4gICAge1xuICAgICAgcXVlcmllcyxcbiAgICAgIHBhZ2luYXRlZFF1ZXJpZXMsXG4gICAgfTogUGljazxFeHRlbmRlZFRyYW5zaXRpb24sIFwicXVlcmllc1wiIHwgXCJwYWdpbmF0ZWRRdWVyaWVzXCI+LFxuICAgIGNhbGxOZXdMaXN0ZW5lcnMgPSBmYWxzZSxcbiAgKSB7XG4gICAgY29uc3QgdXBkYXRlZFF1ZXJpZXMgPSBbXG4gICAgICAuLi5xdWVyaWVzLm1hcCgocSkgPT4gcS50b2tlbiksXG4gICAgICAuLi5wYWdpbmF0ZWRRdWVyaWVzLm1hcCgocSkgPT4gcS50b2tlbiksXG4gICAgXTtcblxuICAgIC8vIERlZHVwaW5nIHN1YnNjcmlwdGlvbnMgaGFwcGVucyBpbiB0aGUgQmFzZUNvbnZleENsaWVudCwgc28gbm90IG11Y2ggdG8gZG8gaGVyZS5cblxuICAgIC8vIENhbGwgYWxsIGNhbGxiYWNrcyBpbiB0aGUgb3JkZXIgdGhleSB3ZXJlIHJlZ2lzdGVyZWRcbiAgICBmb3IgKGNvbnN0IHF1ZXJ5SW5mbyBvZiB0aGlzLmxpc3RlbmVycykge1xuICAgICAgY29uc3QgeyBjYWxsYmFjaywgcXVlcnlUb2tlbiwgb25FcnJvciwgaGFzRXZlclJ1biB9ID0gcXVlcnlJbmZvO1xuICAgICAgY29uc3QgaXNQYWdpbmF0ZWRRdWVyeSA9IHNlcmlhbGl6ZWRRdWVyeVRva2VuSXNQYWdpbmF0ZWQocXVlcnlUb2tlbik7XG5cbiAgICAgIC8vIFdoYXQgZG9lcyBpdCBtZWFuIHRvIGhhdmUgYSBwYWdpbmF0ZWQgcXVlcnkgcmVzdWx0IHJlYWR5PyBJIHRoaW5rIGl0J3NcbiAgICAgIC8vIGFsd2F5cyBnb2luZyB0byBmaXJlIGltbWVkaWF0ZWx5LlxuICAgICAgY29uc3QgaGFzUmVzdWx0UmVhZHkgPSBpc1BhZ2luYXRlZFF1ZXJ5XG4gICAgICAgID8gISF0aGlzLnBhZ2luYXRlZENsaWVudC5sb2NhbFF1ZXJ5UmVzdWx0QnlUb2tlbihxdWVyeVRva2VuKVxuICAgICAgICA6IHRoaXMuY2xpZW50Lmhhc0xvY2FsUXVlcnlSZXN1bHRCeVRva2VuKHF1ZXJ5VG9rZW4pO1xuXG4gICAgICBpZiAoXG4gICAgICAgIHVwZGF0ZWRRdWVyaWVzLmluY2x1ZGVzKHF1ZXJ5VG9rZW4pIHx8XG4gICAgICAgIChjYWxsTmV3TGlzdGVuZXJzICYmICFoYXNFdmVyUnVuICYmIGhhc1Jlc3VsdFJlYWR5KVxuICAgICAgKSB7XG4gICAgICAgIHF1ZXJ5SW5mby5oYXNFdmVyUnVuID0gdHJ1ZTtcbiAgICAgICAgbGV0IG5ld1ZhbHVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChpc1BhZ2luYXRlZFF1ZXJ5KSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHRoaXMucGFnaW5hdGVkQ2xpZW50LmxvY2FsUXVlcnlSZXN1bHRCeVRva2VuKHF1ZXJ5VG9rZW4pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHRoaXMuY2xpZW50LmxvY2FsUXVlcnlSZXN1bHRCeVRva2VuKHF1ZXJ5VG9rZW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBpZiAoIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSkgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICAgIG9uRXJyb3IoXG4gICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICBcIlNlY29uZCBhcmd1bWVudCB0byBvblVwZGF0ZSBvbkVycm9yIGlzIHJlc2VydmVkIGZvciBsYXRlciB1c2VcIixcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc29tZSBub2lzZSB3aXRob3V0IHVuc3Vic2NyaWJpbmcgb3IgZmFpbGluZyB0byBjYWxsIG90aGVyIGNhbGxiYWNrcy5cbiAgICAgICAgICAgIHZvaWQgUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhcbiAgICAgICAgICBuZXdWYWx1ZSxcbiAgICAgICAgICBcIlNlY29uZCBhcmd1bWVudCB0byBvblVwZGF0ZSBjYWxsYmFjayBpcyByZXNlcnZlZCBmb3IgbGF0ZXIgdXNlXCIsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYSBtdXRhdGlvbiBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIG11dGF0aW9uIC0gQSB7QGxpbmsgc2VydmVyLkZ1bmN0aW9uUmVmZXJlbmNlfSBmb3IgdGhlIHB1YmxpYyBtdXRhdGlvblxuICAgKiB0byBydW4uXG4gICAqIEBwYXJhbSBhcmdzIC0gQW4gYXJndW1lbnRzIG9iamVjdCBmb3IgdGhlIG11dGF0aW9uLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEEge0BsaW5rIE11dGF0aW9uT3B0aW9uc30gb3B0aW9ucyBvYmplY3QgZm9yIHRoZSBtdXRhdGlvbi5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIG9mIHRoZSBtdXRhdGlvbidzIHJlc3VsdC5cbiAgICovXG4gIGFzeW5jIG11dGF0aW9uPE11dGF0aW9uIGV4dGVuZHMgRnVuY3Rpb25SZWZlcmVuY2U8XCJtdXRhdGlvblwiPj4oXG4gICAgbXV0YXRpb246IE11dGF0aW9uLFxuICAgIGFyZ3M6IEZ1bmN0aW9uQXJnczxNdXRhdGlvbj4sXG4gICAgb3B0aW9ucz86IE11dGF0aW9uT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxBd2FpdGVkPEZ1bmN0aW9uUmV0dXJuVHlwZTxNdXRhdGlvbj4+PiB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHRocm93IG5ldyBFcnJvcihcIkNvbnZleENsaWVudCBpcyBkaXNhYmxlZFwiKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQubXV0YXRpb24oZ2V0RnVuY3Rpb25OYW1lKG11dGF0aW9uKSwgYXJncywgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZSBhbiBhY3Rpb24gZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSBhY3Rpb24gLSBBIHtAbGluayBzZXJ2ZXIuRnVuY3Rpb25SZWZlcmVuY2V9IGZvciB0aGUgcHVibGljIGFjdGlvblxuICAgKiB0byBydW4uXG4gICAqIEBwYXJhbSBhcmdzIC0gQW4gYXJndW1lbnRzIG9iamVjdCBmb3IgdGhlIGFjdGlvbi5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIG9mIHRoZSBhY3Rpb24ncyByZXN1bHQuXG4gICAqL1xuICBhc3luYyBhY3Rpb248QWN0aW9uIGV4dGVuZHMgRnVuY3Rpb25SZWZlcmVuY2U8XCJhY3Rpb25cIj4+KFxuICAgIGFjdGlvbjogQWN0aW9uLFxuICAgIGFyZ3M6IEZ1bmN0aW9uQXJnczxBY3Rpb24+LFxuICApOiBQcm9taXNlPEF3YWl0ZWQ8RnVuY3Rpb25SZXR1cm5UeXBlPEFjdGlvbj4+PiB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHRocm93IG5ldyBFcnJvcihcIkNvbnZleENsaWVudCBpcyBkaXNhYmxlZFwiKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuYWN0aW9uKGdldEZ1bmN0aW9uTmFtZShhY3Rpb24pLCBhcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIHF1ZXJ5IHJlc3VsdCBvbmNlLlxuICAgKlxuICAgKiBAcGFyYW0gcXVlcnkgLSBBIHtAbGluayBzZXJ2ZXIuRnVuY3Rpb25SZWZlcmVuY2V9IGZvciB0aGUgcHVibGljIHF1ZXJ5XG4gICAqIHRvIHJ1bi5cbiAgICogQHBhcmFtIGFyZ3MgLSBBbiBhcmd1bWVudHMgb2JqZWN0IGZvciB0aGUgcXVlcnkuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSBvZiB0aGUgcXVlcnkncyByZXN1bHQuXG4gICAqL1xuICBhc3luYyBxdWVyeTxRdWVyeSBleHRlbmRzIEZ1bmN0aW9uUmVmZXJlbmNlPFwicXVlcnlcIj4+KFxuICAgIHF1ZXJ5OiBRdWVyeSxcbiAgICBhcmdzOiBRdWVyeVtcIl9hcmdzXCJdLFxuICApOiBQcm9taXNlPEF3YWl0ZWQ8UXVlcnlbXCJfcmV0dXJuVHlwZVwiXT4+IHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkgdGhyb3cgbmV3IEVycm9yKFwiQ29udmV4Q2xpZW50IGlzIGRpc2FibGVkXCIpO1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5jbGllbnQubG9jYWxRdWVyeVJlc3VsdChnZXRGdW5jdGlvbk5hbWUocXVlcnkpLCBhcmdzKSBhc1xuICAgICAgfCBBd2FpdGVkPFF1ZXJ5W1wiX3JldHVyblR5cGVcIl0+XG4gICAgICB8IHVuZGVmaW5lZDtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgeyB1bnN1YnNjcmliZSB9ID0gdGhpcy5vblVwZGF0ZShcbiAgICAgICAgcXVlcnksXG4gICAgICAgIGFyZ3MsXG4gICAgICAgICh2YWx1ZSkgPT4ge1xuICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIChlOiBFcnJvcikgPT4ge1xuICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9LFxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQge0BsaW5rIENvbm5lY3Rpb25TdGF0ZX0gYmV0d2VlbiB0aGUgY2xpZW50IGFuZCB0aGUgQ29udmV4XG4gICAqIGJhY2tlbmQuXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSB7QGxpbmsgQ29ubmVjdGlvblN0YXRlfSB3aXRoIHRoZSBDb252ZXggYmFja2VuZC5cbiAgICovXG4gIGNvbm5lY3Rpb25TdGF0ZSgpOiBDb25uZWN0aW9uU3RhdGUge1xuICAgIGlmICh0aGlzLmRpc2FibGVkKSB0aHJvdyBuZXcgRXJyb3IoXCJDb252ZXhDbGllbnQgaXMgZGlzYWJsZWRcIik7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmNvbm5lY3Rpb25TdGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YnNjcmliZSB0byB0aGUge0BsaW5rIENvbm5lY3Rpb25TdGF0ZX0gYmV0d2VlbiB0aGUgY2xpZW50IGFuZCB0aGUgQ29udmV4XG4gICAqIGJhY2tlbmQsIGNhbGxpbmcgYSBjYWxsYmFjayBlYWNoIHRpbWUgaXQgY2hhbmdlcy5cbiAgICpcbiAgICogU3Vic2NyaWJlZCBjYWxsYmFja3Mgd2lsbCBiZSBjYWxsZWQgd2hlbiBhbnkgcGFydCBvZiBDb25uZWN0aW9uU3RhdGUgY2hhbmdlcy5cbiAgICogQ29ubmVjdGlvblN0YXRlIG1heSBncm93IGluIGZ1dHVyZSB2ZXJzaW9ucyAoZS5nLiB0byBwcm92aWRlIGEgYXJyYXkgb2ZcbiAgICogaW5mbGlnaHQgcmVxdWVzdHMpIGluIHdoaWNoIGNhc2UgY2FsbGJhY2tzIHdvdWxkIGJlIGNhbGxlZCBtb3JlIGZyZXF1ZW50bHkuXG4gICAqXG4gICAqIEByZXR1cm5zIEFuIHVuc3Vic2NyaWJlIGZ1bmN0aW9uIHRvIHN0b3AgbGlzdGVuaW5nLlxuICAgKi9cbiAgc3Vic2NyaWJlVG9Db25uZWN0aW9uU3RhdGUoXG4gICAgY2I6IChjb25uZWN0aW9uU3RhdGU6IENvbm5lY3Rpb25TdGF0ZSkgPT4gdm9pZCxcbiAgKTogKCkgPT4gdm9pZCB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHJldHVybiAoKSA9PiB7fTtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuc3Vic2NyaWJlVG9Db25uZWN0aW9uU3RhdGUoY2IpO1xuICB9XG59XG5cbi8vIGludGVybmFsIGluZm9ybWF0aW9uIHRyYWNrZWQgYWJvdXQgZWFjaCByZWdpc3RlcmVkIGNhbGxiYWNrXG50eXBlIFF1ZXJ5SW5mbyA9IHtcbiAgY2FsbGJhY2s6IChyZXN1bHQ6IGFueSwgbWV0YTogdW5rbm93bikgPT4gdW5rbm93bjtcbiAgb25FcnJvcjogKChlOiBFcnJvciwgbWV0YTogdW5rbm93bikgPT4gdW5rbm93bikgfCB1bmRlZmluZWQ7XG4gIHVuc3Vic2NyaWJlOiAoKSA9PiB2b2lkO1xuICBxdWVyeVRva2VuOiBRdWVyeVRva2VuIHwgUGFnaW5hdGVkUXVlcnlUb2tlbjtcbiAgaGFzRXZlclJ1bjogYm9vbGVhbjtcbiAgLy8gcXVlcnksIGFyZ3MgYW5kIHBhZ2luYXRpb25PcHRpb25zIGFyZSBqdXN0IGhlcmUgZm9yIGRlYnVnZ2luZywgdGhlIHF1ZXJ5VG9rZW4gaXMgYXV0aG9yaXRhdGl2ZVxuICBxdWVyeTogRnVuY3Rpb25SZWZlcmVuY2U8XCJxdWVyeVwiPjtcbiAgYXJnczogYW55O1xuICBwYWdpbmF0aW9uT3B0aW9uczogeyBpbml0aWFsTnVtSXRlbXM6IG51bWJlcjsgaWQ6IG51bWJlciB9IHwgdW5kZWZpbmVkO1xufTtcblxuLy8gaGVscHMgdG8gY29uc3RydWN0IG9iamVjdHMgd2l0aCBhIGNhbGwgc2lnbmF0dXJlXG50eXBlIFJlbW92ZUNhbGxTaWduYXR1cmU8VD4gPSBPbWl0PFQsIG5ldmVyPjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4gX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbmltcG9ydCB7XG4gIHNlcmlhbGl6ZVBhZ2luYXRlZFBhdGhBbmRBcmdzLFxuICBjYW5vbmljYWxpemVVZGZQYXRoXG59IGZyb20gXCIuL3VkZl9wYXRoX3V0aWxzLmpzXCI7XG5pbXBvcnQge1xuICBhc1BhZ2luYXRpb25SZXN1bHRcbn0gZnJvbSBcIi4vcGFnaW5hdGlvbi5qc1wiO1xuaW1wb3J0IHsgTG9uZyB9IGZyb20gXCIuLi8uLi92ZW5kb3IvbG9uZy5qc1wiO1xuZXhwb3J0IGNsYXNzIFBhZ2luYXRlZFF1ZXJ5Q2xpZW50IHtcbiAgY29uc3RydWN0b3IoY2xpZW50LCBvblRyYW5zaXRpb24pIHtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB0aGlzLm9uVHJhbnNpdGlvbiA9IG9uVHJhbnNpdGlvbjtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicGFnaW5hdGVkUXVlcnlTZXRcIiwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgLy8gaG9sZCBvbnRvIGEgcmVhbCBUcmFuc2l0aW9uIHNvIHdlIGNhbiBjb25zdHJ1Y3Qgc3ludGhldGljIG9uZXMgd2l0aCB0aGF0IHRpbWVzdGFtcFxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJsYXN0VHJhbnNpdGlvblRzXCIpO1xuICAgIHRoaXMubGFzdFRyYW5zaXRpb25UcyA9IExvbmcuZnJvbU51bWJlcigwKTtcbiAgICB0aGlzLmNsaWVudC5hZGRPblRyYW5zaXRpb25IYW5kbGVyKFxuICAgICAgKHRyYW5zaXRpb24pID0+IHRoaXMub25CYXNlVHJhbnNpdGlvbih0cmFuc2l0aW9uKVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFN1YnNjcmliZSB0byBhIHBhZ2luYXRlZCBxdWVyeS5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcGFnaW5hdGVkIHF1ZXJ5IGZ1bmN0aW9uXG4gICAqIEBwYXJhbSBhcmdzIC0gQXJndW1lbnRzIGZvciB0aGUgcXVlcnkgKGV4Y2x1ZGluZyBwYWdpbmF0aW9uT3B0cylcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBQYWdpbmF0aW9uIG9wdGlvbnMgaW5jbHVkaW5nIGluaXRpYWxOdW1JdGVtc1xuICAgKiBAcmV0dXJucyBPYmplY3Qgd2l0aCBwYWdpbmF0ZWRRdWVyeVRva2VuIGFuZCB1bnN1YnNjcmliZSBmdW5jdGlvblxuICAgKi9cbiAgc3Vic2NyaWJlKG5hbWUsIGFyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjYW5vbmljYWxpemVkVWRmUGF0aCA9IGNhbm9uaWNhbGl6ZVVkZlBhdGgobmFtZSk7XG4gICAgY29uc3QgdG9rZW4gPSBzZXJpYWxpemVQYWdpbmF0ZWRQYXRoQW5kQXJncyhcbiAgICAgIGNhbm9uaWNhbGl6ZWRVZGZQYXRoLFxuICAgICAgYXJncyxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gKCkgPT4gdGhpcy5yZW1vdmVQYWdpbmF0ZWRRdWVyeVN1YnNjcmliZXIodG9rZW4pO1xuICAgIGNvbnN0IGV4aXN0aW5nRW50cnkgPSB0aGlzLnBhZ2luYXRlZFF1ZXJ5U2V0LmdldCh0b2tlbik7XG4gICAgaWYgKGV4aXN0aW5nRW50cnkpIHtcbiAgICAgIGV4aXN0aW5nRW50cnkubnVtU3Vic2NyaWJlcnMgKz0gMTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhZ2luYXRlZFF1ZXJ5VG9rZW46IHRva2VuLFxuICAgICAgICB1bnN1YnNjcmliZVxuICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5wYWdpbmF0ZWRRdWVyeVNldC5zZXQodG9rZW4sIHtcbiAgICAgIHRva2VuLFxuICAgICAgY2Fub25pY2FsaXplZFVkZlBhdGgsXG4gICAgICBhcmdzLFxuICAgICAgbnVtU3Vic2NyaWJlcnM6IDEsXG4gICAgICBvcHRpb25zOiB7IGluaXRpYWxOdW1JdGVtczogb3B0aW9ucy5pbml0aWFsTnVtSXRlbXMgfSxcbiAgICAgIG5leHRQYWdlS2V5OiAwLFxuICAgICAgcGFnZUtleXM6IFtdLFxuICAgICAgcGFnZUtleVRvUXVlcnk6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgICBvbmdvaW5nU3BsaXRzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgc2tpcDogZmFsc2UsXG4gICAgICBpZDogb3B0aW9ucy5pZFxuICAgIH0pO1xuICAgIHRoaXMuYWRkUGFnZVRvUGFnaW5hdGVkUXVlcnkodG9rZW4sIG51bGwsIG9wdGlvbnMuaW5pdGlhbE51bUl0ZW1zKTtcbiAgICByZXR1cm4ge1xuICAgICAgcGFnaW5hdGVkUXVlcnlUb2tlbjogdG9rZW4sXG4gICAgICB1bnN1YnNjcmliZVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEdldCBjdXJyZW50IHJlc3VsdHMgZm9yIGEgcGFnaW5hdGVkIHF1ZXJ5IGJhc2VkIG9uIGxvY2FsIHN0YXRlLlxuICAgKlxuICAgKiBUaHJvd3MgYW4gZXJyb3Igd2hlbiBvbmUgb2YgdGhlIHBhZ2VzIGhhcyBlcnJvcmVkLlxuICAgKi9cbiAgbG9jYWxRdWVyeVJlc3VsdChuYW1lLCBhcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY2Fub25pY2FsaXplZFVkZlBhdGggPSBjYW5vbmljYWxpemVVZGZQYXRoKG5hbWUpO1xuICAgIGNvbnN0IHRva2VuID0gc2VyaWFsaXplUGFnaW5hdGVkUGF0aEFuZEFyZ3MoXG4gICAgICBjYW5vbmljYWxpemVkVWRmUGF0aCxcbiAgICAgIGFyZ3MsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5sb2NhbFF1ZXJ5UmVzdWx0QnlUb2tlbih0b2tlbik7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbG9jYWxRdWVyeVJlc3VsdEJ5VG9rZW4odG9rZW4pIHtcbiAgICBjb25zdCBwYWdpbmF0ZWRRdWVyeSA9IHRoaXMucGFnaW5hdGVkUXVlcnlTZXQuZ2V0KHRva2VuKTtcbiAgICBpZiAoIXBhZ2luYXRlZFF1ZXJ5KSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBjb25zdCBhY3RpdmVQYWdlcyA9IHRoaXMuYWN0aXZlUGFnZVF1ZXJ5VG9rZW5zKHBhZ2luYXRlZFF1ZXJ5KTtcbiAgICBpZiAoYWN0aXZlUGFnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN1bHRzOiBbXSxcbiAgICAgICAgc3RhdHVzOiBcIkxvYWRpbmdGaXJzdFBhZ2VcIixcbiAgICAgICAgbG9hZE1vcmU6IChudW1JdGVtcykgPT4ge1xuICAgICAgICAgIHJldHVybiB0aGlzLmxvYWRNb3JlT2ZQYWdpbmF0ZWRRdWVyeSh0b2tlbiwgbnVtSXRlbXMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBsZXQgYWxsUmVzdWx0cyA9IFtdO1xuICAgIGxldCBoYXNVbmRlZmluZWQgPSBmYWxzZTtcbiAgICBsZXQgaXNEb25lID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBwYWdlVG9rZW4gb2YgYWN0aXZlUGFnZXMpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuY2xpZW50LmxvY2FsUXVlcnlSZXN1bHRCeVRva2VuKHBhZ2VUb2tlbik7XG4gICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHtcbiAgICAgICAgaGFzVW5kZWZpbmVkID0gdHJ1ZTtcbiAgICAgICAgaXNEb25lID0gZmFsc2U7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFnaW5hdGlvblJlc3VsdCA9IGFzUGFnaW5hdGlvblJlc3VsdChyZXN1bHQpO1xuICAgICAgYWxsUmVzdWx0cyA9IGFsbFJlc3VsdHMuY29uY2F0KHBhZ2luYXRpb25SZXN1bHQucGFnZSk7XG4gICAgICBpc0RvbmUgPSAhIXBhZ2luYXRpb25SZXN1bHQuaXNEb25lO1xuICAgIH1cbiAgICBsZXQgc3RhdHVzO1xuICAgIGlmIChoYXNVbmRlZmluZWQpIHtcbiAgICAgIHN0YXR1cyA9IGFsbFJlc3VsdHMubGVuZ3RoID09PSAwID8gXCJMb2FkaW5nRmlyc3RQYWdlXCIgOiBcIkxvYWRpbmdNb3JlXCI7XG4gICAgfSBlbHNlIGlmIChpc0RvbmUpIHtcbiAgICAgIHN0YXR1cyA9IFwiRXhoYXVzdGVkXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXR1cyA9IFwiQ2FuTG9hZE1vcmVcIjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3VsdHM6IGFsbFJlc3VsdHMsXG4gICAgICBzdGF0dXMsXG4gICAgICBsb2FkTW9yZTogKG51bUl0ZW1zKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRNb3JlT2ZQYWdpbmF0ZWRRdWVyeSh0b2tlbiwgbnVtSXRlbXMpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgb25CYXNlVHJhbnNpdGlvbih0cmFuc2l0aW9uKSB7XG4gICAgY29uc3QgY2hhbmdlZEJhc2VUb2tlbnMgPSB0cmFuc2l0aW9uLnF1ZXJpZXMubWFwKChxKSA9PiBxLnRva2VuKTtcbiAgICBjb25zdCBjaGFuZ2VkID0gdGhpcy5xdWVyaWVzQ29udGFpbmluZ1Rva2VucyhjaGFuZ2VkQmFzZVRva2Vucyk7XG4gICAgbGV0IHBhZ2luYXRlZFF1ZXJpZXMgPSBbXTtcbiAgICBpZiAoY2hhbmdlZC5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnByb2Nlc3NQYWdpbmF0ZWRRdWVyeVNwbGl0cyhcbiAgICAgICAgY2hhbmdlZCxcbiAgICAgICAgKHRva2VuKSA9PiB0aGlzLmNsaWVudC5sb2NhbFF1ZXJ5UmVzdWx0QnlUb2tlbih0b2tlbilcbiAgICAgICk7XG4gICAgICBwYWdpbmF0ZWRRdWVyaWVzID0gY2hhbmdlZC5tYXAoKHRva2VuKSA9PiAoe1xuICAgICAgICB0b2tlbixcbiAgICAgICAgbW9kaWZpY2F0aW9uOiB7XG4gICAgICAgICAga2luZDogXCJVcGRhdGVkXCIsXG4gICAgICAgICAgcmVzdWx0OiB0aGlzLmxvY2FsUXVlcnlSZXN1bHRCeVRva2VuKHRva2VuKVxuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfVxuICAgIGNvbnN0IGV4dGVuZGVkVHJhbnNpdGlvbiA9IHtcbiAgICAgIC4uLnRyYW5zaXRpb24sXG4gICAgICBwYWdpbmF0ZWRRdWVyaWVzXG4gICAgfTtcbiAgICB0aGlzLm9uVHJhbnNpdGlvbihleHRlbmRlZFRyYW5zaXRpb24pO1xuICB9XG4gIC8qKlxuICAgKiBMb2FkIG1vcmUgaXRlbXMgZm9yIGEgcGFnaW5hdGVkIHF1ZXJ5LlxuICAgKlxuICAgKiBUaGlzICphbHdheXMqIGNhdXNlcyBhIHRyYW5zaXRpb24sIHRoZSBzdGF0dXMgb2YgdGhlIHF1ZXJ5XG4gICAqIGhhcyBwcm9iYWJseSBjaGFuZ2VkIGZyb20gXCJDYW5Mb2FkTW9yZVwiIHRvIFwiTG9hZGluZ01vcmVcIi5cbiAgICogRGF0YSBtaWdodCBoYXZlIGNoYW5nZWQgdG9vOiBtYXliZSBhIHN1YnNjcmlwdGlvbiB0byB0aGlzIHBhZ2VcbiAgICogcXVlcnkgYWxyZWFkeSBleGlzdHMgKHVubGlrZWx5IGJ1dCBwb3NzaWJsZSkgb3IgdGhpcyBwYWdlIHF1ZXJ5XG4gICAqIGhhcyBhbiBvcHRpbWlzdGljIHVwZGF0ZSBwcm92aWRpbmcgc29tZSBpbml0aWFsIGRhdGEuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbG9hZE1vcmVPZlBhZ2luYXRlZFF1ZXJ5KHRva2VuLCBudW1JdGVtcykge1xuICAgIHRoaXMubXVzdEdldFBhZ2luYXRlZFF1ZXJ5KHRva2VuKTtcbiAgICBjb25zdCBsYXN0UGFnZVRva2VuID0gdGhpcy5xdWVyeVRva2VuRm9yTGFzdFBhZ2VPZlBhZ2luYXRlZFF1ZXJ5KHRva2VuKTtcbiAgICBjb25zdCBsYXN0UGFnZVJlc3VsdCA9IHRoaXMuY2xpZW50LmxvY2FsUXVlcnlSZXN1bHRCeVRva2VuKGxhc3RQYWdlVG9rZW4pO1xuICAgIGlmICghbGFzdFBhZ2VSZXN1bHQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcGFnaW5hdGlvblJlc3VsdCA9IGFzUGFnaW5hdGlvblJlc3VsdChsYXN0UGFnZVJlc3VsdCk7XG4gICAgaWYgKHBhZ2luYXRpb25SZXN1bHQuaXNEb25lKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuYWRkUGFnZVRvUGFnaW5hdGVkUXVlcnkoXG4gICAgICB0b2tlbixcbiAgICAgIHBhZ2luYXRpb25SZXN1bHQuY29udGludWVDdXJzb3IsXG4gICAgICBudW1JdGVtc1xuICAgICk7XG4gICAgY29uc3QgbG9hZE1vcmVUcmFuc2l0aW9uID0ge1xuICAgICAgdGltZXN0YW1wOiB0aGlzLmxhc3RUcmFuc2l0aW9uVHMsXG4gICAgICByZWZsZWN0ZWRNdXRhdGlvbnM6IFtdLFxuICAgICAgcXVlcmllczogW10sXG4gICAgICBwYWdpbmF0ZWRRdWVyaWVzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0b2tlbixcbiAgICAgICAgICBtb2RpZmljYXRpb246IHtcbiAgICAgICAgICAgIGtpbmQ6IFwiVXBkYXRlZFwiLFxuICAgICAgICAgICAgcmVzdWx0OiB0aGlzLmxvY2FsUXVlcnlSZXN1bHRCeVRva2VuKHRva2VuKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXVxuICAgIH07XG4gICAgdGhpcy5vblRyYW5zaXRpb24obG9hZE1vcmVUcmFuc2l0aW9uKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBxdWVyaWVzQ29udGFpbmluZ1Rva2VucyhxdWVyeVRva2Vucykge1xuICAgIGlmIChxdWVyeVRva2Vucy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgY2hhbmdlZCA9IFtdO1xuICAgIGNvbnN0IHF1ZXJ5VG9rZW5TZXQgPSBuZXcgU2V0KHF1ZXJ5VG9rZW5zKTtcbiAgICBmb3IgKGNvbnN0IFtwYWdpbmF0ZWRUb2tlbiwgcGFnaW5hdGVkUXVlcnldIG9mIHRoaXMucGFnaW5hdGVkUXVlcnlTZXQpIHtcbiAgICAgIGZvciAoY29uc3QgcGFnZVRva2VuIG9mIHRoaXMuYWxsUXVlcnlUb2tlbnMocGFnaW5hdGVkUXVlcnkpKSB7XG4gICAgICAgIGlmIChxdWVyeVRva2VuU2V0LmhhcyhwYWdlVG9rZW4pKSB7XG4gICAgICAgICAgY2hhbmdlZC5wdXNoKHBhZ2luYXRlZFRva2VuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcm9jZXNzUGFnaW5hdGVkUXVlcnlTcGxpdHMoY2hhbmdlZCwgZ2V0UmVzdWx0KSB7XG4gICAgZm9yIChjb25zdCBwYWdpbmF0ZWRRdWVyeVRva2VuIG9mIGNoYW5nZWQpIHtcbiAgICAgIGNvbnN0IHBhZ2luYXRlZFF1ZXJ5ID0gdGhpcy5tdXN0R2V0UGFnaW5hdGVkUXVlcnkocGFnaW5hdGVkUXVlcnlUb2tlbik7XG4gICAgICBjb25zdCB7IG9uZ29pbmdTcGxpdHMsIHBhZ2VLZXlUb1F1ZXJ5LCBwYWdlS2V5cyB9ID0gcGFnaW5hdGVkUXVlcnk7XG4gICAgICBmb3IgKGNvbnN0IFtwYWdlS2V5LCBbc3BsaXRLZXkxLCBzcGxpdEtleTJdXSBvZiBvbmdvaW5nU3BsaXRzKSB7XG4gICAgICAgIGNvbnN0IGJvdGhOZXdQYWdlc0xvYWRlZCA9IGdldFJlc3VsdChwYWdlS2V5VG9RdWVyeS5nZXQoc3BsaXRLZXkxKS5xdWVyeVRva2VuKSAhPT0gdm9pZCAwICYmIGdldFJlc3VsdChwYWdlS2V5VG9RdWVyeS5nZXQoc3BsaXRLZXkyKS5xdWVyeVRva2VuKSAhPT0gdm9pZCAwO1xuICAgICAgICBpZiAoYm90aE5ld1BhZ2VzTG9hZGVkKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZVBhZ2luYXRlZFF1ZXJ5U3BsaXQoXG4gICAgICAgICAgICBwYWdpbmF0ZWRRdWVyeSxcbiAgICAgICAgICAgIHBhZ2VLZXksXG4gICAgICAgICAgICBzcGxpdEtleTEsXG4gICAgICAgICAgICBzcGxpdEtleTJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHBhZ2VLZXkgb2YgcGFnZUtleXMpIHtcbiAgICAgICAgaWYgKG9uZ29pbmdTcGxpdHMuaGFzKHBhZ2VLZXkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFnZVRva2VuID0gcGFnZUtleVRvUXVlcnkuZ2V0KHBhZ2VLZXkpLnF1ZXJ5VG9rZW47XG4gICAgICAgIGNvbnN0IHBhZ2VSZXN1bHQgPSBnZXRSZXN1bHQocGFnZVRva2VuKTtcbiAgICAgICAgaWYgKCFwYWdlUmVzdWx0KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXNQYWdpbmF0aW9uUmVzdWx0KHBhZ2VSZXN1bHQpO1xuICAgICAgICBjb25zdCBzaG91bGRTcGxpdCA9IHJlc3VsdC5zcGxpdEN1cnNvciAmJiAocmVzdWx0LnBhZ2VTdGF0dXMgPT09IFwiU3BsaXRSZWNvbW1lbmRlZFwiIHx8IHJlc3VsdC5wYWdlU3RhdHVzID09PSBcIlNwbGl0UmVxdWlyZWRcIiB8fCAvLyBUaGlzIGNsaWVudC1kcml2ZW4gcGFnZSBzcGxpdHRpbmcgY29uZGl0aW9uIHdpbGwgY2hhbmdlIGluIHRoZSBmdXR1cmUuXG4gICAgICAgIHJlc3VsdC5wYWdlLmxlbmd0aCA+IHBhZ2luYXRlZFF1ZXJ5Lm9wdGlvbnMuaW5pdGlhbE51bUl0ZW1zICogMik7XG4gICAgICAgIGlmIChzaG91bGRTcGxpdCkge1xuICAgICAgICAgIHRoaXMuc3BsaXRQYWdpbmF0ZWRRdWVyeVBhZ2UoXG4gICAgICAgICAgICBwYWdpbmF0ZWRRdWVyeSxcbiAgICAgICAgICAgIHBhZ2VLZXksXG4gICAgICAgICAgICByZXN1bHQuc3BsaXRDdXJzb3IsXG4gICAgICAgICAgICAvLyB3ZSBqdXN0IGNoZWNrZWRcbiAgICAgICAgICAgIHJlc3VsdC5jb250aW51ZUN1cnNvclxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3BsaXRQYWdpbmF0ZWRRdWVyeVBhZ2UocGFnaW5hdGVkUXVlcnksIHBhZ2VLZXksIHNwbGl0Q3Vyc29yLCBjb250aW51ZUN1cnNvcikge1xuICAgIGNvbnN0IHNwbGl0S2V5MSA9IHBhZ2luYXRlZFF1ZXJ5Lm5leHRQYWdlS2V5Kys7XG4gICAgY29uc3Qgc3BsaXRLZXkyID0gcGFnaW5hdGVkUXVlcnkubmV4dFBhZ2VLZXkrKztcbiAgICBjb25zdCBwYWdpbmF0aW9uT3B0cyA9IHtcbiAgICAgIGN1cnNvcjogY29udGludWVDdXJzb3IsXG4gICAgICBudW1JdGVtczogcGFnaW5hdGVkUXVlcnkub3B0aW9ucy5pbml0aWFsTnVtSXRlbXMsXG4gICAgICBpZDogcGFnaW5hdGVkUXVlcnkuaWRcbiAgICB9O1xuICAgIGNvbnN0IGZpcnN0U3Vic2NyaXB0aW9uID0gdGhpcy5jbGllbnQuc3Vic2NyaWJlKFxuICAgICAgcGFnaW5hdGVkUXVlcnkuY2Fub25pY2FsaXplZFVkZlBhdGgsXG4gICAgICB7XG4gICAgICAgIC4uLnBhZ2luYXRlZFF1ZXJ5LmFyZ3MsXG4gICAgICAgIHBhZ2luYXRpb25PcHRzOiB7XG4gICAgICAgICAgLi4ucGFnaW5hdGlvbk9wdHMsXG4gICAgICAgICAgY3Vyc29yOiBudWxsLFxuICAgICAgICAgIC8vIFN0YXJ0IGZyb20gYmVnaW5uaW5nIGZvciBmaXJzdCBzcGxpdFxuICAgICAgICAgIGVuZEN1cnNvcjogc3BsaXRDdXJzb3JcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gICAgcGFnaW5hdGVkUXVlcnkucGFnZUtleVRvUXVlcnkuc2V0KHNwbGl0S2V5MSwgZmlyc3RTdWJzY3JpcHRpb24pO1xuICAgIGNvbnN0IHNlY29uZFN1YnNjcmlwdGlvbiA9IHRoaXMuY2xpZW50LnN1YnNjcmliZShcbiAgICAgIHBhZ2luYXRlZFF1ZXJ5LmNhbm9uaWNhbGl6ZWRVZGZQYXRoLFxuICAgICAge1xuICAgICAgICAuLi5wYWdpbmF0ZWRRdWVyeS5hcmdzLFxuICAgICAgICBwYWdpbmF0aW9uT3B0czoge1xuICAgICAgICAgIC4uLnBhZ2luYXRpb25PcHRzLFxuICAgICAgICAgIGN1cnNvcjogc3BsaXRDdXJzb3IsXG4gICAgICAgICAgZW5kQ3Vyc29yOiBjb250aW51ZUN1cnNvclxuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICBwYWdpbmF0ZWRRdWVyeS5wYWdlS2V5VG9RdWVyeS5zZXQoc3BsaXRLZXkyLCBzZWNvbmRTdWJzY3JpcHRpb24pO1xuICAgIHBhZ2luYXRlZFF1ZXJ5Lm9uZ29pbmdTcGxpdHMuc2V0KHBhZ2VLZXksIFtzcGxpdEtleTEsIHNwbGl0S2V5Ml0pO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGFkZFBhZ2VUb1BhZ2luYXRlZFF1ZXJ5KHRva2VuLCBjb250aW51ZUN1cnNvciwgbnVtSXRlbXMpIHtcbiAgICBjb25zdCBwYWdpbmF0ZWRRdWVyeSA9IHRoaXMubXVzdEdldFBhZ2luYXRlZFF1ZXJ5KHRva2VuKTtcbiAgICBjb25zdCBwYWdlS2V5ID0gcGFnaW5hdGVkUXVlcnkubmV4dFBhZ2VLZXkrKztcbiAgICBjb25zdCBwYWdpbmF0aW9uT3B0cyA9IHtcbiAgICAgIGN1cnNvcjogY29udGludWVDdXJzb3IsXG4gICAgICBudW1JdGVtcyxcbiAgICAgIGlkOiBwYWdpbmF0ZWRRdWVyeS5pZFxuICAgIH07XG4gICAgY29uc3QgcGFnZUFyZ3MgPSB7XG4gICAgICAuLi5wYWdpbmF0ZWRRdWVyeS5hcmdzLFxuICAgICAgcGFnaW5hdGlvbk9wdHNcbiAgICB9O1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHRoaXMuY2xpZW50LnN1YnNjcmliZShcbiAgICAgIHBhZ2luYXRlZFF1ZXJ5LmNhbm9uaWNhbGl6ZWRVZGZQYXRoLFxuICAgICAgcGFnZUFyZ3NcbiAgICApO1xuICAgIHBhZ2luYXRlZFF1ZXJ5LnBhZ2VLZXlzLnB1c2gocGFnZUtleSk7XG4gICAgcGFnaW5hdGVkUXVlcnkucGFnZUtleVRvUXVlcnkuc2V0KHBhZ2VLZXksIHN1YnNjcmlwdGlvbik7XG4gICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgfVxuICByZW1vdmVQYWdpbmF0ZWRRdWVyeVN1YnNjcmliZXIodG9rZW4pIHtcbiAgICBjb25zdCBwYWdpbmF0ZWRRdWVyeSA9IHRoaXMucGFnaW5hdGVkUXVlcnlTZXQuZ2V0KHRva2VuKTtcbiAgICBpZiAoIXBhZ2luYXRlZFF1ZXJ5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHBhZ2luYXRlZFF1ZXJ5Lm51bVN1YnNjcmliZXJzIC09IDE7XG4gICAgaWYgKHBhZ2luYXRlZFF1ZXJ5Lm51bVN1YnNjcmliZXJzID4gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHN1YnNjcmlwdGlvbiBvZiBwYWdpbmF0ZWRRdWVyeS5wYWdlS2V5VG9RdWVyeS52YWx1ZXMoKSkge1xuICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIHRoaXMucGFnaW5hdGVkUXVlcnlTZXQuZGVsZXRlKHRva2VuKTtcbiAgfVxuICBjb21wbGV0ZVBhZ2luYXRlZFF1ZXJ5U3BsaXQocGFnaW5hdGVkUXVlcnksIHBhZ2VLZXksIHNwbGl0S2V5MSwgc3BsaXRLZXkyKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxRdWVyeSA9IHBhZ2luYXRlZFF1ZXJ5LnBhZ2VLZXlUb1F1ZXJ5LmdldChwYWdlS2V5KTtcbiAgICBwYWdpbmF0ZWRRdWVyeS5wYWdlS2V5VG9RdWVyeS5kZWxldGUocGFnZUtleSk7XG4gICAgY29uc3QgcGFnZUluZGV4ID0gcGFnaW5hdGVkUXVlcnkucGFnZUtleXMuaW5kZXhPZihwYWdlS2V5KTtcbiAgICBwYWdpbmF0ZWRRdWVyeS5wYWdlS2V5cy5zcGxpY2UocGFnZUluZGV4LCAxLCBzcGxpdEtleTEsIHNwbGl0S2V5Mik7XG4gICAgcGFnaW5hdGVkUXVlcnkub25nb2luZ1NwbGl0cy5kZWxldGUocGFnZUtleSk7XG4gICAgb3JpZ2luYWxRdWVyeS51bnN1YnNjcmliZSgpO1xuICB9XG4gIC8qKiBUaGUgcXVlcnkgdG9rZW5zIGZvciBhbGwgYWN0aXZlIHBhZ2VzLCBpbiByZXN1bHQgb3JkZXIgKi9cbiAgYWN0aXZlUGFnZVF1ZXJ5VG9rZW5zKHBhZ2luYXRlZFF1ZXJ5KSB7XG4gICAgcmV0dXJuIHBhZ2luYXRlZFF1ZXJ5LnBhZ2VLZXlzLm1hcChcbiAgICAgIChwYWdlS2V5KSA9PiBwYWdpbmF0ZWRRdWVyeS5wYWdlS2V5VG9RdWVyeS5nZXQocGFnZUtleSkucXVlcnlUb2tlblxuICAgICk7XG4gIH1cbiAgYWxsUXVlcnlUb2tlbnMocGFnaW5hdGVkUXVlcnkpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShwYWdpbmF0ZWRRdWVyeS5wYWdlS2V5VG9RdWVyeS52YWx1ZXMoKSkubWFwKFxuICAgICAgKHN1YikgPT4gc3ViLnF1ZXJ5VG9rZW5cbiAgICApO1xuICB9XG4gIHF1ZXJ5VG9rZW5Gb3JMYXN0UGFnZU9mUGFnaW5hdGVkUXVlcnkodG9rZW4pIHtcbiAgICBjb25zdCBwYWdpbmF0ZWRRdWVyeSA9IHRoaXMubXVzdEdldFBhZ2luYXRlZFF1ZXJ5KHRva2VuKTtcbiAgICBjb25zdCBsYXN0UGFnZUtleSA9IHBhZ2luYXRlZFF1ZXJ5LnBhZ2VLZXlzW3BhZ2luYXRlZFF1ZXJ5LnBhZ2VLZXlzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChsYXN0UGFnZUtleSA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHBhZ2VzIGZvciBwYWdpbmF0ZWQgcXVlcnkgJHt0b2tlbn1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhZ2luYXRlZFF1ZXJ5LnBhZ2VLZXlUb1F1ZXJ5LmdldChsYXN0UGFnZUtleSkucXVlcnlUb2tlbjtcbiAgfVxuICBtdXN0R2V0UGFnaW5hdGVkUXVlcnkodG9rZW4pIHtcbiAgICBjb25zdCBwYWdpbmF0ZWRRdWVyeSA9IHRoaXMucGFnaW5hdGVkUXVlcnlTZXQuZ2V0KHRva2VuKTtcbiAgICBpZiAoIXBhZ2luYXRlZFF1ZXJ5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwYWdpbmF0ZWQgcXVlcnkgbm8gbG9uZ2VyIGV4aXN0cyBmb3IgdG9rZW4gXCIgKyB0b2tlbik7XG4gICAgfVxuICAgIHJldHVybiBwYWdpbmF0ZWRRdWVyeTtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFnaW5hdGVkX3F1ZXJ5X2NsaWVudC5qcy5tYXBcbiIsIi8qKlxuICogUGFnaW5hdGVkUXVlcnlDbGllbnQgbWFwcyBzdWJzY3JpcHRpb25zIHRvIHBhZ2luYXRlZCBxdWVyaWVzIHRvIHRoZVxuICogaW5kaXZpZHVhbCBwYWdlIHF1ZXJpZXMgYW5kIGhhbmRsZXMgcGFnZSBzcGxpdHMuXG4gKlxuICogSW4gb3JkZXIgdG8gcHJvY2VzcyBhbGwgbW9kaWZpZWQgcXVlcmllcywgcGFnaW5hdGVkIGFuZCBub3JtYWwsIGluIHRoZSBzYW1lXG4gKiBzeW5jaHJvbm91cyBjYWxsIHRoZSBQYWdpbmF0ZWRRdWVyeUNsaWVudCB0cmFuc2l0aW9uIHNob3VsZCBiZSB1c2VkIGV4Y2x1c2l2ZWx5LlxuICpcbiAqIExpa2UgdGhlIEJhc2VDb252ZXhDbGllbnQsIHRoaXMgY2xpZW50IGlzIG5vdCBDb252ZXggRnVuY3Rpb24gdHlwZS1hd2FyZTogaXQgZGVhbHNcbiAqIHdpdGggcXVlcmllcyBhcyBmdW5jdGlvbnMgdGhhdCByZXR1cm4gVmFsdWUsIG5vdCB0aGUgc3BlY2lmaWMgdmFsdWUuXG4gKiBVc2UgYSBoaWdoZXItbGV2ZWwgbGlicmFyeSB0byBnZXQgdHlwZXMuXG4gKi9cblxuaW1wb3J0IHsgVmFsdWUgfSBmcm9tIFwiLi4vLi4vdmFsdWVzL2luZGV4LmpzXCI7XG5pbXBvcnQge1xuICBQYWdpbmF0ZWRRdWVyeVRva2VuLFxuICBRdWVyeVRva2VuLFxuICBzZXJpYWxpemVQYWdpbmF0ZWRQYXRoQW5kQXJncyxcbiAgY2Fub25pY2FsaXplVWRmUGF0aCxcbn0gZnJvbSBcIi4vdWRmX3BhdGhfdXRpbHMuanNcIjtcbmltcG9ydCB7IEJhc2VDb252ZXhDbGllbnQsIFRyYW5zaXRpb24gfSBmcm9tIFwiLi9jbGllbnQuanNcIjtcbmltcG9ydCB7XG4gIFBhZ2luYXRlZFF1ZXJ5UmVzdWx0LFxuICBQYWdpbmF0aW9uU3RhdHVzLFxuICBhc1BhZ2luYXRpb25SZXN1bHQsXG59IGZyb20gXCIuL3BhZ2luYXRpb24uanNcIjtcbmltcG9ydCB7IFRTIH0gZnJvbSBcIi4vcHJvdG9jb2wuanNcIjtcbmltcG9ydCB7IExvbmcgfSBmcm9tIFwiLi4vLi4vdmVuZG9yL2xvbmcuanNcIjtcblxudHlwZSBRdWVyeVBhZ2VLZXkgPSBudW1iZXI7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHBhZ2luYXRlZCBxdWVyeSBzdWJzY3JpcHRpb24gd2l0aCBtdWx0aXBsZSBwYWdlcy5cbiAqXG4gKiBUbyBrbm93IHRoZSBvcmRlciBvZiBwYWdlcyBpdCdzIG5lY2Vzc2FyeSB0byBjb25zdWx0IGBwYWdlS2V5c2AuXG4gKiBUaGUgcGFnZXMgaW4gdGhpcyBhcnJheSBhcmUgYWN0aXZlLCB0aGV5IGNvbnN0aXR1dGUgYSBnYXBsZXNzIHNlcXVlbmNlIG9mIHJlc3VsdHMuXG4gKiBTb21lIHBhZ2VzIGFyZSBub3QgaW4gdGhpcyBhcnJheTogdGhleSBtYXkgYmUgd2FpdGluZyBmb3IgZGF0YSBmb3IgYSBwYWdlIHNwbGl0LlxuICovXG50eXBlIExvY2FsUGFnaW5hdGVkUXVlcnkgPSB7XG4gIHRva2VuOiBQYWdpbmF0ZWRRdWVyeVRva2VuO1xuICBjYW5vbmljYWxpemVkVWRmUGF0aDogc3RyaW5nO1xuICBhcmdzOiBSZWNvcmQ8c3RyaW5nLCBWYWx1ZT47IC8vIFdJVEhPVVQgcGFnaW5hdGlvbk9wdHNcbiAgbnVtU3Vic2NyaWJlcnM6IG51bWJlcjtcbiAgb3B0aW9uczogeyBpbml0aWFsTnVtSXRlbXM6IG51bWJlciB9O1xuICBuZXh0UGFnZUtleTogUXVlcnlQYWdlS2V5O1xuICBwYWdlS2V5czogUXVlcnlQYWdlS2V5W107IC8vIFRoZXNlIHBhZ2VzIG1ha2UgdXAgdGhlIGFjdGl2ZSBwYWdlIHF1ZXJpZXMuXG4gIC8vIE1hcCBwYWdlIGtleXMgdG8gdGhlaXIgcXVlcnkgc3Vic2NyaXB0aW9uc1xuICBwYWdlS2V5VG9RdWVyeTogTWFwPFxuICAgIFF1ZXJ5UGFnZUtleSxcbiAgICB7IHF1ZXJ5VG9rZW46IFF1ZXJ5VG9rZW47IHVuc3Vic2NyaWJlOiAoKSA9PiB2b2lkIH1cbiAgPjtcbiAgb25nb2luZ1NwbGl0czogTWFwPFF1ZXJ5UGFnZUtleSwgW1F1ZXJ5UGFnZUtleSwgUXVlcnlQYWdlS2V5XT47XG4gIHNraXA6IGJvb2xlYW47XG5cbiAgLy8gR2l2ZSBzZXBhcmF0ZSB1c2VzIG9mIHRoZSBxdWVyeSBzZXBhcmF0ZSBpZGVudGl0aWVzLFxuICAvLyB3aGljaCBtYXkgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlIHRvIGltcHJvdmUgY2FjaGluZy5cbiAgaWQ6IG51bWJlcjtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3Vic2NyaWJlVG9QYWdpbmF0ZWRRdWVyeU9wdGlvbnMge1xuICBpbml0aWFsTnVtSXRlbXM6IG51bWJlcjtcbiAgaWQ6IG51bWJlcjtcbn1cblxudHlwZSBBbnlQYWdpbmF0ZWRRdWVyeVJlc3VsdCA9IFBhZ2luYXRlZFF1ZXJ5UmVzdWx0PFZhbHVlPjtcblxuZXhwb3J0IHR5cGUgUGFnaW5hdGVkUXVlcnlNb2RpZmljYXRpb24gPVxuICB8IHsga2luZDogXCJVcGRhdGVkXCI7IHJlc3VsdDogQW55UGFnaW5hdGVkUXVlcnlSZXN1bHQgfCB1bmRlZmluZWQgfVxuICB8IHsga2luZDogXCJSZW1vdmVkXCIgfTtcblxuZXhwb3J0IHR5cGUgRXh0ZW5kZWRUcmFuc2l0aW9uID0gVHJhbnNpdGlvbiAmIHtcbiAgcGFnaW5hdGVkUXVlcmllczogQXJyYXk8e1xuICAgIHRva2VuOiBQYWdpbmF0ZWRRdWVyeVRva2VuO1xuICAgIG1vZGlmaWNhdGlvbjogUGFnaW5hdGVkUXVlcnlNb2RpZmljYXRpb247XG4gIH0+O1xufTtcblxuZXhwb3J0IGNsYXNzIFBhZ2luYXRlZFF1ZXJ5Q2xpZW50IHtcbiAgcHJpdmF0ZSBwYWdpbmF0ZWRRdWVyeVNldDogTWFwPFBhZ2luYXRlZFF1ZXJ5VG9rZW4sIExvY2FsUGFnaW5hdGVkUXVlcnk+ID1cbiAgICBuZXcgTWFwKCk7XG4gIC8vIGhvbGQgb250byBhIHJlYWwgVHJhbnNpdGlvbiBzbyB3ZSBjYW4gY29uc3RydWN0IHN5bnRoZXRpYyBvbmVzIHdpdGggdGhhdCB0aW1lc3RhbXBcbiAgcHJpdmF0ZSBsYXN0VHJhbnNpdGlvblRzOiBUUztcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGNsaWVudDogQmFzZUNvbnZleENsaWVudCxcbiAgICBwcml2YXRlIG9uVHJhbnNpdGlvbjogKHRyYW5zaXRpb246IEV4dGVuZGVkVHJhbnNpdGlvbikgPT4gdm9pZCxcbiAgKSB7XG4gICAgLy8gTm9uc2Vuc2UgaW5pdGlhbCB2YWx1ZSB0byBjb25zdHJ1Y3Qgc3ludGhldGljIFRyYW5zaXRpb25zXG4gICAgdGhpcy5sYXN0VHJhbnNpdGlvblRzID0gTG9uZy5mcm9tTnVtYmVyKDApO1xuICAgIHRoaXMuY2xpZW50LmFkZE9uVHJhbnNpdGlvbkhhbmRsZXIoKHRyYW5zaXRpb246IFRyYW5zaXRpb24pID0+XG4gICAgICB0aGlzLm9uQmFzZVRyYW5zaXRpb24odHJhbnNpdGlvbiksXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgdG8gYSBwYWdpbmF0ZWQgcXVlcnkuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHBhZ2luYXRlZCBxdWVyeSBmdW5jdGlvblxuICAgKiBAcGFyYW0gYXJncyAtIEFyZ3VtZW50cyBmb3IgdGhlIHF1ZXJ5IChleGNsdWRpbmcgcGFnaW5hdGlvbk9wdHMpXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUGFnaW5hdGlvbiBvcHRpb25zIGluY2x1ZGluZyBpbml0aWFsTnVtSXRlbXNcbiAgICogQHJldHVybnMgT2JqZWN0IHdpdGggcGFnaW5hdGVkUXVlcnlUb2tlbiBhbmQgdW5zdWJzY3JpYmUgZnVuY3Rpb25cbiAgICovXG4gIHN1YnNjcmliZShcbiAgICBuYW1lOiBzdHJpbmcsXG4gICAgYXJnczogUmVjb3JkPHN0cmluZywgVmFsdWU+LFxuICAgIG9wdGlvbnM6IFN1YnNjcmliZVRvUGFnaW5hdGVkUXVlcnlPcHRpb25zLFxuICApOiB7XG4gICAgcGFnaW5hdGVkUXVlcnlUb2tlbjogUGFnaW5hdGVkUXVlcnlUb2tlbjtcbiAgICB1bnN1YnNjcmliZTogKCkgPT4gdm9pZDtcbiAgfSB7XG4gICAgY29uc3QgY2Fub25pY2FsaXplZFVkZlBhdGggPSBjYW5vbmljYWxpemVVZGZQYXRoKG5hbWUpO1xuICAgIC8vIE5vdGUgdGhhdCBvbmx5IHRoZSBleHBlY3RlZCBvcHRpb25zIGFyZSBpbmNsdWRlZCBpbiB0aGUgc2VyaWFsaXphdGlvbi5cbiAgICBjb25zdCB0b2tlbiA9IHNlcmlhbGl6ZVBhZ2luYXRlZFBhdGhBbmRBcmdzKFxuICAgICAgY2Fub25pY2FsaXplZFVkZlBhdGgsXG4gICAgICBhcmdzLFxuICAgICAgb3B0aW9ucyxcbiAgICApO1xuXG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSAoKSA9PiB0aGlzLnJlbW92ZVBhZ2luYXRlZFF1ZXJ5U3Vic2NyaWJlcih0b2tlbik7XG5cbiAgICBjb25zdCBleGlzdGluZ0VudHJ5ID0gdGhpcy5wYWdpbmF0ZWRRdWVyeVNldC5nZXQodG9rZW4pO1xuICAgIGlmIChleGlzdGluZ0VudHJ5KSB7XG4gICAgICBleGlzdGluZ0VudHJ5Lm51bVN1YnNjcmliZXJzICs9IDE7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYWdpbmF0ZWRRdWVyeVRva2VuOiB0b2tlbixcbiAgICAgICAgdW5zdWJzY3JpYmUsXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBuZXcgcGFnaW5hdGVkIHF1ZXJ5XG4gICAgdGhpcy5wYWdpbmF0ZWRRdWVyeVNldC5zZXQodG9rZW4sIHtcbiAgICAgIHRva2VuLFxuICAgICAgY2Fub25pY2FsaXplZFVkZlBhdGgsXG4gICAgICBhcmdzLFxuICAgICAgbnVtU3Vic2NyaWJlcnM6IDEsXG4gICAgICBvcHRpb25zOiB7IGluaXRpYWxOdW1JdGVtczogb3B0aW9ucy5pbml0aWFsTnVtSXRlbXMgfSxcbiAgICAgIG5leHRQYWdlS2V5OiAwLFxuICAgICAgcGFnZUtleXM6IFtdLFxuICAgICAgcGFnZUtleVRvUXVlcnk6IG5ldyBNYXAoKSxcbiAgICAgIG9uZ29pbmdTcGxpdHM6IG5ldyBNYXAoKSxcbiAgICAgIHNraXA6IGZhbHNlLFxuICAgICAgaWQ6IG9wdGlvbnMuaWQsXG4gICAgfSk7XG5cbiAgICB0aGlzLmFkZFBhZ2VUb1BhZ2luYXRlZFF1ZXJ5KHRva2VuLCBudWxsLCBvcHRpb25zLmluaXRpYWxOdW1JdGVtcyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGFnaW5hdGVkUXVlcnlUb2tlbjogdG9rZW4sXG4gICAgICB1bnN1YnNjcmliZSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBjdXJyZW50IHJlc3VsdHMgZm9yIGEgcGFnaW5hdGVkIHF1ZXJ5IGJhc2VkIG9uIGxvY2FsIHN0YXRlLlxuICAgKlxuICAgKiBUaHJvd3MgYW4gZXJyb3Igd2hlbiBvbmUgb2YgdGhlIHBhZ2VzIGhhcyBlcnJvcmVkLlxuICAgKi9cbiAgbG9jYWxRdWVyeVJlc3VsdChcbiAgICBuYW1lOiBzdHJpbmcsXG4gICAgYXJnczogUmVjb3JkPHN0cmluZywgVmFsdWU+LFxuICAgIG9wdGlvbnM6IHsgaW5pdGlhbE51bUl0ZW1zOiBudW1iZXI7IGlkOiBudW1iZXIgfSxcbiAgKTogQW55UGFnaW5hdGVkUXVlcnlSZXN1bHQgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IGNhbm9uaWNhbGl6ZWRVZGZQYXRoID0gY2Fub25pY2FsaXplVWRmUGF0aChuYW1lKTtcbiAgICBjb25zdCB0b2tlbiA9IHNlcmlhbGl6ZVBhZ2luYXRlZFBhdGhBbmRBcmdzKFxuICAgICAgY2Fub25pY2FsaXplZFVkZlBhdGgsXG4gICAgICBhcmdzLFxuICAgICAgb3B0aW9ucyxcbiAgICApO1xuICAgIHJldHVybiB0aGlzLmxvY2FsUXVlcnlSZXN1bHRCeVRva2VuKHRva2VuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGxvY2FsUXVlcnlSZXN1bHRCeVRva2VuKFxuICAgIHRva2VuOiBQYWdpbmF0ZWRRdWVyeVRva2VuLFxuICApOiBBbnlQYWdpbmF0ZWRRdWVyeVJlc3VsdCB8IHVuZGVmaW5lZCB7XG4gICAgLy8gdW5kZWZpbmVkIGlzIHByb2JhYmx5IHRoZSB3cm9uZyB2YWx1ZSEgU2hvdWxkIGJlIGEgcmVhbCBwYWdpbmF0ZWQgcXVlcnkgcmVzdWx0IGZvciBsb2FkaW5nIVxuICAgIC8vIEJ1dGl0J3MgY29uZnVzaW5nIHdoeSB3ZSdkIGV2ZXIgZ2V0IHRoaXMsIEkgZ3Vlc3Mgc29tZSBmbG93cyBjYWxsIGxvY2FsUXVlcnlSZXN1bHQgYmVmb3JlXG4gICAgLy8gc3Vic2NyaWJpbmc/IFRoYXQncyBwcm9hYmJseSBmYWlyIGJ1dCBpcyBpdCBjb25zaXN0ZW50IHdpdGggdGhlIG5vcm1hbCBjbGllbnQ/XG4gICAgLy8gV2hhdCBpcyB0aGUgaW52YXJpYW50IGhlcmUsIHdpbGwgYSB0b2tlbiBhbHdheXMgZXhpc3Q/IE9yIGNhbiBhIGxvb2t1cCBvY2N1ciBhdCBhbnkgdGltZT9cbiAgICBjb25zdCBwYWdpbmF0ZWRRdWVyeSA9IHRoaXMucGFnaW5hdGVkUXVlcnlTZXQuZ2V0KHRva2VuKTtcbiAgICBpZiAoIXBhZ2luYXRlZFF1ZXJ5KSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IGFjdGl2ZVBhZ2VzID0gdGhpcy5hY3RpdmVQYWdlUXVlcnlUb2tlbnMocGFnaW5hdGVkUXVlcnkpO1xuICAgIGlmIChhY3RpdmVQYWdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlc3VsdHM6IFtdLFxuICAgICAgICBzdGF0dXM6IFwiTG9hZGluZ0ZpcnN0UGFnZVwiLFxuICAgICAgICBsb2FkTW9yZTogKG51bUl0ZW1zOiBudW1iZXIpID0+IHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5sb2FkTW9yZU9mUGFnaW5hdGVkUXVlcnkodG9rZW4sIG51bUl0ZW1zKTtcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgbGV0IGFsbFJlc3VsdHM6IFZhbHVlW10gPSBbXTtcblxuICAgIC8vIFNvbWUgcGFnZSBpcyBsb2FkaW5nICh0aGlzIGlzbid0IHN1cHBvc2VkIHRvIGhhcHBlbiB0byBhbnkgcGFnZSBidXQgdGhlIGxhc3QpXG4gICAgbGV0IGhhc1VuZGVmaW5lZCA9IGZhbHNlO1xuICAgIGxldCBpc0RvbmUgPSBmYWxzZTtcblxuICAgIGZvciAoY29uc3QgcGFnZVRva2VuIG9mIGFjdGl2ZVBhZ2VzKSB7XG4gICAgICAvLyBUaGlzIHRocm93cywgZG9uJ3QgY2F0Y2ggaXQsIGl0IHNob3VsZCBidWJibGUgdXAuXG4gICAgICAvLyBJdCBtaWdodCBiZSBhIEludmFsaWRDdXJzb3IgRXJyb3IuIElmIGl0IGlzLCB0aGlzIHF1ZXJ5XG4gICAgICAvLyBzaG91bGQgYmUgcmVzZXQgKGZvciBub3csIHVzZSBhIG5ldyBJRCB0byBlbnN1cmUgbmV3IHN0YXRlKS5cbiAgICAgIC8vXG4gICAgICAvLyBJbiB0aGUgZnV0dXJlIHRoaXMgbWlnaHQgYmUgY2F1Z2h0IGFuZCBkZWFsdCB3aXRoIGhlcmUgYnV0XG4gICAgICAvLyBhbiBJRC1iYXNlZCBzb2x1dGlvbiB3b24ndCB3b3JrIGhlcmUsIElEIGlzIGFuIGludHJpbnNpYyBwcm9wZXJ0eVxuICAgICAgLy8gb2YgdGhpcyBwYWdpbmF0ZWQgcXVlcnkuXG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmNsaWVudC5sb2NhbFF1ZXJ5UmVzdWx0QnlUb2tlbihwYWdlVG9rZW4pO1xuXG4gICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaGFzVW5kZWZpbmVkID0gdHJ1ZTtcbiAgICAgICAgaXNEb25lID0gZmFsc2U7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwYWdpbmF0aW9uUmVzdWx0ID0gYXNQYWdpbmF0aW9uUmVzdWx0KHJlc3VsdCk7XG4gICAgICBhbGxSZXN1bHRzID0gYWxsUmVzdWx0cy5jb25jYXQocGFnaW5hdGlvblJlc3VsdC5wYWdlKTtcbiAgICAgIC8vIGxvZ2ljIG9ubHkgcmVsZXZhbnQgdG8gdGhlIGxhc3QgcGFnZSwgd2UganVzdCBoYXBwZW4gdG8gcnVuIGl0IGVhY2ggdGltZVxuICAgICAgaXNEb25lID0gISFwYWdpbmF0aW9uUmVzdWx0LmlzRG9uZTtcbiAgICB9XG5cbiAgICBsZXQgc3RhdHVzOiBQYWdpbmF0aW9uU3RhdHVzO1xuICAgIGlmIChoYXNVbmRlZmluZWQpIHtcbiAgICAgIHN0YXR1cyA9IGFsbFJlc3VsdHMubGVuZ3RoID09PSAwID8gXCJMb2FkaW5nRmlyc3RQYWdlXCIgOiBcIkxvYWRpbmdNb3JlXCI7XG4gICAgfSBlbHNlIGlmIChpc0RvbmUpIHtcbiAgICAgIHN0YXR1cyA9IFwiRXhoYXVzdGVkXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXR1cyA9IFwiQ2FuTG9hZE1vcmVcIjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcmVzdWx0czogYWxsUmVzdWx0cyxcbiAgICAgIHN0YXR1cyxcbiAgICAgIGxvYWRNb3JlOiAobnVtSXRlbXM6IG51bWJlcikgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2FkTW9yZU9mUGFnaW5hdGVkUXVlcnkodG9rZW4sIG51bUl0ZW1zKTtcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgb25CYXNlVHJhbnNpdGlvbih0cmFuc2l0aW9uOiBUcmFuc2l0aW9uKSB7XG4gICAgY29uc3QgY2hhbmdlZEJhc2VUb2tlbnMgPSB0cmFuc2l0aW9uLnF1ZXJpZXMubWFwKChxKSA9PiBxLnRva2VuKTtcbiAgICBjb25zdCBjaGFuZ2VkID0gdGhpcy5xdWVyaWVzQ29udGFpbmluZ1Rva2VucyhjaGFuZ2VkQmFzZVRva2Vucyk7XG5cbiAgICBsZXQgcGFnaW5hdGVkUXVlcmllczogQXJyYXk8e1xuICAgICAgdG9rZW46IFBhZ2luYXRlZFF1ZXJ5VG9rZW47XG4gICAgICBtb2RpZmljYXRpb246IFBhZ2luYXRlZFF1ZXJ5TW9kaWZpY2F0aW9uO1xuICAgIH0+ID0gW107XG5cbiAgICBpZiAoY2hhbmdlZC5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnByb2Nlc3NQYWdpbmF0ZWRRdWVyeVNwbGl0cyhjaGFuZ2VkLCAodG9rZW4pID0+XG4gICAgICAgIHRoaXMuY2xpZW50LmxvY2FsUXVlcnlSZXN1bHRCeVRva2VuKHRva2VuKSxcbiAgICAgICk7XG5cbiAgICAgIHBhZ2luYXRlZFF1ZXJpZXMgPSBjaGFuZ2VkLm1hcCgodG9rZW4pID0+ICh7XG4gICAgICAgIHRva2VuLFxuICAgICAgICBtb2RpZmljYXRpb246IHtcbiAgICAgICAgICBraW5kOiBcIlVwZGF0ZWRcIiBhcyBjb25zdCxcbiAgICAgICAgICByZXN1bHQ6IHRoaXMubG9jYWxRdWVyeVJlc3VsdEJ5VG9rZW4odG9rZW4pLFxuICAgICAgICB9LFxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIGNvbnN0IGV4dGVuZGVkVHJhbnNpdGlvbjogRXh0ZW5kZWRUcmFuc2l0aW9uID0ge1xuICAgICAgLi4udHJhbnNpdGlvbixcbiAgICAgIHBhZ2luYXRlZFF1ZXJpZXMsXG4gICAgfTtcblxuICAgIHRoaXMub25UcmFuc2l0aW9uKGV4dGVuZGVkVHJhbnNpdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogTG9hZCBtb3JlIGl0ZW1zIGZvciBhIHBhZ2luYXRlZCBxdWVyeS5cbiAgICpcbiAgICogVGhpcyAqYWx3YXlzKiBjYXVzZXMgYSB0cmFuc2l0aW9uLCB0aGUgc3RhdHVzIG9mIHRoZSBxdWVyeVxuICAgKiBoYXMgcHJvYmFibHkgY2hhbmdlZCBmcm9tIFwiQ2FuTG9hZE1vcmVcIiB0byBcIkxvYWRpbmdNb3JlXCIuXG4gICAqIERhdGEgbWlnaHQgaGF2ZSBjaGFuZ2VkIHRvbzogbWF5YmUgYSBzdWJzY3JpcHRpb24gdG8gdGhpcyBwYWdlXG4gICAqIHF1ZXJ5IGFscmVhZHkgZXhpc3RzICh1bmxpa2VseSBidXQgcG9zc2libGUpIG9yIHRoaXMgcGFnZSBxdWVyeVxuICAgKiBoYXMgYW4gb3B0aW1pc3RpYyB1cGRhdGUgcHJvdmlkaW5nIHNvbWUgaW5pdGlhbCBkYXRhLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByaXZhdGUgbG9hZE1vcmVPZlBhZ2luYXRlZFF1ZXJ5KFxuICAgIHRva2VuOiBQYWdpbmF0ZWRRdWVyeVRva2VuLFxuICAgIG51bUl0ZW1zOiBudW1iZXIsXG4gICk6IGJvb2xlYW4ge1xuICAgIHRoaXMubXVzdEdldFBhZ2luYXRlZFF1ZXJ5KHRva2VuKTtcblxuICAgIGNvbnN0IGxhc3RQYWdlVG9rZW4gPSB0aGlzLnF1ZXJ5VG9rZW5Gb3JMYXN0UGFnZU9mUGFnaW5hdGVkUXVlcnkodG9rZW4pO1xuICAgIGNvbnN0IGxhc3RQYWdlUmVzdWx0ID0gdGhpcy5jbGllbnQubG9jYWxRdWVyeVJlc3VsdEJ5VG9rZW4obGFzdFBhZ2VUb2tlbik7XG5cbiAgICBpZiAoIWxhc3RQYWdlUmVzdWx0KSB7XG4gICAgICAvLyBTdGlsbCBsb2FkaW5nIGEgcGFnZSBhbmQgY29uY3VycmVudCBsb2FkcyBhcmUgbm90IGFsbG93ZWRcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBwYWdpbmF0aW9uUmVzdWx0ID0gYXNQYWdpbmF0aW9uUmVzdWx0KGxhc3RQYWdlUmVzdWx0KTtcbiAgICBpZiAocGFnaW5hdGlvblJlc3VsdC5pc0RvbmUpIHtcbiAgICAgIC8vIE5vIG1vcmUgcGFnZXMgYXZhaWxhYmxlXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5hZGRQYWdlVG9QYWdpbmF0ZWRRdWVyeShcbiAgICAgIHRva2VuLFxuICAgICAgcGFnaW5hdGlvblJlc3VsdC5jb250aW51ZUN1cnNvcixcbiAgICAgIG51bUl0ZW1zLFxuICAgICk7XG5cbiAgICBjb25zdCBsb2FkTW9yZVRyYW5zaXRpb246IEV4dGVuZGVkVHJhbnNpdGlvbiA9IHtcbiAgICAgIHRpbWVzdGFtcDogdGhpcy5sYXN0VHJhbnNpdGlvblRzLFxuICAgICAgcmVmbGVjdGVkTXV0YXRpb25zOiBbXSxcbiAgICAgIHF1ZXJpZXM6IFtdLFxuICAgICAgcGFnaW5hdGVkUXVlcmllczogW1xuICAgICAgICB7XG4gICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgbW9kaWZpY2F0aW9uOiB7XG4gICAgICAgICAgICBraW5kOiBcIlVwZGF0ZWRcIiBhcyBjb25zdCxcbiAgICAgICAgICAgIHJlc3VsdDogdGhpcy5sb2NhbFF1ZXJ5UmVzdWx0QnlUb2tlbih0b2tlbiksXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgfTtcbiAgICB0aGlzLm9uVHJhbnNpdGlvbihsb2FkTW9yZVRyYW5zaXRpb24pO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcml2YXRlIHF1ZXJpZXNDb250YWluaW5nVG9rZW5zKFxuICAgIHF1ZXJ5VG9rZW5zOiBRdWVyeVRva2VuW10sXG4gICk6IFBhZ2luYXRlZFF1ZXJ5VG9rZW5bXSB7XG4gICAgaWYgKHF1ZXJ5VG9rZW5zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGNvbnN0IGNoYW5nZWQ6IFBhZ2luYXRlZFF1ZXJ5VG9rZW5bXSA9IFtdO1xuICAgIGNvbnN0IHF1ZXJ5VG9rZW5TZXQgPSBuZXcgU2V0KHF1ZXJ5VG9rZW5zKTtcblxuICAgIGZvciAoY29uc3QgW3BhZ2luYXRlZFRva2VuLCBwYWdpbmF0ZWRRdWVyeV0gb2YgdGhpcy5wYWdpbmF0ZWRRdWVyeVNldCkge1xuICAgICAgZm9yIChjb25zdCBwYWdlVG9rZW4gb2YgdGhpcy5hbGxRdWVyeVRva2VucyhwYWdpbmF0ZWRRdWVyeSkpIHtcbiAgICAgICAgaWYgKHF1ZXJ5VG9rZW5TZXQuaGFzKHBhZ2VUb2tlbikpIHtcbiAgICAgICAgICBjaGFuZ2VkLnB1c2gocGFnaW5hdGVkVG9rZW4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoYW5nZWQ7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcml2YXRlIHByb2Nlc3NQYWdpbmF0ZWRRdWVyeVNwbGl0cyhcbiAgICBjaGFuZ2VkOiBQYWdpbmF0ZWRRdWVyeVRva2VuW10sXG4gICAgZ2V0UmVzdWx0OiAodG9rZW46IFF1ZXJ5VG9rZW4pID0+IFZhbHVlIHwgdW5kZWZpbmVkLFxuICApOiB2b2lkIHtcbiAgICBmb3IgKGNvbnN0IHBhZ2luYXRlZFF1ZXJ5VG9rZW4gb2YgY2hhbmdlZCkge1xuICAgICAgY29uc3QgcGFnaW5hdGVkUXVlcnkgPSB0aGlzLm11c3RHZXRQYWdpbmF0ZWRRdWVyeShwYWdpbmF0ZWRRdWVyeVRva2VuKTtcblxuICAgICAgLy8gVGhlc2UgcHJvcGVydGllcyBhcmUgYWxsIG11dGFibGUsIHRoZSBkZXN0cnVjdHVyZSBoZXJlIGlzIG9wdGlvbmFsLlxuICAgICAgY29uc3QgeyBvbmdvaW5nU3BsaXRzLCBwYWdlS2V5VG9RdWVyeSwgcGFnZUtleXMgfSA9IHBhZ2luYXRlZFF1ZXJ5O1xuXG4gICAgICAvLyBDaGVjayBmb3IgYW55IGNvbXBsZXRlZCBzcGxpdHNcbiAgICAgIGZvciAoY29uc3QgW3BhZ2VLZXksIFtzcGxpdEtleTEsIHNwbGl0S2V5Ml1dIG9mIG9uZ29pbmdTcGxpdHMpIHtcbiAgICAgICAgY29uc3QgYm90aE5ld1BhZ2VzTG9hZGVkID1cbiAgICAgICAgICBnZXRSZXN1bHQocGFnZUtleVRvUXVlcnkuZ2V0KHNwbGl0S2V5MSkhLnF1ZXJ5VG9rZW4pICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICBnZXRSZXN1bHQocGFnZUtleVRvUXVlcnkuZ2V0KHNwbGl0S2V5MikhLnF1ZXJ5VG9rZW4pICE9PSB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKGJvdGhOZXdQYWdlc0xvYWRlZCkge1xuICAgICAgICAgIHRoaXMuY29tcGxldGVQYWdpbmF0ZWRRdWVyeVNwbGl0KFxuICAgICAgICAgICAgcGFnaW5hdGVkUXVlcnksXG4gICAgICAgICAgICBwYWdlS2V5LFxuICAgICAgICAgICAgc3BsaXRLZXkxLFxuICAgICAgICAgICAgc3BsaXRLZXkyLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgZWFjaCBhY3RpdmUgcGFnZSBmb3Igc3BsaXRzIG5lZWRlZFxuICAgICAgZm9yIChjb25zdCBwYWdlS2V5IG9mIHBhZ2VLZXlzKSB7XG4gICAgICAgIGlmIChvbmdvaW5nU3BsaXRzLmhhcyhwYWdlS2V5KSkge1xuICAgICAgICAgIGNvbnRpbnVlOyAvLyBBbHJlYWR5IHNwbGl0dGluZ1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcGFnZVRva2VuID0gcGFnZUtleVRvUXVlcnkuZ2V0KHBhZ2VLZXkpIS5xdWVyeVRva2VuO1xuICAgICAgICBjb25zdCBwYWdlUmVzdWx0ID0gZ2V0UmVzdWx0KHBhZ2VUb2tlbik7XG4gICAgICAgIGlmICghcGFnZVJlc3VsdCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGFzUGFnaW5hdGlvblJlc3VsdChwYWdlUmVzdWx0KTtcblxuICAgICAgICAvLyBDaGVjayBpZiB0aGlzIHBhZ2UgbmVlZHMgc3BsaXR0aW5nXG4gICAgICAgIGNvbnN0IHNob3VsZFNwbGl0ID1cbiAgICAgICAgICByZXN1bHQuc3BsaXRDdXJzb3IgJiZcbiAgICAgICAgICAocmVzdWx0LnBhZ2VTdGF0dXMgPT09IFwiU3BsaXRSZWNvbW1lbmRlZFwiIHx8XG4gICAgICAgICAgICByZXN1bHQucGFnZVN0YXR1cyA9PT0gXCJTcGxpdFJlcXVpcmVkXCIgfHxcbiAgICAgICAgICAgIC8vIFRoaXMgY2xpZW50LWRyaXZlbiBwYWdlIHNwbGl0dGluZyBjb25kaXRpb24gd2lsbCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS5cbiAgICAgICAgICAgIHJlc3VsdC5wYWdlLmxlbmd0aCA+IHBhZ2luYXRlZFF1ZXJ5Lm9wdGlvbnMuaW5pdGlhbE51bUl0ZW1zICogMik7XG5cbiAgICAgICAgaWYgKHNob3VsZFNwbGl0KSB7XG4gICAgICAgICAgdGhpcy5zcGxpdFBhZ2luYXRlZFF1ZXJ5UGFnZShcbiAgICAgICAgICAgIHBhZ2luYXRlZFF1ZXJ5LFxuICAgICAgICAgICAgcGFnZUtleSxcbiAgICAgICAgICAgIHJlc3VsdC5zcGxpdEN1cnNvciEsIC8vIHdlIGp1c3QgY2hlY2tlZFxuICAgICAgICAgICAgcmVzdWx0LmNvbnRpbnVlQ3Vyc29yLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHNwbGl0UGFnaW5hdGVkUXVlcnlQYWdlKFxuICAgIHBhZ2luYXRlZFF1ZXJ5OiBMb2NhbFBhZ2luYXRlZFF1ZXJ5LFxuICAgIHBhZ2VLZXk6IFF1ZXJ5UGFnZUtleSxcbiAgICBzcGxpdEN1cnNvcjogc3RyaW5nLFxuICAgIGNvbnRpbnVlQ3Vyc29yOiBzdHJpbmcgfCBudWxsLFxuICApOiB2b2lkIHtcbiAgICBjb25zdCBzcGxpdEtleTEgPSBwYWdpbmF0ZWRRdWVyeS5uZXh0UGFnZUtleSsrO1xuICAgIGNvbnN0IHNwbGl0S2V5MiA9IHBhZ2luYXRlZFF1ZXJ5Lm5leHRQYWdlS2V5Kys7XG5cbiAgICBjb25zdCBwYWdpbmF0aW9uT3B0czogVmFsdWUgPSB7XG4gICAgICBjdXJzb3I6IGNvbnRpbnVlQ3Vyc29yLFxuICAgICAgbnVtSXRlbXM6IHBhZ2luYXRlZFF1ZXJ5Lm9wdGlvbnMuaW5pdGlhbE51bUl0ZW1zLFxuICAgICAgaWQ6IHBhZ2luYXRlZFF1ZXJ5LmlkLFxuICAgIH07XG5cbiAgICAvLyBGaXJzdCBzcGxpdCBwYWdlOiBzYW1lIGN1cnNvciBhcyBvcmlnaW5hbCwgYnV0IGFkZCBlbmRDdXJzb3IgYXQgc3BsaXRDdXJzb3JcbiAgICBjb25zdCBmaXJzdFN1YnNjcmlwdGlvbiA9IHRoaXMuY2xpZW50LnN1YnNjcmliZShcbiAgICAgIHBhZ2luYXRlZFF1ZXJ5LmNhbm9uaWNhbGl6ZWRVZGZQYXRoLFxuICAgICAge1xuICAgICAgICAuLi5wYWdpbmF0ZWRRdWVyeS5hcmdzLFxuICAgICAgICBwYWdpbmF0aW9uT3B0czoge1xuICAgICAgICAgIC4uLnBhZ2luYXRpb25PcHRzLFxuICAgICAgICAgIGN1cnNvcjogbnVsbCwgLy8gU3RhcnQgZnJvbSBiZWdpbm5pbmcgZm9yIGZpcnN0IHNwbGl0XG4gICAgICAgICAgZW5kQ3Vyc29yOiBzcGxpdEN1cnNvcixcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgKTtcbiAgICBwYWdpbmF0ZWRRdWVyeS5wYWdlS2V5VG9RdWVyeS5zZXQoc3BsaXRLZXkxLCBmaXJzdFN1YnNjcmlwdGlvbik7XG5cbiAgICAvLyBTZWNvbmQgc3BsaXQgcGFnZTogY3Vyc29yIHN0YXJ0cyBhdCBzcGxpdEN1cnNvciwgZW5kQ3Vyc29yIGlzIHRoZSBvcmlnaW5hbCBjb250aW51ZUN1cnNvclxuICAgIGNvbnN0IHNlY29uZFN1YnNjcmlwdGlvbiA9IHRoaXMuY2xpZW50LnN1YnNjcmliZShcbiAgICAgIHBhZ2luYXRlZFF1ZXJ5LmNhbm9uaWNhbGl6ZWRVZGZQYXRoLFxuICAgICAge1xuICAgICAgICAuLi5wYWdpbmF0ZWRRdWVyeS5hcmdzLFxuICAgICAgICBwYWdpbmF0aW9uT3B0czoge1xuICAgICAgICAgIC4uLnBhZ2luYXRpb25PcHRzLFxuICAgICAgICAgIGN1cnNvcjogc3BsaXRDdXJzb3IsXG4gICAgICAgICAgZW5kQ3Vyc29yOiBjb250aW51ZUN1cnNvcixcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgKTtcbiAgICBwYWdpbmF0ZWRRdWVyeS5wYWdlS2V5VG9RdWVyeS5zZXQoc3BsaXRLZXkyLCBzZWNvbmRTdWJzY3JpcHRpb24pO1xuXG4gICAgcGFnaW5hdGVkUXVlcnkub25nb2luZ1NwbGl0cy5zZXQocGFnZUtleSwgW3NwbGl0S2V5MSwgc3BsaXRLZXkyXSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcml2YXRlIGFkZFBhZ2VUb1BhZ2luYXRlZFF1ZXJ5KFxuICAgIHRva2VuOiBQYWdpbmF0ZWRRdWVyeVRva2VuLFxuICAgIGNvbnRpbnVlQ3Vyc29yOiBzdHJpbmcgfCBudWxsLFxuICAgIG51bUl0ZW1zOiBudW1iZXIsXG4gICk6IHsgcXVlcnlUb2tlbjogUXVlcnlUb2tlbjsgdW5zdWJzY3JpYmU6ICgpID0+IHZvaWQgfSB7XG4gICAgY29uc3QgcGFnaW5hdGVkUXVlcnkgPSB0aGlzLm11c3RHZXRQYWdpbmF0ZWRRdWVyeSh0b2tlbik7XG4gICAgY29uc3QgcGFnZUtleSA9IHBhZ2luYXRlZFF1ZXJ5Lm5leHRQYWdlS2V5Kys7XG5cbiAgICBjb25zdCBwYWdpbmF0aW9uT3B0czogVmFsdWUgPSB7XG4gICAgICBjdXJzb3I6IGNvbnRpbnVlQ3Vyc29yLFxuICAgICAgbnVtSXRlbXMsXG4gICAgICBpZDogcGFnaW5hdGVkUXVlcnkuaWQsXG4gICAgfTtcblxuICAgIGNvbnN0IHBhZ2VBcmdzID0ge1xuICAgICAgLi4ucGFnaW5hdGVkUXVlcnkuYXJncyxcbiAgICAgIHBhZ2luYXRpb25PcHRzLFxuICAgIH07XG5cbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSB0aGlzLmNsaWVudC5zdWJzY3JpYmUoXG4gICAgICBwYWdpbmF0ZWRRdWVyeS5jYW5vbmljYWxpemVkVWRmUGF0aCxcbiAgICAgIHBhZ2VBcmdzLFxuICAgICk7XG5cbiAgICBwYWdpbmF0ZWRRdWVyeS5wYWdlS2V5cy5wdXNoKHBhZ2VLZXkpO1xuICAgIHBhZ2luYXRlZFF1ZXJ5LnBhZ2VLZXlUb1F1ZXJ5LnNldChwYWdlS2V5LCBzdWJzY3JpcHRpb24pO1xuICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gIH1cblxuICBwcml2YXRlIHJlbW92ZVBhZ2luYXRlZFF1ZXJ5U3Vic2NyaWJlcih0b2tlbjogUGFnaW5hdGVkUXVlcnlUb2tlbik6IHZvaWQge1xuICAgIGNvbnN0IHBhZ2luYXRlZFF1ZXJ5ID0gdGhpcy5wYWdpbmF0ZWRRdWVyeVNldC5nZXQodG9rZW4pO1xuICAgIGlmICghcGFnaW5hdGVkUXVlcnkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwYWdpbmF0ZWRRdWVyeS5udW1TdWJzY3JpYmVycyAtPSAxO1xuICAgIGlmIChwYWdpbmF0ZWRRdWVyeS5udW1TdWJzY3JpYmVycyA+IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgYWxsIHBhZ2Ugc3Vic2NyaXB0aW9ucyBieSBjYWxsaW5nIHRoZWlyIHVuc3Vic2NyaWJlIGNhbGxiYWNrc1xuICAgIGZvciAoY29uc3Qgc3Vic2NyaXB0aW9uIG9mIHBhZ2luYXRlZFF1ZXJ5LnBhZ2VLZXlUb1F1ZXJ5LnZhbHVlcygpKSB7XG4gICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICB0aGlzLnBhZ2luYXRlZFF1ZXJ5U2V0LmRlbGV0ZSh0b2tlbik7XG4gIH1cblxuICBwcml2YXRlIGNvbXBsZXRlUGFnaW5hdGVkUXVlcnlTcGxpdChcbiAgICBwYWdpbmF0ZWRRdWVyeTogTG9jYWxQYWdpbmF0ZWRRdWVyeSxcbiAgICBwYWdlS2V5OiBRdWVyeVBhZ2VLZXksXG4gICAgc3BsaXRLZXkxOiBRdWVyeVBhZ2VLZXksXG4gICAgc3BsaXRLZXkyOiBRdWVyeVBhZ2VLZXksXG4gICk6IHZvaWQge1xuICAgIGNvbnN0IG9yaWdpbmFsUXVlcnkgPSBwYWdpbmF0ZWRRdWVyeS5wYWdlS2V5VG9RdWVyeS5nZXQocGFnZUtleSkhO1xuICAgIHBhZ2luYXRlZFF1ZXJ5LnBhZ2VLZXlUb1F1ZXJ5LmRlbGV0ZShwYWdlS2V5KTtcbiAgICBjb25zdCBwYWdlSW5kZXggPSBwYWdpbmF0ZWRRdWVyeS5wYWdlS2V5cy5pbmRleE9mKHBhZ2VLZXkpO1xuICAgIHBhZ2luYXRlZFF1ZXJ5LnBhZ2VLZXlzLnNwbGljZShwYWdlSW5kZXgsIDEsIHNwbGl0S2V5MSwgc3BsaXRLZXkyKTtcbiAgICBwYWdpbmF0ZWRRdWVyeS5vbmdvaW5nU3BsaXRzLmRlbGV0ZShwYWdlS2V5KTtcbiAgICBvcmlnaW5hbFF1ZXJ5LnVuc3Vic2NyaWJlKCk7XG4gIH1cblxuICAvKiogVGhlIHF1ZXJ5IHRva2VucyBmb3IgYWxsIGFjdGl2ZSBwYWdlcywgaW4gcmVzdWx0IG9yZGVyICovXG4gIHByaXZhdGUgYWN0aXZlUGFnZVF1ZXJ5VG9rZW5zKFxuICAgIHBhZ2luYXRlZFF1ZXJ5OiBMb2NhbFBhZ2luYXRlZFF1ZXJ5LFxuICApOiBRdWVyeVRva2VuW10ge1xuICAgIHJldHVybiBwYWdpbmF0ZWRRdWVyeS5wYWdlS2V5cy5tYXAoXG4gICAgICAocGFnZUtleSkgPT4gcGFnaW5hdGVkUXVlcnkucGFnZUtleVRvUXVlcnkuZ2V0KHBhZ2VLZXkpIS5xdWVyeVRva2VuLFxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIGFsbFF1ZXJ5VG9rZW5zKHBhZ2luYXRlZFF1ZXJ5OiBMb2NhbFBhZ2luYXRlZFF1ZXJ5KTogUXVlcnlUb2tlbltdIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShwYWdpbmF0ZWRRdWVyeS5wYWdlS2V5VG9RdWVyeS52YWx1ZXMoKSkubWFwKFxuICAgICAgKHN1YikgPT4gc3ViLnF1ZXJ5VG9rZW4sXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgcXVlcnlUb2tlbkZvckxhc3RQYWdlT2ZQYWdpbmF0ZWRRdWVyeShcbiAgICB0b2tlbjogUGFnaW5hdGVkUXVlcnlUb2tlbixcbiAgKTogUXVlcnlUb2tlbiB7XG4gICAgY29uc3QgcGFnaW5hdGVkUXVlcnkgPSB0aGlzLm11c3RHZXRQYWdpbmF0ZWRRdWVyeSh0b2tlbik7XG4gICAgY29uc3QgbGFzdFBhZ2VLZXkgPVxuICAgICAgcGFnaW5hdGVkUXVlcnkucGFnZUtleXNbcGFnaW5hdGVkUXVlcnkucGFnZUtleXMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGxhc3RQYWdlS2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gcGFnZXMgZm9yIHBhZ2luYXRlZCBxdWVyeSAke3Rva2VufWApO1xuICAgIH1cbiAgICByZXR1cm4gcGFnaW5hdGVkUXVlcnkucGFnZUtleVRvUXVlcnkuZ2V0KGxhc3RQYWdlS2V5KSEucXVlcnlUb2tlbjtcbiAgfVxuXG4gIHByaXZhdGUgbXVzdEdldFBhZ2luYXRlZFF1ZXJ5KFxuICAgIHRva2VuOiBQYWdpbmF0ZWRRdWVyeVRva2VuLFxuICApOiBMb2NhbFBhZ2luYXRlZFF1ZXJ5IHtcbiAgICBjb25zdCBwYWdpbmF0ZWRRdWVyeSA9IHRoaXMucGFnaW5hdGVkUXVlcnlTZXQuZ2V0KHRva2VuKTtcbiAgICBpZiAoIXBhZ2luYXRlZFF1ZXJ5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwYWdpbmF0ZWQgcXVlcnkgbm8gbG9uZ2VyIGV4aXN0cyBmb3IgdG9rZW4gXCIgKyB0b2tlbik7XG4gICAgfVxuICAgIHJldHVybiBwYWdpbmF0ZWRRdWVyeTtcbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnQgZnVuY3Rpb24gYXNQYWdpbmF0aW9uQXJncyh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlLnBhZ2luYXRpb25PcHRzLm51bUl0ZW1zICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBOb3QgdmFsaWQgcGFnaW5hdGVkIHF1ZXJ5IGFyZ3M6ICR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfWApO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhc1BhZ2luYXRpb25SZXN1bHQodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PT0gbnVsbCB8fCAhQXJyYXkuaXNBcnJheSh2YWx1ZS5wYWdlKSB8fCB0eXBlb2YgdmFsdWUuaXNEb25lICE9PSBcImJvb2xlYW5cIiB8fCB0eXBlb2YgdmFsdWUuY29udGludWVDdXJzb3IgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCBhIHZhbGlkIHBhZ2luYXRlZCBxdWVyeSByZXN1bHQ6ICR7dmFsdWU/LnRvU3RyaW5nKCl9YCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFnaW5hdGlvbi5qcy5tYXBcbiIsImltcG9ydCB0eXBlIHsgUGFnaW5hdGlvblJlc3VsdCB9IGZyb20gXCIuLi8uLi9zZXJ2ZXIvaW5kZXguanNcIjtcbmltcG9ydCB0eXBlIHsgSW5mZXIsIFZhbHVlIH0gZnJvbSBcIi4uLy4uL3ZhbHVlcy9pbmRleC5qc1wiO1xuaW1wb3J0IHR5cGUgeyBwYWdpbmF0aW9uT3B0c1ZhbGlkYXRvciB9IGZyb20gXCIuLi8uLi9zZXJ2ZXIvaW5kZXguanNcIjtcblxuZXhwb3J0IHR5cGUgUGFnaW5hdGlvblN0YXR1cyA9XG4gIHwgXCJMb2FkaW5nRmlyc3RQYWdlXCJcbiAgfCBcIkNhbkxvYWRNb3JlXCJcbiAgfCBcIkxvYWRpbmdNb3JlXCJcbiAgfCBcIkV4aGF1c3RlZFwiO1xuXG5leHBvcnQgdHlwZSBQYWdpbmF0ZWRRdWVyeVJlc3VsdDxUPiA9IHtcbiAgcmVzdWx0czogVFtdO1xuICBzdGF0dXM6IFBhZ2luYXRpb25TdGF0dXM7XG4gIGxvYWRNb3JlOiBMb2FkTW9yZU9mUGFnaW5hdGVkUXVlcnk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBsb2FkaW5nIG1vcmUgd2FzIGFjdHVhbGx5IGluaXRpYXRlZDsgaW4gY2FzZXMgd2hlcmVcbiAqIGEgcGFnaW5hdGVkIHF1ZXJ5IGlzIGFscmVhZHkgbG9hZGluZyBtb3JlIGl0ZW1zIG9yIHRoZXJlIGFyZSBubyBtb3JlXG4gKiBpdGVtcyBhdmFpbGFibGUsIGNhbGxpbmcgbG9hZE1vcmUoKSBtYXkgZG8gbm90aGluZy5cbiAqL1xuZXhwb3J0IHR5cGUgTG9hZE1vcmVPZlBhZ2luYXRlZFF1ZXJ5ID0gKG51bUl0ZW1zOiBudW1iZXIpID0+IGJvb2xlYW47XG5cbi8vIFRoZSBhcmd1bWVudHMgZm9yIGVhY2ggcGFnZSBxdWVyeS5cbmV4cG9ydCBmdW5jdGlvbiBhc1BhZ2luYXRpb25BcmdzKHZhbHVlOiBWYWx1ZSk6IFJlY29yZDxzdHJpbmcsIFZhbHVlPiAmIHtcbiAgcGFnaW5hdGlvbk9wdHM6IEluZmVyPHR5cGVvZiBwYWdpbmF0aW9uT3B0c1ZhbGlkYXRvcj47XG59IHtcbiAgaWYgKHR5cGVvZiAodmFsdWUgYXMgYW55KS5wYWdpbmF0aW9uT3B0cy5udW1JdGVtcyAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihgTm90IHZhbGlkIHBhZ2luYXRlZCBxdWVyeSBhcmdzOiAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gKTtcbiAgfVxuICByZXR1cm4gdmFsdWUgYXMgdW5rbm93biBhcyBSZWNvcmQ8c3RyaW5nLCBWYWx1ZT4gJiB7XG4gICAgcGFnaW5hdGlvbk9wdHM6IEluZmVyPHR5cGVvZiBwYWdpbmF0aW9uT3B0c1ZhbGlkYXRvcj47XG4gIH07XG59XG5cbi8qKlxuICogVmFsaWRhdGVzIHRoYXQgYSBWYWx1ZSBpcyBhIHZhbGlkIHBhZ2luYXRpb24gcmVzdWx0IGFuZCByZXR1cm5zIGl0IGNhc3QgdG8gUGFnaW5hdGlvblJlc3VsdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzUGFnaW5hdGlvblJlc3VsdCh2YWx1ZTogVmFsdWUpOiBQYWdpbmF0aW9uUmVzdWx0PFZhbHVlPiB7XG4gIGlmIChcbiAgICB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHxcbiAgICB2YWx1ZSA9PT0gbnVsbCB8fFxuICAgICFBcnJheS5pc0FycmF5KCh2YWx1ZSBhcyBhbnkpLnBhZ2UpIHx8XG4gICAgdHlwZW9mICh2YWx1ZSBhcyBhbnkpLmlzRG9uZSAhPT0gXCJib29sZWFuXCIgfHxcbiAgICB0eXBlb2YgKHZhbHVlIGFzIGFueSkuY29udGludWVDdXJzb3IgIT09IFwic3RyaW5nXCJcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBOb3QgYSB2YWxpZCBwYWdpbmF0ZWQgcXVlcnkgcmVzdWx0OiAke3ZhbHVlPy50b1N0cmluZygpfWApO1xuICB9XG4gIHJldHVybiB2YWx1ZSBhcyB1bmtub3duIGFzIFBhZ2luYXRpb25SZXN1bHQ8VmFsdWU+O1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuaW1wb3J0IHtcbiAgZ2V0RnVuY3Rpb25OYW1lXG59IGZyb20gXCIuLi9zZXJ2ZXIvYXBpLmpzXCI7XG5pbXBvcnQgeyBwYXJzZUFyZ3MsIHZhbGlkYXRlRGVwbG95bWVudFVybCB9IGZyb20gXCIuLi9jb21tb24vaW5kZXguanNcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi4vaW5kZXguanNcIjtcbmltcG9ydCB7XG4gIENvbnZleEVycm9yLFxuICBjb252ZXhUb0pzb24sXG4gIGpzb25Ub0NvbnZleFxufSBmcm9tIFwiLi4vdmFsdWVzL2luZGV4LmpzXCI7XG5pbXBvcnQge1xuICBpbnN0YW50aWF0ZURlZmF1bHRMb2dnZXIsXG4gIGluc3RhbnRpYXRlTm9vcExvZ2dlcixcbiAgbG9nRm9yRnVuY3Rpb25cbn0gZnJvbSBcIi4vbG9nZ2luZy5qc1wiO1xuZXhwb3J0IGNvbnN0IFNUQVRVU19DT0RFX09LID0gMjAwO1xuZXhwb3J0IGNvbnN0IFNUQVRVU19DT0RFX0JBRF9SRVFVRVNUID0gNDAwO1xuZXhwb3J0IGNvbnN0IFNUQVRVU19DT0RFX1VERl9GQUlMRUQgPSA1NjA7XG5sZXQgc3BlY2lmaWVkRmV0Y2ggPSB2b2lkIDA7XG5leHBvcnQgZnVuY3Rpb24gc2V0RmV0Y2goZikge1xuICBzcGVjaWZpZWRGZXRjaCA9IGY7XG59XG5leHBvcnQgY2xhc3MgQ29udmV4SHR0cENsaWVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcge0BsaW5rIENvbnZleEh0dHBDbGllbnR9LlxuICAgKlxuICAgKiBAcGFyYW0gYWRkcmVzcyAtIFRoZSB1cmwgb2YgeW91ciBDb252ZXggZGVwbG95bWVudCwgb2Z0ZW4gcHJvdmlkZWRcbiAgICogYnkgYW4gZW52aXJvbm1lbnQgdmFyaWFibGUuIEUuZy4gYGh0dHBzOi8vc21hbGwtbW91c2UtMTIzLmNvbnZleC5jbG91ZGAuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb2JqZWN0IG9mIG9wdGlvbnMuXG4gICAqIC0gYHNraXBDb252ZXhEZXBsb3ltZW50VXJsQ2hlY2tgIC0gU2tpcCB2YWxpZGF0aW5nIHRoYXQgdGhlIENvbnZleCBkZXBsb3ltZW50IFVSTCBsb29rcyBsaWtlXG4gICAqIGBodHRwczovL2hhcHB5LWFuaW1hbC0xMjMuY29udmV4LmNsb3VkYCBvciBsb2NhbGhvc3QuIFRoaXMgY2FuIGJlIHVzZWZ1bCBpZiBydW5uaW5nIGEgc2VsZi1ob3N0ZWRcbiAgICogQ29udmV4IGJhY2tlbmQgdGhhdCB1c2VzIGEgZGlmZmVyZW50IFVSTC5cbiAgICogLSBgbG9nZ2VyYCAtIEEgbG9nZ2VyIG9yIGEgYm9vbGVhbi4gSWYgbm90IHByb3ZpZGVkLCBsb2dzIHRvIHRoZSBjb25zb2xlLlxuICAgKiBZb3UgY2FuIGNvbnN0cnVjdCB5b3VyIG93biBsb2dnZXIgdG8gY3VzdG9taXplIGxvZ2dpbmcgdG8gbG9nIGVsc2V3aGVyZVxuICAgKiBvciBub3QgbG9nIGF0IGFsbCwgb3IgdXNlIGBmYWxzZWAgYXMgYSBzaG9ydGhhbmQgZm9yIGEgbm8tb3AgbG9nZ2VyLlxuICAgKiBBIGxvZ2dlciBpcyBhbiBvYmplY3Qgd2l0aCA0IG1ldGhvZHM6IGxvZygpLCB3YXJuKCksIGVycm9yKCksIGFuZCBsb2dWZXJib3NlKCkuXG4gICAqIFRoZXNlIG1ldGhvZHMgY2FuIHJlY2VpdmUgbXVsdGlwbGUgYXJndW1lbnRzIG9mIGFueSB0eXBlcywgbGlrZSBjb25zb2xlLmxvZygpLlxuICAgKiAtIGBhdXRoYCAtIEEgSldUIGNvbnRhaW5pbmcgaWRlbnRpdHkgY2xhaW1zIGFjY2Vzc2libGUgaW4gQ29udmV4IGZ1bmN0aW9ucy5cbiAgICogVGhpcyBpZGVudGl0eSBtYXkgZXhwaXJlIHNvIGl0IG1heSBiZSBuZWNlc3NhcnkgdG8gY2FsbCBgc2V0QXV0aCgpYCBsYXRlcixcbiAgICogYnV0IGZvciBzaG9ydC1saXZlZCBjbGllbnRzIGl0J3MgY29udmVuaWVudCB0byBzcGVjaWZ5IHRoaXMgdmFsdWUgaGVyZS5cbiAgICogLSBgZmV0Y2hgIC0gQSBjdXN0b20gZmV0Y2ggaW1wbGVtZW50YXRpb24gdG8gdXNlIGZvciBhbGwgSFRUUCByZXF1ZXN0cyBtYWRlIGJ5IHRoaXMgY2xpZW50LlxuICAgKi9cbiAgY29uc3RydWN0b3IoYWRkcmVzcywgb3B0aW9ucykge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJhZGRyZXNzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJhdXRoXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJhZG1pbkF1dGhcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImVuY29kZWRUc1Byb21pc2VcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImRlYnVnXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJmZXRjaE9wdGlvbnNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImZldGNoXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJsb2dnZXJcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm11dGF0aW9uUXVldWVcIiwgW10pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJpc1Byb2Nlc3NpbmdRdWV1ZVwiLCBmYWxzZSk7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcImJvb2xlYW5cIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcInNraXBDb252ZXhEZXBsb3ltZW50VXJsQ2hlY2sgYXMgdGhlIHNlY29uZCBhcmd1bWVudCBpcyBubyBsb25nZXIgc3VwcG9ydGVkLiBQbGVhc2UgcGFzcyBhbiBvcHRpb25zIG9iamVjdCwgYHsgc2tpcENvbnZleERlcGxveW1lbnRVcmxDaGVjazogdHJ1ZSB9YC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3Qgb3B0cyA9IG9wdGlvbnMgPz8ge307XG4gICAgaWYgKG9wdHMuc2tpcENvbnZleERlcGxveW1lbnRVcmxDaGVjayAhPT0gdHJ1ZSkge1xuICAgICAgdmFsaWRhdGVEZXBsb3ltZW50VXJsKGFkZHJlc3MpO1xuICAgIH1cbiAgICB0aGlzLmxvZ2dlciA9IG9wdGlvbnM/LmxvZ2dlciA9PT0gZmFsc2UgPyBpbnN0YW50aWF0ZU5vb3BMb2dnZXIoeyB2ZXJib3NlOiBmYWxzZSB9KSA6IG9wdGlvbnM/LmxvZ2dlciAhPT0gdHJ1ZSAmJiBvcHRpb25zPy5sb2dnZXIgPyBvcHRpb25zLmxvZ2dlciA6IGluc3RhbnRpYXRlRGVmYXVsdExvZ2dlcih7IHZlcmJvc2U6IGZhbHNlIH0pO1xuICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgdGhpcy5kZWJ1ZyA9IHRydWU7XG4gICAgdGhpcy5hdXRoID0gdm9pZCAwO1xuICAgIHRoaXMuYWRtaW5BdXRoID0gdm9pZCAwO1xuICAgIHRoaXMuZmV0Y2ggPSBvcHRpb25zPy5mZXRjaDtcbiAgICBpZiAob3B0aW9ucz8uYXV0aCkge1xuICAgICAgdGhpcy5zZXRBdXRoKG9wdGlvbnMuYXV0aCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBPYnRhaW4gdGhlIHtAbGluayBDb252ZXhIdHRwQ2xpZW50fSdzIFVSTCB0byBpdHMgYmFja2VuZC5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHVybCwgd2hpY2ggcmV0dXJucyB0aGUgdXJsIHdpdGhvdXQgL2FwaSBhdCB0aGUgZW5kLlxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgVVJMIHRvIHRoZSBDb252ZXggYmFja2VuZCwgaW5jbHVkaW5nIHRoZSBjbGllbnQncyBBUEkgdmVyc2lvbi5cbiAgICovXG4gIGJhY2tlbmRVcmwoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuYWRkcmVzc30vYXBpYDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHRoZSBhZGRyZXNzIGZvciB0aGlzIGNsaWVudCwgdXNlZnVsIGZvciBjcmVhdGluZyBhIG5ldyBjbGllbnQuXG4gICAqXG4gICAqIE5vdCBndWFyYW50ZWVkIHRvIG1hdGNoIHRoZSBhZGRyZXNzIHdpdGggd2hpY2ggdGhpcyBjbGllbnQgd2FzIGNvbnN0cnVjdGVkOlxuICAgKiBpdCBtYXkgYmUgY2Fub25pY2FsaXplZC5cbiAgICovXG4gIGdldCB1cmwoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkcmVzcztcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSBhdXRoZW50aWNhdGlvbiB0b2tlbiB0byBiZSB1c2VkIGZvciBzdWJzZXF1ZW50IHF1ZXJpZXMgYW5kIG11dGF0aW9ucy5cbiAgICpcbiAgICogU2hvdWxkIGJlIGNhbGxlZCB3aGVuZXZlciB0aGUgdG9rZW4gY2hhbmdlcyAoaS5lLiBkdWUgdG8gZXhwaXJhdGlvbiBhbmQgcmVmcmVzaCkuXG4gICAqXG4gICAqIEBwYXJhbSB2YWx1ZSAtIEpXVC1lbmNvZGVkIE9wZW5JRCBDb25uZWN0IGlkZW50aXR5IHRva2VuLlxuICAgKi9cbiAgc2V0QXV0aCh2YWx1ZSkge1xuICAgIHRoaXMuY2xlYXJBdXRoKCk7XG4gICAgdGhpcy5hdXRoID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBhZG1pbiBhdXRoIHRva2VuIHRvIGFsbG93IGNhbGxpbmcgaW50ZXJuYWwgcXVlcmllcywgbXV0YXRpb25zLCBhbmQgYWN0aW9uc1xuICAgKiBhbmQgYWN0aW5nIGFzIGFuIGlkZW50aXR5LlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHNldEFkbWluQXV0aCh0b2tlbiwgYWN0aW5nQXNJZGVudGl0eSkge1xuICAgIHRoaXMuY2xlYXJBdXRoKCk7XG4gICAgaWYgKGFjdGluZ0FzSWRlbnRpdHkgIT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoSlNPTi5zdHJpbmdpZnkoYWN0aW5nQXNJZGVudGl0eSkpO1xuICAgICAgY29uc3QgYWN0aW5nQXNJZGVudGl0eUVuY29kZWQgPSBidG9hKFN0cmluZy5mcm9tQ29kZVBvaW50KC4uLmJ5dGVzKSk7XG4gICAgICB0aGlzLmFkbWluQXV0aCA9IGAke3Rva2VufToke2FjdGluZ0FzSWRlbnRpdHlFbmNvZGVkfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRtaW5BdXRoID0gdG9rZW47XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDbGVhciB0aGUgY3VycmVudCBhdXRoZW50aWNhdGlvbiB0b2tlbiBpZiBzZXQuXG4gICAqL1xuICBjbGVhckF1dGgoKSB7XG4gICAgdGhpcy5hdXRoID0gdm9pZCAwO1xuICAgIHRoaXMuYWRtaW5BdXRoID0gdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHdoZXRoZXIgdGhlIHJlc3VsdCBsb2cgbGluZXMgc2hvdWxkIGJlIHByaW50ZWQgb24gdGhlIGNvbnNvbGUgb3Igbm90LlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHNldERlYnVnKGRlYnVnKSB7XG4gICAgdGhpcy5kZWJ1ZyA9IGRlYnVnO1xuICB9XG4gIC8qKlxuICAgKiBVc2VkIHRvIGN1c3RvbWl6ZSB0aGUgZmV0Y2ggYmVoYXZpb3IgaW4gc29tZSBydW50aW1lcy5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzZXRGZXRjaE9wdGlvbnMoZmV0Y2hPcHRpb25zKSB7XG4gICAgdGhpcy5mZXRjaE9wdGlvbnMgPSBmZXRjaE9wdGlvbnM7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbDogaXQgbWF5IGNoYW5nZSBvciBkaXNhcHBlYXIuXG4gICAqXG4gICAqIEV4ZWN1dGUgYSBDb252ZXggcXVlcnkgZnVuY3Rpb24gYXQgdGhlIHNhbWUgdGltZXN0YW1wIGFzIGV2ZXJ5IG90aGVyXG4gICAqIGNvbnNpc3RlbnQgcXVlcnkgZXhlY3V0aW9uIHJ1biBieSB0aGlzIEhUVFAgY2xpZW50LlxuICAgKlxuICAgKiBUaGlzIGRvZXNuJ3QgbWFrZSBzZW5zZSBmb3IgbG9uZy1saXZlZCBDb252ZXhIdHRwQ2xpZW50cyBhcyBDb252ZXhcbiAgICogYmFja2VuZHMgY2FuIHJlYWQgYSBsaW1pdGVkIGFtb3VudCBpbnRvIHRoZSBwYXN0OiBiZXlvbmQgMzAgc2Vjb25kc1xuICAgKiBpbiB0aGUgcGFzdCBtYXkgbm90IGJlIGF2YWlsYWJsZS5cbiAgICpcbiAgICogQ3JlYXRlIGEgbmV3IGNsaWVudCB0byB1c2UgYSBjb25zaXN0ZW50IHRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHF1ZXJ5LlxuICAgKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgb2JqZWN0IGZvciB0aGUgcXVlcnkuIElmIHRoaXMgaXMgb21pdHRlZCxcbiAgICogdGhlIGFyZ3VtZW50cyB3aWxsIGJlIGB7fWAuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSBvZiB0aGUgcXVlcnkncyByZXN1bHQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbDogaXQgbWF5IGNoYW5nZSBvciBkaXNhcHBlYXIuXG4gICAqL1xuICBhc3luYyBjb25zaXN0ZW50UXVlcnkocXVlcnksIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBxdWVyeUFyZ3MgPSBwYXJzZUFyZ3MoYXJnc1swXSk7XG4gICAgY29uc3QgdGltZXN0YW1wUHJvbWlzZSA9IHRoaXMuZ2V0VGltZXN0YW1wKCk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucXVlcnlJbm5lcihxdWVyeSwgcXVlcnlBcmdzLCB7IHRpbWVzdGFtcFByb21pc2UgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0VGltZXN0YW1wKCkge1xuICAgIGlmICh0aGlzLmVuY29kZWRUc1Byb21pc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuY29kZWRUc1Byb21pc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVuY29kZWRUc1Byb21pc2UgPSB0aGlzLmdldFRpbWVzdGFtcElubmVyKCk7XG4gIH1cbiAgYXN5bmMgZ2V0VGltZXN0YW1wSW5uZXIoKSB7XG4gICAgY29uc3QgbG9jYWxGZXRjaCA9IHRoaXMuZmV0Y2ggfHwgc3BlY2lmaWVkRmV0Y2ggfHwgZmV0Y2g7XG4gICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgXCJDb252ZXgtQ2xpZW50XCI6IGBucG0tJHt2ZXJzaW9ufWBcbiAgICB9O1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbG9jYWxGZXRjaChgJHt0aGlzLmFkZHJlc3N9L2FwaS9xdWVyeV90c2AsIHtcbiAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnNcbiAgICB9KTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYXdhaXQgcmVzcG9uc2UudGV4dCgpKTtcbiAgICB9XG4gICAgY29uc3QgeyB0cyB9ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIHJldHVybiB0cztcbiAgfVxuICAvKipcbiAgICogRXhlY3V0ZSBhIENvbnZleCBxdWVyeSBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcXVlcnkuXG4gICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyBvYmplY3QgZm9yIHRoZSBxdWVyeS4gSWYgdGhpcyBpcyBvbWl0dGVkLFxuICAgKiB0aGUgYXJndW1lbnRzIHdpbGwgYmUgYHt9YC5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIG9mIHRoZSBxdWVyeSdzIHJlc3VsdC5cbiAgICovXG4gIGFzeW5jIHF1ZXJ5KHF1ZXJ5LCAuLi5hcmdzKSB7XG4gICAgY29uc3QgcXVlcnlBcmdzID0gcGFyc2VBcmdzKGFyZ3NbMF0pO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnF1ZXJ5SW5uZXIocXVlcnksIHF1ZXJ5QXJncywge30pO1xuICB9XG4gIGFzeW5jIHF1ZXJ5SW5uZXIocXVlcnksIHF1ZXJ5QXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IG5hbWUgPSBnZXRGdW5jdGlvbk5hbWUocXVlcnkpO1xuICAgIGNvbnN0IGFyZ3MgPSBbY29udmV4VG9Kc29uKHF1ZXJ5QXJncyldO1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIFwiQ29udmV4LUNsaWVudFwiOiBgbnBtLSR7dmVyc2lvbn1gXG4gICAgfTtcbiAgICBpZiAodGhpcy5hZG1pbkF1dGgpIHtcbiAgICAgIGhlYWRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gYENvbnZleCAke3RoaXMuYWRtaW5BdXRofWA7XG4gICAgfSBlbHNlIGlmICh0aGlzLmF1dGgpIHtcbiAgICAgIGhlYWRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gYEJlYXJlciAke3RoaXMuYXV0aH1gO1xuICAgIH1cbiAgICBjb25zdCBsb2NhbEZldGNoID0gdGhpcy5mZXRjaCB8fCBzcGVjaWZpZWRGZXRjaCB8fCBmZXRjaDtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBvcHRpb25zLnRpbWVzdGFtcFByb21pc2UgPyBhd2FpdCBvcHRpb25zLnRpbWVzdGFtcFByb21pc2UgOiB2b2lkIDA7XG4gICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIHBhdGg6IG5hbWUsXG4gICAgICBmb3JtYXQ6IFwiY29udmV4X2VuY29kZWRfanNvblwiLFxuICAgICAgYXJncyxcbiAgICAgIC4uLnRpbWVzdGFtcCA/IHsgdHM6IHRpbWVzdGFtcCB9IDoge31cbiAgICB9KTtcbiAgICBjb25zdCBlbmRwb2ludCA9IHRpbWVzdGFtcCA/IGAke3RoaXMuYWRkcmVzc30vYXBpL3F1ZXJ5X2F0X3RzYCA6IGAke3RoaXMuYWRkcmVzc30vYXBpL3F1ZXJ5YDtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGxvY2FsRmV0Y2goZW5kcG9pbnQsIHtcbiAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgYm9keSxcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzXG4gICAgfSk7XG4gICAgaWYgKCFyZXNwb25zZS5vayAmJiByZXNwb25zZS5zdGF0dXMgIT09IFNUQVRVU19DT0RFX1VERl9GQUlMRUQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihhd2FpdCByZXNwb25zZS50ZXh0KCkpO1xuICAgIH1cbiAgICBjb25zdCByZXNwSlNPTiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgZm9yIChjb25zdCBsaW5lIG9mIHJlc3BKU09OLmxvZ0xpbmVzID8/IFtdKSB7XG4gICAgICAgIGxvZ0ZvckZ1bmN0aW9uKHRoaXMubG9nZ2VyLCBcImluZm9cIiwgXCJxdWVyeVwiLCBuYW1lLCBsaW5lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoIChyZXNwSlNPTi5zdGF0dXMpIHtcbiAgICAgIGNhc2UgXCJzdWNjZXNzXCI6XG4gICAgICAgIHJldHVybiBqc29uVG9Db252ZXgocmVzcEpTT04udmFsdWUpO1xuICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgIGlmIChyZXNwSlNPTi5lcnJvckRhdGEgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHRocm93IGZvcndhcmRFcnJvckRhdGEoXG4gICAgICAgICAgICByZXNwSlNPTi5lcnJvckRhdGEsXG4gICAgICAgICAgICBuZXcgQ29udmV4RXJyb3IocmVzcEpTT04uZXJyb3JNZXNzYWdlKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BKU09OLmVycm9yTWVzc2FnZSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcmVzcG9uc2U6ICR7SlNPTi5zdHJpbmdpZnkocmVzcEpTT04pfWApO1xuICAgIH1cbiAgfVxuICBhc3luYyBtdXRhdGlvbklubmVyKG11dGF0aW9uLCBtdXRhdGlvbkFyZ3MpIHtcbiAgICBjb25zdCBuYW1lID0gZ2V0RnVuY3Rpb25OYW1lKG11dGF0aW9uKTtcbiAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgcGF0aDogbmFtZSxcbiAgICAgIGZvcm1hdDogXCJjb252ZXhfZW5jb2RlZF9qc29uXCIsXG4gICAgICBhcmdzOiBbY29udmV4VG9Kc29uKG11dGF0aW9uQXJncyldXG4gICAgfSk7XG4gICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgXCJDb252ZXgtQ2xpZW50XCI6IGBucG0tJHt2ZXJzaW9ufWBcbiAgICB9O1xuICAgIGlmICh0aGlzLmFkbWluQXV0aCkge1xuICAgICAgaGVhZGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSBgQ29udmV4ICR7dGhpcy5hZG1pbkF1dGh9YDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYXV0aCkge1xuICAgICAgaGVhZGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSBgQmVhcmVyICR7dGhpcy5hdXRofWA7XG4gICAgfVxuICAgIGNvbnN0IGxvY2FsRmV0Y2ggPSB0aGlzLmZldGNoIHx8IHNwZWNpZmllZEZldGNoIHx8IGZldGNoO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbG9jYWxGZXRjaChgJHt0aGlzLmFkZHJlc3N9L2FwaS9tdXRhdGlvbmAsIHtcbiAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgYm9keSxcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzXG4gICAgfSk7XG4gICAgaWYgKCFyZXNwb25zZS5vayAmJiByZXNwb25zZS5zdGF0dXMgIT09IFNUQVRVU19DT0RFX1VERl9GQUlMRUQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihhd2FpdCByZXNwb25zZS50ZXh0KCkpO1xuICAgIH1cbiAgICBjb25zdCByZXNwSlNPTiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgZm9yIChjb25zdCBsaW5lIG9mIHJlc3BKU09OLmxvZ0xpbmVzID8/IFtdKSB7XG4gICAgICAgIGxvZ0ZvckZ1bmN0aW9uKHRoaXMubG9nZ2VyLCBcImluZm9cIiwgXCJtdXRhdGlvblwiLCBuYW1lLCBsaW5lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoIChyZXNwSlNPTi5zdGF0dXMpIHtcbiAgICAgIGNhc2UgXCJzdWNjZXNzXCI6XG4gICAgICAgIHJldHVybiBqc29uVG9Db252ZXgocmVzcEpTT04udmFsdWUpO1xuICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgIGlmIChyZXNwSlNPTi5lcnJvckRhdGEgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHRocm93IGZvcndhcmRFcnJvckRhdGEoXG4gICAgICAgICAgICByZXNwSlNPTi5lcnJvckRhdGEsXG4gICAgICAgICAgICBuZXcgQ29udmV4RXJyb3IocmVzcEpTT04uZXJyb3JNZXNzYWdlKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BKU09OLmVycm9yTWVzc2FnZSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcmVzcG9uc2U6ICR7SlNPTi5zdHJpbmdpZnkocmVzcEpTT04pfWApO1xuICAgIH1cbiAgfVxuICBhc3luYyBwcm9jZXNzTXV0YXRpb25RdWV1ZSgpIHtcbiAgICBpZiAodGhpcy5pc1Byb2Nlc3NpbmdRdWV1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmlzUHJvY2Vzc2luZ1F1ZXVlID0gdHJ1ZTtcbiAgICB3aGlsZSAodGhpcy5tdXRhdGlvblF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHsgbXV0YXRpb24sIGFyZ3MsIHJlc29sdmUsIHJlamVjdCB9ID0gdGhpcy5tdXRhdGlvblF1ZXVlLnNoaWZ0KCk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLm11dGF0aW9uSW5uZXIobXV0YXRpb24sIGFyZ3MpO1xuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmlzUHJvY2Vzc2luZ1F1ZXVlID0gZmFsc2U7XG4gIH1cbiAgZW5xdWV1ZU11dGF0aW9uKG11dGF0aW9uLCBhcmdzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMubXV0YXRpb25RdWV1ZS5wdXNoKHsgbXV0YXRpb24sIGFyZ3MsIHJlc29sdmUsIHJlamVjdCB9KTtcbiAgICAgIHZvaWQgdGhpcy5wcm9jZXNzTXV0YXRpb25RdWV1ZSgpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBFeGVjdXRlIGEgQ29udmV4IG11dGF0aW9uIGZ1bmN0aW9uLiBNdXRhdGlvbnMgYXJlIHF1ZXVlZCBieSBkZWZhdWx0LlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBtdXRhdGlvbi5cbiAgICogQHBhcmFtIGFyZ3MgLSBUaGUgYXJndW1lbnRzIG9iamVjdCBmb3IgdGhlIG11dGF0aW9uLiBJZiB0aGlzIGlzIG9taXR0ZWQsXG4gICAqIHRoZSBhcmd1bWVudHMgd2lsbCBiZSBge31gLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbmFsIG9iamVjdCBjb250YWluaW5nXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSBvZiB0aGUgbXV0YXRpb24ncyByZXN1bHQuXG4gICAqL1xuICBhc3luYyBtdXRhdGlvbihtdXRhdGlvbiwgLi4uYXJncykge1xuICAgIGNvbnN0IFtmbkFyZ3MsIG9wdGlvbnNdID0gYXJncztcbiAgICBjb25zdCBtdXRhdGlvbkFyZ3MgPSBwYXJzZUFyZ3MoZm5BcmdzKTtcbiAgICBjb25zdCBxdWV1ZWQgPSAhb3B0aW9ucz8uc2tpcFF1ZXVlO1xuICAgIGlmIChxdWV1ZWQpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmVucXVldWVNdXRhdGlvbihtdXRhdGlvbiwgbXV0YXRpb25BcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubXV0YXRpb25Jbm5lcihtdXRhdGlvbiwgbXV0YXRpb25BcmdzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYSBDb252ZXggYWN0aW9uIGZ1bmN0aW9uLiBBY3Rpb25zIGFyZSBub3QgcXVldWVkLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBhY3Rpb24uXG4gICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyBvYmplY3QgZm9yIHRoZSBhY3Rpb24uIElmIHRoaXMgaXMgb21pdHRlZCxcbiAgICogdGhlIGFyZ3VtZW50cyB3aWxsIGJlIGB7fWAuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSBvZiB0aGUgYWN0aW9uJ3MgcmVzdWx0LlxuICAgKi9cbiAgYXN5bmMgYWN0aW9uKGFjdGlvbiwgLi4uYXJncykge1xuICAgIGNvbnN0IGFjdGlvbkFyZ3MgPSBwYXJzZUFyZ3MoYXJnc1swXSk7XG4gICAgY29uc3QgbmFtZSA9IGdldEZ1bmN0aW9uTmFtZShhY3Rpb24pO1xuICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBwYXRoOiBuYW1lLFxuICAgICAgZm9ybWF0OiBcImNvbnZleF9lbmNvZGVkX2pzb25cIixcbiAgICAgIGFyZ3M6IFtjb252ZXhUb0pzb24oYWN0aW9uQXJncyldXG4gICAgfSk7XG4gICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgXCJDb252ZXgtQ2xpZW50XCI6IGBucG0tJHt2ZXJzaW9ufWBcbiAgICB9O1xuICAgIGlmICh0aGlzLmFkbWluQXV0aCkge1xuICAgICAgaGVhZGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSBgQ29udmV4ICR7dGhpcy5hZG1pbkF1dGh9YDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYXV0aCkge1xuICAgICAgaGVhZGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSBgQmVhcmVyICR7dGhpcy5hdXRofWA7XG4gICAgfVxuICAgIGNvbnN0IGxvY2FsRmV0Y2ggPSB0aGlzLmZldGNoIHx8IHNwZWNpZmllZEZldGNoIHx8IGZldGNoO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbG9jYWxGZXRjaChgJHt0aGlzLmFkZHJlc3N9L2FwaS9hY3Rpb25gLCB7XG4gICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgIGJvZHksXG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyc1xuICAgIH0pO1xuICAgIGlmICghcmVzcG9uc2Uub2sgJiYgcmVzcG9uc2Uuc3RhdHVzICE9PSBTVEFUVVNfQ09ERV9VREZfRkFJTEVEKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYXdhaXQgcmVzcG9uc2UudGV4dCgpKTtcbiAgICB9XG4gICAgY29uc3QgcmVzcEpTT04gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgIGZvciAoY29uc3QgbGluZSBvZiByZXNwSlNPTi5sb2dMaW5lcyA/PyBbXSkge1xuICAgICAgICBsb2dGb3JGdW5jdGlvbih0aGlzLmxvZ2dlciwgXCJpbmZvXCIsIFwiYWN0aW9uXCIsIG5hbWUsIGxpbmUpO1xuICAgICAgfVxuICAgIH1cbiAgICBzd2l0Y2ggKHJlc3BKU09OLnN0YXR1cykge1xuICAgICAgY2FzZSBcInN1Y2Nlc3NcIjpcbiAgICAgICAgcmV0dXJuIGpzb25Ub0NvbnZleChyZXNwSlNPTi52YWx1ZSk7XG4gICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgaWYgKHJlc3BKU09OLmVycm9yRGF0YSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgdGhyb3cgZm9yd2FyZEVycm9yRGF0YShcbiAgICAgICAgICAgIHJlc3BKU09OLmVycm9yRGF0YSxcbiAgICAgICAgICAgIG5ldyBDb252ZXhFcnJvcihyZXNwSlNPTi5lcnJvck1lc3NhZ2UpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzcEpTT04uZXJyb3JNZXNzYWdlKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCByZXNwb25zZTogJHtKU09OLnN0cmluZ2lmeShyZXNwSlNPTil9YCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBFeGVjdXRlIGEgQ29udmV4IGZ1bmN0aW9uIG9mIGFuIHVua25vd24gdHlwZS4gVGhlc2UgZnVuY3Rpb24gY2FsbHMgYXJlIG5vdCBxdWV1ZWQuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgb2JqZWN0IGZvciB0aGUgZnVuY3Rpb24uIElmIHRoaXMgaXMgb21pdHRlZCxcbiAgICogdGhlIGFyZ3VtZW50cyB3aWxsIGJlIGB7fWAuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSBvZiB0aGUgZnVuY3Rpb24ncyByZXN1bHQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24oYW55RnVuY3Rpb24sIGNvbXBvbmVudFBhdGgsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBmdW5jdGlvbkFyZ3MgPSBwYXJzZUFyZ3MoYXJnc1swXSk7XG4gICAgY29uc3QgbmFtZSA9IHR5cGVvZiBhbnlGdW5jdGlvbiA9PT0gXCJzdHJpbmdcIiA/IGFueUZ1bmN0aW9uIDogZ2V0RnVuY3Rpb25OYW1lKGFueUZ1bmN0aW9uKTtcbiAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgY29tcG9uZW50UGF0aCxcbiAgICAgIHBhdGg6IG5hbWUsXG4gICAgICBmb3JtYXQ6IFwiY29udmV4X2VuY29kZWRfanNvblwiLFxuICAgICAgYXJnczogY29udmV4VG9Kc29uKGZ1bmN0aW9uQXJncylcbiAgICB9KTtcbiAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICBcIkNvbnZleC1DbGllbnRcIjogYG5wbS0ke3ZlcnNpb259YFxuICAgIH07XG4gICAgaWYgKHRoaXMuYWRtaW5BdXRoKSB7XG4gICAgICBoZWFkZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IGBDb252ZXggJHt0aGlzLmFkbWluQXV0aH1gO1xuICAgIH0gZWxzZSBpZiAodGhpcy5hdXRoKSB7XG4gICAgICBoZWFkZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IGBCZWFyZXIgJHt0aGlzLmF1dGh9YDtcbiAgICB9XG4gICAgY29uc3QgbG9jYWxGZXRjaCA9IHRoaXMuZmV0Y2ggfHwgc3BlY2lmaWVkRmV0Y2ggfHwgZmV0Y2g7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBsb2NhbEZldGNoKGAke3RoaXMuYWRkcmVzc30vYXBpL2Z1bmN0aW9uYCwge1xuICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICBib2R5LFxuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnNcbiAgICB9KTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rICYmIHJlc3BvbnNlLnN0YXR1cyAhPT0gU1RBVFVTX0NPREVfVURGX0ZBSUxFRCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGF3YWl0IHJlc3BvbnNlLnRleHQoKSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BKU09OID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgcmVzcEpTT04ubG9nTGluZXMgPz8gW10pIHtcbiAgICAgICAgbG9nRm9yRnVuY3Rpb24odGhpcy5sb2dnZXIsIFwiaW5mb1wiLCBcImFueVwiLCBuYW1lLCBsaW5lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoIChyZXNwSlNPTi5zdGF0dXMpIHtcbiAgICAgIGNhc2UgXCJzdWNjZXNzXCI6XG4gICAgICAgIHJldHVybiBqc29uVG9Db252ZXgocmVzcEpTT04udmFsdWUpO1xuICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgIGlmIChyZXNwSlNPTi5lcnJvckRhdGEgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHRocm93IGZvcndhcmRFcnJvckRhdGEoXG4gICAgICAgICAgICByZXNwSlNPTi5lcnJvckRhdGEsXG4gICAgICAgICAgICBuZXcgQ29udmV4RXJyb3IocmVzcEpTT04uZXJyb3JNZXNzYWdlKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BKU09OLmVycm9yTWVzc2FnZSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcmVzcG9uc2U6ICR7SlNPTi5zdHJpbmdpZnkocmVzcEpTT04pfWApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZm9yd2FyZEVycm9yRGF0YShlcnJvckRhdGEsIGVycm9yKSB7XG4gIGVycm9yLmRhdGEgPSBqc29uVG9Db252ZXgoZXJyb3JEYXRhKTtcbiAgcmV0dXJuIGVycm9yO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aHR0cF9jbGllbnQuanMubWFwXG4iLCJpbXBvcnQge1xuICBGdW5jdGlvblJlZmVyZW5jZSxcbiAgRnVuY3Rpb25SZXR1cm5UeXBlLFxuICBPcHRpb25hbFJlc3RBcmdzLFxuICBnZXRGdW5jdGlvbk5hbWUsXG59IGZyb20gXCIuLi9zZXJ2ZXIvYXBpLmpzXCI7XG5pbXBvcnQgeyBwYXJzZUFyZ3MsIHZhbGlkYXRlRGVwbG95bWVudFVybCB9IGZyb20gXCIuLi9jb21tb24vaW5kZXguanNcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi4vaW5kZXguanNcIjtcbmltcG9ydCB7XG4gIENvbnZleEVycm9yLFxuICBKU09OVmFsdWUsXG4gIGNvbnZleFRvSnNvbixcbiAganNvblRvQ29udmV4LFxufSBmcm9tIFwiLi4vdmFsdWVzL2luZGV4LmpzXCI7XG5pbXBvcnQge1xuICBpbnN0YW50aWF0ZURlZmF1bHRMb2dnZXIsXG4gIGluc3RhbnRpYXRlTm9vcExvZ2dlcixcbiAgbG9nRm9yRnVuY3Rpb24sXG4gIExvZ2dlcixcbn0gZnJvbSBcIi4vbG9nZ2luZy5qc1wiO1xuaW1wb3J0IHtcbiAgQXJnc0FuZE9wdGlvbnMsXG4gIEZ1bmN0aW9uQXJncyxcbiAgVXNlcklkZW50aXR5QXR0cmlidXRlcyxcbn0gZnJvbSBcIi4uL3NlcnZlci9pbmRleC5qc1wiO1xuXG5leHBvcnQgY29uc3QgU1RBVFVTX0NPREVfT0sgPSAyMDA7XG5leHBvcnQgY29uc3QgU1RBVFVTX0NPREVfQkFEX1JFUVVFU1QgPSA0MDA7XG4vLyBTcGVjaWFsIGN1c3RvbSA1eHggSFRUUCBzdGF0dXMgY29kZSB0byBtZWFuIHRoYXQgdGhlIFVERiByZXR1cm5lZCBhbiBlcnJvci5cbi8vXG4vLyBNdXN0IG1hdGNoIHRoZSBjb25zdGFudCBvZiB0aGUgc2FtZSBuYW1lIGluIHRoZSBiYWNrZW5kLlxuZXhwb3J0IGNvbnN0IFNUQVRVU19DT0RFX1VERl9GQUlMRUQgPSA1NjA7XG5cbi8vIEFsbG93IGZldGNoIHRvIGJlIHNoaW1tZWQgaW4gZm9yIE5vZGUuanMgPCAxOFxubGV0IHNwZWNpZmllZEZldGNoOiB0eXBlb2YgZ2xvYmFsVGhpcy5mZXRjaCB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbmV4cG9ydCBmdW5jdGlvbiBzZXRGZXRjaChmOiB0eXBlb2YgZ2xvYmFsVGhpcy5mZXRjaCkge1xuICBzcGVjaWZpZWRGZXRjaCA9IGY7XG59XG5cbmV4cG9ydCB0eXBlIEh0dHBNdXRhdGlvbk9wdGlvbnMgPSB7XG4gIC8qKlxuICAgKiBTa2lwIHRoZSBkZWZhdWx0IHF1ZXVlIG9mIG11dGF0aW9ucyBhbmQgcnVuIHRoaXMgaW1tZWRpYXRlbHkuXG4gICAqXG4gICAqIFRoaXMgYWxsb3dzIHRoZSBzYW1lIEh0dHBDb252ZXhDbGllbnQgdG8gYmUgdXNlZCB0byByZXF1ZXN0IG11bHRpcGxlXG4gICAqIG11dGF0aW9ucyBpbiBwYXJhbGxlbCwgc29tZXRoaW5nIG5vdCBwb3NzaWJsZSB3aXRoIFdlYlNvY2tldC1iYXNlZCBjbGllbnRzLlxuICAgKi9cbiAgc2tpcFF1ZXVlOiBib29sZWFuO1xufTtcblxuLyoqXG4gKiBBIENvbnZleCBjbGllbnQgdGhhdCBydW5zIHF1ZXJpZXMgYW5kIG11dGF0aW9ucyBvdmVyIEhUVFAuXG4gKlxuICogVGhpcyBjbGllbnQgaXMgc3RhdGVmdWwgKGl0IGhhcyB1c2VyIGNyZWRlbnRpYWxzIGFuZCBxdWV1ZXMgbXV0YXRpb25zKVxuICogc28gdGFrZSBjYXJlIHRvIGF2b2lkIHNoYXJpbmcgaXQgYmV0d2VlbiByZXF1ZXN0cyBpbiBhIHNlcnZlci5cbiAqXG4gKiBUaGlzIGlzIGFwcHJvcHJpYXRlIGZvciBzZXJ2ZXItc2lkZSBjb2RlIChsaWtlIE5ldGxpZnkgTGFtYmRhcykgb3Igbm9uLXJlYWN0aXZlXG4gKiB3ZWJhcHBzLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIENvbnZleEh0dHBDbGllbnQge1xuICBwcml2YXRlIHJlYWRvbmx5IGFkZHJlc3M6IHN0cmluZztcbiAgcHJpdmF0ZSBhdXRoOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIHByaXZhdGUgYWRtaW5BdXRoOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIHByaXZhdGUgZW5jb2RlZFRzUHJvbWlzZT86IFByb21pc2U8c3RyaW5nPjtcbiAgcHJpdmF0ZSBkZWJ1ZzogYm9vbGVhbjtcbiAgcHJpdmF0ZSBmZXRjaE9wdGlvbnM/OiBGZXRjaE9wdGlvbnM7XG4gIHByaXZhdGUgZmV0Y2g/OiB0eXBlb2YgZ2xvYmFsVGhpcy5mZXRjaCB8IHVuZGVmaW5lZDtcbiAgcHJpdmF0ZSBsb2dnZXI6IExvZ2dlcjtcbiAgcHJpdmF0ZSBtdXRhdGlvblF1ZXVlOiBBcnJheTx7XG4gICAgbXV0YXRpb246IEZ1bmN0aW9uUmVmZXJlbmNlPFwibXV0YXRpb25cIj47XG4gICAgYXJnczogRnVuY3Rpb25BcmdzPGFueT47XG4gICAgcmVzb2x2ZTogKHZhbHVlOiBhbnkpID0+IHZvaWQ7XG4gICAgcmVqZWN0OiAoZXJyb3I6IGFueSkgPT4gdm9pZDtcbiAgfT4gPSBbXTtcbiAgcHJpdmF0ZSBpc1Byb2Nlc3NpbmdRdWV1ZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcge0BsaW5rIENvbnZleEh0dHBDbGllbnR9LlxuICAgKlxuICAgKiBAcGFyYW0gYWRkcmVzcyAtIFRoZSB1cmwgb2YgeW91ciBDb252ZXggZGVwbG95bWVudCwgb2Z0ZW4gcHJvdmlkZWRcbiAgICogYnkgYW4gZW52aXJvbm1lbnQgdmFyaWFibGUuIEUuZy4gYGh0dHBzOi8vc21hbGwtbW91c2UtMTIzLmNvbnZleC5jbG91ZGAuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb2JqZWN0IG9mIG9wdGlvbnMuXG4gICAqIC0gYHNraXBDb252ZXhEZXBsb3ltZW50VXJsQ2hlY2tgIC0gU2tpcCB2YWxpZGF0aW5nIHRoYXQgdGhlIENvbnZleCBkZXBsb3ltZW50IFVSTCBsb29rcyBsaWtlXG4gICAqIGBodHRwczovL2hhcHB5LWFuaW1hbC0xMjMuY29udmV4LmNsb3VkYCBvciBsb2NhbGhvc3QuIFRoaXMgY2FuIGJlIHVzZWZ1bCBpZiBydW5uaW5nIGEgc2VsZi1ob3N0ZWRcbiAgICogQ29udmV4IGJhY2tlbmQgdGhhdCB1c2VzIGEgZGlmZmVyZW50IFVSTC5cbiAgICogLSBgbG9nZ2VyYCAtIEEgbG9nZ2VyIG9yIGEgYm9vbGVhbi4gSWYgbm90IHByb3ZpZGVkLCBsb2dzIHRvIHRoZSBjb25zb2xlLlxuICAgKiBZb3UgY2FuIGNvbnN0cnVjdCB5b3VyIG93biBsb2dnZXIgdG8gY3VzdG9taXplIGxvZ2dpbmcgdG8gbG9nIGVsc2V3aGVyZVxuICAgKiBvciBub3QgbG9nIGF0IGFsbCwgb3IgdXNlIGBmYWxzZWAgYXMgYSBzaG9ydGhhbmQgZm9yIGEgbm8tb3AgbG9nZ2VyLlxuICAgKiBBIGxvZ2dlciBpcyBhbiBvYmplY3Qgd2l0aCA0IG1ldGhvZHM6IGxvZygpLCB3YXJuKCksIGVycm9yKCksIGFuZCBsb2dWZXJib3NlKCkuXG4gICAqIFRoZXNlIG1ldGhvZHMgY2FuIHJlY2VpdmUgbXVsdGlwbGUgYXJndW1lbnRzIG9mIGFueSB0eXBlcywgbGlrZSBjb25zb2xlLmxvZygpLlxuICAgKiAtIGBhdXRoYCAtIEEgSldUIGNvbnRhaW5pbmcgaWRlbnRpdHkgY2xhaW1zIGFjY2Vzc2libGUgaW4gQ29udmV4IGZ1bmN0aW9ucy5cbiAgICogVGhpcyBpZGVudGl0eSBtYXkgZXhwaXJlIHNvIGl0IG1heSBiZSBuZWNlc3NhcnkgdG8gY2FsbCBgc2V0QXV0aCgpYCBsYXRlcixcbiAgICogYnV0IGZvciBzaG9ydC1saXZlZCBjbGllbnRzIGl0J3MgY29udmVuaWVudCB0byBzcGVjaWZ5IHRoaXMgdmFsdWUgaGVyZS5cbiAgICogLSBgZmV0Y2hgIC0gQSBjdXN0b20gZmV0Y2ggaW1wbGVtZW50YXRpb24gdG8gdXNlIGZvciBhbGwgSFRUUCByZXF1ZXN0cyBtYWRlIGJ5IHRoaXMgY2xpZW50LlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgYWRkcmVzczogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiB7XG4gICAgICBza2lwQ29udmV4RGVwbG95bWVudFVybENoZWNrPzogYm9vbGVhbjtcbiAgICAgIGxvZ2dlcj86IExvZ2dlciB8IGJvb2xlYW47XG4gICAgICBhdXRoPzogc3RyaW5nO1xuICAgICAgZmV0Y2g/OiB0eXBlb2YgZ2xvYmFsVGhpcy5mZXRjaDtcbiAgICB9LFxuICApIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwic2tpcENvbnZleERlcGxveW1lbnRVcmxDaGVjayBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuIFBsZWFzZSBwYXNzIGFuIG9wdGlvbnMgb2JqZWN0LCBgeyBza2lwQ29udmV4RGVwbG95bWVudFVybENoZWNrOiB0cnVlIH1gLlwiLFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3Qgb3B0cyA9IG9wdGlvbnMgPz8ge307XG4gICAgaWYgKG9wdHMuc2tpcENvbnZleERlcGxveW1lbnRVcmxDaGVjayAhPT0gdHJ1ZSkge1xuICAgICAgdmFsaWRhdGVEZXBsb3ltZW50VXJsKGFkZHJlc3MpO1xuICAgIH1cbiAgICB0aGlzLmxvZ2dlciA9XG4gICAgICBvcHRpb25zPy5sb2dnZXIgPT09IGZhbHNlXG4gICAgICAgID8gaW5zdGFudGlhdGVOb29wTG9nZ2VyKHsgdmVyYm9zZTogZmFsc2UgfSlcbiAgICAgICAgOiBvcHRpb25zPy5sb2dnZXIgIT09IHRydWUgJiYgb3B0aW9ucz8ubG9nZ2VyXG4gICAgICAgICAgPyBvcHRpb25zLmxvZ2dlclxuICAgICAgICAgIDogaW5zdGFudGlhdGVEZWZhdWx0TG9nZ2VyKHsgdmVyYm9zZTogZmFsc2UgfSk7XG4gICAgdGhpcy5hZGRyZXNzID0gYWRkcmVzcztcbiAgICB0aGlzLmRlYnVnID0gdHJ1ZTtcbiAgICB0aGlzLmF1dGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5hZG1pbkF1dGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mZXRjaCA9IG9wdGlvbnM/LmZldGNoO1xuICAgIGlmIChvcHRpb25zPy5hdXRoKSB7XG4gICAgICB0aGlzLnNldEF1dGgob3B0aW9ucy5hdXRoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT2J0YWluIHRoZSB7QGxpbmsgQ29udmV4SHR0cENsaWVudH0ncyBVUkwgdG8gaXRzIGJhY2tlbmQuXG4gICAqIEBkZXByZWNhdGVkIFVzZSB1cmwsIHdoaWNoIHJldHVybnMgdGhlIHVybCB3aXRob3V0IC9hcGkgYXQgdGhlIGVuZC5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIFVSTCB0byB0aGUgQ29udmV4IGJhY2tlbmQsIGluY2x1ZGluZyB0aGUgY2xpZW50J3MgQVBJIHZlcnNpb24uXG4gICAqL1xuICBiYWNrZW5kVXJsKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGAke3RoaXMuYWRkcmVzc30vYXBpYDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGFkZHJlc3MgZm9yIHRoaXMgY2xpZW50LCB1c2VmdWwgZm9yIGNyZWF0aW5nIGEgbmV3IGNsaWVudC5cbiAgICpcbiAgICogTm90IGd1YXJhbnRlZWQgdG8gbWF0Y2ggdGhlIGFkZHJlc3Mgd2l0aCB3aGljaCB0aGlzIGNsaWVudCB3YXMgY29uc3RydWN0ZWQ6XG4gICAqIGl0IG1heSBiZSBjYW5vbmljYWxpemVkLlxuICAgKi9cbiAgZ2V0IHVybCgpIHtcbiAgICByZXR1cm4gdGhpcy5hZGRyZXNzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgYXV0aGVudGljYXRpb24gdG9rZW4gdG8gYmUgdXNlZCBmb3Igc3Vic2VxdWVudCBxdWVyaWVzIGFuZCBtdXRhdGlvbnMuXG4gICAqXG4gICAqIFNob3VsZCBiZSBjYWxsZWQgd2hlbmV2ZXIgdGhlIHRva2VuIGNoYW5nZXMgKGkuZS4gZHVlIHRvIGV4cGlyYXRpb24gYW5kIHJlZnJlc2gpLlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWUgLSBKV1QtZW5jb2RlZCBPcGVuSUQgQ29ubmVjdCBpZGVudGl0eSB0b2tlbi5cbiAgICovXG4gIHNldEF1dGgodmFsdWU6IHN0cmluZykge1xuICAgIHRoaXMuY2xlYXJBdXRoKCk7XG4gICAgdGhpcy5hdXRoID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGFkbWluIGF1dGggdG9rZW4gdG8gYWxsb3cgY2FsbGluZyBpbnRlcm5hbCBxdWVyaWVzLCBtdXRhdGlvbnMsIGFuZCBhY3Rpb25zXG4gICAqIGFuZCBhY3RpbmcgYXMgYW4gaWRlbnRpdHkuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc2V0QWRtaW5BdXRoKHRva2VuOiBzdHJpbmcsIGFjdGluZ0FzSWRlbnRpdHk/OiBVc2VySWRlbnRpdHlBdHRyaWJ1dGVzKSB7XG4gICAgdGhpcy5jbGVhckF1dGgoKTtcbiAgICBpZiAoYWN0aW5nQXNJZGVudGl0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFbmNvZGUgdGhlIGlkZW50aXR5IHRvIGEgYmFzZTY0IHN0cmluZ1xuICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoSlNPTi5zdHJpbmdpZnkoYWN0aW5nQXNJZGVudGl0eSkpO1xuICAgICAgY29uc3QgYWN0aW5nQXNJZGVudGl0eUVuY29kZWQgPSBidG9hKFN0cmluZy5mcm9tQ29kZVBvaW50KC4uLmJ5dGVzKSk7XG4gICAgICB0aGlzLmFkbWluQXV0aCA9IGAke3Rva2VufToke2FjdGluZ0FzSWRlbnRpdHlFbmNvZGVkfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRtaW5BdXRoID0gdG9rZW47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIHRoZSBjdXJyZW50IGF1dGhlbnRpY2F0aW9uIHRva2VuIGlmIHNldC5cbiAgICovXG4gIGNsZWFyQXV0aCgpIHtcbiAgICB0aGlzLmF1dGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5hZG1pbkF1dGggPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB3aGV0aGVyIHRoZSByZXN1bHQgbG9nIGxpbmVzIHNob3VsZCBiZSBwcmludGVkIG9uIHRoZSBjb25zb2xlIG9yIG5vdC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzZXREZWJ1ZyhkZWJ1ZzogYm9vbGVhbikge1xuICAgIHRoaXMuZGVidWcgPSBkZWJ1ZztcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGN1c3RvbWl6ZSB0aGUgZmV0Y2ggYmVoYXZpb3IgaW4gc29tZSBydW50aW1lcy5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzZXRGZXRjaE9wdGlvbnMoZmV0Y2hPcHRpb25zOiBGZXRjaE9wdGlvbnMpIHtcbiAgICB0aGlzLmZldGNoT3B0aW9ucyA9IGZldGNoT3B0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWw6IGl0IG1heSBjaGFuZ2Ugb3IgZGlzYXBwZWFyLlxuICAgKlxuICAgKiBFeGVjdXRlIGEgQ29udmV4IHF1ZXJ5IGZ1bmN0aW9uIGF0IHRoZSBzYW1lIHRpbWVzdGFtcCBhcyBldmVyeSBvdGhlclxuICAgKiBjb25zaXN0ZW50IHF1ZXJ5IGV4ZWN1dGlvbiBydW4gYnkgdGhpcyBIVFRQIGNsaWVudC5cbiAgICpcbiAgICogVGhpcyBkb2Vzbid0IG1ha2Ugc2Vuc2UgZm9yIGxvbmctbGl2ZWQgQ29udmV4SHR0cENsaWVudHMgYXMgQ29udmV4XG4gICAqIGJhY2tlbmRzIGNhbiByZWFkIGEgbGltaXRlZCBhbW91bnQgaW50byB0aGUgcGFzdDogYmV5b25kIDMwIHNlY29uZHNcbiAgICogaW4gdGhlIHBhc3QgbWF5IG5vdCBiZSBhdmFpbGFibGUuXG4gICAqXG4gICAqIENyZWF0ZSBhIG5ldyBjbGllbnQgdG8gdXNlIGEgY29uc2lzdGVudCB0aW1lLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBxdWVyeS5cbiAgICogQHBhcmFtIGFyZ3MgLSBUaGUgYXJndW1lbnRzIG9iamVjdCBmb3IgdGhlIHF1ZXJ5LiBJZiB0aGlzIGlzIG9taXR0ZWQsXG4gICAqIHRoZSBhcmd1bWVudHMgd2lsbCBiZSBge31gLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2Ugb2YgdGhlIHF1ZXJ5J3MgcmVzdWx0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBUaGlzIEFQSSBpcyBleHBlcmltZW50YWw6IGl0IG1heSBjaGFuZ2Ugb3IgZGlzYXBwZWFyLlxuICAgKi9cbiAgYXN5bmMgY29uc2lzdGVudFF1ZXJ5PFF1ZXJ5IGV4dGVuZHMgRnVuY3Rpb25SZWZlcmVuY2U8XCJxdWVyeVwiPj4oXG4gICAgcXVlcnk6IFF1ZXJ5LFxuICAgIC4uLmFyZ3M6IE9wdGlvbmFsUmVzdEFyZ3M8UXVlcnk+XG4gICk6IFByb21pc2U8RnVuY3Rpb25SZXR1cm5UeXBlPFF1ZXJ5Pj4ge1xuICAgIGNvbnN0IHF1ZXJ5QXJncyA9IHBhcnNlQXJncyhhcmdzWzBdKTtcblxuICAgIGNvbnN0IHRpbWVzdGFtcFByb21pc2UgPSB0aGlzLmdldFRpbWVzdGFtcCgpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnF1ZXJ5SW5uZXIocXVlcnksIHF1ZXJ5QXJncywgeyB0aW1lc3RhbXBQcm9taXNlIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBnZXRUaW1lc3RhbXAoKSB7XG4gICAgaWYgKHRoaXMuZW5jb2RlZFRzUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlZFRzUHJvbWlzZTtcbiAgICB9XG4gICAgcmV0dXJuICh0aGlzLmVuY29kZWRUc1Byb21pc2UgPSB0aGlzLmdldFRpbWVzdGFtcElubmVyKCkpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBnZXRUaW1lc3RhbXBJbm5lcigpIHtcbiAgICBjb25zdCBsb2NhbEZldGNoID0gdGhpcy5mZXRjaCB8fCBzcGVjaWZpZWRGZXRjaCB8fCBmZXRjaDtcblxuICAgIGNvbnN0IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIFwiQ29udmV4LUNsaWVudFwiOiBgbnBtLSR7dmVyc2lvbn1gLFxuICAgIH07XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBsb2NhbEZldGNoKGAke3RoaXMuYWRkcmVzc30vYXBpL3F1ZXJ5X3RzYCwge1xuICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICB9KTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYXdhaXQgcmVzcG9uc2UudGV4dCgpKTtcbiAgICB9XG4gICAgY29uc3QgeyB0cyB9ID0gKGF3YWl0IHJlc3BvbnNlLmpzb24oKSkgYXMgeyB0czogc3RyaW5nIH07XG4gICAgcmV0dXJuIHRzO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYSBDb252ZXggcXVlcnkgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHF1ZXJ5LlxuICAgKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgb2JqZWN0IGZvciB0aGUgcXVlcnkuIElmIHRoaXMgaXMgb21pdHRlZCxcbiAgICogdGhlIGFyZ3VtZW50cyB3aWxsIGJlIGB7fWAuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSBvZiB0aGUgcXVlcnkncyByZXN1bHQuXG4gICAqL1xuICBhc3luYyBxdWVyeTxRdWVyeSBleHRlbmRzIEZ1bmN0aW9uUmVmZXJlbmNlPFwicXVlcnlcIj4+KFxuICAgIHF1ZXJ5OiBRdWVyeSxcbiAgICAuLi5hcmdzOiBPcHRpb25hbFJlc3RBcmdzPFF1ZXJ5PlxuICApOiBQcm9taXNlPEZ1bmN0aW9uUmV0dXJuVHlwZTxRdWVyeT4+IHtcbiAgICBjb25zdCBxdWVyeUFyZ3MgPSBwYXJzZUFyZ3MoYXJnc1swXSk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucXVlcnlJbm5lcihxdWVyeSwgcXVlcnlBcmdzLCB7fSk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHF1ZXJ5SW5uZXI8UXVlcnkgZXh0ZW5kcyBGdW5jdGlvblJlZmVyZW5jZTxcInF1ZXJ5XCI+PihcbiAgICBxdWVyeTogUXVlcnksXG4gICAgcXVlcnlBcmdzOiBGdW5jdGlvbkFyZ3M8UXVlcnk+LFxuICAgIG9wdGlvbnM6IHsgdGltZXN0YW1wUHJvbWlzZT86IFByb21pc2U8c3RyaW5nPiB9LFxuICApOiBQcm9taXNlPEZ1bmN0aW9uUmV0dXJuVHlwZTxRdWVyeT4+IHtcbiAgICBjb25zdCBuYW1lID0gZ2V0RnVuY3Rpb25OYW1lKHF1ZXJ5KTtcbiAgICBjb25zdCBhcmdzID0gW2NvbnZleFRvSnNvbihxdWVyeUFyZ3MpXTtcbiAgICBjb25zdCBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICBcIkNvbnZleC1DbGllbnRcIjogYG5wbS0ke3ZlcnNpb259YCxcbiAgICB9O1xuICAgIGlmICh0aGlzLmFkbWluQXV0aCkge1xuICAgICAgaGVhZGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSBgQ29udmV4ICR7dGhpcy5hZG1pbkF1dGh9YDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYXV0aCkge1xuICAgICAgaGVhZGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSBgQmVhcmVyICR7dGhpcy5hdXRofWA7XG4gICAgfVxuICAgIGNvbnN0IGxvY2FsRmV0Y2ggPSB0aGlzLmZldGNoIHx8IHNwZWNpZmllZEZldGNoIHx8IGZldGNoO1xuXG4gICAgY29uc3QgdGltZXN0YW1wID0gb3B0aW9ucy50aW1lc3RhbXBQcm9taXNlXG4gICAgICA/IGF3YWl0IG9wdGlvbnMudGltZXN0YW1wUHJvbWlzZVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgcGF0aDogbmFtZSxcbiAgICAgIGZvcm1hdDogXCJjb252ZXhfZW5jb2RlZF9qc29uXCIsXG4gICAgICBhcmdzLFxuICAgICAgLi4uKHRpbWVzdGFtcCA/IHsgdHM6IHRpbWVzdGFtcCB9IDoge30pLFxuICAgIH0pO1xuICAgIGNvbnN0IGVuZHBvaW50ID0gdGltZXN0YW1wXG4gICAgICA/IGAke3RoaXMuYWRkcmVzc30vYXBpL3F1ZXJ5X2F0X3RzYFxuICAgICAgOiBgJHt0aGlzLmFkZHJlc3N9L2FwaS9xdWVyeWA7XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGxvY2FsRmV0Y2goZW5kcG9pbnQsIHtcbiAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgYm9keSxcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgIH0pO1xuICAgIGlmICghcmVzcG9uc2Uub2sgJiYgcmVzcG9uc2Uuc3RhdHVzICE9PSBTVEFUVVNfQ09ERV9VREZfRkFJTEVEKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYXdhaXQgcmVzcG9uc2UudGV4dCgpKTtcbiAgICB9XG4gICAgY29uc3QgcmVzcEpTT04gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgZm9yIChjb25zdCBsaW5lIG9mIHJlc3BKU09OLmxvZ0xpbmVzID8/IFtdKSB7XG4gICAgICAgIGxvZ0ZvckZ1bmN0aW9uKHRoaXMubG9nZ2VyLCBcImluZm9cIiwgXCJxdWVyeVwiLCBuYW1lLCBsaW5lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoIChyZXNwSlNPTi5zdGF0dXMpIHtcbiAgICAgIGNhc2UgXCJzdWNjZXNzXCI6XG4gICAgICAgIHJldHVybiBqc29uVG9Db252ZXgocmVzcEpTT04udmFsdWUpO1xuICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgIGlmIChyZXNwSlNPTi5lcnJvckRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IGZvcndhcmRFcnJvckRhdGEoXG4gICAgICAgICAgICByZXNwSlNPTi5lcnJvckRhdGEsXG4gICAgICAgICAgICBuZXcgQ29udmV4RXJyb3IocmVzcEpTT04uZXJyb3JNZXNzYWdlKSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyZXNwSlNPTi5lcnJvck1lc3NhZ2UpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHJlc3BvbnNlOiAke0pTT04uc3RyaW5naWZ5KHJlc3BKU09OKX1gKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIG11dGF0aW9uSW5uZXI8TXV0YXRpb24gZXh0ZW5kcyBGdW5jdGlvblJlZmVyZW5jZTxcIm11dGF0aW9uXCI+PihcbiAgICBtdXRhdGlvbjogTXV0YXRpb24sXG4gICAgbXV0YXRpb25BcmdzOiBGdW5jdGlvbkFyZ3M8TXV0YXRpb24+LFxuICApOiBQcm9taXNlPEZ1bmN0aW9uUmV0dXJuVHlwZTxNdXRhdGlvbj4+IHtcbiAgICBjb25zdCBuYW1lID0gZ2V0RnVuY3Rpb25OYW1lKG11dGF0aW9uKTtcbiAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgcGF0aDogbmFtZSxcbiAgICAgIGZvcm1hdDogXCJjb252ZXhfZW5jb2RlZF9qc29uXCIsXG4gICAgICBhcmdzOiBbY29udmV4VG9Kc29uKG11dGF0aW9uQXJncyldLFxuICAgIH0pO1xuICAgIGNvbnN0IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIFwiQ29udmV4LUNsaWVudFwiOiBgbnBtLSR7dmVyc2lvbn1gLFxuICAgIH07XG4gICAgaWYgKHRoaXMuYWRtaW5BdXRoKSB7XG4gICAgICBoZWFkZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IGBDb252ZXggJHt0aGlzLmFkbWluQXV0aH1gO1xuICAgIH0gZWxzZSBpZiAodGhpcy5hdXRoKSB7XG4gICAgICBoZWFkZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IGBCZWFyZXIgJHt0aGlzLmF1dGh9YDtcbiAgICB9XG4gICAgY29uc3QgbG9jYWxGZXRjaCA9IHRoaXMuZmV0Y2ggfHwgc3BlY2lmaWVkRmV0Y2ggfHwgZmV0Y2g7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBsb2NhbEZldGNoKGAke3RoaXMuYWRkcmVzc30vYXBpL211dGF0aW9uYCwge1xuICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICBib2R5LFxuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgfSk7XG4gICAgaWYgKCFyZXNwb25zZS5vayAmJiByZXNwb25zZS5zdGF0dXMgIT09IFNUQVRVU19DT0RFX1VERl9GQUlMRUQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihhd2FpdCByZXNwb25zZS50ZXh0KCkpO1xuICAgIH1cbiAgICBjb25zdCByZXNwSlNPTiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgZm9yIChjb25zdCBsaW5lIG9mIHJlc3BKU09OLmxvZ0xpbmVzID8/IFtdKSB7XG4gICAgICAgIGxvZ0ZvckZ1bmN0aW9uKHRoaXMubG9nZ2VyLCBcImluZm9cIiwgXCJtdXRhdGlvblwiLCBuYW1lLCBsaW5lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoIChyZXNwSlNPTi5zdGF0dXMpIHtcbiAgICAgIGNhc2UgXCJzdWNjZXNzXCI6XG4gICAgICAgIHJldHVybiBqc29uVG9Db252ZXgocmVzcEpTT04udmFsdWUpO1xuICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgIGlmIChyZXNwSlNPTi5lcnJvckRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IGZvcndhcmRFcnJvckRhdGEoXG4gICAgICAgICAgICByZXNwSlNPTi5lcnJvckRhdGEsXG4gICAgICAgICAgICBuZXcgQ29udmV4RXJyb3IocmVzcEpTT04uZXJyb3JNZXNzYWdlKSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyZXNwSlNPTi5lcnJvck1lc3NhZ2UpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHJlc3BvbnNlOiAke0pTT04uc3RyaW5naWZ5KHJlc3BKU09OKX1gKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHByb2Nlc3NNdXRhdGlvblF1ZXVlKCkge1xuICAgIGlmICh0aGlzLmlzUHJvY2Vzc2luZ1F1ZXVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5pc1Byb2Nlc3NpbmdRdWV1ZSA9IHRydWU7XG4gICAgd2hpbGUgKHRoaXMubXV0YXRpb25RdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCB7IG11dGF0aW9uLCBhcmdzLCByZXNvbHZlLCByZWplY3QgfSA9IHRoaXMubXV0YXRpb25RdWV1ZS5zaGlmdCgpITtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMubXV0YXRpb25Jbm5lcihtdXRhdGlvbiwgYXJncyk7XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuaXNQcm9jZXNzaW5nUXVldWUgPSBmYWxzZTtcbiAgfVxuXG4gIHByaXZhdGUgZW5xdWV1ZU11dGF0aW9uPE11dGF0aW9uIGV4dGVuZHMgRnVuY3Rpb25SZWZlcmVuY2U8XCJtdXRhdGlvblwiPj4oXG4gICAgbXV0YXRpb246IE11dGF0aW9uLFxuICAgIGFyZ3M6IEZ1bmN0aW9uQXJnczxNdXRhdGlvbj4sXG4gICk6IFByb21pc2U8RnVuY3Rpb25SZXR1cm5UeXBlPE11dGF0aW9uPj4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLm11dGF0aW9uUXVldWUucHVzaCh7IG11dGF0aW9uLCBhcmdzLCByZXNvbHZlLCByZWplY3QgfSk7XG4gICAgICB2b2lkIHRoaXMucHJvY2Vzc011dGF0aW9uUXVldWUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIGEgQ29udmV4IG11dGF0aW9uIGZ1bmN0aW9uLiBNdXRhdGlvbnMgYXJlIHF1ZXVlZCBieSBkZWZhdWx0LlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBtdXRhdGlvbi5cbiAgICogQHBhcmFtIGFyZ3MgLSBUaGUgYXJndW1lbnRzIG9iamVjdCBmb3IgdGhlIG11dGF0aW9uLiBJZiB0aGlzIGlzIG9taXR0ZWQsXG4gICAqIHRoZSBhcmd1bWVudHMgd2lsbCBiZSBge31gLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbmFsIG9iamVjdCBjb250YWluaW5nXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSBvZiB0aGUgbXV0YXRpb24ncyByZXN1bHQuXG4gICAqL1xuICBhc3luYyBtdXRhdGlvbjxNdXRhdGlvbiBleHRlbmRzIEZ1bmN0aW9uUmVmZXJlbmNlPFwibXV0YXRpb25cIj4+KFxuICAgIG11dGF0aW9uOiBNdXRhdGlvbixcbiAgICAuLi5hcmdzOiBBcmdzQW5kT3B0aW9uczxNdXRhdGlvbiwgSHR0cE11dGF0aW9uT3B0aW9ucz5cbiAgKTogUHJvbWlzZTxGdW5jdGlvblJldHVyblR5cGU8TXV0YXRpb24+PiB7XG4gICAgY29uc3QgW2ZuQXJncywgb3B0aW9uc10gPSBhcmdzO1xuICAgIGNvbnN0IG11dGF0aW9uQXJncyA9IHBhcnNlQXJncyhmbkFyZ3MpO1xuICAgIGNvbnN0IHF1ZXVlZCA9ICFvcHRpb25zPy5za2lwUXVldWU7XG5cbiAgICBpZiAocXVldWVkKSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5lbnF1ZXVlTXV0YXRpb24obXV0YXRpb24sIG11dGF0aW9uQXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLm11dGF0aW9uSW5uZXIobXV0YXRpb24sIG11dGF0aW9uQXJncyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYSBDb252ZXggYWN0aW9uIGZ1bmN0aW9uLiBBY3Rpb25zIGFyZSBub3QgcXVldWVkLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBhY3Rpb24uXG4gICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyBvYmplY3QgZm9yIHRoZSBhY3Rpb24uIElmIHRoaXMgaXMgb21pdHRlZCxcbiAgICogdGhlIGFyZ3VtZW50cyB3aWxsIGJlIGB7fWAuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSBvZiB0aGUgYWN0aW9uJ3MgcmVzdWx0LlxuICAgKi9cbiAgYXN5bmMgYWN0aW9uPEFjdGlvbiBleHRlbmRzIEZ1bmN0aW9uUmVmZXJlbmNlPFwiYWN0aW9uXCI+PihcbiAgICBhY3Rpb246IEFjdGlvbixcbiAgICAuLi5hcmdzOiBPcHRpb25hbFJlc3RBcmdzPEFjdGlvbj5cbiAgKTogUHJvbWlzZTxGdW5jdGlvblJldHVyblR5cGU8QWN0aW9uPj4ge1xuICAgIGNvbnN0IGFjdGlvbkFyZ3MgPSBwYXJzZUFyZ3MoYXJnc1swXSk7XG4gICAgY29uc3QgbmFtZSA9IGdldEZ1bmN0aW9uTmFtZShhY3Rpb24pO1xuICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBwYXRoOiBuYW1lLFxuICAgICAgZm9ybWF0OiBcImNvbnZleF9lbmNvZGVkX2pzb25cIixcbiAgICAgIGFyZ3M6IFtjb252ZXhUb0pzb24oYWN0aW9uQXJncyldLFxuICAgIH0pO1xuICAgIGNvbnN0IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIFwiQ29udmV4LUNsaWVudFwiOiBgbnBtLSR7dmVyc2lvbn1gLFxuICAgIH07XG4gICAgaWYgKHRoaXMuYWRtaW5BdXRoKSB7XG4gICAgICBoZWFkZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IGBDb252ZXggJHt0aGlzLmFkbWluQXV0aH1gO1xuICAgIH0gZWxzZSBpZiAodGhpcy5hdXRoKSB7XG4gICAgICBoZWFkZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IGBCZWFyZXIgJHt0aGlzLmF1dGh9YDtcbiAgICB9XG4gICAgY29uc3QgbG9jYWxGZXRjaCA9IHRoaXMuZmV0Y2ggfHwgc3BlY2lmaWVkRmV0Y2ggfHwgZmV0Y2g7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBsb2NhbEZldGNoKGAke3RoaXMuYWRkcmVzc30vYXBpL2FjdGlvbmAsIHtcbiAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgYm9keSxcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgIH0pO1xuICAgIGlmICghcmVzcG9uc2Uub2sgJiYgcmVzcG9uc2Uuc3RhdHVzICE9PSBTVEFUVVNfQ09ERV9VREZfRkFJTEVEKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYXdhaXQgcmVzcG9uc2UudGV4dCgpKTtcbiAgICB9XG4gICAgY29uc3QgcmVzcEpTT04gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgIGZvciAoY29uc3QgbGluZSBvZiByZXNwSlNPTi5sb2dMaW5lcyA/PyBbXSkge1xuICAgICAgICBsb2dGb3JGdW5jdGlvbih0aGlzLmxvZ2dlciwgXCJpbmZvXCIsIFwiYWN0aW9uXCIsIG5hbWUsIGxpbmUpO1xuICAgICAgfVxuICAgIH1cbiAgICBzd2l0Y2ggKHJlc3BKU09OLnN0YXR1cykge1xuICAgICAgY2FzZSBcInN1Y2Nlc3NcIjpcbiAgICAgICAgcmV0dXJuIGpzb25Ub0NvbnZleChyZXNwSlNPTi52YWx1ZSk7XG4gICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgaWYgKHJlc3BKU09OLmVycm9yRGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgZm9yd2FyZEVycm9yRGF0YShcbiAgICAgICAgICAgIHJlc3BKU09OLmVycm9yRGF0YSxcbiAgICAgICAgICAgIG5ldyBDb252ZXhFcnJvcihyZXNwSlNPTi5lcnJvck1lc3NhZ2UpLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BKU09OLmVycm9yTWVzc2FnZSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcmVzcG9uc2U6ICR7SlNPTi5zdHJpbmdpZnkocmVzcEpTT04pfWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIGEgQ29udmV4IGZ1bmN0aW9uIG9mIGFuIHVua25vd24gdHlwZS4gVGhlc2UgZnVuY3Rpb24gY2FsbHMgYXJlIG5vdCBxdWV1ZWQuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgb2JqZWN0IGZvciB0aGUgZnVuY3Rpb24uIElmIHRoaXMgaXMgb21pdHRlZCxcbiAgICogdGhlIGFyZ3VtZW50cyB3aWxsIGJlIGB7fWAuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSBvZiB0aGUgZnVuY3Rpb24ncyByZXN1bHQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb248XG4gICAgQW55RnVuY3Rpb24gZXh0ZW5kcyBGdW5jdGlvblJlZmVyZW5jZTxcInF1ZXJ5XCIgfCBcIm11dGF0aW9uXCIgfCBcImFjdGlvblwiPixcbiAgPihcbiAgICBhbnlGdW5jdGlvbjogQW55RnVuY3Rpb24gfCBzdHJpbmcsXG4gICAgY29tcG9uZW50UGF0aD86IHN0cmluZyxcbiAgICAuLi5hcmdzOiBPcHRpb25hbFJlc3RBcmdzPEFueUZ1bmN0aW9uPlxuICApOiBQcm9taXNlPEZ1bmN0aW9uUmV0dXJuVHlwZTxBbnlGdW5jdGlvbj4+IHtcbiAgICBjb25zdCBmdW5jdGlvbkFyZ3MgPSBwYXJzZUFyZ3MoYXJnc1swXSk7XG4gICAgY29uc3QgbmFtZSA9XG4gICAgICB0eXBlb2YgYW55RnVuY3Rpb24gPT09IFwic3RyaW5nXCJcbiAgICAgICAgPyBhbnlGdW5jdGlvblxuICAgICAgICA6IGdldEZ1bmN0aW9uTmFtZShhbnlGdW5jdGlvbik7XG4gICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIGNvbXBvbmVudFBhdGg6IGNvbXBvbmVudFBhdGgsXG4gICAgICBwYXRoOiBuYW1lLFxuICAgICAgZm9ybWF0OiBcImNvbnZleF9lbmNvZGVkX2pzb25cIixcbiAgICAgIGFyZ3M6IGNvbnZleFRvSnNvbihmdW5jdGlvbkFyZ3MpLFxuICAgIH0pO1xuICAgIGNvbnN0IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIFwiQ29udmV4LUNsaWVudFwiOiBgbnBtLSR7dmVyc2lvbn1gLFxuICAgIH07XG4gICAgaWYgKHRoaXMuYWRtaW5BdXRoKSB7XG4gICAgICBoZWFkZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IGBDb252ZXggJHt0aGlzLmFkbWluQXV0aH1gO1xuICAgIH0gZWxzZSBpZiAodGhpcy5hdXRoKSB7XG4gICAgICBoZWFkZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IGBCZWFyZXIgJHt0aGlzLmF1dGh9YDtcbiAgICB9XG4gICAgY29uc3QgbG9jYWxGZXRjaCA9IHRoaXMuZmV0Y2ggfHwgc3BlY2lmaWVkRmV0Y2ggfHwgZmV0Y2g7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBsb2NhbEZldGNoKGAke3RoaXMuYWRkcmVzc30vYXBpL2Z1bmN0aW9uYCwge1xuICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICBib2R5LFxuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgfSk7XG4gICAgaWYgKCFyZXNwb25zZS5vayAmJiByZXNwb25zZS5zdGF0dXMgIT09IFNUQVRVU19DT0RFX1VERl9GQUlMRUQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihhd2FpdCByZXNwb25zZS50ZXh0KCkpO1xuICAgIH1cbiAgICBjb25zdCByZXNwSlNPTiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgZm9yIChjb25zdCBsaW5lIG9mIHJlc3BKU09OLmxvZ0xpbmVzID8/IFtdKSB7XG4gICAgICAgIGxvZ0ZvckZ1bmN0aW9uKHRoaXMubG9nZ2VyLCBcImluZm9cIiwgXCJhbnlcIiwgbmFtZSwgbGluZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAocmVzcEpTT04uc3RhdHVzKSB7XG4gICAgICBjYXNlIFwic3VjY2Vzc1wiOlxuICAgICAgICByZXR1cm4ganNvblRvQ29udmV4KHJlc3BKU09OLnZhbHVlKTtcbiAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICBpZiAocmVzcEpTT04uZXJyb3JEYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBmb3J3YXJkRXJyb3JEYXRhKFxuICAgICAgICAgICAgcmVzcEpTT04uZXJyb3JEYXRhLFxuICAgICAgICAgICAgbmV3IENvbnZleEVycm9yKHJlc3BKU09OLmVycm9yTWVzc2FnZSksXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzcEpTT04uZXJyb3JNZXNzYWdlKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCByZXNwb25zZTogJHtKU09OLnN0cmluZ2lmeShyZXNwSlNPTil9YCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZvcndhcmRFcnJvckRhdGEoZXJyb3JEYXRhOiBKU09OVmFsdWUsIGVycm9yOiBDb252ZXhFcnJvcjxzdHJpbmc+KSB7XG4gIChlcnJvciBhcyBDb252ZXhFcnJvcjxhbnk+KS5kYXRhID0ganNvblRvQ29udmV4KGVycm9yRGF0YSk7XG4gIHJldHVybiBlcnJvcjtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xudHlwZSBGZXRjaE9wdGlvbnMgPSB7IGNhY2hlOiBcImZvcmNlLWNhY2hlXCIgfCBcIm5vLXN0b3JlXCIgfTtcbiIsIi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIEdlbmVyYXRlZCBgYXBpYCB1dGlsaXR5LlxuICpcbiAqIFRISVMgQ09ERSBJUyBBVVRPTUFUSUNBTExZIEdFTkVSQVRFRC5cbiAqXG4gKiBUbyByZWdlbmVyYXRlLCBydW4gYG5weCBjb252ZXggZGV2YC5cbiAqIEBtb2R1bGVcbiAqL1xuXG5pbXBvcnQgeyBhbnlBcGksIGNvbXBvbmVudHNHZW5lcmljIH0gZnJvbSBcImNvbnZleC9zZXJ2ZXJcIjtcblxuLyoqXG4gKiBBIHV0aWxpdHkgZm9yIHJlZmVyZW5jaW5nIENvbnZleCBmdW5jdGlvbnMgaW4geW91ciBhcHAncyBBUEkuXG4gKlxuICogVXNhZ2U6XG4gKiBgYGBqc1xuICogY29uc3QgbXlGdW5jdGlvblJlZmVyZW5jZSA9IGFwaS5teU1vZHVsZS5teUZ1bmN0aW9uO1xuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCBhcGkgPSBhbnlBcGk7XG5leHBvcnQgY29uc3QgaW50ZXJuYWwgPSBhbnlBcGk7XG5leHBvcnQgY29uc3QgY29tcG9uZW50cyA9IGNvbXBvbmVudHNHZW5lcmljKCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2RhdGFiYXNlLmpzXCI7XG5leHBvcnQge1xuICBhY3Rpb25HZW5lcmljLFxuICBodHRwQWN0aW9uR2VuZXJpYyxcbiAgbXV0YXRpb25HZW5lcmljLFxuICBxdWVyeUdlbmVyaWMsXG4gIGludGVybmFsQWN0aW9uR2VuZXJpYyxcbiAgaW50ZXJuYWxNdXRhdGlvbkdlbmVyaWMsXG4gIGludGVybmFsUXVlcnlHZW5lcmljXG59IGZyb20gXCIuL2ltcGwvcmVnaXN0cmF0aW9uX2ltcGwuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3BhZ2luYXRpb24uanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3NlYXJjaF9maWx0ZXJfYnVpbGRlci5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vc3RvcmFnZS5qc1wiO1xuZXhwb3J0IHsgY3JvbkpvYnMgfSBmcm9tIFwiLi9jcm9uLmpzXCI7XG5leHBvcnQgeyBodHRwUm91dGVyLCBIdHRwUm91dGVyLCBST1VUQUJMRV9IVFRQX01FVEhPRFMgfSBmcm9tIFwiLi9yb3V0ZXIuanNcIjtcbmV4cG9ydCB7XG4gIGFueUFwaSxcbiAgZ2V0RnVuY3Rpb25OYW1lLFxuICBtYWtlRnVuY3Rpb25SZWZlcmVuY2UsXG4gIGZpbHRlckFwaVxufSBmcm9tIFwiLi9hcGkuanNcIjtcbmV4cG9ydCB7XG4gIGRlZmluZUFwcCxcbiAgZGVmaW5lQ29tcG9uZW50LFxuICBjb21wb25lbnRzR2VuZXJpYyxcbiAgY3JlYXRlRnVuY3Rpb25IYW5kbGVcbn0gZnJvbSBcIi4vY29tcG9uZW50cy9pbmRleC5qc1wiO1xuZXhwb3J0IHsgY3VycmVudFN5c3RlbVVkZkluQ29tcG9uZW50IH0gZnJvbSBcIi4vY29tcG9uZW50cy9pbmRleC5qc1wiO1xuZXhwb3J0IHsgZ2V0RnVuY3Rpb25BZGRyZXNzIH0gZnJvbSBcIi4vY29tcG9uZW50cy9pbmRleC5qc1wiO1xuZXhwb3J0IHsgZGVmaW5lVGFibGUsIGRlZmluZVNjaGVtYSB9IGZyb20gXCIuL3NjaGVtYS5qc1wiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCIvKipcbiAqIFV0aWxpdGllcyBmb3IgaW1wbGVtZW50aW5nIHNlcnZlci1zaWRlIENvbnZleCBxdWVyeSBhbmQgbXV0YXRpb24gZnVuY3Rpb25zLlxuICpcbiAqICMjIFVzYWdlXG4gKlxuICogIyMjIENvZGUgR2VuZXJhdGlvblxuICpcbiAqIFRoaXMgbW9kdWxlIGlzIHR5cGljYWxseSB1c2VkIGFsb25nc2lkZSBnZW5lcmF0ZWQgc2VydmVyIGNvZGUuXG4gKlxuICogVG8gZ2VuZXJhdGUgdGhlIHNlcnZlciBjb2RlLCBydW4gYG5weCBjb252ZXggZGV2YCBpbiB5b3VyIENvbnZleCBwcm9qZWN0LlxuICogVGhpcyB3aWxsIGNyZWF0ZSBhIGBjb252ZXgvX2dlbmVyYXRlZC9zZXJ2ZXIuanNgIGZpbGUgd2l0aCB0aGUgZm9sbG93aW5nXG4gKiBmdW5jdGlvbnMsIHR5cGVkIGZvciB5b3VyIHNjaGVtYTpcbiAqIC0gW3F1ZXJ5XShodHRwczovL2RvY3MuY29udmV4LmRldi9nZW5lcmF0ZWQtYXBpL3NlcnZlciNxdWVyeSlcbiAqIC0gW211dGF0aW9uXShodHRwczovL2RvY3MuY29udmV4LmRldi9nZW5lcmF0ZWQtYXBpL3NlcnZlciNtdXRhdGlvbilcbiAqXG4gKiBJZiB5b3UgYXJlbid0IHVzaW5nIFR5cGVTY3JpcHQgYW5kIGNvZGUgZ2VuZXJhdGlvbiwgeW91IGNhbiB1c2UgdGhlc2UgdW50eXBlZFxuICogZnVuY3Rpb25zIGluc3RlYWQ6XG4gKiAtIHtAbGluayBxdWVyeUdlbmVyaWN9XG4gKiAtIHtAbGluayBtdXRhdGlvbkdlbmVyaWN9XG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBDb252ZXggZnVuY3Rpb25zIGFyZSBkZWZpbmVkIGJ5IHVzaW5nIGVpdGhlciB0aGUgYHF1ZXJ5YCBvclxuICogYG11dGF0aW9uYCB3cmFwcGVycy5cbiAqXG4gKiBRdWVyaWVzIHJlY2VpdmUgYSBgZGJgIHRoYXQgaW1wbGVtZW50cyB0aGUge0BsaW5rIEdlbmVyaWNEYXRhYmFzZVJlYWRlcn0gaW50ZXJmYWNlLlxuICpcbiAqIGBgYGpzXG4gKiBpbXBvcnQgeyBxdWVyeSB9IGZyb20gXCIuL19nZW5lcmF0ZWQvc2VydmVyXCI7XG4gKlxuICogZXhwb3J0IGRlZmF1bHQgcXVlcnkoe1xuICogICBoYW5kbGVyOiBhc3luYyAoeyBkYiB9LCB7IGFyZzEsIGFyZzIgfSkgPT4ge1xuICogICAgIC8vIFlvdXIgKHJlYWQtb25seSkgY29kZSBoZXJlIVxuICogICB9LFxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBJZiB5b3VyIGZ1bmN0aW9uIG5lZWRzIHRvIHdyaXRlIHRvIHRoZSBkYXRhYmFzZSwgc3VjaCBhcyBpbnNlcnRpbmcsIHVwZGF0aW5nLFxuICogb3IgZGVsZXRpbmcgZG9jdW1lbnRzLCB1c2UgYG11dGF0aW9uYCBpbnN0ZWFkIHdoaWNoIHByb3ZpZGVzIGEgYGRiYCB0aGF0XG4gKiBpbXBsZW1lbnRzIHRoZSB7QGxpbmsgR2VuZXJpY0RhdGFiYXNlV3JpdGVyfSBpbnRlcmZhY2UuXG4gKlxuICogYGBganNcbiAqIGltcG9ydCB7IG11dGF0aW9uIH0gZnJvbSBcIi4vX2dlbmVyYXRlZC9zZXJ2ZXJcIjtcbiAqXG4gKiBleHBvcnQgZGVmYXVsdCBtdXRhdGlvbih7XG4gKiAgIGhhbmRsZXI6IGFzeW5jICh7IGRiIH0sIHsgYXJnMSwgYXJnMiB9KSA9PiB7XG4gKiAgICAgLy8gWW91ciBtdXRhdGlvbiBjb2RlIGhlcmUhXG4gKiAgIH0sXG4gKiB9KTtcbiAqIGBgYFxuICogQG1vZHVsZVxuICovXG5cbmV4cG9ydCB0eXBlIHtcbiAgQXV0aCxcbiAgQXV0aENvbmZpZyxcbiAgQXV0aFByb3ZpZGVyLFxuICBVc2VySWRlbnRpdHksXG4gIFVzZXJJZGVudGl0eUF0dHJpYnV0ZXMsXG59IGZyb20gXCIuL2F1dGhlbnRpY2F0aW9uLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9kYXRhYmFzZS5qc1wiO1xuZXhwb3J0IHR5cGUge1xuICBHZW5lcmljRG9jdW1lbnQsXG4gIEdlbmVyaWNGaWVsZFBhdGhzLFxuICBHZW5lcmljSW5kZXhGaWVsZHMsXG4gIEdlbmVyaWNUYWJsZUluZGV4ZXMsXG4gIEdlbmVyaWNTZWFyY2hJbmRleENvbmZpZyxcbiAgR2VuZXJpY1RhYmxlU2VhcmNoSW5kZXhlcyxcbiAgR2VuZXJpY1ZlY3RvckluZGV4Q29uZmlnLFxuICBHZW5lcmljVGFibGVWZWN0b3JJbmRleGVzLFxuICBGaWVsZFR5cGVGcm9tRmllbGRQYXRoLFxuICBGaWVsZFR5cGVGcm9tRmllbGRQYXRoSW5uZXIsXG4gIEdlbmVyaWNUYWJsZUluZm8sXG4gIERvY3VtZW50QnlJbmZvLFxuICBGaWVsZFBhdGhzLFxuICBJbmRleGVzLFxuICBJbmRleE5hbWVzLFxuICBOYW1lZEluZGV4LFxuICBTZWFyY2hJbmRleGVzLFxuICBTZWFyY2hJbmRleE5hbWVzLFxuICBOYW1lZFNlYXJjaEluZGV4LFxuICBWZWN0b3JJbmRleGVzLFxuICBWZWN0b3JJbmRleE5hbWVzLFxuICBOYW1lZFZlY3RvckluZGV4LFxuICBHZW5lcmljRGF0YU1vZGVsLFxuICBBbnlEYXRhTW9kZWwsXG4gIFRhYmxlTmFtZXNJbkRhdGFNb2RlbCxcbiAgTmFtZWRUYWJsZUluZm8sXG4gIERvY3VtZW50QnlOYW1lLFxufSBmcm9tIFwiLi9kYXRhX21vZGVsLmpzXCI7XG5cbmV4cG9ydCB0eXBlIHtcbiAgRXhwcmVzc2lvbixcbiAgRXhwcmVzc2lvbk9yVmFsdWUsXG4gIEZpbHRlckJ1aWxkZXIsXG59IGZyb20gXCIuL2ZpbHRlcl9idWlsZGVyLmpzXCI7XG5leHBvcnQge1xuICBhY3Rpb25HZW5lcmljLFxuICBodHRwQWN0aW9uR2VuZXJpYyxcbiAgbXV0YXRpb25HZW5lcmljLFxuICBxdWVyeUdlbmVyaWMsXG4gIGludGVybmFsQWN0aW9uR2VuZXJpYyxcbiAgaW50ZXJuYWxNdXRhdGlvbkdlbmVyaWMsXG4gIGludGVybmFsUXVlcnlHZW5lcmljLFxufSBmcm9tIFwiLi9pbXBsL3JlZ2lzdHJhdGlvbl9pbXBsLmpzXCI7XG5leHBvcnQgdHlwZSB7IEluZGV4UmFuZ2UsIEluZGV4UmFuZ2VCdWlsZGVyIH0gZnJvbSBcIi4vaW5kZXhfcmFuZ2VfYnVpbGRlci5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vcGFnaW5hdGlvbi5qc1wiO1xuZXhwb3J0IHR5cGUgeyBPcmRlcmVkUXVlcnksIFF1ZXJ5LCBRdWVyeUluaXRpYWxpemVyIH0gZnJvbSBcIi4vcXVlcnkuanNcIjtcbmV4cG9ydCB0eXBlIHtcbiAgQXJnc0FycmF5LFxuICBEZWZhdWx0RnVuY3Rpb25BcmdzLFxuICBGdW5jdGlvblZpc2liaWxpdHksXG4gIEFjdGlvbkJ1aWxkZXIsXG4gIE11dGF0aW9uQnVpbGRlcixcbiAgTXV0YXRpb25CdWlsZGVyV2l0aFRhYmxlLFxuICBRdWVyeUJ1aWxkZXIsXG4gIFF1ZXJ5QnVpbGRlcldpdGhUYWJsZSxcbiAgSHR0cEFjdGlvbkJ1aWxkZXIsXG4gIEdlbmVyaWNBY3Rpb25DdHgsXG4gIEdlbmVyaWNNdXRhdGlvbkN0eCxcbiAgR2VuZXJpY011dGF0aW9uQ3R4V2l0aFRhYmxlLFxuICBHZW5lcmljUXVlcnlDdHgsXG4gIEdlbmVyaWNRdWVyeUN0eFdpdGhUYWJsZSxcbiAgUmVnaXN0ZXJlZEFjdGlvbixcbiAgUmVnaXN0ZXJlZE11dGF0aW9uLFxuICBSZWdpc3RlcmVkUXVlcnksXG4gIFB1YmxpY0h0dHBBY3Rpb24sXG4gIFVudmFsaWRhdGVkRnVuY3Rpb24sXG4gIFZhbGlkYXRlZEZ1bmN0aW9uLFxuICBSZXR1cm5WYWx1ZUZvck9wdGlvbmFsVmFsaWRhdG9yLFxuICBBcmdzQXJyYXlGb3JPcHRpb25hbFZhbGlkYXRvcixcbiAgQXJnc0FycmF5VG9PYmplY3QsXG4gIERlZmF1bHRBcmdzRm9yT3B0aW9uYWxWYWxpZGF0b3IsXG59IGZyb20gXCIuL3JlZ2lzdHJhdGlvbi5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vc2VhcmNoX2ZpbHRlcl9idWlsZGVyLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9zdG9yYWdlLmpzXCI7XG5leHBvcnQgdHlwZSB7IFNjaGVkdWxlciwgU2NoZWR1bGFibGVGdW5jdGlvblJlZmVyZW5jZSB9IGZyb20gXCIuL3NjaGVkdWxlci5qc1wiO1xuZXhwb3J0IHsgY3JvbkpvYnMgfSBmcm9tIFwiLi9jcm9uLmpzXCI7XG5leHBvcnQgdHlwZSB7IENyb25Kb2IsIENyb25zIH0gZnJvbSBcIi4vY3Jvbi5qc1wiO1xuZXhwb3J0IHR5cGUge1xuICBTeXN0ZW1GaWVsZHMsXG4gIElkRmllbGQsXG4gIFdpdGhvdXRTeXN0ZW1GaWVsZHMsXG4gIFdpdGhPcHRpb25hbFN5c3RlbUZpZWxkcyxcbiAgU3lzdGVtSW5kZXhlcyxcbiAgSW5kZXhUaWVicmVha2VyRmllbGQsXG59IGZyb20gXCIuL3N5c3RlbV9maWVsZHMuanNcIjtcbmV4cG9ydCB7IGh0dHBSb3V0ZXIsIEh0dHBSb3V0ZXIsIFJPVVRBQkxFX0hUVFBfTUVUSE9EUyB9IGZyb20gXCIuL3JvdXRlci5qc1wiO1xuZXhwb3J0IHR5cGUge1xuICBSb3V0YWJsZU1ldGhvZCxcbiAgUm91dGVTcGVjLFxuICBSb3V0ZVNwZWNXaXRoUGF0aCxcbiAgUm91dGVTcGVjV2l0aFBhdGhQcmVmaXgsXG59IGZyb20gXCIuL3JvdXRlci5qc1wiO1xuZXhwb3J0IHtcbiAgYW55QXBpLFxuICBnZXRGdW5jdGlvbk5hbWUsXG4gIG1ha2VGdW5jdGlvblJlZmVyZW5jZSxcbiAgZmlsdGVyQXBpLFxufSBmcm9tIFwiLi9hcGkuanNcIjtcbmV4cG9ydCB0eXBlIHtcbiAgQXBpRnJvbU1vZHVsZXMsXG4gIEFueUFwaSxcbiAgRmlsdGVyQXBpLFxuICBGdW5jdGlvblR5cGUsXG4gIEZ1bmN0aW9uUmVmZXJlbmNlLFxuICBGdW5jdGlvbkFyZ3MsXG4gIE9wdGlvbmFsUmVzdEFyZ3MsXG4gIFBhcnRpYWxBcGksXG4gIEFyZ3NBbmRPcHRpb25zLFxuICBGdW5jdGlvblJldHVyblR5cGUsXG59IGZyb20gXCIuL2FwaS5qc1wiO1xuZXhwb3J0IHtcbiAgZGVmaW5lQXBwLFxuICBkZWZpbmVDb21wb25lbnQsXG4gIGNvbXBvbmVudHNHZW5lcmljLFxuICBjcmVhdGVGdW5jdGlvbkhhbmRsZSxcbiAgdHlwZSBBbnlDaGlsZENvbXBvbmVudHMsXG59IGZyb20gXCIuL2NvbXBvbmVudHMvaW5kZXguanNcIjtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCB7IGN1cnJlbnRTeXN0ZW1VZGZJbkNvbXBvbmVudCB9IGZyb20gXCIuL2NvbXBvbmVudHMvaW5kZXguanNcIjtcbmV4cG9ydCB7IGdldEZ1bmN0aW9uQWRkcmVzcyB9IGZyb20gXCIuL2NvbXBvbmVudHMvaW5kZXguanNcIjtcbmV4cG9ydCB0eXBlIHtcbiAgQ29tcG9uZW50RGVmaW5pdGlvbixcbiAgQW55Q29tcG9uZW50cyxcbiAgRnVuY3Rpb25IYW5kbGUsXG59IGZyb20gXCIuL2NvbXBvbmVudHMvaW5kZXguanNcIjtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IHR5cGUgeyBJbmRleCwgU2VhcmNoSW5kZXgsIFZlY3RvckluZGV4IH0gZnJvbSBcIi4vc2NoZW1hLmpzXCI7XG5cbmV4cG9ydCB0eXBlIHtcbiAgU2VhcmNoSW5kZXhDb25maWcsXG4gIFZlY3RvckluZGV4Q29uZmlnLFxuICBUYWJsZURlZmluaXRpb24sXG4gIFNjaGVtYURlZmluaXRpb24sXG4gIERlZmluZVNjaGVtYU9wdGlvbnMsXG4gIEdlbmVyaWNTY2hlbWEsXG4gIERhdGFNb2RlbEZyb21TY2hlbWFEZWZpbml0aW9uLFxuICBTeXN0ZW1EYXRhTW9kZWwsXG4gIFN5c3RlbVRhYmxlTmFtZXMsXG59IGZyb20gXCIuL3NjaGVtYS5qc1wiO1xuZXhwb3J0IHsgZGVmaW5lVGFibGUsIGRlZmluZVNjaGVtYSB9IGZyb20gXCIuL3NjaGVtYS5qc1wiO1xuXG5leHBvcnQgdHlwZSB7XG4gIFZlY3RvclNlYXJjaCxcbiAgVmVjdG9yU2VhcmNoUXVlcnksXG4gIFZlY3RvckZpbHRlckJ1aWxkZXIsXG4gIEZpbHRlckV4cHJlc3Npb24sXG59IGZyb20gXCIuL3ZlY3Rvcl9zZWFyY2guanNcIjtcblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCB0eXBlIHsgQmV0dGVyT21pdCwgRXhwYW5kIH0gZnJvbSBcIi4uL3R5cGVfdXRpbHMuanNcIjtcbiIsIlwidXNlIHN0cmljdFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YWJhc2UuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7XG4gIGNvbnZleFRvSnNvbixcbiAganNvblRvQ29udmV4LFxuICB2XG59IGZyb20gXCIuLi8uLi92YWx1ZXMvaW5kZXguanNcIjtcbmltcG9ydCB7IHNldHVwQWN0aW9uQ2FsbHMgfSBmcm9tIFwiLi9hY3Rpb25zX2ltcGwuanNcIjtcbmltcG9ydCB7IHNldHVwQWN0aW9uVmVjdG9yU2VhcmNoIH0gZnJvbSBcIi4vdmVjdG9yX3NlYXJjaF9pbXBsLmpzXCI7XG5pbXBvcnQgeyBzZXR1cEF1dGggfSBmcm9tIFwiLi9hdXRoZW50aWNhdGlvbl9pbXBsLmpzXCI7XG5pbXBvcnQgeyBzZXR1cFJlYWRlciwgc2V0dXBXcml0ZXIgfSBmcm9tIFwiLi9kYXRhYmFzZV9pbXBsLmpzXCI7XG5pbXBvcnQgeyBRdWVyeUltcGwsIFF1ZXJ5SW5pdGlhbGl6ZXJJbXBsIH0gZnJvbSBcIi4vcXVlcnlfaW1wbC5qc1wiO1xuaW1wb3J0IHtcbiAgc2V0dXBBY3Rpb25TY2hlZHVsZXIsXG4gIHNldHVwTXV0YXRpb25TY2hlZHVsZXJcbn0gZnJvbSBcIi4vc2NoZWR1bGVyX2ltcGwuanNcIjtcbmltcG9ydCB7XG4gIHNldHVwU3RvcmFnZUFjdGlvbldyaXRlcixcbiAgc2V0dXBTdG9yYWdlUmVhZGVyLFxuICBzZXR1cFN0b3JhZ2VXcml0ZXJcbn0gZnJvbSBcIi4vc3RvcmFnZV9pbXBsLmpzXCI7XG5pbXBvcnQgeyBwYXJzZUFyZ3MgfSBmcm9tIFwiLi4vLi4vY29tbW9uL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBwZXJmb3JtQXN5bmNTeXNjYWxsIH0gZnJvbSBcIi4vc3lzY2FsbC5qc1wiO1xuaW1wb3J0IHsgYXNPYmplY3RWYWxpZGF0b3IgfSBmcm9tIFwiLi4vLi4vdmFsdWVzL3ZhbGlkYXRvci5qc1wiO1xuaW1wb3J0IHsgZ2V0RnVuY3Rpb25BZGRyZXNzIH0gZnJvbSBcIi4uL2NvbXBvbmVudHMvcGF0aHMuanNcIjtcbmFzeW5jIGZ1bmN0aW9uIGludm9rZU11dGF0aW9uKGZ1bmMsIGFyZ3NTdHIpIHtcbiAgY29uc3QgcmVxdWVzdElkID0gXCJcIjtcbiAgY29uc3QgYXJncyA9IGpzb25Ub0NvbnZleChKU09OLnBhcnNlKGFyZ3NTdHIpKTtcbiAgY29uc3QgbXV0YXRpb25DdHggPSB7XG4gICAgZGI6IHNldHVwV3JpdGVyKCksXG4gICAgYXV0aDogc2V0dXBBdXRoKHJlcXVlc3RJZCksXG4gICAgc3RvcmFnZTogc2V0dXBTdG9yYWdlV3JpdGVyKHJlcXVlc3RJZCksXG4gICAgc2NoZWR1bGVyOiBzZXR1cE11dGF0aW9uU2NoZWR1bGVyKCksXG4gICAgcnVuUXVlcnk6IChyZWZlcmVuY2UsIGFyZ3MyKSA9PiBydW5VZGYoXCJxdWVyeVwiLCByZWZlcmVuY2UsIGFyZ3MyKSxcbiAgICBydW5NdXRhdGlvbjogKHJlZmVyZW5jZSwgYXJnczIpID0+IHJ1blVkZihcIm11dGF0aW9uXCIsIHJlZmVyZW5jZSwgYXJnczIpXG4gIH07XG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGludm9rZUZ1bmN0aW9uKGZ1bmMsIG11dGF0aW9uQ3R4LCBhcmdzKTtcbiAgdmFsaWRhdGVSZXR1cm5WYWx1ZShyZXN1bHQpO1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoY29udmV4VG9Kc29uKHJlc3VsdCA9PT0gdm9pZCAwID8gbnVsbCA6IHJlc3VsdCkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlUmV0dXJuVmFsdWUodjIpIHtcbiAgaWYgKHYyIGluc3RhbmNlb2YgUXVlcnlJbml0aWFsaXplckltcGwgfHwgdjIgaW5zdGFuY2VvZiBRdWVyeUltcGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlJldHVybiB2YWx1ZSBpcyBhIFF1ZXJ5LiBSZXN1bHRzIG11c3QgYmUgcmV0cmlldmVkIHdpdGggYC5jb2xsZWN0KClgLCBgLnRha2UobiksIGAudW5pcXVlKClgLCBvciBgLmZpcnN0KClgLlwiXG4gICAgKTtcbiAgfVxufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGludm9rZUZ1bmN0aW9uKGZ1bmMsIGN0eCwgYXJncykge1xuICBsZXQgcmVzdWx0O1xuICB0cnkge1xuICAgIHJlc3VsdCA9IGF3YWl0IFByb21pc2UucmVzb2x2ZShmdW5jKGN0eCwgLi4uYXJncykpO1xuICB9IGNhdGNoICh0aHJvd24pIHtcbiAgICB0aHJvdyBzZXJpYWxpemVDb252ZXhFcnJvckRhdGEodGhyb3duKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZG9udENhbGxEaXJlY3RseShmdW5jVHlwZSwgaGFuZGxlcikge1xuICByZXR1cm4gKGN0eCwgYXJncykgPT4ge1xuICAgIGdsb2JhbFRoaXMuY29uc29sZS53YXJuKFxuICAgICAgYENvbnZleCBmdW5jdGlvbnMgc2hvdWxkIG5vdCBkaXJlY3RseSBjYWxsIG90aGVyIENvbnZleCBmdW5jdGlvbnMuIENvbnNpZGVyIGNhbGxpbmcgYSBoZWxwZXIgZnVuY3Rpb24gaW5zdGVhZC4gZS5nLiBcXGBleHBvcnQgY29uc3QgZm9vID0gJHtmdW5jVHlwZX0oLi4uKTsgYXdhaXQgZm9vKGN0eCk7XFxgIGlzIG5vdCBzdXBwb3J0ZWQuIFNlZSBodHRwczovL2RvY3MuY29udmV4LmRldi9wcm9kdWN0aW9uL2Jlc3QtcHJhY3RpY2VzLyN1c2UtaGVscGVyLWZ1bmN0aW9ucy10by13cml0ZS1zaGFyZWQtY29kZWBcbiAgICApO1xuICAgIHJldHVybiBoYW5kbGVyKGN0eCwgYXJncyk7XG4gIH07XG59XG5mdW5jdGlvbiBzZXJpYWxpemVDb252ZXhFcnJvckRhdGEodGhyb3duKSB7XG4gIGlmICh0eXBlb2YgdGhyb3duID09PSBcIm9iamVjdFwiICYmIHRocm93biAhPT0gbnVsbCAmJiBTeW1ib2wuZm9yKFwiQ29udmV4RXJyb3JcIikgaW4gdGhyb3duKSB7XG4gICAgY29uc3QgZXJyb3IgPSB0aHJvd247XG4gICAgZXJyb3IuZGF0YSA9IEpTT04uc3RyaW5naWZ5KFxuICAgICAgY29udmV4VG9Kc29uKGVycm9yLmRhdGEgPT09IHZvaWQgMCA/IG51bGwgOiBlcnJvci5kYXRhKVxuICAgICk7XG4gICAgZXJyb3IuQ29udmV4RXJyb3JTeW1ib2wgPSBTeW1ib2wuZm9yKFwiQ29udmV4RXJyb3JcIik7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aHJvd247XG4gIH1cbn1cbmZ1bmN0aW9uIGFzc2VydE5vdEJyb3dzZXIoKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8IHdpbmRvdy5fX2NvbnZleEFsbG93RnVuY3Rpb25zSW5Ccm93c2VyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGlzUmVhbEJyb3dzZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGdsb2JhbFRoaXMsIFwid2luZG93XCIpPy5nZXQ/LnRvU3RyaW5nKCkuaW5jbHVkZXMoXCJbbmF0aXZlIGNvZGVdXCIpID8/IGZhbHNlO1xuICBpZiAoaXNSZWFsQnJvd3Nlcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICBcIkNvbnZleCBmdW5jdGlvbnMgc2hvdWxkIG5vdCBiZSBpbXBvcnRlZCBpbiB0aGUgYnJvd3Nlci4gVGhpcyB3aWxsIHRocm93IGFuIGVycm9yIGluIGZ1dHVyZSB2ZXJzaW9ucyBvZiBgY29udmV4YC4gSWYgdGhpcyBpcyBhIGZhbHNlIG5lZ2F0aXZlLCBwbGVhc2UgcmVwb3J0IGl0IHRvIENvbnZleCBzdXBwb3J0LlwiXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gc3RyaWN0UmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBBIHZhbGlkYXRvciBpcyB1bmRlZmluZWQgZm9yIGZpZWxkIFwiJHtrZXl9XCIuIFRoaXMgaXMgb2Z0ZW4gY2F1c2VkIGJ5IGNpcmN1bGFyIGltcG9ydHMuIFNlZSBodHRwczovL2RvY3MuY29udmV4LmRldi9lcnJvciN1bmRlZmluZWQtdmFsaWRhdG9yIGZvciBkZXRhaWxzLmBcbiAgICApO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGV4cG9ydEFyZ3MoZnVuY3Rpb25EZWZpbml0aW9uKSB7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgbGV0IGFyZ3MgPSB2LmFueSgpO1xuICAgIGlmICh0eXBlb2YgZnVuY3Rpb25EZWZpbml0aW9uID09PSBcIm9iamVjdFwiICYmIGZ1bmN0aW9uRGVmaW5pdGlvbi5hcmdzICE9PSB2b2lkIDApIHtcbiAgICAgIGFyZ3MgPSBhc09iamVjdFZhbGlkYXRvcihmdW5jdGlvbkRlZmluaXRpb24uYXJncyk7XG4gICAgfVxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzLmpzb24sIHN0cmljdFJlcGxhY2VyKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGV4cG9ydFJldHVybnMoZnVuY3Rpb25EZWZpbml0aW9uKSB7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgbGV0IHJldHVybnM7XG4gICAgaWYgKHR5cGVvZiBmdW5jdGlvbkRlZmluaXRpb24gPT09IFwib2JqZWN0XCIgJiYgZnVuY3Rpb25EZWZpbml0aW9uLnJldHVybnMgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJucyA9IGFzT2JqZWN0VmFsaWRhdG9yKGZ1bmN0aW9uRGVmaW5pdGlvbi5yZXR1cm5zKTtcbiAgICB9XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHJldHVybnMgPyByZXR1cm5zLmpzb24gOiBudWxsLCBzdHJpY3RSZXBsYWNlcik7XG4gIH07XG59XG5leHBvcnQgY29uc3QgbXV0YXRpb25HZW5lcmljID0gKGZ1bmN0aW9uRGVmaW5pdGlvbikgPT4ge1xuICBjb25zdCBoYW5kbGVyID0gdHlwZW9mIGZ1bmN0aW9uRGVmaW5pdGlvbiA9PT0gXCJmdW5jdGlvblwiID8gZnVuY3Rpb25EZWZpbml0aW9uIDogZnVuY3Rpb25EZWZpbml0aW9uLmhhbmRsZXI7XG4gIGNvbnN0IGZ1bmMgPSBkb250Q2FsbERpcmVjdGx5KFwibXV0YXRpb25cIiwgaGFuZGxlcik7XG4gIGFzc2VydE5vdEJyb3dzZXIoKTtcbiAgZnVuYy5pc011dGF0aW9uID0gdHJ1ZTtcbiAgZnVuYy5pc1B1YmxpYyA9IHRydWU7XG4gIGZ1bmMuaW52b2tlTXV0YXRpb24gPSAoYXJnc1N0cikgPT4gaW52b2tlTXV0YXRpb24oaGFuZGxlciwgYXJnc1N0cik7XG4gIGZ1bmMuZXhwb3J0QXJncyA9IGV4cG9ydEFyZ3MoZnVuY3Rpb25EZWZpbml0aW9uKTtcbiAgZnVuYy5leHBvcnRSZXR1cm5zID0gZXhwb3J0UmV0dXJucyhmdW5jdGlvbkRlZmluaXRpb24pO1xuICBmdW5jLl9oYW5kbGVyID0gaGFuZGxlcjtcbiAgcmV0dXJuIGZ1bmM7XG59O1xuZXhwb3J0IGNvbnN0IGludGVybmFsTXV0YXRpb25HZW5lcmljID0gKGZ1bmN0aW9uRGVmaW5pdGlvbikgPT4ge1xuICBjb25zdCBoYW5kbGVyID0gdHlwZW9mIGZ1bmN0aW9uRGVmaW5pdGlvbiA9PT0gXCJmdW5jdGlvblwiID8gZnVuY3Rpb25EZWZpbml0aW9uIDogZnVuY3Rpb25EZWZpbml0aW9uLmhhbmRsZXI7XG4gIGNvbnN0IGZ1bmMgPSBkb250Q2FsbERpcmVjdGx5KFxuICAgIFwiaW50ZXJuYWxNdXRhdGlvblwiLFxuICAgIGhhbmRsZXJcbiAgKTtcbiAgYXNzZXJ0Tm90QnJvd3NlcigpO1xuICBmdW5jLmlzTXV0YXRpb24gPSB0cnVlO1xuICBmdW5jLmlzSW50ZXJuYWwgPSB0cnVlO1xuICBmdW5jLmludm9rZU11dGF0aW9uID0gKGFyZ3NTdHIpID0+IGludm9rZU11dGF0aW9uKGhhbmRsZXIsIGFyZ3NTdHIpO1xuICBmdW5jLmV4cG9ydEFyZ3MgPSBleHBvcnRBcmdzKGZ1bmN0aW9uRGVmaW5pdGlvbik7XG4gIGZ1bmMuZXhwb3J0UmV0dXJucyA9IGV4cG9ydFJldHVybnMoZnVuY3Rpb25EZWZpbml0aW9uKTtcbiAgZnVuYy5faGFuZGxlciA9IGhhbmRsZXI7XG4gIHJldHVybiBmdW5jO1xufTtcbmFzeW5jIGZ1bmN0aW9uIGludm9rZVF1ZXJ5KGZ1bmMsIGFyZ3NTdHIpIHtcbiAgY29uc3QgcmVxdWVzdElkID0gXCJcIjtcbiAgY29uc3QgYXJncyA9IGpzb25Ub0NvbnZleChKU09OLnBhcnNlKGFyZ3NTdHIpKTtcbiAgY29uc3QgcXVlcnlDdHggPSB7XG4gICAgZGI6IHNldHVwUmVhZGVyKCksXG4gICAgYXV0aDogc2V0dXBBdXRoKHJlcXVlc3RJZCksXG4gICAgc3RvcmFnZTogc2V0dXBTdG9yYWdlUmVhZGVyKHJlcXVlc3RJZCksXG4gICAgcnVuUXVlcnk6IChyZWZlcmVuY2UsIGFyZ3MyKSA9PiBydW5VZGYoXCJxdWVyeVwiLCByZWZlcmVuY2UsIGFyZ3MyKVxuICB9O1xuICBjb25zdCByZXN1bHQgPSBhd2FpdCBpbnZva2VGdW5jdGlvbihmdW5jLCBxdWVyeUN0eCwgYXJncyk7XG4gIHZhbGlkYXRlUmV0dXJuVmFsdWUocmVzdWx0KTtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGNvbnZleFRvSnNvbihyZXN1bHQgPT09IHZvaWQgMCA/IG51bGwgOiByZXN1bHQpKTtcbn1cbmV4cG9ydCBjb25zdCBxdWVyeUdlbmVyaWMgPSAoZnVuY3Rpb25EZWZpbml0aW9uKSA9PiB7XG4gIGNvbnN0IGhhbmRsZXIgPSB0eXBlb2YgZnVuY3Rpb25EZWZpbml0aW9uID09PSBcImZ1bmN0aW9uXCIgPyBmdW5jdGlvbkRlZmluaXRpb24gOiBmdW5jdGlvbkRlZmluaXRpb24uaGFuZGxlcjtcbiAgY29uc3QgZnVuYyA9IGRvbnRDYWxsRGlyZWN0bHkoXCJxdWVyeVwiLCBoYW5kbGVyKTtcbiAgYXNzZXJ0Tm90QnJvd3NlcigpO1xuICBmdW5jLmlzUXVlcnkgPSB0cnVlO1xuICBmdW5jLmlzUHVibGljID0gdHJ1ZTtcbiAgZnVuYy5pbnZva2VRdWVyeSA9IChhcmdzU3RyKSA9PiBpbnZva2VRdWVyeShoYW5kbGVyLCBhcmdzU3RyKTtcbiAgZnVuYy5leHBvcnRBcmdzID0gZXhwb3J0QXJncyhmdW5jdGlvbkRlZmluaXRpb24pO1xuICBmdW5jLmV4cG9ydFJldHVybnMgPSBleHBvcnRSZXR1cm5zKGZ1bmN0aW9uRGVmaW5pdGlvbik7XG4gIGZ1bmMuX2hhbmRsZXIgPSBoYW5kbGVyO1xuICByZXR1cm4gZnVuYztcbn07XG5leHBvcnQgY29uc3QgaW50ZXJuYWxRdWVyeUdlbmVyaWMgPSAoZnVuY3Rpb25EZWZpbml0aW9uKSA9PiB7XG4gIGNvbnN0IGhhbmRsZXIgPSB0eXBlb2YgZnVuY3Rpb25EZWZpbml0aW9uID09PSBcImZ1bmN0aW9uXCIgPyBmdW5jdGlvbkRlZmluaXRpb24gOiBmdW5jdGlvbkRlZmluaXRpb24uaGFuZGxlcjtcbiAgY29uc3QgZnVuYyA9IGRvbnRDYWxsRGlyZWN0bHkoXCJpbnRlcm5hbFF1ZXJ5XCIsIGhhbmRsZXIpO1xuICBhc3NlcnROb3RCcm93c2VyKCk7XG4gIGZ1bmMuaXNRdWVyeSA9IHRydWU7XG4gIGZ1bmMuaXNJbnRlcm5hbCA9IHRydWU7XG4gIGZ1bmMuaW52b2tlUXVlcnkgPSAoYXJnc1N0cikgPT4gaW52b2tlUXVlcnkoaGFuZGxlciwgYXJnc1N0cik7XG4gIGZ1bmMuZXhwb3J0QXJncyA9IGV4cG9ydEFyZ3MoZnVuY3Rpb25EZWZpbml0aW9uKTtcbiAgZnVuYy5leHBvcnRSZXR1cm5zID0gZXhwb3J0UmV0dXJucyhmdW5jdGlvbkRlZmluaXRpb24pO1xuICBmdW5jLl9oYW5kbGVyID0gaGFuZGxlcjtcbiAgcmV0dXJuIGZ1bmM7XG59O1xuYXN5bmMgZnVuY3Rpb24gaW52b2tlQWN0aW9uKGZ1bmMsIHJlcXVlc3RJZCwgYXJnc1N0cikge1xuICBjb25zdCBhcmdzID0ganNvblRvQ29udmV4KEpTT04ucGFyc2UoYXJnc1N0cikpO1xuICBjb25zdCBjYWxscyA9IHNldHVwQWN0aW9uQ2FsbHMocmVxdWVzdElkKTtcbiAgY29uc3QgY3R4ID0ge1xuICAgIC4uLmNhbGxzLFxuICAgIGF1dGg6IHNldHVwQXV0aChyZXF1ZXN0SWQpLFxuICAgIHNjaGVkdWxlcjogc2V0dXBBY3Rpb25TY2hlZHVsZXIocmVxdWVzdElkKSxcbiAgICBzdG9yYWdlOiBzZXR1cFN0b3JhZ2VBY3Rpb25Xcml0ZXIocmVxdWVzdElkKSxcbiAgICB2ZWN0b3JTZWFyY2g6IHNldHVwQWN0aW9uVmVjdG9yU2VhcmNoKHJlcXVlc3RJZClcbiAgfTtcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaW52b2tlRnVuY3Rpb24oZnVuYywgY3R4LCBhcmdzKTtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGNvbnZleFRvSnNvbihyZXN1bHQgPT09IHZvaWQgMCA/IG51bGwgOiByZXN1bHQpKTtcbn1cbmV4cG9ydCBjb25zdCBhY3Rpb25HZW5lcmljID0gKGZ1bmN0aW9uRGVmaW5pdGlvbikgPT4ge1xuICBjb25zdCBoYW5kbGVyID0gdHlwZW9mIGZ1bmN0aW9uRGVmaW5pdGlvbiA9PT0gXCJmdW5jdGlvblwiID8gZnVuY3Rpb25EZWZpbml0aW9uIDogZnVuY3Rpb25EZWZpbml0aW9uLmhhbmRsZXI7XG4gIGNvbnN0IGZ1bmMgPSBkb250Q2FsbERpcmVjdGx5KFwiYWN0aW9uXCIsIGhhbmRsZXIpO1xuICBhc3NlcnROb3RCcm93c2VyKCk7XG4gIGZ1bmMuaXNBY3Rpb24gPSB0cnVlO1xuICBmdW5jLmlzUHVibGljID0gdHJ1ZTtcbiAgZnVuYy5pbnZva2VBY3Rpb24gPSAocmVxdWVzdElkLCBhcmdzU3RyKSA9PiBpbnZva2VBY3Rpb24oaGFuZGxlciwgcmVxdWVzdElkLCBhcmdzU3RyKTtcbiAgZnVuYy5leHBvcnRBcmdzID0gZXhwb3J0QXJncyhmdW5jdGlvbkRlZmluaXRpb24pO1xuICBmdW5jLmV4cG9ydFJldHVybnMgPSBleHBvcnRSZXR1cm5zKGZ1bmN0aW9uRGVmaW5pdGlvbik7XG4gIGZ1bmMuX2hhbmRsZXIgPSBoYW5kbGVyO1xuICByZXR1cm4gZnVuYztcbn07XG5leHBvcnQgY29uc3QgaW50ZXJuYWxBY3Rpb25HZW5lcmljID0gKGZ1bmN0aW9uRGVmaW5pdGlvbikgPT4ge1xuICBjb25zdCBoYW5kbGVyID0gdHlwZW9mIGZ1bmN0aW9uRGVmaW5pdGlvbiA9PT0gXCJmdW5jdGlvblwiID8gZnVuY3Rpb25EZWZpbml0aW9uIDogZnVuY3Rpb25EZWZpbml0aW9uLmhhbmRsZXI7XG4gIGNvbnN0IGZ1bmMgPSBkb250Q2FsbERpcmVjdGx5KFwiaW50ZXJuYWxBY3Rpb25cIiwgaGFuZGxlcik7XG4gIGFzc2VydE5vdEJyb3dzZXIoKTtcbiAgZnVuYy5pc0FjdGlvbiA9IHRydWU7XG4gIGZ1bmMuaXNJbnRlcm5hbCA9IHRydWU7XG4gIGZ1bmMuaW52b2tlQWN0aW9uID0gKHJlcXVlc3RJZCwgYXJnc1N0cikgPT4gaW52b2tlQWN0aW9uKGhhbmRsZXIsIHJlcXVlc3RJZCwgYXJnc1N0cik7XG4gIGZ1bmMuZXhwb3J0QXJncyA9IGV4cG9ydEFyZ3MoZnVuY3Rpb25EZWZpbml0aW9uKTtcbiAgZnVuYy5leHBvcnRSZXR1cm5zID0gZXhwb3J0UmV0dXJucyhmdW5jdGlvbkRlZmluaXRpb24pO1xuICBmdW5jLl9oYW5kbGVyID0gaGFuZGxlcjtcbiAgcmV0dXJuIGZ1bmM7XG59O1xuYXN5bmMgZnVuY3Rpb24gaW52b2tlSHR0cEFjdGlvbihmdW5jLCByZXF1ZXN0KSB7XG4gIGNvbnN0IHJlcXVlc3RJZCA9IFwiXCI7XG4gIGNvbnN0IGNhbGxzID0gc2V0dXBBY3Rpb25DYWxscyhyZXF1ZXN0SWQpO1xuICBjb25zdCBjdHggPSB7XG4gICAgLi4uY2FsbHMsXG4gICAgYXV0aDogc2V0dXBBdXRoKHJlcXVlc3RJZCksXG4gICAgc3RvcmFnZTogc2V0dXBTdG9yYWdlQWN0aW9uV3JpdGVyKHJlcXVlc3RJZCksXG4gICAgc2NoZWR1bGVyOiBzZXR1cEFjdGlvblNjaGVkdWxlcihyZXF1ZXN0SWQpLFxuICAgIHZlY3RvclNlYXJjaDogc2V0dXBBY3Rpb25WZWN0b3JTZWFyY2gocmVxdWVzdElkKVxuICB9O1xuICByZXR1cm4gYXdhaXQgaW52b2tlRnVuY3Rpb24oZnVuYywgY3R4LCBbcmVxdWVzdF0pO1xufVxuZXhwb3J0IGNvbnN0IGh0dHBBY3Rpb25HZW5lcmljID0gKGZ1bmMpID0+IHtcbiAgY29uc3QgcSA9IGRvbnRDYWxsRGlyZWN0bHkoXCJodHRwQWN0aW9uXCIsIGZ1bmMpO1xuICBhc3NlcnROb3RCcm93c2VyKCk7XG4gIHEuaXNIdHRwID0gdHJ1ZTtcbiAgcS5pbnZva2VIdHRwQWN0aW9uID0gKHJlcXVlc3QpID0+IGludm9rZUh0dHBBY3Rpb24oZnVuYywgcmVxdWVzdCk7XG4gIHEuX2hhbmRsZXIgPSBmdW5jO1xuICByZXR1cm4gcTtcbn07XG5hc3luYyBmdW5jdGlvbiBydW5VZGYodWRmVHlwZSwgZiwgYXJncykge1xuICBjb25zdCBxdWVyeUFyZ3MgPSBwYXJzZUFyZ3MoYXJncyk7XG4gIGNvbnN0IHN5c2NhbGxBcmdzID0ge1xuICAgIHVkZlR5cGUsXG4gICAgYXJnczogY29udmV4VG9Kc29uKHF1ZXJ5QXJncyksXG4gICAgLi4uZ2V0RnVuY3Rpb25BZGRyZXNzKGYpXG4gIH07XG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHBlcmZvcm1Bc3luY1N5c2NhbGwoXCIxLjAvcnVuVWRmXCIsIHN5c2NhbGxBcmdzKTtcbiAgcmV0dXJuIGpzb25Ub0NvbnZleChyZXN1bHQpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVnaXN0cmF0aW9uX2ltcGwuanMubWFwXG4iLCJpbXBvcnQge1xuICBDb252ZXhFcnJvcixcbiAgY29udmV4VG9Kc29uLFxuICBHZW5lcmljVmFsaWRhdG9yLFxuICBqc29uVG9Db252ZXgsXG4gIHYsXG4gIFZhbGlkYXRvcixcbiAgVmFsdWUsXG59IGZyb20gXCIuLi8uLi92YWx1ZXMvaW5kZXguanNcIjtcbmltcG9ydCB7IEdlbmVyaWNEYXRhTW9kZWwgfSBmcm9tIFwiLi4vZGF0YV9tb2RlbC5qc1wiO1xuaW1wb3J0IHtcbiAgQWN0aW9uQnVpbGRlcixcbiAgRGVmYXVsdEZ1bmN0aW9uQXJncyxcbiAgR2VuZXJpY0FjdGlvbkN0eCxcbiAgR2VuZXJpY011dGF0aW9uQ3R4LFxuICBHZW5lcmljUXVlcnlDdHgsXG4gIE11dGF0aW9uQnVpbGRlcixcbiAgUHVibGljSHR0cEFjdGlvbixcbiAgUXVlcnlCdWlsZGVyLFxuICBSZWdpc3RlcmVkQWN0aW9uLFxuICBSZWdpc3RlcmVkTXV0YXRpb24sXG4gIFJlZ2lzdGVyZWRRdWVyeSxcbn0gZnJvbSBcIi4uL3JlZ2lzdHJhdGlvbi5qc1wiO1xuaW1wb3J0IHsgc2V0dXBBY3Rpb25DYWxscyB9IGZyb20gXCIuL2FjdGlvbnNfaW1wbC5qc1wiO1xuaW1wb3J0IHsgc2V0dXBBY3Rpb25WZWN0b3JTZWFyY2ggfSBmcm9tIFwiLi92ZWN0b3Jfc2VhcmNoX2ltcGwuanNcIjtcbmltcG9ydCB7IHNldHVwQXV0aCB9IGZyb20gXCIuL2F1dGhlbnRpY2F0aW9uX2ltcGwuanNcIjtcbmltcG9ydCB7IHNldHVwUmVhZGVyLCBzZXR1cFdyaXRlciB9IGZyb20gXCIuL2RhdGFiYXNlX2ltcGwuanNcIjtcbmltcG9ydCB7IFF1ZXJ5SW1wbCwgUXVlcnlJbml0aWFsaXplckltcGwgfSBmcm9tIFwiLi9xdWVyeV9pbXBsLmpzXCI7XG5pbXBvcnQge1xuICBzZXR1cEFjdGlvblNjaGVkdWxlcixcbiAgc2V0dXBNdXRhdGlvblNjaGVkdWxlcixcbn0gZnJvbSBcIi4vc2NoZWR1bGVyX2ltcGwuanNcIjtcbmltcG9ydCB7XG4gIHNldHVwU3RvcmFnZUFjdGlvbldyaXRlcixcbiAgc2V0dXBTdG9yYWdlUmVhZGVyLFxuICBzZXR1cFN0b3JhZ2VXcml0ZXIsXG59IGZyb20gXCIuL3N0b3JhZ2VfaW1wbC5qc1wiO1xuaW1wb3J0IHsgcGFyc2VBcmdzIH0gZnJvbSBcIi4uLy4uL2NvbW1vbi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgcGVyZm9ybUFzeW5jU3lzY2FsbCB9IGZyb20gXCIuL3N5c2NhbGwuanNcIjtcbmltcG9ydCB7IGFzT2JqZWN0VmFsaWRhdG9yIH0gZnJvbSBcIi4uLy4uL3ZhbHVlcy92YWxpZGF0b3IuanNcIjtcbmltcG9ydCB7IGdldEZ1bmN0aW9uQWRkcmVzcyB9IGZyb20gXCIuLi9jb21wb25lbnRzL3BhdGhzLmpzXCI7XG5cbmFzeW5jIGZ1bmN0aW9uIGludm9rZU11dGF0aW9uPFxuICBGIGV4dGVuZHMgKGN0eDogR2VuZXJpY011dGF0aW9uQ3R4PEdlbmVyaWNEYXRhTW9kZWw+LCAuLi5hcmdzOiBhbnkpID0+IGFueSxcbj4oZnVuYzogRiwgYXJnc1N0cjogc3RyaW5nKSB7XG4gIC8vIFRPRE8ocHJlc2xleSk6IENoYW5nZSB0aGUgZnVuY3Rpb24gc2lnbmF0dXJlIGFuZCBwcm9wYWdhdGUgdGhlIHJlcXVlc3RJZCBmcm9tIFJ1c3QuXG4gIC8vIE9rLCB0byBtb2NrIGl0IG91dCBmb3Igbm93LCBzaW5jZSBxdWVyaWVzIGFyZSBvbmx5IHJ1bm5pbmcgaW4gVjguXG4gIGNvbnN0IHJlcXVlc3RJZCA9IFwiXCI7XG4gIGNvbnN0IGFyZ3MgPSBqc29uVG9Db252ZXgoSlNPTi5wYXJzZShhcmdzU3RyKSk7XG4gIGNvbnN0IG11dGF0aW9uQ3R4ID0ge1xuICAgIGRiOiBzZXR1cFdyaXRlcigpLFxuICAgIGF1dGg6IHNldHVwQXV0aChyZXF1ZXN0SWQpLFxuICAgIHN0b3JhZ2U6IHNldHVwU3RvcmFnZVdyaXRlcihyZXF1ZXN0SWQpLFxuICAgIHNjaGVkdWxlcjogc2V0dXBNdXRhdGlvblNjaGVkdWxlcigpLFxuXG4gICAgcnVuUXVlcnk6IChyZWZlcmVuY2U6IGFueSwgYXJncz86IGFueSkgPT4gcnVuVWRmKFwicXVlcnlcIiwgcmVmZXJlbmNlLCBhcmdzKSxcbiAgICBydW5NdXRhdGlvbjogKHJlZmVyZW5jZTogYW55LCBhcmdzPzogYW55KSA9PlxuICAgICAgcnVuVWRmKFwibXV0YXRpb25cIiwgcmVmZXJlbmNlLCBhcmdzKSxcbiAgfTtcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaW52b2tlRnVuY3Rpb24oZnVuYywgbXV0YXRpb25DdHgsIGFyZ3MgYXMgYW55KTtcbiAgdmFsaWRhdGVSZXR1cm5WYWx1ZShyZXN1bHQpO1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoY29udmV4VG9Kc29uKHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHJlc3VsdCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVSZXR1cm5WYWx1ZSh2OiBhbnkpIHtcbiAgaWYgKHYgaW5zdGFuY2VvZiBRdWVyeUluaXRpYWxpemVySW1wbCB8fCB2IGluc3RhbmNlb2YgUXVlcnlJbXBsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJSZXR1cm4gdmFsdWUgaXMgYSBRdWVyeS4gUmVzdWx0cyBtdXN0IGJlIHJldHJpZXZlZCB3aXRoIGAuY29sbGVjdCgpYCwgYC50YWtlKG4pLCBgLnVuaXF1ZSgpYCwgb3IgYC5maXJzdCgpYC5cIixcbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbnZva2VGdW5jdGlvbjxcbiAgQ3R4LFxuICBBcmdzIGV4dGVuZHMgYW55W10sXG4gIEYgZXh0ZW5kcyAoY3R4OiBDdHgsIC4uLmFyZ3M6IEFyZ3MpID0+IGFueSxcbj4oZnVuYzogRiwgY3R4OiBDdHgsIGFyZ3M6IEFyZ3MpIHtcbiAgbGV0IHJlc3VsdDtcbiAgdHJ5IHtcbiAgICByZXN1bHQgPSBhd2FpdCBQcm9taXNlLnJlc29sdmUoZnVuYyhjdHgsIC4uLmFyZ3MpKTtcbiAgfSBjYXRjaCAodGhyb3duOiB1bmtub3duKSB7XG4gICAgdGhyb3cgc2VyaWFsaXplQ29udmV4RXJyb3JEYXRhKHRocm93bik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZG9udENhbGxEaXJlY3RseShcbiAgZnVuY1R5cGU6IHN0cmluZyxcbiAgaGFuZGxlcjogKGN0eDogYW55LCBhcmdzOiBhbnkpID0+IGFueSxcbik6IHVua25vd24ge1xuICByZXR1cm4gKGN0eDogYW55LCBhcmdzOiBhbnkpID0+IHtcbiAgICBnbG9iYWxUaGlzLmNvbnNvbGUud2FybihcbiAgICAgIFwiQ29udmV4IGZ1bmN0aW9ucyBzaG91bGQgbm90IGRpcmVjdGx5IGNhbGwgb3RoZXIgQ29udmV4IGZ1bmN0aW9ucy4gQ29uc2lkZXIgY2FsbGluZyBhIGhlbHBlciBmdW5jdGlvbiBpbnN0ZWFkLiBcIiArXG4gICAgICAgIGBlLmcuIFxcYGV4cG9ydCBjb25zdCBmb28gPSAke2Z1bmNUeXBlfSguLi4pOyBhd2FpdCBmb28oY3R4KTtcXGAgaXMgbm90IHN1cHBvcnRlZC4gYCArXG4gICAgICAgIFwiU2VlIGh0dHBzOi8vZG9jcy5jb252ZXguZGV2L3Byb2R1Y3Rpb24vYmVzdC1wcmFjdGljZXMvI3VzZS1oZWxwZXItZnVuY3Rpb25zLXRvLXdyaXRlLXNoYXJlZC1jb2RlXCIsXG4gICAgKTtcbiAgICByZXR1cm4gaGFuZGxlcihjdHgsIGFyZ3MpO1xuICB9O1xufVxuXG4vLyBLZWVwIGluIHN5bmMgd2l0aCBub2RlIGV4ZWN1dG9yXG5mdW5jdGlvbiBzZXJpYWxpemVDb252ZXhFcnJvckRhdGEodGhyb3duOiB1bmtub3duKSB7XG4gIGlmIChcbiAgICB0eXBlb2YgdGhyb3duID09PSBcIm9iamVjdFwiICYmXG4gICAgdGhyb3duICE9PSBudWxsICYmXG4gICAgU3ltYm9sLmZvcihcIkNvbnZleEVycm9yXCIpIGluIHRocm93blxuICApIHtcbiAgICBjb25zdCBlcnJvciA9IHRocm93biBhcyBDb252ZXhFcnJvcjxhbnk+O1xuICAgIGVycm9yLmRhdGEgPSBKU09OLnN0cmluZ2lmeShcbiAgICAgIGNvbnZleFRvSnNvbihlcnJvci5kYXRhID09PSB1bmRlZmluZWQgPyBudWxsIDogZXJyb3IuZGF0YSksXG4gICAgKTtcbiAgICAoZXJyb3IgYXMgYW55KS5Db252ZXhFcnJvclN5bWJvbCA9IFN5bWJvbC5mb3IoXCJDb252ZXhFcnJvclwiKTtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRocm93bjtcbiAgfVxufVxuXG4vKipcbiAqIEd1YXJkIGFnYWluc3QgQ29udmV4IGZ1bmN0aW9ucyBhY2NpZGVudGFsbHkgZ2V0dGluZyBpbmNsdWRlZCBpbiBhIGJyb3dzZXIgYnVuZGxlLlxuICogQ29udmV4IGZ1bmN0aW9ucyBtYXkgaW5jbHVkZSBzZWNyZXQgbG9naWMgb3IgY3JlZGVudGlhbHMgdGhhdCBzaG91bGQgbm90IGJlXG4gKiBzZW5kIHRvIHVudHJ1c3RlZCBjbGllbnRzIChicm93c2VycykuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydE5vdEJyb3dzZXIoKSB7XG4gIGlmIChcbiAgICB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8XG4gICAgKHdpbmRvdyBhcyBhbnkpLl9fY29udmV4QWxsb3dGdW5jdGlvbnNJbkJyb3dzZXJcbiAgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIEpTRG9tIGRvZXNuJ3QgY291bnQsIGRldmVsb3BlcnMgYXJlIGFsbG93ZWQgdG8gdXNlIEpTRG9tIGluIENvbnZleCBmdW5jdGlvbnMuXG4gIGNvbnN0IGlzUmVhbEJyb3dzZXIgPVxuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZ2xvYmFsVGhpcywgXCJ3aW5kb3dcIilcbiAgICAgID8uZ2V0Py50b1N0cmluZygpXG4gICAgICAuaW5jbHVkZXMoXCJbbmF0aXZlIGNvZGVdXCIpID8/IGZhbHNlO1xuICBpZiAoaXNSZWFsQnJvd3Nlcikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIFwiQ29udmV4IGZ1bmN0aW9ucyBzaG91bGQgbm90IGJlIGltcG9ydGVkIGluIHRoZSBicm93c2VyLiBUaGlzIHdpbGwgdGhyb3cgYW4gZXJyb3IgaW4gZnV0dXJlIHZlcnNpb25zIG9mIGBjb252ZXhgLiBJZiB0aGlzIGlzIGEgZmFsc2UgbmVnYXRpdmUsIHBsZWFzZSByZXBvcnQgaXQgdG8gQ29udmV4IHN1cHBvcnQuXCIsXG4gICAgKTtcbiAgfVxufVxuXG50eXBlIEZ1bmN0aW9uRGVmaW5pdGlvbiA9XG4gIHwgKChjdHg6IGFueSwgYXJnczogRGVmYXVsdEZ1bmN0aW9uQXJncykgPT4gYW55KVxuICB8IHtcbiAgICAgIGFyZ3M/OiBHZW5lcmljVmFsaWRhdG9yIHwgUmVjb3JkPHN0cmluZywgR2VuZXJpY1ZhbGlkYXRvcj47XG4gICAgICByZXR1cm5zPzogR2VuZXJpY1ZhbGlkYXRvciB8IFJlY29yZDxzdHJpbmcsIEdlbmVyaWNWYWxpZGF0b3I+O1xuICAgICAgaGFuZGxlcjogKGN0eDogYW55LCBhcmdzOiBEZWZhdWx0RnVuY3Rpb25BcmdzKSA9PiBhbnk7XG4gICAgfTtcblxuZnVuY3Rpb24gc3RyaWN0UmVwbGFjZXIoa2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkpIHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQSB2YWxpZGF0b3IgaXMgdW5kZWZpbmVkIGZvciBmaWVsZCBcIiR7a2V5fVwiLiBgICtcbiAgICAgICAgYFRoaXMgaXMgb2Z0ZW4gY2F1c2VkIGJ5IGNpcmN1bGFyIGltcG9ydHMuIGAgK1xuICAgICAgICBgU2VlIGh0dHBzOi8vZG9jcy5jb252ZXguZGV2L2Vycm9yI3VuZGVmaW5lZC12YWxpZGF0b3IgZm9yIGRldGFpbHMuYCxcbiAgICApO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGV4cG9ydEFyZ3MoZnVuY3Rpb25EZWZpbml0aW9uOiBGdW5jdGlvbkRlZmluaXRpb24pIHtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBsZXQgYXJnczogR2VuZXJpY1ZhbGlkYXRvciA9IHYuYW55KCk7XG4gICAgaWYgKFxuICAgICAgdHlwZW9mIGZ1bmN0aW9uRGVmaW5pdGlvbiA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgZnVuY3Rpb25EZWZpbml0aW9uLmFyZ3MgIT09IHVuZGVmaW5lZFxuICAgICkge1xuICAgICAgYXJncyA9IGFzT2JqZWN0VmFsaWRhdG9yKGZ1bmN0aW9uRGVmaW5pdGlvbi5hcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3MuanNvbiwgc3RyaWN0UmVwbGFjZXIpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBleHBvcnRSZXR1cm5zKGZ1bmN0aW9uRGVmaW5pdGlvbjogRnVuY3Rpb25EZWZpbml0aW9uKSB7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgbGV0IHJldHVybnM6IFZhbGlkYXRvcjxhbnksIGFueSwgYW55PiB8IHVuZGVmaW5lZDtcbiAgICBpZiAoXG4gICAgICB0eXBlb2YgZnVuY3Rpb25EZWZpbml0aW9uID09PSBcIm9iamVjdFwiICYmXG4gICAgICBmdW5jdGlvbkRlZmluaXRpb24ucmV0dXJucyAhPT0gdW5kZWZpbmVkXG4gICAgKSB7XG4gICAgICByZXR1cm5zID0gYXNPYmplY3RWYWxpZGF0b3IoZnVuY3Rpb25EZWZpbml0aW9uLnJldHVybnMpO1xuICAgIH1cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocmV0dXJucyA/IHJldHVybnMuanNvbiA6IG51bGwsIHN0cmljdFJlcGxhY2VyKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSBtdXRhdGlvbiBpbiB0aGlzIENvbnZleCBhcHAncyBwdWJsaWMgQVBJLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBhbGxvd2VkIHRvIG1vZGlmeSB5b3VyIENvbnZleCBkYXRhYmFzZSBhbmQgd2lsbCBiZSBhY2Nlc3NpYmxlIGZyb20gdGhlIGNsaWVudC5cbiAqXG4gKiBJZiB5b3UncmUgdXNpbmcgY29kZSBnZW5lcmF0aW9uLCB1c2UgdGhlIGBtdXRhdGlvbmAgZnVuY3Rpb24gaW5cbiAqIGBjb252ZXgvX2dlbmVyYXRlZC9zZXJ2ZXIuZC50c2Agd2hpY2ggaXMgdHlwZWQgZm9yIHlvdXIgZGF0YSBtb2RlbC5cbiAqXG4gKiBAcGFyYW0gZnVuYyAtIFRoZSBtdXRhdGlvbiBmdW5jdGlvbi4gSXQgcmVjZWl2ZXMgYSB7QGxpbmsgR2VuZXJpY011dGF0aW9uQ3R4fSBhcyBpdHMgZmlyc3QgYXJndW1lbnQuXG4gKiBAcmV0dXJucyBUaGUgd3JhcHBlZCBtdXRhdGlvbi4gSW5jbHVkZSB0aGlzIGFzIGFuIGBleHBvcnRgIHRvIG5hbWUgaXQgYW5kIG1ha2UgaXQgYWNjZXNzaWJsZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBtdXRhdGlvbkdlbmVyaWM6IE11dGF0aW9uQnVpbGRlcjxhbnksIFwicHVibGljXCI+ID0gKChcbiAgZnVuY3Rpb25EZWZpbml0aW9uOiBGdW5jdGlvbkRlZmluaXRpb24sXG4pID0+IHtcbiAgY29uc3QgaGFuZGxlciA9IChcbiAgICB0eXBlb2YgZnVuY3Rpb25EZWZpbml0aW9uID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gZnVuY3Rpb25EZWZpbml0aW9uXG4gICAgICA6IGZ1bmN0aW9uRGVmaW5pdGlvbi5oYW5kbGVyXG4gICkgYXMgKGN0eDogR2VuZXJpY011dGF0aW9uQ3R4PGFueT4sIGFyZ3M6IGFueSkgPT4gYW55O1xuICBjb25zdCBmdW5jID0gZG9udENhbGxEaXJlY3RseShcIm11dGF0aW9uXCIsIGhhbmRsZXIpIGFzIFJlZ2lzdGVyZWRNdXRhdGlvbjxcbiAgICBcInB1YmxpY1wiLFxuICAgIGFueSxcbiAgICBhbnlcbiAgPjtcblxuICBhc3NlcnROb3RCcm93c2VyKCk7XG4gIGZ1bmMuaXNNdXRhdGlvbiA9IHRydWU7XG4gIGZ1bmMuaXNQdWJsaWMgPSB0cnVlO1xuICBmdW5jLmludm9rZU11dGF0aW9uID0gKGFyZ3NTdHIpID0+IGludm9rZU11dGF0aW9uKGhhbmRsZXIsIGFyZ3NTdHIpO1xuICBmdW5jLmV4cG9ydEFyZ3MgPSBleHBvcnRBcmdzKGZ1bmN0aW9uRGVmaW5pdGlvbik7XG4gIGZ1bmMuZXhwb3J0UmV0dXJucyA9IGV4cG9ydFJldHVybnMoZnVuY3Rpb25EZWZpbml0aW9uKTtcbiAgZnVuYy5faGFuZGxlciA9IGhhbmRsZXI7XG4gIHJldHVybiBmdW5jO1xufSkgYXMgTXV0YXRpb25CdWlsZGVyPGFueSwgXCJwdWJsaWNcIj47XG5cbi8qKlxuICogRGVmaW5lIGEgbXV0YXRpb24gdGhhdCBpcyBvbmx5IGFjY2Vzc2libGUgZnJvbSBvdGhlciBDb252ZXggZnVuY3Rpb25zIChidXQgbm90IGZyb20gdGhlIGNsaWVudCkuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGFsbG93ZWQgdG8gbW9kaWZ5IHlvdXIgQ29udmV4IGRhdGFiYXNlLiBJdCB3aWxsIG5vdCBiZSBhY2Nlc3NpYmxlIGZyb20gdGhlIGNsaWVudC5cbiAqXG4gKiBJZiB5b3UncmUgdXNpbmcgY29kZSBnZW5lcmF0aW9uLCB1c2UgdGhlIGBpbnRlcm5hbE11dGF0aW9uYCBmdW5jdGlvbiBpblxuICogYGNvbnZleC9fZ2VuZXJhdGVkL3NlcnZlci5kLnRzYCB3aGljaCBpcyB0eXBlZCBmb3IgeW91ciBkYXRhIG1vZGVsLlxuICpcbiAqIEBwYXJhbSBmdW5jIC0gVGhlIG11dGF0aW9uIGZ1bmN0aW9uLiBJdCByZWNlaXZlcyBhIHtAbGluayBHZW5lcmljTXV0YXRpb25DdHh9IGFzIGl0cyBmaXJzdCBhcmd1bWVudC5cbiAqIEByZXR1cm5zIFRoZSB3cmFwcGVkIG11dGF0aW9uLiBJbmNsdWRlIHRoaXMgYXMgYW4gYGV4cG9ydGAgdG8gbmFtZSBpdCBhbmQgbWFrZSBpdCBhY2Nlc3NpYmxlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGludGVybmFsTXV0YXRpb25HZW5lcmljOiBNdXRhdGlvbkJ1aWxkZXI8YW55LCBcImludGVybmFsXCI+ID0gKChcbiAgZnVuY3Rpb25EZWZpbml0aW9uOiBGdW5jdGlvbkRlZmluaXRpb24sXG4pID0+IHtcbiAgY29uc3QgaGFuZGxlciA9IChcbiAgICB0eXBlb2YgZnVuY3Rpb25EZWZpbml0aW9uID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gZnVuY3Rpb25EZWZpbml0aW9uXG4gICAgICA6IGZ1bmN0aW9uRGVmaW5pdGlvbi5oYW5kbGVyXG4gICkgYXMgKGN0eDogR2VuZXJpY011dGF0aW9uQ3R4PGFueT4sIGFyZ3M6IGFueSkgPT4gYW55O1xuICBjb25zdCBmdW5jID0gZG9udENhbGxEaXJlY3RseShcbiAgICBcImludGVybmFsTXV0YXRpb25cIixcbiAgICBoYW5kbGVyLFxuICApIGFzIFJlZ2lzdGVyZWRNdXRhdGlvbjxcImludGVybmFsXCIsIGFueSwgYW55PjtcblxuICBhc3NlcnROb3RCcm93c2VyKCk7XG4gIGZ1bmMuaXNNdXRhdGlvbiA9IHRydWU7XG4gIGZ1bmMuaXNJbnRlcm5hbCA9IHRydWU7XG4gIGZ1bmMuaW52b2tlTXV0YXRpb24gPSAoYXJnc1N0cikgPT4gaW52b2tlTXV0YXRpb24oaGFuZGxlciwgYXJnc1N0cik7XG4gIGZ1bmMuZXhwb3J0QXJncyA9IGV4cG9ydEFyZ3MoZnVuY3Rpb25EZWZpbml0aW9uKTtcbiAgZnVuYy5leHBvcnRSZXR1cm5zID0gZXhwb3J0UmV0dXJucyhmdW5jdGlvbkRlZmluaXRpb24pO1xuICBmdW5jLl9oYW5kbGVyID0gaGFuZGxlcjtcbiAgcmV0dXJuIGZ1bmM7XG59KSBhcyBNdXRhdGlvbkJ1aWxkZXI8YW55LCBcImludGVybmFsXCI+O1xuXG5hc3luYyBmdW5jdGlvbiBpbnZva2VRdWVyeTxcbiAgRiBleHRlbmRzIChjdHg6IEdlbmVyaWNRdWVyeUN0eDxHZW5lcmljRGF0YU1vZGVsPiwgLi4uYXJnczogYW55KSA9PiBhbnksXG4+KGZ1bmM6IEYsIGFyZ3NTdHI6IHN0cmluZykge1xuICAvLyBUT0RPKHByZXNsZXkpOiBDaGFuZ2UgdGhlIGZ1bmN0aW9uIHNpZ25hdHVyZSBhbmQgcHJvcGFnYXRlIHRoZSByZXF1ZXN0SWQgZnJvbSBSdXN0LlxuICAvLyBPaywgdG8gbW9jayBpdCBvdXQgZm9yIG5vdywgc2luY2UgcXVlcmllcyBhcmUgb25seSBydW5uaW5nIGluIFY4LlxuICBjb25zdCByZXF1ZXN0SWQgPSBcIlwiO1xuICBjb25zdCBhcmdzID0ganNvblRvQ29udmV4KEpTT04ucGFyc2UoYXJnc1N0cikpO1xuICBjb25zdCBxdWVyeUN0eCA9IHtcbiAgICBkYjogc2V0dXBSZWFkZXIoKSxcbiAgICBhdXRoOiBzZXR1cEF1dGgocmVxdWVzdElkKSxcbiAgICBzdG9yYWdlOiBzZXR1cFN0b3JhZ2VSZWFkZXIocmVxdWVzdElkKSxcbiAgICBydW5RdWVyeTogKHJlZmVyZW5jZTogYW55LCBhcmdzPzogYW55KSA9PiBydW5VZGYoXCJxdWVyeVwiLCByZWZlcmVuY2UsIGFyZ3MpLFxuICB9O1xuICBjb25zdCByZXN1bHQgPSBhd2FpdCBpbnZva2VGdW5jdGlvbihmdW5jLCBxdWVyeUN0eCwgYXJncyBhcyBhbnkpO1xuICB2YWxpZGF0ZVJldHVyblZhbHVlKHJlc3VsdCk7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShjb252ZXhUb0pzb24ocmVzdWx0ID09PSB1bmRlZmluZWQgPyBudWxsIDogcmVzdWx0KSk7XG59XG5cbi8qKlxuICogRGVmaW5lIGEgcXVlcnkgaW4gdGhpcyBDb252ZXggYXBwJ3MgcHVibGljIEFQSS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgYWxsb3dlZCB0byByZWFkIHlvdXIgQ29udmV4IGRhdGFiYXNlIGFuZCB3aWxsIGJlIGFjY2Vzc2libGUgZnJvbSB0aGUgY2xpZW50LlxuICpcbiAqIElmIHlvdSdyZSB1c2luZyBjb2RlIGdlbmVyYXRpb24sIHVzZSB0aGUgYHF1ZXJ5YCBmdW5jdGlvbiBpblxuICogYGNvbnZleC9fZ2VuZXJhdGVkL3NlcnZlci5kLnRzYCB3aGljaCBpcyB0eXBlZCBmb3IgeW91ciBkYXRhIG1vZGVsLlxuICpcbiAqIEBwYXJhbSBmdW5jIC0gVGhlIHF1ZXJ5IGZ1bmN0aW9uLiBJdCByZWNlaXZlcyBhIHtAbGluayBHZW5lcmljUXVlcnlDdHh9IGFzIGl0cyBmaXJzdCBhcmd1bWVudC5cbiAqIEByZXR1cm5zIFRoZSB3cmFwcGVkIHF1ZXJ5LiBJbmNsdWRlIHRoaXMgYXMgYW4gYGV4cG9ydGAgdG8gbmFtZSBpdCBhbmQgbWFrZSBpdCBhY2Nlc3NpYmxlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHF1ZXJ5R2VuZXJpYzogUXVlcnlCdWlsZGVyPGFueSwgXCJwdWJsaWNcIj4gPSAoKFxuICBmdW5jdGlvbkRlZmluaXRpb246IEZ1bmN0aW9uRGVmaW5pdGlvbixcbikgPT4ge1xuICBjb25zdCBoYW5kbGVyID0gKFxuICAgIHR5cGVvZiBmdW5jdGlvbkRlZmluaXRpb24gPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyBmdW5jdGlvbkRlZmluaXRpb25cbiAgICAgIDogZnVuY3Rpb25EZWZpbml0aW9uLmhhbmRsZXJcbiAgKSBhcyAoY3R4OiBHZW5lcmljUXVlcnlDdHg8YW55PiwgYXJnczogYW55KSA9PiBhbnk7XG4gIGNvbnN0IGZ1bmMgPSBkb250Q2FsbERpcmVjdGx5KFwicXVlcnlcIiwgaGFuZGxlcikgYXMgUmVnaXN0ZXJlZFF1ZXJ5PFxuICAgIFwicHVibGljXCIsXG4gICAgYW55LFxuICAgIGFueVxuICA+O1xuXG4gIGFzc2VydE5vdEJyb3dzZXIoKTtcbiAgZnVuYy5pc1F1ZXJ5ID0gdHJ1ZTtcbiAgZnVuYy5pc1B1YmxpYyA9IHRydWU7XG4gIGZ1bmMuaW52b2tlUXVlcnkgPSAoYXJnc1N0cikgPT4gaW52b2tlUXVlcnkoaGFuZGxlciwgYXJnc1N0cik7XG4gIGZ1bmMuZXhwb3J0QXJncyA9IGV4cG9ydEFyZ3MoZnVuY3Rpb25EZWZpbml0aW9uKTtcbiAgZnVuYy5leHBvcnRSZXR1cm5zID0gZXhwb3J0UmV0dXJucyhmdW5jdGlvbkRlZmluaXRpb24pO1xuICBmdW5jLl9oYW5kbGVyID0gaGFuZGxlcjtcbiAgcmV0dXJuIGZ1bmM7XG59KSBhcyBRdWVyeUJ1aWxkZXI8YW55LCBcInB1YmxpY1wiPjtcblxuLyoqXG4gKiBEZWZpbmUgYSBxdWVyeSB0aGF0IGlzIG9ubHkgYWNjZXNzaWJsZSBmcm9tIG90aGVyIENvbnZleCBmdW5jdGlvbnMgKGJ1dCBub3QgZnJvbSB0aGUgY2xpZW50KS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgYWxsb3dlZCB0byByZWFkIGZyb20geW91ciBDb252ZXggZGF0YWJhc2UuIEl0IHdpbGwgbm90IGJlIGFjY2Vzc2libGUgZnJvbSB0aGUgY2xpZW50LlxuICpcbiAqIElmIHlvdSdyZSB1c2luZyBjb2RlIGdlbmVyYXRpb24sIHVzZSB0aGUgYGludGVybmFsUXVlcnlgIGZ1bmN0aW9uIGluXG4gKiBgY29udmV4L19nZW5lcmF0ZWQvc2VydmVyLmQudHNgIHdoaWNoIGlzIHR5cGVkIGZvciB5b3VyIGRhdGEgbW9kZWwuXG4gKlxuICogQHBhcmFtIGZ1bmMgLSBUaGUgcXVlcnkgZnVuY3Rpb24uIEl0IHJlY2VpdmVzIGEge0BsaW5rIEdlbmVyaWNRdWVyeUN0eH0gYXMgaXRzIGZpcnN0IGFyZ3VtZW50LlxuICogQHJldHVybnMgVGhlIHdyYXBwZWQgcXVlcnkuIEluY2x1ZGUgdGhpcyBhcyBhbiBgZXhwb3J0YCB0byBuYW1lIGl0IGFuZCBtYWtlIGl0IGFjY2Vzc2libGUuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgaW50ZXJuYWxRdWVyeUdlbmVyaWM6IFF1ZXJ5QnVpbGRlcjxhbnksIFwiaW50ZXJuYWxcIj4gPSAoKFxuICBmdW5jdGlvbkRlZmluaXRpb246IEZ1bmN0aW9uRGVmaW5pdGlvbixcbikgPT4ge1xuICBjb25zdCBoYW5kbGVyID0gKFxuICAgIHR5cGVvZiBmdW5jdGlvbkRlZmluaXRpb24gPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyBmdW5jdGlvbkRlZmluaXRpb25cbiAgICAgIDogZnVuY3Rpb25EZWZpbml0aW9uLmhhbmRsZXJcbiAgKSBhcyAoY3R4OiBHZW5lcmljUXVlcnlDdHg8YW55PiwgYXJnczogYW55KSA9PiBhbnk7XG4gIGNvbnN0IGZ1bmMgPSBkb250Q2FsbERpcmVjdGx5KFwiaW50ZXJuYWxRdWVyeVwiLCBoYW5kbGVyKSBhcyBSZWdpc3RlcmVkUXVlcnk8XG4gICAgXCJpbnRlcm5hbFwiLFxuICAgIGFueSxcbiAgICBhbnlcbiAgPjtcblxuICBhc3NlcnROb3RCcm93c2VyKCk7XG4gIGZ1bmMuaXNRdWVyeSA9IHRydWU7XG4gIGZ1bmMuaXNJbnRlcm5hbCA9IHRydWU7XG4gIGZ1bmMuaW52b2tlUXVlcnkgPSAoYXJnc1N0cikgPT4gaW52b2tlUXVlcnkoaGFuZGxlciBhcyBhbnksIGFyZ3NTdHIpO1xuICBmdW5jLmV4cG9ydEFyZ3MgPSBleHBvcnRBcmdzKGZ1bmN0aW9uRGVmaW5pdGlvbik7XG4gIGZ1bmMuZXhwb3J0UmV0dXJucyA9IGV4cG9ydFJldHVybnMoZnVuY3Rpb25EZWZpbml0aW9uKTtcbiAgZnVuYy5faGFuZGxlciA9IGhhbmRsZXI7XG4gIHJldHVybiBmdW5jO1xufSkgYXMgUXVlcnlCdWlsZGVyPGFueSwgXCJpbnRlcm5hbFwiPjtcblxuYXN5bmMgZnVuY3Rpb24gaW52b2tlQWN0aW9uPFxuICBGIGV4dGVuZHMgKGN0eDogR2VuZXJpY0FjdGlvbkN0eDxHZW5lcmljRGF0YU1vZGVsPiwgLi4uYXJnczogYW55KSA9PiBhbnksXG4+KGZ1bmM6IEYsIHJlcXVlc3RJZDogc3RyaW5nLCBhcmdzU3RyOiBzdHJpbmcpIHtcbiAgY29uc3QgYXJncyA9IGpzb25Ub0NvbnZleChKU09OLnBhcnNlKGFyZ3NTdHIpKTtcbiAgY29uc3QgY2FsbHMgPSBzZXR1cEFjdGlvbkNhbGxzKHJlcXVlc3RJZCk7XG4gIGNvbnN0IGN0eCA9IHtcbiAgICAuLi5jYWxscyxcbiAgICBhdXRoOiBzZXR1cEF1dGgocmVxdWVzdElkKSxcbiAgICBzY2hlZHVsZXI6IHNldHVwQWN0aW9uU2NoZWR1bGVyKHJlcXVlc3RJZCksXG4gICAgc3RvcmFnZTogc2V0dXBTdG9yYWdlQWN0aW9uV3JpdGVyKHJlcXVlc3RJZCksXG4gICAgdmVjdG9yU2VhcmNoOiBzZXR1cEFjdGlvblZlY3RvclNlYXJjaChyZXF1ZXN0SWQpIGFzIGFueSxcbiAgfTtcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaW52b2tlRnVuY3Rpb24oZnVuYywgY3R4LCBhcmdzIGFzIGFueSk7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShjb252ZXhUb0pzb24ocmVzdWx0ID09PSB1bmRlZmluZWQgPyBudWxsIDogcmVzdWx0KSk7XG59XG5cbi8qKlxuICogRGVmaW5lIGFuIGFjdGlvbiBpbiB0aGlzIENvbnZleCBhcHAncyBwdWJsaWMgQVBJLlxuICpcbiAqIElmIHlvdSdyZSB1c2luZyBjb2RlIGdlbmVyYXRpb24sIHVzZSB0aGUgYGFjdGlvbmAgZnVuY3Rpb24gaW5cbiAqIGBjb252ZXgvX2dlbmVyYXRlZC9zZXJ2ZXIuZC50c2Agd2hpY2ggaXMgdHlwZWQgZm9yIHlvdXIgZGF0YSBtb2RlbC5cbiAqXG4gKiBAcGFyYW0gZnVuYyAtIFRoZSBmdW5jdGlvbi4gSXQgcmVjZWl2ZXMgYSB7QGxpbmsgR2VuZXJpY0FjdGlvbkN0eH0gYXMgaXRzIGZpcnN0IGFyZ3VtZW50LlxuICogQHJldHVybnMgVGhlIHdyYXBwZWQgZnVuY3Rpb24uIEluY2x1ZGUgdGhpcyBhcyBhbiBgZXhwb3J0YCB0byBuYW1lIGl0IGFuZCBtYWtlIGl0IGFjY2Vzc2libGUuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgYWN0aW9uR2VuZXJpYzogQWN0aW9uQnVpbGRlcjxhbnksIFwicHVibGljXCI+ID0gKChcbiAgZnVuY3Rpb25EZWZpbml0aW9uOiBGdW5jdGlvbkRlZmluaXRpb24sXG4pID0+IHtcbiAgY29uc3QgaGFuZGxlciA9IChcbiAgICB0eXBlb2YgZnVuY3Rpb25EZWZpbml0aW9uID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gZnVuY3Rpb25EZWZpbml0aW9uXG4gICAgICA6IGZ1bmN0aW9uRGVmaW5pdGlvbi5oYW5kbGVyXG4gICkgYXMgKGN0eDogR2VuZXJpY0FjdGlvbkN0eDxhbnk+LCBhcmdzOiBhbnkpID0+IGFueTtcbiAgY29uc3QgZnVuYyA9IGRvbnRDYWxsRGlyZWN0bHkoXCJhY3Rpb25cIiwgaGFuZGxlcikgYXMgUmVnaXN0ZXJlZEFjdGlvbjxcbiAgICBcInB1YmxpY1wiLFxuICAgIGFueSxcbiAgICBhbnlcbiAgPjtcblxuICBhc3NlcnROb3RCcm93c2VyKCk7XG4gIGZ1bmMuaXNBY3Rpb24gPSB0cnVlO1xuICBmdW5jLmlzUHVibGljID0gdHJ1ZTtcbiAgZnVuYy5pbnZva2VBY3Rpb24gPSAocmVxdWVzdElkLCBhcmdzU3RyKSA9PlxuICAgIGludm9rZUFjdGlvbihoYW5kbGVyLCByZXF1ZXN0SWQsIGFyZ3NTdHIpO1xuICBmdW5jLmV4cG9ydEFyZ3MgPSBleHBvcnRBcmdzKGZ1bmN0aW9uRGVmaW5pdGlvbik7XG4gIGZ1bmMuZXhwb3J0UmV0dXJucyA9IGV4cG9ydFJldHVybnMoZnVuY3Rpb25EZWZpbml0aW9uKTtcbiAgZnVuYy5faGFuZGxlciA9IGhhbmRsZXI7XG4gIHJldHVybiBmdW5jO1xufSkgYXMgQWN0aW9uQnVpbGRlcjxhbnksIFwicHVibGljXCI+O1xuXG4vKipcbiAqIERlZmluZSBhbiBhY3Rpb24gdGhhdCBpcyBvbmx5IGFjY2Vzc2libGUgZnJvbSBvdGhlciBDb252ZXggZnVuY3Rpb25zIChidXQgbm90IGZyb20gdGhlIGNsaWVudCkuXG4gKlxuICogSWYgeW91J3JlIHVzaW5nIGNvZGUgZ2VuZXJhdGlvbiwgdXNlIHRoZSBgaW50ZXJuYWxBY3Rpb25gIGZ1bmN0aW9uIGluXG4gKiBgY29udmV4L19nZW5lcmF0ZWQvc2VydmVyLmQudHNgIHdoaWNoIGlzIHR5cGVkIGZvciB5b3VyIGRhdGEgbW9kZWwuXG4gKlxuICogQHBhcmFtIGZ1bmMgLSBUaGUgZnVuY3Rpb24uIEl0IHJlY2VpdmVzIGEge0BsaW5rIEdlbmVyaWNBY3Rpb25DdHh9IGFzIGl0cyBmaXJzdCBhcmd1bWVudC5cbiAqIEByZXR1cm5zIFRoZSB3cmFwcGVkIGZ1bmN0aW9uLiBJbmNsdWRlIHRoaXMgYXMgYW4gYGV4cG9ydGAgdG8gbmFtZSBpdCBhbmQgbWFrZSBpdCBhY2Nlc3NpYmxlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGludGVybmFsQWN0aW9uR2VuZXJpYzogQWN0aW9uQnVpbGRlcjxhbnksIFwiaW50ZXJuYWxcIj4gPSAoKFxuICBmdW5jdGlvbkRlZmluaXRpb246IEZ1bmN0aW9uRGVmaW5pdGlvbixcbikgPT4ge1xuICBjb25zdCBoYW5kbGVyID0gKFxuICAgIHR5cGVvZiBmdW5jdGlvbkRlZmluaXRpb24gPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyBmdW5jdGlvbkRlZmluaXRpb25cbiAgICAgIDogZnVuY3Rpb25EZWZpbml0aW9uLmhhbmRsZXJcbiAgKSBhcyAoY3R4OiBHZW5lcmljQWN0aW9uQ3R4PGFueT4sIGFyZ3M6IGFueSkgPT4gYW55O1xuICBjb25zdCBmdW5jID0gZG9udENhbGxEaXJlY3RseShcImludGVybmFsQWN0aW9uXCIsIGhhbmRsZXIpIGFzIFJlZ2lzdGVyZWRBY3Rpb248XG4gICAgXCJpbnRlcm5hbFwiLFxuICAgIGFueSxcbiAgICBhbnlcbiAgPjtcblxuICBhc3NlcnROb3RCcm93c2VyKCk7XG4gIGZ1bmMuaXNBY3Rpb24gPSB0cnVlO1xuICBmdW5jLmlzSW50ZXJuYWwgPSB0cnVlO1xuICBmdW5jLmludm9rZUFjdGlvbiA9IChyZXF1ZXN0SWQsIGFyZ3NTdHIpID0+XG4gICAgaW52b2tlQWN0aW9uKGhhbmRsZXIsIHJlcXVlc3RJZCwgYXJnc1N0cik7XG4gIGZ1bmMuZXhwb3J0QXJncyA9IGV4cG9ydEFyZ3MoZnVuY3Rpb25EZWZpbml0aW9uKTtcbiAgZnVuYy5leHBvcnRSZXR1cm5zID0gZXhwb3J0UmV0dXJucyhmdW5jdGlvbkRlZmluaXRpb24pO1xuICBmdW5jLl9oYW5kbGVyID0gaGFuZGxlcjtcbiAgcmV0dXJuIGZ1bmM7XG59KSBhcyBBY3Rpb25CdWlsZGVyPGFueSwgXCJpbnRlcm5hbFwiPjtcblxuYXN5bmMgZnVuY3Rpb24gaW52b2tlSHR0cEFjdGlvbjxcbiAgRiBleHRlbmRzIChjdHg6IEdlbmVyaWNBY3Rpb25DdHg8R2VuZXJpY0RhdGFNb2RlbD4sIHJlcXVlc3Q6IFJlcXVlc3QpID0+IGFueSxcbj4oZnVuYzogRiwgcmVxdWVzdDogUmVxdWVzdCkge1xuICAvLyBUT0RPKHByZXNsZXkpOiBDaGFuZ2UgdGhlIGZ1bmN0aW9uIHNpZ25hdHVyZSBhbmQgcHJvcGFnYXRlIHRoZSByZXF1ZXN0SWQgZnJvbSBSdXN0LlxuICAvLyBPaywgdG8gbW9jayBpdCBvdXQgZm9yIG5vdywgc2luY2UgaHR0cCBlbmRwb2ludHMgYXJlIG9ubHkgcnVubmluZyBpbiBWOC5cbiAgY29uc3QgcmVxdWVzdElkID0gXCJcIjtcbiAgY29uc3QgY2FsbHMgPSBzZXR1cEFjdGlvbkNhbGxzKHJlcXVlc3RJZCk7XG4gIGNvbnN0IGN0eCA9IHtcbiAgICAuLi5jYWxscyxcbiAgICBhdXRoOiBzZXR1cEF1dGgocmVxdWVzdElkKSxcbiAgICBzdG9yYWdlOiBzZXR1cFN0b3JhZ2VBY3Rpb25Xcml0ZXIocmVxdWVzdElkKSxcbiAgICBzY2hlZHVsZXI6IHNldHVwQWN0aW9uU2NoZWR1bGVyKHJlcXVlc3RJZCksXG4gICAgdmVjdG9yU2VhcmNoOiBzZXR1cEFjdGlvblZlY3RvclNlYXJjaChyZXF1ZXN0SWQpIGFzIGFueSxcbiAgfTtcbiAgcmV0dXJuIGF3YWl0IGludm9rZUZ1bmN0aW9uKGZ1bmMsIGN0eCwgW3JlcXVlc3RdKTtcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSBDb252ZXggSFRUUCBhY3Rpb24uXG4gKlxuICogQHBhcmFtIGZ1bmMgLSBUaGUgZnVuY3Rpb24uIEl0IHJlY2VpdmVzIGFuIHtAbGluayBHZW5lcmljQWN0aW9uQ3R4fSBhcyBpdHMgZmlyc3QgYXJndW1lbnQsIGFuZCBhIGBSZXF1ZXN0YCBvYmplY3RcbiAqIGFzIGl0cyBzZWNvbmQuXG4gKiBAcmV0dXJucyBUaGUgd3JhcHBlZCBmdW5jdGlvbi4gUm91dGUgYSBVUkwgcGF0aCB0byB0aGlzIGZ1bmN0aW9uIGluIGBjb252ZXgvaHR0cC5qc2AuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgaHR0cEFjdGlvbkdlbmVyaWMgPSAoXG4gIGZ1bmM6IChcbiAgICBjdHg6IEdlbmVyaWNBY3Rpb25DdHg8R2VuZXJpY0RhdGFNb2RlbD4sXG4gICAgcmVxdWVzdDogUmVxdWVzdCxcbiAgKSA9PiBQcm9taXNlPFJlc3BvbnNlPixcbik6IFB1YmxpY0h0dHBBY3Rpb24gPT4ge1xuICBjb25zdCBxID0gZG9udENhbGxEaXJlY3RseShcImh0dHBBY3Rpb25cIiwgZnVuYykgYXMgUHVibGljSHR0cEFjdGlvbjtcbiAgYXNzZXJ0Tm90QnJvd3NlcigpO1xuICBxLmlzSHR0cCA9IHRydWU7XG4gIHEuaW52b2tlSHR0cEFjdGlvbiA9IChyZXF1ZXN0KSA9PiBpbnZva2VIdHRwQWN0aW9uKGZ1bmMgYXMgYW55LCByZXF1ZXN0KTtcbiAgcS5faGFuZGxlciA9IGZ1bmM7XG4gIHJldHVybiBxO1xufTtcblxuYXN5bmMgZnVuY3Rpb24gcnVuVWRmKFxuICB1ZGZUeXBlOiBcInF1ZXJ5XCIgfCBcIm11dGF0aW9uXCIsXG4gIGY6IGFueSxcbiAgYXJncz86IFJlY29yZDxzdHJpbmcsIFZhbHVlPixcbik6IFByb21pc2U8YW55PiB7XG4gIGNvbnN0IHF1ZXJ5QXJncyA9IHBhcnNlQXJncyhhcmdzKTtcbiAgY29uc3Qgc3lzY2FsbEFyZ3MgPSB7XG4gICAgdWRmVHlwZSxcbiAgICBhcmdzOiBjb252ZXhUb0pzb24ocXVlcnlBcmdzKSxcbiAgICAuLi5nZXRGdW5jdGlvbkFkZHJlc3MoZiksXG4gIH07XG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHBlcmZvcm1Bc3luY1N5c2NhbGwoXCIxLjAvcnVuVWRmXCIsIHN5c2NhbGxBcmdzKTtcbiAgcmV0dXJuIGpzb25Ub0NvbnZleChyZXN1bHQpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBjb252ZXhUb0pzb24sIGpzb25Ub0NvbnZleCB9IGZyb20gXCIuLi8uLi92YWx1ZXMvaW5kZXguanNcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi4vLi4vaW5kZXguanNcIjtcbmltcG9ydCB7IHBlcmZvcm1Bc3luY1N5c2NhbGwgfSBmcm9tIFwiLi9zeXNjYWxsLmpzXCI7XG5pbXBvcnQgeyBwYXJzZUFyZ3MgfSBmcm9tIFwiLi4vLi4vY29tbW9uL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBnZXRGdW5jdGlvbkFkZHJlc3MgfSBmcm9tIFwiLi4vY29tcG9uZW50cy9wYXRocy5qc1wiO1xuZnVuY3Rpb24gc3lzY2FsbEFyZ3MocmVxdWVzdElkLCBmdW5jdGlvblJlZmVyZW5jZSwgYXJncykge1xuICBjb25zdCBhZGRyZXNzID0gZ2V0RnVuY3Rpb25BZGRyZXNzKGZ1bmN0aW9uUmVmZXJlbmNlKTtcbiAgcmV0dXJuIHtcbiAgICAuLi5hZGRyZXNzLFxuICAgIGFyZ3M6IGNvbnZleFRvSnNvbihwYXJzZUFyZ3MoYXJncykpLFxuICAgIHZlcnNpb24sXG4gICAgcmVxdWVzdElkXG4gIH07XG59XG5leHBvcnQgZnVuY3Rpb24gc2V0dXBBY3Rpb25DYWxscyhyZXF1ZXN0SWQpIHtcbiAgcmV0dXJuIHtcbiAgICBydW5RdWVyeTogYXN5bmMgKHF1ZXJ5LCBhcmdzKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwZXJmb3JtQXN5bmNTeXNjYWxsKFxuICAgICAgICBcIjEuMC9hY3Rpb25zL3F1ZXJ5XCIsXG4gICAgICAgIHN5c2NhbGxBcmdzKHJlcXVlc3RJZCwgcXVlcnksIGFyZ3MpXG4gICAgICApO1xuICAgICAgcmV0dXJuIGpzb25Ub0NvbnZleChyZXN1bHQpO1xuICAgIH0sXG4gICAgcnVuTXV0YXRpb246IGFzeW5jIChtdXRhdGlvbiwgYXJncykgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcGVyZm9ybUFzeW5jU3lzY2FsbChcbiAgICAgICAgXCIxLjAvYWN0aW9ucy9tdXRhdGlvblwiLFxuICAgICAgICBzeXNjYWxsQXJncyhyZXF1ZXN0SWQsIG11dGF0aW9uLCBhcmdzKVxuICAgICAgKTtcbiAgICAgIHJldHVybiBqc29uVG9Db252ZXgocmVzdWx0KTtcbiAgICB9LFxuICAgIHJ1bkFjdGlvbjogYXN5bmMgKGFjdGlvbiwgYXJncykgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcGVyZm9ybUFzeW5jU3lzY2FsbChcbiAgICAgICAgXCIxLjAvYWN0aW9ucy9hY3Rpb25cIixcbiAgICAgICAgc3lzY2FsbEFyZ3MocmVxdWVzdElkLCBhY3Rpb24sIGFyZ3MpXG4gICAgICApO1xuICAgICAgcmV0dXJuIGpzb25Ub0NvbnZleChyZXN1bHQpO1xuICAgIH1cbiAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjdGlvbnNfaW1wbC5qcy5tYXBcbiIsImltcG9ydCB7IGNvbnZleFRvSnNvbiwganNvblRvQ29udmV4LCBWYWx1ZSB9IGZyb20gXCIuLi8uLi92YWx1ZXMvaW5kZXguanNcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi4vLi4vaW5kZXguanNcIjtcbmltcG9ydCB7IHBlcmZvcm1Bc3luY1N5c2NhbGwgfSBmcm9tIFwiLi9zeXNjYWxsLmpzXCI7XG5pbXBvcnQgeyBwYXJzZUFyZ3MgfSBmcm9tIFwiLi4vLi4vY29tbW9uL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBGdW5jdGlvblJlZmVyZW5jZSB9IGZyb20gXCIuLi8uLi9zZXJ2ZXIvYXBpLmpzXCI7XG5pbXBvcnQgeyBnZXRGdW5jdGlvbkFkZHJlc3MgfSBmcm9tIFwiLi4vY29tcG9uZW50cy9wYXRocy5qc1wiO1xuXG5mdW5jdGlvbiBzeXNjYWxsQXJncyhcbiAgcmVxdWVzdElkOiBzdHJpbmcsXG4gIGZ1bmN0aW9uUmVmZXJlbmNlOiBhbnksXG4gIGFyZ3M/OiBSZWNvcmQ8c3RyaW5nLCBWYWx1ZT4sXG4pIHtcbiAgY29uc3QgYWRkcmVzcyA9IGdldEZ1bmN0aW9uQWRkcmVzcyhmdW5jdGlvblJlZmVyZW5jZSk7XG4gIHJldHVybiB7XG4gICAgLi4uYWRkcmVzcyxcbiAgICBhcmdzOiBjb252ZXhUb0pzb24ocGFyc2VBcmdzKGFyZ3MpKSxcbiAgICB2ZXJzaW9uLFxuICAgIHJlcXVlc3RJZCxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldHVwQWN0aW9uQ2FsbHMocmVxdWVzdElkOiBzdHJpbmcpIHtcbiAgcmV0dXJuIHtcbiAgICBydW5RdWVyeTogYXN5bmMgKFxuICAgICAgcXVlcnk6IEZ1bmN0aW9uUmVmZXJlbmNlPFwicXVlcnlcIiwgXCJwdWJsaWNcIiB8IFwiaW50ZXJuYWxcIj4sXG4gICAgICBhcmdzPzogUmVjb3JkPHN0cmluZywgVmFsdWU+LFxuICAgICk6IFByb21pc2U8YW55PiA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwZXJmb3JtQXN5bmNTeXNjYWxsKFxuICAgICAgICBcIjEuMC9hY3Rpb25zL3F1ZXJ5XCIsXG4gICAgICAgIHN5c2NhbGxBcmdzKHJlcXVlc3RJZCwgcXVlcnksIGFyZ3MpLFxuICAgICAgKTtcbiAgICAgIHJldHVybiBqc29uVG9Db252ZXgocmVzdWx0KTtcbiAgICB9LFxuICAgIHJ1bk11dGF0aW9uOiBhc3luYyAoXG4gICAgICBtdXRhdGlvbjogRnVuY3Rpb25SZWZlcmVuY2U8XCJtdXRhdGlvblwiLCBcInB1YmxpY1wiIHwgXCJpbnRlcm5hbFwiPixcbiAgICAgIGFyZ3M/OiBSZWNvcmQ8c3RyaW5nLCBWYWx1ZT4sXG4gICAgKTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHBlcmZvcm1Bc3luY1N5c2NhbGwoXG4gICAgICAgIFwiMS4wL2FjdGlvbnMvbXV0YXRpb25cIixcbiAgICAgICAgc3lzY2FsbEFyZ3MocmVxdWVzdElkLCBtdXRhdGlvbiwgYXJncyksXG4gICAgICApO1xuICAgICAgcmV0dXJuIGpzb25Ub0NvbnZleChyZXN1bHQpO1xuICAgIH0sXG4gICAgcnVuQWN0aW9uOiBhc3luYyAoXG4gICAgICBhY3Rpb246IEZ1bmN0aW9uUmVmZXJlbmNlPFwiYWN0aW9uXCIsIFwicHVibGljXCIgfCBcImludGVybmFsXCI+LFxuICAgICAgYXJncz86IFJlY29yZDxzdHJpbmcsIFZhbHVlPixcbiAgICApOiBQcm9taXNlPGFueT4gPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcGVyZm9ybUFzeW5jU3lzY2FsbChcbiAgICAgICAgXCIxLjAvYWN0aW9ucy9hY3Rpb25cIixcbiAgICAgICAgc3lzY2FsbEFyZ3MocmVxdWVzdElkLCBhY3Rpb24sIGFyZ3MpLFxuICAgICAgKTtcbiAgICAgIHJldHVybiBqc29uVG9Db252ZXgocmVzdWx0KTtcbiAgICB9LFxuICB9O1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBDb252ZXhFcnJvciB9IGZyb20gXCIuLi8uLi92YWx1ZXMvZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyBqc29uVG9Db252ZXggfSBmcm9tIFwiLi4vLi4vdmFsdWVzL3ZhbHVlLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gcGVyZm9ybVN5c2NhbGwob3AsIGFyZykge1xuICBpZiAodHlwZW9mIENvbnZleCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBDb252ZXguc3lzY2FsbCA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJUaGUgQ29udmV4IGRhdGFiYXNlIGFuZCBhdXRoIG9iamVjdHMgYXJlIGJlaW5nIHVzZWQgb3V0c2lkZSBvZiBhIENvbnZleCBiYWNrZW5kLiBEaWQgeW91IG1lYW4gdG8gdXNlIGB1c2VRdWVyeWAgb3IgYHVzZU11dGF0aW9uYCB0byBjYWxsIGEgQ29udmV4IGZ1bmN0aW9uP1wiXG4gICAgKTtcbiAgfVxuICBjb25zdCByZXN1bHRTdHIgPSBDb252ZXguc3lzY2FsbChvcCwgSlNPTi5zdHJpbmdpZnkoYXJnKSk7XG4gIHJldHVybiBKU09OLnBhcnNlKHJlc3VsdFN0cik7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcGVyZm9ybUFzeW5jU3lzY2FsbChvcCwgYXJnKSB7XG4gIGlmICh0eXBlb2YgQ29udmV4ID09PSBcInVuZGVmaW5lZFwiIHx8IENvbnZleC5hc3luY1N5c2NhbGwgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiVGhlIENvbnZleCBkYXRhYmFzZSBhbmQgYXV0aCBvYmplY3RzIGFyZSBiZWluZyB1c2VkIG91dHNpZGUgb2YgYSBDb252ZXggYmFja2VuZC4gRGlkIHlvdSBtZWFuIHRvIHVzZSBgdXNlUXVlcnlgIG9yIGB1c2VNdXRhdGlvbmAgdG8gY2FsbCBhIENvbnZleCBmdW5jdGlvbj9cIlxuICAgICk7XG4gIH1cbiAgbGV0IHJlc3VsdFN0cjtcbiAgdHJ5IHtcbiAgICByZXN1bHRTdHIgPSBhd2FpdCBDb252ZXguYXN5bmNTeXNjYWxsKG9wLCBKU09OLnN0cmluZ2lmeShhcmcpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlLmRhdGEgIT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgcmV0aHJvd24gPSBuZXcgQ29udmV4RXJyb3IoZS5tZXNzYWdlKTtcbiAgICAgIHJldGhyb3duLmRhdGEgPSBqc29uVG9Db252ZXgoZS5kYXRhKTtcbiAgICAgIHRocm93IHJldGhyb3duO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoZS5tZXNzYWdlKTtcbiAgfVxuICByZXR1cm4gSlNPTi5wYXJzZShyZXN1bHRTdHIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBlcmZvcm1Kc1N5c2NhbGwob3AsIGFyZykge1xuICBpZiAodHlwZW9mIENvbnZleCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBDb252ZXguanNTeXNjYWxsID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlRoZSBDb252ZXggZGF0YWJhc2UgYW5kIGF1dGggb2JqZWN0cyBhcmUgYmVpbmcgdXNlZCBvdXRzaWRlIG9mIGEgQ29udmV4IGJhY2tlbmQuIERpZCB5b3UgbWVhbiB0byB1c2UgYHVzZVF1ZXJ5YCBvciBgdXNlTXV0YXRpb25gIHRvIGNhbGwgYSBDb252ZXggZnVuY3Rpb24/XCJcbiAgICApO1xuICB9XG4gIHJldHVybiBDb252ZXguanNTeXNjYWxsKG9wLCBhcmcpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3lzY2FsbC5qcy5tYXBcbiIsImltcG9ydCB7IENvbnZleEVycm9yIH0gZnJvbSBcIi4uLy4uL3ZhbHVlcy9lcnJvcnMuanNcIjtcbmltcG9ydCB7IGpzb25Ub0NvbnZleCB9IGZyb20gXCIuLi8uLi92YWx1ZXMvdmFsdWUuanNcIjtcblxuZGVjbGFyZSBjb25zdCBDb252ZXg6IHtcbiAgc3lzY2FsbDogKG9wOiBzdHJpbmcsIGpzb25BcmdzOiBzdHJpbmcpID0+IHN0cmluZztcbiAgYXN5bmNTeXNjYWxsOiAob3A6IHN0cmluZywganNvbkFyZ3M6IHN0cmluZykgPT4gUHJvbWlzZTxzdHJpbmc+O1xuICBqc1N5c2NhbGw6IChvcDogc3RyaW5nLCBhcmdzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSA9PiBhbnk7XG59O1xuLyoqXG4gKiBQZXJmb3JtIGEgc3lzY2FsbCwgdGFraW5nIGluIGEgSlNPTi1lbmNvZGFibGUgb2JqZWN0IGFzIGFuIGFyZ3VtZW50LCBzZXJpYWxpemluZyB3aXRoXG4gKiBKU09OLnN0cmluZ2lmeSwgY2FsbGluZyBpbnRvIFJ1c3QsIGFuZCB0aGVuIHBhcnNpbmcgdGhlIHJlc3BvbnNlIGFzIGEgSlNPTi1lbmNvZGFibGVcbiAqIHZhbHVlLiBJZiBvbmUgb2YgeW91ciBhcmd1bWVudHMgaXMgYSBDb252ZXggdmFsdWUsIHlvdSBtdXN0IGNhbGwgYGNvbnZleFRvSnNvbmAgb24gaXRcbiAqIGJlZm9yZSBwYXNzaW5nIGl0IHRvIHRoaXMgZnVuY3Rpb24sIGFuZCBpZiB0aGUgcmV0dXJuIHZhbHVlIGhhcyBhIENvbnZleCB2YWx1ZSwgeW91J3JlXG4gKiBhbHNvIHJlc3BvbnNpYmxlIGZvciBjYWxsaW5nIGBqc29uVG9Db252ZXhgOiBUaGlzIGxheWVyIG9ubHkgZGVhbHMgaW4gSlNPTi5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcGVyZm9ybVN5c2NhbGwob3A6IHN0cmluZywgYXJnOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogYW55IHtcbiAgaWYgKHR5cGVvZiBDb252ZXggPT09IFwidW5kZWZpbmVkXCIgfHwgQ29udmV4LnN5c2NhbGwgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiVGhlIENvbnZleCBkYXRhYmFzZSBhbmQgYXV0aCBvYmplY3RzIGFyZSBiZWluZyB1c2VkIG91dHNpZGUgb2YgYSBDb252ZXggYmFja2VuZC4gXCIgK1xuICAgICAgICBcIkRpZCB5b3UgbWVhbiB0byB1c2UgYHVzZVF1ZXJ5YCBvciBgdXNlTXV0YXRpb25gIHRvIGNhbGwgYSBDb252ZXggZnVuY3Rpb24/XCIsXG4gICAgKTtcbiAgfVxuICBjb25zdCByZXN1bHRTdHIgPSBDb252ZXguc3lzY2FsbChvcCwgSlNPTi5zdHJpbmdpZnkoYXJnKSk7XG4gIHJldHVybiBKU09OLnBhcnNlKHJlc3VsdFN0cik7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwZXJmb3JtQXN5bmNTeXNjYWxsKFxuICBvcDogc3RyaW5nLFxuICBhcmc6IFJlY29yZDxzdHJpbmcsIGFueT4sXG4pOiBQcm9taXNlPGFueT4ge1xuICBpZiAodHlwZW9mIENvbnZleCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBDb252ZXguYXN5bmNTeXNjYWxsID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlRoZSBDb252ZXggZGF0YWJhc2UgYW5kIGF1dGggb2JqZWN0cyBhcmUgYmVpbmcgdXNlZCBvdXRzaWRlIG9mIGEgQ29udmV4IGJhY2tlbmQuIFwiICtcbiAgICAgICAgXCJEaWQgeW91IG1lYW4gdG8gdXNlIGB1c2VRdWVyeWAgb3IgYHVzZU11dGF0aW9uYCB0byBjYWxsIGEgQ29udmV4IGZ1bmN0aW9uP1wiLFxuICAgICk7XG4gIH1cbiAgbGV0IHJlc3VsdFN0cjtcbiAgdHJ5IHtcbiAgICByZXN1bHRTdHIgPSBhd2FpdCBDb252ZXguYXN5bmNTeXNjYWxsKG9wLCBKU09OLnN0cmluZ2lmeShhcmcpKTtcbiAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgLy8gUmV0aHJvdyB0aGUgZXhjZXB0aW9uIHRvIGF0dGFjaCBzdGFjayB0cmFjZSBzdGFydGluZyBmcm9tIGhlcmUuXG4gICAgLy8gSWYgdGhlIGVycm9yIGNhbWUgZnJvbSBKUyBpdCB3aWxsIGluY2x1ZGUgaXRzIG93biBzdGFjayB0cmFjZSBpbiB0aGUgbWVzc2FnZS5cbiAgICAvLyBJZiBpdCBjYW1lIGZyb20gUnVzdCBpdCB3b24ndC5cblxuICAgIC8vIFRoaXMgb25seSBoYXBwZW5zIGlmIHdlJ3JlIHByb3BhZ2F0aW5nIENvbnZleEVycm9yc1xuICAgIGlmIChlLmRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgcmV0aHJvd24gPSBuZXcgQ29udmV4RXJyb3IoZS5tZXNzYWdlKTtcbiAgICAgIHJldGhyb3duLmRhdGEgPSBqc29uVG9Db252ZXgoZS5kYXRhKTtcbiAgICAgIHRocm93IHJldGhyb3duO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoZS5tZXNzYWdlKTtcbiAgfVxuICByZXR1cm4gSlNPTi5wYXJzZShyZXN1bHRTdHIpO1xufVxuXG4vKipcbiAqIENhbGwgaW50byBhIFwiSlNcIiBzeXNjYWxsLiBMaWtlIGBwZXJmb3JtU3lzY2FsbGAsIHRoaXMgY2FsbHMgYSBkeW5hbWljYWxseSBsaW5rZWRcbiAqIGZ1bmN0aW9uIHNldCB1cCBpbiB0aGUgQ29udmV4IGZ1bmN0aW9uIGV4ZWN1dGlvbi4gVW5saWtlIGBwZXJmb3JtU3lzY2FsbGAsIHRoZVxuICogYXJndW1lbnRzIGRvIG5vdCBuZWVkIHRvIGJlIEpTT04tZW5jb2RhYmxlIGFuZCBuZWl0aGVyIGRvZXMgdGhlIHJldHVybiB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gb3BcbiAqIEBwYXJhbSBhcmdcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwZXJmb3JtSnNTeXNjYWxsKG9wOiBzdHJpbmcsIGFyZzogUmVjb3JkPHN0cmluZywgYW55Pik6IGFueSB7XG4gIGlmICh0eXBlb2YgQ29udmV4ID09PSBcInVuZGVmaW5lZFwiIHx8IENvbnZleC5qc1N5c2NhbGwgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiVGhlIENvbnZleCBkYXRhYmFzZSBhbmQgYXV0aCBvYmplY3RzIGFyZSBiZWluZyB1c2VkIG91dHNpZGUgb2YgYSBDb252ZXggYmFja2VuZC4gXCIgK1xuICAgICAgICBcIkRpZCB5b3UgbWVhbiB0byB1c2UgYHVzZVF1ZXJ5YCBvciBgdXNlTXV0YXRpb25gIHRvIGNhbGwgYSBDb252ZXggZnVuY3Rpb24/XCIsXG4gICAgKTtcbiAgfVxuICByZXR1cm4gQ29udmV4LmpzU3lzY2FsbChvcCwgYXJnKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4gX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbmltcG9ydCB7IHBlcmZvcm1Bc3luY1N5c2NhbGwgfSBmcm9tIFwiLi9zeXNjYWxsLmpzXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4uLy4uL2luZGV4LmpzXCI7XG5pbXBvcnQge1xuICBGaWx0ZXJFeHByZXNzaW9uXG59IGZyb20gXCIuLi92ZWN0b3Jfc2VhcmNoLmpzXCI7XG5pbXBvcnQgeyB2YWxpZGF0ZUFyZyB9IGZyb20gXCIuL3ZhbGlkYXRlLmpzXCI7XG5pbXBvcnQgeyBjb252ZXhPclVuZGVmaW5lZFRvSnNvbiB9IGZyb20gXCIuLi8uLi92YWx1ZXMvdmFsdWUuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBzZXR1cEFjdGlvblZlY3RvclNlYXJjaChyZXF1ZXN0SWQpIHtcbiAgcmV0dXJuIGFzeW5jICh0YWJsZU5hbWUsIGluZGV4TmFtZSwgcXVlcnkpID0+IHtcbiAgICB2YWxpZGF0ZUFyZyh0YWJsZU5hbWUsIDEsIFwidmVjdG9yU2VhcmNoXCIsIFwidGFibGVOYW1lXCIpO1xuICAgIHZhbGlkYXRlQXJnKGluZGV4TmFtZSwgMiwgXCJ2ZWN0b3JTZWFyY2hcIiwgXCJpbmRleE5hbWVcIik7XG4gICAgdmFsaWRhdGVBcmcocXVlcnksIDMsIFwidmVjdG9yU2VhcmNoXCIsIFwicXVlcnlcIik7XG4gICAgaWYgKCFxdWVyeS52ZWN0b3IgfHwgIUFycmF5LmlzQXJyYXkocXVlcnkudmVjdG9yKSB8fCBxdWVyeS52ZWN0b3IubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBFcnJvcihcImB2ZWN0b3JgIG11c3QgYmUgYSBub24tZW1wdHkgQXJyYXkgaW4gdmVjdG9yU2VhcmNoXCIpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgbmV3IFZlY3RvclF1ZXJ5SW1wbChcbiAgICAgIHJlcXVlc3RJZCxcbiAgICAgIHRhYmxlTmFtZSArIFwiLlwiICsgaW5kZXhOYW1lLFxuICAgICAgcXVlcnlcbiAgICApLmNvbGxlY3QoKTtcbiAgfTtcbn1cbmV4cG9ydCBjbGFzcyBWZWN0b3JRdWVyeUltcGwge1xuICBjb25zdHJ1Y3RvcihyZXF1ZXN0SWQsIGluZGV4TmFtZSwgcXVlcnkpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVxdWVzdElkXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzdGF0ZVwiKTtcbiAgICB0aGlzLnJlcXVlc3RJZCA9IHJlcXVlc3RJZDtcbiAgICBjb25zdCBmaWx0ZXJzID0gcXVlcnkuZmlsdGVyID8gc2VyaWFsaXplRXhwcmVzc2lvbihxdWVyeS5maWx0ZXIoZmlsdGVyQnVpbGRlckltcGwpKSA6IG51bGw7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHR5cGU6IFwicHJlcGFyaW5nXCIsXG4gICAgICBxdWVyeToge1xuICAgICAgICBpbmRleE5hbWUsXG4gICAgICAgIGxpbWl0OiBxdWVyeS5saW1pdCxcbiAgICAgICAgdmVjdG9yOiBxdWVyeS52ZWN0b3IsXG4gICAgICAgIGV4cHJlc3Npb25zOiBmaWx0ZXJzXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBhc3luYyBjb2xsZWN0KCkge1xuICAgIGlmICh0aGlzLnN0YXRlLnR5cGUgPT09IFwiY29uc3VtZWRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBxdWVyeSBpcyBjbG9zZWQgYW5kIGNhbid0IGVtaXQgYW55IG1vcmUgdmFsdWVzLlwiKTtcbiAgICB9XG4gICAgY29uc3QgcXVlcnkgPSB0aGlzLnN0YXRlLnF1ZXJ5O1xuICAgIHRoaXMuc3RhdGUgPSB7IHR5cGU6IFwiY29uc3VtZWRcIiB9O1xuICAgIGNvbnN0IHsgcmVzdWx0cyB9ID0gYXdhaXQgcGVyZm9ybUFzeW5jU3lzY2FsbChcIjEuMC9hY3Rpb25zL3ZlY3RvclNlYXJjaFwiLCB7XG4gICAgICByZXF1ZXN0SWQ6IHRoaXMucmVxdWVzdElkLFxuICAgICAgdmVyc2lvbixcbiAgICAgIHF1ZXJ5XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBFeHByZXNzaW9uSW1wbCBleHRlbmRzIEZpbHRlckV4cHJlc3Npb24ge1xuICBjb25zdHJ1Y3Rvcihpbm5lcikge1xuICAgIHN1cGVyKCk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImlubmVyXCIpO1xuICAgIHRoaXMuaW5uZXIgPSBpbm5lcjtcbiAgfVxuICBzZXJpYWxpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5uZXI7XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemVFeHByZXNzaW9uKGV4cHIpIHtcbiAgaWYgKGV4cHIgaW5zdGFuY2VvZiBFeHByZXNzaW9uSW1wbCkge1xuICAgIHJldHVybiBleHByLnNlcmlhbGl6ZSgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7ICRsaXRlcmFsOiBjb252ZXhPclVuZGVmaW5lZFRvSnNvbihleHByKSB9O1xuICB9XG59XG5leHBvcnQgY29uc3QgZmlsdGVyQnVpbGRlckltcGwgPSB7XG4gIC8vICBDb21wYXJpc29ucyAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICBlcShmaWVsZE5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBmaWVsZE5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBmaXJzdCBhcmd1bWVudCB0byBgcS5lcWAgbXVzdCBiZSBhIGZpZWxkIG5hbWUuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEV4cHJlc3Npb25JbXBsKHtcbiAgICAgICRlcTogW1xuICAgICAgICBzZXJpYWxpemVFeHByZXNzaW9uKG5ldyBFeHByZXNzaW9uSW1wbCh7ICRmaWVsZDogZmllbGROYW1lIH0pKSxcbiAgICAgICAgc2VyaWFsaXplRXhwcmVzc2lvbih2YWx1ZSlcbiAgICAgIF1cbiAgICB9KTtcbiAgfSxcbiAgLy8gIExvZ2ljICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIG9yKC4uLmV4cHJzKSB7XG4gICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uSW1wbCh7ICRvcjogZXhwcnMubWFwKHNlcmlhbGl6ZUV4cHJlc3Npb24pIH0pO1xuICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVjdG9yX3NlYXJjaF9pbXBsLmpzLm1hcFxuIiwiaW1wb3J0IHsgSlNPTlZhbHVlIH0gZnJvbSBcIi4uLy4uL3ZhbHVlcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgcGVyZm9ybUFzeW5jU3lzY2FsbCB9IGZyb20gXCIuL3N5c2NhbGwuanNcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi4vLi4vaW5kZXguanNcIjtcbmltcG9ydCB7XG4gIEZpbHRlckV4cHJlc3Npb24sXG4gIFZlY3RvckZpbHRlckJ1aWxkZXIsXG4gIFZlY3RvclNlYXJjaCxcbiAgVmVjdG9yU2VhcmNoUXVlcnksXG59IGZyb20gXCIuLi92ZWN0b3Jfc2VhcmNoLmpzXCI7XG5pbXBvcnQge1xuICBGaWVsZFR5cGVGcm9tRmllbGRQYXRoLFxuICBHZW5lcmljRGF0YU1vZGVsLFxuICBHZW5lcmljRG9jdW1lbnQsXG4gIEdlbmVyaWNUYWJsZUluZm8sXG4gIEdlbmVyaWNWZWN0b3JJbmRleENvbmZpZyxcbn0gZnJvbSBcIi4uL2RhdGFfbW9kZWwuanNcIjtcbmltcG9ydCB7IHZhbGlkYXRlQXJnIH0gZnJvbSBcIi4vdmFsaWRhdGUuanNcIjtcbmltcG9ydCB7IFZhbHVlLCBjb252ZXhPclVuZGVmaW5lZFRvSnNvbiB9IGZyb20gXCIuLi8uLi92YWx1ZXMvdmFsdWUuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHNldHVwQWN0aW9uVmVjdG9yU2VhcmNoKFxuICByZXF1ZXN0SWQ6IHN0cmluZyxcbik6IFZlY3RvclNlYXJjaDxHZW5lcmljRGF0YU1vZGVsLCBzdHJpbmcsIHN0cmluZz4ge1xuICByZXR1cm4gYXN5bmMgKFxuICAgIHRhYmxlTmFtZTogc3RyaW5nLFxuICAgIGluZGV4TmFtZTogc3RyaW5nLFxuICAgIHF1ZXJ5OiBWZWN0b3JTZWFyY2hRdWVyeTxHZW5lcmljVGFibGVJbmZvLCBzdHJpbmc+LFxuICApID0+IHtcbiAgICB2YWxpZGF0ZUFyZyh0YWJsZU5hbWUsIDEsIFwidmVjdG9yU2VhcmNoXCIsIFwidGFibGVOYW1lXCIpO1xuICAgIHZhbGlkYXRlQXJnKGluZGV4TmFtZSwgMiwgXCJ2ZWN0b3JTZWFyY2hcIiwgXCJpbmRleE5hbWVcIik7XG4gICAgdmFsaWRhdGVBcmcocXVlcnksIDMsIFwidmVjdG9yU2VhcmNoXCIsIFwicXVlcnlcIik7XG4gICAgaWYgKFxuICAgICAgIXF1ZXJ5LnZlY3RvciB8fFxuICAgICAgIUFycmF5LmlzQXJyYXkocXVlcnkudmVjdG9yKSB8fFxuICAgICAgcXVlcnkudmVjdG9yLmxlbmd0aCA9PT0gMFxuICAgICkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJgdmVjdG9yYCBtdXN0IGJlIGEgbm9uLWVtcHR5IEFycmF5IGluIHZlY3RvclNlYXJjaFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgbmV3IFZlY3RvclF1ZXJ5SW1wbChcbiAgICAgIHJlcXVlc3RJZCxcbiAgICAgIHRhYmxlTmFtZSArIFwiLlwiICsgaW5kZXhOYW1lLFxuICAgICAgcXVlcnksXG4gICAgKS5jb2xsZWN0KCk7XG4gIH07XG59XG5cbmV4cG9ydCBjbGFzcyBWZWN0b3JRdWVyeUltcGwge1xuICBwcml2YXRlIHJlcXVlc3RJZDogc3RyaW5nO1xuICBwcml2YXRlIHN0YXRlOlxuICAgIHwgeyB0eXBlOiBcInByZXBhcmluZ1wiOyBxdWVyeTogU2VyaWFsaXplZFZlY3RvclF1ZXJ5IH1cbiAgICB8IHsgdHlwZTogXCJjb25zdW1lZFwiIH07XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcmVxdWVzdElkOiBzdHJpbmcsXG4gICAgaW5kZXhOYW1lOiBzdHJpbmcsXG4gICAgcXVlcnk6IFZlY3RvclNlYXJjaFF1ZXJ5PEdlbmVyaWNUYWJsZUluZm8sIHN0cmluZz4sXG4gICkge1xuICAgIHRoaXMucmVxdWVzdElkID0gcmVxdWVzdElkO1xuICAgIGNvbnN0IGZpbHRlcnMgPSBxdWVyeS5maWx0ZXJcbiAgICAgID8gc2VyaWFsaXplRXhwcmVzc2lvbihxdWVyeS5maWx0ZXIoZmlsdGVyQnVpbGRlckltcGwpKVxuICAgICAgOiBudWxsO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHR5cGU6IFwicHJlcGFyaW5nXCIsXG4gICAgICBxdWVyeToge1xuICAgICAgICBpbmRleE5hbWUsXG4gICAgICAgIGxpbWl0OiBxdWVyeS5saW1pdCxcbiAgICAgICAgdmVjdG9yOiBxdWVyeS52ZWN0b3IsXG4gICAgICAgIGV4cHJlc3Npb25zOiBmaWx0ZXJzLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgYXN5bmMgY29sbGVjdCgpOiBQcm9taXNlPEFycmF5PGFueT4+IHtcbiAgICBpZiAodGhpcy5zdGF0ZS50eXBlID09PSBcImNvbnN1bWVkXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgcXVlcnkgaXMgY2xvc2VkIGFuZCBjYW4ndCBlbWl0IGFueSBtb3JlIHZhbHVlcy5cIik7XG4gICAgfVxuICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5zdGF0ZS5xdWVyeTtcbiAgICB0aGlzLnN0YXRlID0geyB0eXBlOiBcImNvbnN1bWVkXCIgfTtcblxuICAgIGNvbnN0IHsgcmVzdWx0cyB9ID0gYXdhaXQgcGVyZm9ybUFzeW5jU3lzY2FsbChcIjEuMC9hY3Rpb25zL3ZlY3RvclNlYXJjaFwiLCB7XG4gICAgICByZXF1ZXN0SWQ6IHRoaXMucmVxdWVzdElkLFxuICAgICAgdmVyc2lvbixcbiAgICAgIHF1ZXJ5LFxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG59XG5cbnR5cGUgU2VyaWFsaXplZFZlY3RvclF1ZXJ5ID0ge1xuICBpbmRleE5hbWU6IHN0cmluZztcbiAgbGltaXQ/OiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gIHZlY3RvcjogQXJyYXk8bnVtYmVyPjtcbiAgZXhwcmVzc2lvbnM6IEpTT05WYWx1ZTtcbn07XG5cbnR5cGUgRXhwcmVzc2lvbk9yVmFsdWU8VCBleHRlbmRzIFZhbHVlIHwgdW5kZWZpbmVkPiA9IEZpbHRlckV4cHJlc3Npb248VD4gfCBUO1xuXG4vLyBUaGUgYGFueWAgdHlwZSBwYXJhbWV0ZXIgaW4gYEV4cHJlc3Npb248YW55PmAgYWxsb3dzIHVzIHRvIHVzZSB0aGlzIGNsYXNzXG4vLyBpbiBwbGFjZSBvZiBhbnkgYEV4cHJlc3Npb25gIHR5cGUgaW4gYGZpbHRlckJ1aWxkZXJJbXBsYC5cbmV4cG9ydCBjbGFzcyBFeHByZXNzaW9uSW1wbCBleHRlbmRzIEZpbHRlckV4cHJlc3Npb248YW55PiB7XG4gIHByaXZhdGUgaW5uZXI6IEpTT05WYWx1ZTtcbiAgY29uc3RydWN0b3IoaW5uZXI6IEpTT05WYWx1ZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5pbm5lciA9IGlubmVyO1xuICB9XG5cbiAgc2VyaWFsaXplKCk6IEpTT05WYWx1ZSB7XG4gICAgcmV0dXJuIHRoaXMuaW5uZXI7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZUV4cHJlc3Npb24oXG4gIGV4cHI6IEV4cHJlc3Npb25PclZhbHVlPFZhbHVlIHwgdW5kZWZpbmVkPixcbik6IEpTT05WYWx1ZSB7XG4gIGlmIChleHByIGluc3RhbmNlb2YgRXhwcmVzc2lvbkltcGwpIHtcbiAgICByZXR1cm4gZXhwci5zZXJpYWxpemUoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBBc3N1bWUgdGhhdCB0aGUgZXhwcmVzc2lvbiBpcyBhIGxpdGVyYWwgQ29udmV4IHZhbHVlLCB3aGljaCB3ZSdsbCBzZXJpYWxpemVcbiAgICAvLyB0byBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi5cbiAgICByZXR1cm4geyAkbGl0ZXJhbDogY29udmV4T3JVbmRlZmluZWRUb0pzb24oZXhwciBhcyBWYWx1ZSB8IHVuZGVmaW5lZCkgfTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZmlsdGVyQnVpbGRlckltcGw6IFZlY3RvckZpbHRlckJ1aWxkZXI8XG4gIEdlbmVyaWNEb2N1bWVudCxcbiAgR2VuZXJpY1ZlY3RvckluZGV4Q29uZmlnXG4+ID0ge1xuICAvLyAgQ29tcGFyaXNvbnMgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICBlcTxGaWVsZE5hbWUgZXh0ZW5kcyBHZW5lcmljVmVjdG9ySW5kZXhDb25maWdbXCJmaWx0ZXJGaWVsZHNcIl0+KFxuICAgIGZpZWxkTmFtZTogRmllbGROYW1lLFxuICAgIHZhbHVlOiBGaWVsZFR5cGVGcm9tRmllbGRQYXRoPEdlbmVyaWNEb2N1bWVudCwgRmllbGROYW1lPixcbiAgKTogRmlsdGVyRXhwcmVzc2lvbjxib29sZWFuPiB7XG4gICAgaWYgKHR5cGVvZiBmaWVsZE5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBmaXJzdCBhcmd1bWVudCB0byBgcS5lcWAgbXVzdCBiZSBhIGZpZWxkIG5hbWUuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEV4cHJlc3Npb25JbXBsKHtcbiAgICAgICRlcTogW1xuICAgICAgICBzZXJpYWxpemVFeHByZXNzaW9uKG5ldyBFeHByZXNzaW9uSW1wbCh7ICRmaWVsZDogZmllbGROYW1lIH0pKSxcbiAgICAgICAgc2VyaWFsaXplRXhwcmVzc2lvbih2YWx1ZSksXG4gICAgICBdLFxuICAgIH0pO1xuICB9LFxuXG4gIC8vICBMb2dpYyAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIG9yKC4uLmV4cHJzOiBBcnJheTxFeHByZXNzaW9uT3JWYWx1ZTxib29sZWFuPj4pOiBGaWx0ZXJFeHByZXNzaW9uPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gbmV3IEV4cHJlc3Npb25JbXBsKHsgJG9yOiBleHBycy5tYXAoc2VyaWFsaXplRXhwcmVzc2lvbikgfSk7XG4gIH0sXG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuZXhwb3J0IGNsYXNzIEZpbHRlckV4cHJlc3Npb24ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvLyBQcm9wZXJ0eSBmb3Igbm9taW5hbCB0eXBlIHN1cHBvcnQuXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9pc0V4cHJlc3Npb25cIik7XG4gICAgLy8gUHJvcGVydHkgdG8gZGlzdGluZ3Vpc2ggZXhwcmVzc2lvbnMgYnkgdGhlIHR5cGUgdGhleSByZXNvbHZlIHRvLlxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfdmFsdWVcIik7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlY3Rvcl9zZWFyY2guanMubWFwXG4iLCJpbXBvcnQgeyBJZCwgVmFsdWUgfSBmcm9tIFwiLi4vdmFsdWVzL3ZhbHVlLmpzXCI7XG5pbXBvcnQge1xuICBEb2N1bWVudEJ5SW5mbyxcbiAgRmllbGRUeXBlRnJvbUZpZWxkUGF0aCxcbiAgR2VuZXJpY0RhdGFNb2RlbCxcbiAgR2VuZXJpY0RvY3VtZW50LFxuICBHZW5lcmljVGFibGVJbmZvLFxuICBHZW5lcmljVmVjdG9ySW5kZXhDb25maWcsXG4gIE5hbWVkVGFibGVJbmZvLFxuICBOYW1lZFZlY3RvckluZGV4LFxuICBUYWJsZU5hbWVzSW5EYXRhTW9kZWwsXG4gIFZlY3RvckluZGV4TmFtZXMsXG59IGZyb20gXCIuL2RhdGFfbW9kZWwuanNcIjtcblxuLyoqXG4gKiBBbiBvYmplY3Qgd2l0aCBwYXJhbWV0ZXJzIGZvciBwZXJmb3JtaW5nIGEgdmVjdG9yIHNlYXJjaCBhZ2FpbnN0IGEgdmVjdG9yIGluZGV4LlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFZlY3RvclNlYXJjaFF1ZXJ5PFxuICBUYWJsZUluZm8gZXh0ZW5kcyBHZW5lcmljVGFibGVJbmZvLFxuICBJbmRleE5hbWUgZXh0ZW5kcyBWZWN0b3JJbmRleE5hbWVzPFRhYmxlSW5mbz4sXG4+IHtcbiAgLyoqXG4gICAqIFRoZSBxdWVyeSB2ZWN0b3IuXG4gICAqXG4gICAqIFRoaXMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aCBhcyB0aGUgYGRpbWVuc2lvbnNgIG9mIHRoZSBpbmRleC5cbiAgICogVGhpcyB2ZWN0b3Igc2VhcmNoIHdpbGwgcmV0dXJuIHRoZSBJRHMgb2YgdGhlIGRvY3VtZW50cyBtb3N0IHNpbWlsYXIgdG9cbiAgICogdGhpcyB2ZWN0b3IuXG4gICAqL1xuICB2ZWN0b3I6IG51bWJlcltdO1xuICAvKipcbiAgICogVGhlIG51bWJlciBvZiByZXN1bHRzIHRvIHJldHVybi4gSWYgc3BlY2lmaWVkLCBtdXN0IGJlIGJldHdlZW4gMSBhbmQgMjU2XG4gICAqIGluY2x1c2l2ZS5cbiAgICpcbiAgICogQGRlZmF1bHQgMTBcbiAgICovXG4gIGxpbWl0PzogbnVtYmVyO1xuICAvKipcbiAgICogT3B0aW9uYWwgZmlsdGVyIGV4cHJlc3Npb24gbWFkZSB1cCBvZiBgcS5vcmAgYW5kIGBxLmVxYCBvcGVyYXRpbmdcbiAgICogb3ZlciB0aGUgZmlsdGVyIGZpZWxkcyBvZiB0aGUgaW5kZXguXG4gICAqXG4gICAqIGUuZy4gYGZpbHRlcjogcSA9PiBxLm9yKHEuZXEoXCJnZW5yZVwiLCBcImNvbWVkeVwiKSwgcS5lcShcImdlbnJlXCIsIFwiZHJhbWFcIikpYFxuICAgKlxuICAgKiBAcGFyYW0gcVxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZmlsdGVyPzogKFxuICAgIHE6IFZlY3RvckZpbHRlckJ1aWxkZXI8XG4gICAgICBEb2N1bWVudEJ5SW5mbzxUYWJsZUluZm8+LFxuICAgICAgTmFtZWRWZWN0b3JJbmRleDxUYWJsZUluZm8sIEluZGV4TmFtZT5cbiAgICA+LFxuICApID0+IEZpbHRlckV4cHJlc3Npb248Ym9vbGVhbj47XG59XG5cbmV4cG9ydCB0eXBlIFZlY3RvclNlYXJjaDxcbiAgRGF0YU1vZGVsIGV4dGVuZHMgR2VuZXJpY0RhdGFNb2RlbCxcbiAgVGFibGVOYW1lIGV4dGVuZHMgVGFibGVOYW1lc0luRGF0YU1vZGVsPERhdGFNb2RlbD4sXG4gIEluZGV4TmFtZSBleHRlbmRzIFZlY3RvckluZGV4TmFtZXM8TmFtZWRUYWJsZUluZm88RGF0YU1vZGVsLCBUYWJsZU5hbWU+Pixcbj4gPSAoXG4gIHRhYmxlTmFtZTogVGFibGVOYW1lLFxuICBpbmRleE5hbWU6IEluZGV4TmFtZSxcbiAgcXVlcnk6IFZlY3RvclNlYXJjaFF1ZXJ5PE5hbWVkVGFibGVJbmZvPERhdGFNb2RlbCwgVGFibGVOYW1lPiwgSW5kZXhOYW1lPixcbikgPT4gUHJvbWlzZTxBcnJheTx7IF9pZDogSWQ8VGFibGVOYW1lPjsgX3Njb3JlOiBudW1iZXIgfT4+O1xuXG4vKipcbiAqIEV4cHJlc3Npb25zIGFyZSBldmFsdWF0ZWQgdG8gcHJvZHVjZSBhIHtAbGluayB2YWx1ZXMuVmFsdWV9IGluIHRoZSBjb3Vyc2Ugb2YgZXhlY3V0aW5nIGEgcXVlcnkuXG4gKlxuICogVG8gY29uc3RydWN0IGFuIGV4cHJlc3Npb24sIHVzZSB0aGUge0BsaW5rIFZlY3RvckZpbHRlckJ1aWxkZXJ9IHByb3ZpZGVkIHdpdGhpblxuICoge0BsaW5rIFZlY3RvclNlYXJjaFF1ZXJ5fS5cbiAqXG4gKiBAdHlwZVBhcmFtIFQgLSBUaGUgdHlwZSB0aGF0IHRoaXMgZXhwcmVzc2lvbiBldmFsdWF0ZXMgdG8uXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBGaWx0ZXJFeHByZXNzaW9uPFQgZXh0ZW5kcyBWYWx1ZSB8IHVuZGVmaW5lZD4ge1xuICAvLyBQcm9wZXJ0eSBmb3Igbm9taW5hbCB0eXBlIHN1cHBvcnQuXG4gIHByaXZhdGUgX2lzRXhwcmVzc2lvbjogdW5kZWZpbmVkO1xuXG4gIC8vIFByb3BlcnR5IHRvIGRpc3Rpbmd1aXNoIGV4cHJlc3Npb25zIGJ5IHRoZSB0eXBlIHRoZXkgcmVzb2x2ZSB0by5cbiAgcHJpdmF0ZSBfdmFsdWUhOiBUO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8vIG9ubHkgZGVmaW5pbmcgdGhlIGNvbnN0cnVjdG9yIHNvIHdlIGNhbiBtYXJrIGl0IGFzIGludGVybmFsIGFuZCBrZWVwXG4gICAgLy8gaXQgb3V0IG9mIHRoZSBkb2NzLlxuICB9XG59XG5cbi8qKlxuICogQW4gaW50ZXJmYWNlIGZvciBkZWZpbmluZyBmaWx0ZXJzIGZvciB2ZWN0b3Igc2VhcmNoZXMuXG4gKlxuICogVGhpcyBoYXMgYSBzaW1pbGFyIGludGVyZmFjZSB0byB7QGxpbmsgRmlsdGVyQnVpbGRlcn0sIHdoaWNoIGlzIHVzZWQgaW5cbiAqIGRhdGFiYXNlIHF1ZXJpZXMsIGJ1dCBzdXBwb3J0cyBvbmx5IHRoZSBtZXRob2RzIHRoYXQgY2FuIGJlIGVmZmljaWVudGx5XG4gKiBkb25lIGluIGEgdmVjdG9yIHNlYXJjaC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVmVjdG9yRmlsdGVyQnVpbGRlcjxcbiAgRG9jdW1lbnQgZXh0ZW5kcyBHZW5lcmljRG9jdW1lbnQsXG4gIFZlY3RvckluZGV4Q29uZmlnIGV4dGVuZHMgR2VuZXJpY1ZlY3RvckluZGV4Q29uZmlnLFxuPiB7XG4gIC8vICBDb21wYXJpc29ucyAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIC8qKlxuICAgKiBJcyB0aGUgZmllbGQgYXQgYGZpZWxkTmFtZWAgZXF1YWwgdG8gYHZhbHVlYFxuICAgKlxuICAgKiBAcHVibGljXG4gICAqICovXG4gIGVxPEZpZWxkTmFtZSBleHRlbmRzIFZlY3RvckluZGV4Q29uZmlnW1wiZmlsdGVyRmllbGRzXCJdPihcbiAgICBmaWVsZE5hbWU6IEZpZWxkTmFtZSxcbiAgICB2YWx1ZTogRmllbGRUeXBlRnJvbUZpZWxkUGF0aDxEb2N1bWVudCwgRmllbGROYW1lPixcbiAgKTogRmlsdGVyRXhwcmVzc2lvbjxib29sZWFuPjtcblxuICAvLyAgTG9naWMgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAvKipcbiAgICogYGV4cHJzWzBdIHx8IGV4cHJzWzFdIHx8IC4uLiB8fCBleHByc1tuXWBcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgb3IoLi4uZXhwcnM6IEFycmF5PEZpbHRlckV4cHJlc3Npb248Ym9vbGVhbj4+KTogRmlsdGVyRXhwcmVzc2lvbjxib29sZWFuPjtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQXJnKGFyZywgaWR4LCBtZXRob2QsIGFyZ05hbWUpIHtcbiAgaWYgKGFyZyA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgIGBNdXN0IHByb3ZpZGUgYXJnICR7aWR4fSBcXGAke2FyZ05hbWV9XFxgIHRvIFxcYCR7bWV0aG9kfVxcYGBcbiAgICApO1xuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVBcmdJc0ludGVnZXIoYXJnLCBpZHgsIG1ldGhvZCwgYXJnTmFtZSkge1xuICBpZiAoIU51bWJlci5pc0ludGVnZXIoYXJnKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBgQXJnICR7aWR4fSBcXGAke2FyZ05hbWV9XFxgIHRvIFxcYCR7bWV0aG9kfVxcYCBtdXN0IGJlIGFuIGludGVnZXJgXG4gICAgKTtcbiAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQXJnSXNOb25OZWdhdGl2ZUludGVnZXIoYXJnLCBpZHgsIG1ldGhvZCwgYXJnTmFtZSkge1xuICBpZiAoIU51bWJlci5pc0ludGVnZXIoYXJnKSB8fCBhcmcgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgIGBBcmcgJHtpZHh9IFxcYCR7YXJnTmFtZX1cXGAgdG8gXFxgJHttZXRob2R9XFxgIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlcmBcbiAgICApO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWxpZGF0ZS5qcy5tYXBcbiIsImV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUFyZyhcbiAgYXJnOiBhbnksXG4gIGlkeDogbnVtYmVyLFxuICBtZXRob2Q6IHN0cmluZyxcbiAgYXJnTmFtZTogc3RyaW5nLFxuKSB7XG4gIGlmIChhcmcgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBgTXVzdCBwcm92aWRlIGFyZyAke2lkeH0gXFxgJHthcmdOYW1lfVxcYCB0byBcXGAke21ldGhvZH1cXGBgLFxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQXJnSXNJbnRlZ2VyKFxuICBhcmc6IGFueSxcbiAgaWR4OiBudW1iZXIsXG4gIG1ldGhvZDogc3RyaW5nLFxuICBhcmdOYW1lOiBzdHJpbmcsXG4pIHtcbiAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGFyZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgYEFyZyAke2lkeH0gXFxgJHthcmdOYW1lfVxcYCB0byBcXGAke21ldGhvZH1cXGAgbXVzdCBiZSBhbiBpbnRlZ2VyYCxcbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUFyZ0lzTm9uTmVnYXRpdmVJbnRlZ2VyKFxuICBhcmc6IGFueSxcbiAgaWR4OiBudW1iZXIsXG4gIG1ldGhvZDogc3RyaW5nLFxuICBhcmdOYW1lOiBzdHJpbmcsXG4pIHtcbiAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGFyZykgfHwgYXJnIDwgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBgQXJnICR7aWR4fSBcXGAke2FyZ05hbWV9XFxgIHRvIFxcYCR7bWV0aG9kfVxcYCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXJgLFxuICAgICk7XG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgcGVyZm9ybUFzeW5jU3lzY2FsbCB9IGZyb20gXCIuL3N5c2NhbGwuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBzZXR1cEF1dGgocmVxdWVzdElkKSB7XG4gIHJldHVybiB7XG4gICAgZ2V0VXNlcklkZW50aXR5OiBhc3luYyAoKSA9PiB7XG4gICAgICByZXR1cm4gYXdhaXQgcGVyZm9ybUFzeW5jU3lzY2FsbChcIjEuMC9nZXRVc2VySWRlbnRpdHlcIiwge1xuICAgICAgICByZXF1ZXN0SWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1dGhlbnRpY2F0aW9uX2ltcGwuanMubWFwXG4iLCJpbXBvcnQgeyBBdXRoIH0gZnJvbSBcIi4uL2F1dGhlbnRpY2F0aW9uLmpzXCI7XG5pbXBvcnQgeyBwZXJmb3JtQXN5bmNTeXNjYWxsIH0gZnJvbSBcIi4vc3lzY2FsbC5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0dXBBdXRoKHJlcXVlc3RJZDogc3RyaW5nKTogQXV0aCB7XG4gIHJldHVybiB7XG4gICAgZ2V0VXNlcklkZW50aXR5OiBhc3luYyAoKSA9PiB7XG4gICAgICByZXR1cm4gYXdhaXQgcGVyZm9ybUFzeW5jU3lzY2FsbChcIjEuMC9nZXRVc2VySWRlbnRpdHlcIiwge1xuICAgICAgICByZXF1ZXN0SWQsXG4gICAgICB9KTtcbiAgICB9LFxuICB9O1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQge1xuICBjb252ZXhUb0pzb24sXG4gIGpzb25Ub0NvbnZleFxufSBmcm9tIFwiLi4vLi4vdmFsdWVzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBwZXJmb3JtQXN5bmNTeXNjYWxsLCBwZXJmb3JtU3lzY2FsbCB9IGZyb20gXCIuL3N5c2NhbGwuanNcIjtcbmltcG9ydCB7IFF1ZXJ5SW5pdGlhbGl6ZXJJbXBsIH0gZnJvbSBcIi4vcXVlcnlfaW1wbC5qc1wiO1xuaW1wb3J0IHsgdmFsaWRhdGVBcmcgfSBmcm9tIFwiLi92YWxpZGF0ZS5qc1wiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuLi8uLi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgcGF0Y2hWYWx1ZVRvSnNvbiB9IGZyb20gXCIuLi8uLi92YWx1ZXMvdmFsdWUuanNcIjtcbmFzeW5jIGZ1bmN0aW9uIGdldCh0YWJsZSwgaWQsIGlzU3lzdGVtKSB7XG4gIHZhbGlkYXRlQXJnKGlkLCAxLCBcImdldFwiLCBcImlkXCIpO1xuICBpZiAodHlwZW9mIGlkICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFsaWQgYXJndW1lbnQgXFxgaWRcXGAgZm9yIFxcYGRiLmdldFxcYCwgZXhwZWN0ZWQgc3RyaW5nIGJ1dCBnb3QgJyR7dHlwZW9mIGlkfSc6ICR7aWR9YFxuICAgICk7XG4gIH1cbiAgY29uc3QgYXJncyA9IHtcbiAgICBpZDogY29udmV4VG9Kc29uKGlkKSxcbiAgICBpc1N5c3RlbSxcbiAgICB2ZXJzaW9uLFxuICAgIHRhYmxlXG4gIH07XG4gIGNvbnN0IHN5c2NhbGxKU09OID0gYXdhaXQgcGVyZm9ybUFzeW5jU3lzY2FsbChcIjEuMC9nZXRcIiwgYXJncyk7XG4gIHJldHVybiBqc29uVG9Db252ZXgoc3lzY2FsbEpTT04pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNldHVwUmVhZGVyKCkge1xuICBjb25zdCByZWFkZXIgPSAoaXNTeXN0ZW0gPSBmYWxzZSkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBnZXQ6IGFzeW5jIChhcmcwLCBhcmcxKSA9PiB7XG4gICAgICAgIHJldHVybiBhcmcxICE9PSB2b2lkIDAgPyBhd2FpdCBnZXQoYXJnMCwgYXJnMSwgaXNTeXN0ZW0pIDogYXdhaXQgZ2V0KHZvaWQgMCwgYXJnMCwgaXNTeXN0ZW0pO1xuICAgICAgfSxcbiAgICAgIHF1ZXJ5OiAodGFibGVOYW1lKSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgVGFibGVSZWFkZXIodGFibGVOYW1lLCBpc1N5c3RlbSkucXVlcnkoKTtcbiAgICAgIH0sXG4gICAgICBub3JtYWxpemVJZDogKHRhYmxlTmFtZSwgaWQpID0+IHtcbiAgICAgICAgdmFsaWRhdGVBcmcodGFibGVOYW1lLCAxLCBcIm5vcm1hbGl6ZUlkXCIsIFwidGFibGVOYW1lXCIpO1xuICAgICAgICB2YWxpZGF0ZUFyZyhpZCwgMiwgXCJub3JtYWxpemVJZFwiLCBcImlkXCIpO1xuICAgICAgICBjb25zdCBhY2Nlc3NpbmdTeXN0ZW1UYWJsZSA9IHRhYmxlTmFtZS5zdGFydHNXaXRoKFwiX1wiKTtcbiAgICAgICAgaWYgKGFjY2Vzc2luZ1N5c3RlbVRhYmxlICE9PSBpc1N5c3RlbSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGAke2FjY2Vzc2luZ1N5c3RlbVRhYmxlID8gXCJTeXN0ZW1cIiA6IFwiVXNlclwifSB0YWJsZXMgY2FuIG9ubHkgYmUgYWNjZXNzZWQgZnJvbSBkYi4ke2lzU3lzdGVtID8gXCJcIiA6IFwic3lzdGVtLlwifW5vcm1hbGl6ZUlkKCkuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3lzY2FsbEpTT04gPSBwZXJmb3JtU3lzY2FsbChcIjEuMC9kYi9ub3JtYWxpemVJZFwiLCB7XG4gICAgICAgICAgdGFibGU6IHRhYmxlTmFtZSxcbiAgICAgICAgICBpZFN0cmluZzogaWRcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHN5c2NhbGxSZXN1bHQgPSBqc29uVG9Db252ZXgoc3lzY2FsbEpTT04pO1xuICAgICAgICByZXR1cm4gc3lzY2FsbFJlc3VsdC5pZDtcbiAgICAgIH0sXG4gICAgICAvLyBXZSBzZXQgdGhlIHN5c3RlbSByZWFkZXIgb24gdGhlIG5leHQgbGluZVxuICAgICAgc3lzdGVtOiBudWxsLFxuICAgICAgdGFibGU6ICh0YWJsZU5hbWUpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBUYWJsZVJlYWRlcih0YWJsZU5hbWUsIGlzU3lzdGVtKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICBjb25zdCB7IHN5c3RlbTogXywgLi4ucmVzdCB9ID0gcmVhZGVyKHRydWUpO1xuICBjb25zdCByID0gcmVhZGVyKCk7XG4gIHIuc3lzdGVtID0gcmVzdDtcbiAgcmV0dXJuIHI7XG59XG5hc3luYyBmdW5jdGlvbiBpbnNlcnQodGFibGVOYW1lLCB2YWx1ZSkge1xuICBpZiAodGFibGVOYW1lLnN0YXJ0c1dpdGgoXCJfXCIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU3lzdGVtIHRhYmxlcyAocHJlZml4ZWQgd2l0aCBgX2ApIGFyZSByZWFkLW9ubHkuXCIpO1xuICB9XG4gIHZhbGlkYXRlQXJnKHRhYmxlTmFtZSwgMSwgXCJpbnNlcnRcIiwgXCJ0YWJsZVwiKTtcbiAgdmFsaWRhdGVBcmcodmFsdWUsIDIsIFwiaW5zZXJ0XCIsIFwidmFsdWVcIik7XG4gIGNvbnN0IHN5c2NhbGxKU09OID0gYXdhaXQgcGVyZm9ybUFzeW5jU3lzY2FsbChcIjEuMC9pbnNlcnRcIiwge1xuICAgIHRhYmxlOiB0YWJsZU5hbWUsXG4gICAgdmFsdWU6IGNvbnZleFRvSnNvbih2YWx1ZSlcbiAgfSk7XG4gIGNvbnN0IHN5c2NhbGxSZXN1bHQgPSBqc29uVG9Db252ZXgoc3lzY2FsbEpTT04pO1xuICByZXR1cm4gc3lzY2FsbFJlc3VsdC5faWQ7XG59XG5hc3luYyBmdW5jdGlvbiBwYXRjaCh0YWJsZSwgaWQsIHZhbHVlKSB7XG4gIHZhbGlkYXRlQXJnKGlkLCAxLCBcInBhdGNoXCIsIFwiaWRcIik7XG4gIHZhbGlkYXRlQXJnKHZhbHVlLCAyLCBcInBhdGNoXCIsIFwidmFsdWVcIik7XG4gIGF3YWl0IHBlcmZvcm1Bc3luY1N5c2NhbGwoXCIxLjAvc2hhbGxvd01lcmdlXCIsIHtcbiAgICBpZDogY29udmV4VG9Kc29uKGlkKSxcbiAgICB2YWx1ZTogcGF0Y2hWYWx1ZVRvSnNvbih2YWx1ZSksXG4gICAgdGFibGVcbiAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiByZXBsYWNlKHRhYmxlLCBpZCwgdmFsdWUpIHtcbiAgdmFsaWRhdGVBcmcoaWQsIDEsIFwicmVwbGFjZVwiLCBcImlkXCIpO1xuICB2YWxpZGF0ZUFyZyh2YWx1ZSwgMiwgXCJyZXBsYWNlXCIsIFwidmFsdWVcIik7XG4gIGF3YWl0IHBlcmZvcm1Bc3luY1N5c2NhbGwoXCIxLjAvcmVwbGFjZVwiLCB7XG4gICAgaWQ6IGNvbnZleFRvSnNvbihpZCksXG4gICAgdmFsdWU6IGNvbnZleFRvSnNvbih2YWx1ZSksXG4gICAgdGFibGVcbiAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBkZWxldGVfKHRhYmxlLCBpZCkge1xuICB2YWxpZGF0ZUFyZyhpZCwgMSwgXCJkZWxldGVcIiwgXCJpZFwiKTtcbiAgYXdhaXQgcGVyZm9ybUFzeW5jU3lzY2FsbChcIjEuMC9yZW1vdmVcIiwge1xuICAgIGlkOiBjb252ZXhUb0pzb24oaWQpLFxuICAgIHRhYmxlXG4gIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNldHVwV3JpdGVyKCkge1xuICBjb25zdCByZWFkZXIgPSBzZXR1cFJlYWRlcigpO1xuICByZXR1cm4ge1xuICAgIGdldDogcmVhZGVyLmdldCxcbiAgICBxdWVyeTogcmVhZGVyLnF1ZXJ5LFxuICAgIG5vcm1hbGl6ZUlkOiByZWFkZXIubm9ybWFsaXplSWQsXG4gICAgc3lzdGVtOiByZWFkZXIuc3lzdGVtLFxuICAgIGluc2VydDogYXN5bmMgKHRhYmxlLCB2YWx1ZSkgPT4ge1xuICAgICAgcmV0dXJuIGF3YWl0IGluc2VydCh0YWJsZSwgdmFsdWUpO1xuICAgIH0sXG4gICAgcGF0Y2g6IGFzeW5jIChhcmcwLCBhcmcxLCBhcmcyKSA9PiB7XG4gICAgICByZXR1cm4gYXJnMiAhPT0gdm9pZCAwID8gYXdhaXQgcGF0Y2goYXJnMCwgYXJnMSwgYXJnMikgOiBhd2FpdCBwYXRjaCh2b2lkIDAsIGFyZzAsIGFyZzEpO1xuICAgIH0sXG4gICAgcmVwbGFjZTogYXN5bmMgKGFyZzAsIGFyZzEsIGFyZzIpID0+IHtcbiAgICAgIHJldHVybiBhcmcyICE9PSB2b2lkIDAgPyBhd2FpdCByZXBsYWNlKGFyZzAsIGFyZzEsIGFyZzIpIDogYXdhaXQgcmVwbGFjZSh2b2lkIDAsIGFyZzAsIGFyZzEpO1xuICAgIH0sXG4gICAgZGVsZXRlOiBhc3luYyAoYXJnMCwgYXJnMSkgPT4ge1xuICAgICAgcmV0dXJuIGFyZzEgIT09IHZvaWQgMCA/IGF3YWl0IGRlbGV0ZV8oYXJnMCwgYXJnMSkgOiBhd2FpdCBkZWxldGVfKHZvaWQgMCwgYXJnMCk7XG4gICAgfSxcbiAgICB0YWJsZTogKHRhYmxlTmFtZSkgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBUYWJsZVdyaXRlcih0YWJsZU5hbWUsIGZhbHNlKTtcbiAgICB9XG4gIH07XG59XG5jbGFzcyBUYWJsZVJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHRhYmxlTmFtZSwgaXNTeXN0ZW0pIHtcbiAgICB0aGlzLnRhYmxlTmFtZSA9IHRhYmxlTmFtZTtcbiAgICB0aGlzLmlzU3lzdGVtID0gaXNTeXN0ZW07XG4gIH1cbiAgYXN5bmMgZ2V0KGlkKSB7XG4gICAgcmV0dXJuIGdldCh0aGlzLnRhYmxlTmFtZSwgaWQsIHRoaXMuaXNTeXN0ZW0pO1xuICB9XG4gIHF1ZXJ5KCkge1xuICAgIGNvbnN0IGFjY2Vzc2luZ1N5c3RlbVRhYmxlID0gdGhpcy50YWJsZU5hbWUuc3RhcnRzV2l0aChcIl9cIik7XG4gICAgaWYgKGFjY2Vzc2luZ1N5c3RlbVRhYmxlICE9PSB0aGlzLmlzU3lzdGVtKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGAke2FjY2Vzc2luZ1N5c3RlbVRhYmxlID8gXCJTeXN0ZW1cIiA6IFwiVXNlclwifSB0YWJsZXMgY2FuIG9ubHkgYmUgYWNjZXNzZWQgZnJvbSBkYi4ke3RoaXMuaXNTeXN0ZW0gPyBcIlwiIDogXCJzeXN0ZW0uXCJ9cXVlcnkoKS5gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFF1ZXJ5SW5pdGlhbGl6ZXJJbXBsKHRoaXMudGFibGVOYW1lKTtcbiAgfVxufVxuY2xhc3MgVGFibGVXcml0ZXIgZXh0ZW5kcyBUYWJsZVJlYWRlciB7XG4gIGFzeW5jIGluc2VydCh2YWx1ZSkge1xuICAgIHJldHVybiBpbnNlcnQodGhpcy50YWJsZU5hbWUsIHZhbHVlKTtcbiAgfVxuICBhc3luYyBwYXRjaChpZCwgdmFsdWUpIHtcbiAgICByZXR1cm4gcGF0Y2godGhpcy50YWJsZU5hbWUsIGlkLCB2YWx1ZSk7XG4gIH1cbiAgYXN5bmMgcmVwbGFjZShpZCwgdmFsdWUpIHtcbiAgICByZXR1cm4gcmVwbGFjZSh0aGlzLnRhYmxlTmFtZSwgaWQsIHZhbHVlKTtcbiAgfVxuICBhc3luYyBkZWxldGUoaWQpIHtcbiAgICByZXR1cm4gZGVsZXRlXyh0aGlzLnRhYmxlTmFtZSwgaWQpO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhYmFzZV9pbXBsLmpzLm1hcFxuIiwiaW1wb3J0IHtcbiAgY29udmV4VG9Kc29uLFxuICBHZW5lcmljSWQsXG4gIGpzb25Ub0NvbnZleCxcbiAgVmFsdWUsXG59IGZyb20gXCIuLi8uLi92YWx1ZXMvaW5kZXguanNcIjtcbmltcG9ydCB7IHBlcmZvcm1Bc3luY1N5c2NhbGwsIHBlcmZvcm1TeXNjYWxsIH0gZnJvbSBcIi4vc3lzY2FsbC5qc1wiO1xuaW1wb3J0IHtcbiAgR2VuZXJpY0RhdGFiYXNlUmVhZGVyLFxuICBHZW5lcmljRGF0YWJhc2VSZWFkZXJXaXRoVGFibGUsXG4gIEdlbmVyaWNEYXRhYmFzZVdyaXRlcixcbiAgR2VuZXJpY0RhdGFiYXNlV3JpdGVyV2l0aFRhYmxlLFxufSBmcm9tIFwiLi4vZGF0YWJhc2UuanNcIjtcbmltcG9ydCB7IFF1ZXJ5SW5pdGlhbGl6ZXJJbXBsIH0gZnJvbSBcIi4vcXVlcnlfaW1wbC5qc1wiO1xuaW1wb3J0IHsgR2VuZXJpY0RhdGFNb2RlbCwgR2VuZXJpY0RvY3VtZW50IH0gZnJvbSBcIi4uL2RhdGFfbW9kZWwuanNcIjtcbmltcG9ydCB7IHZhbGlkYXRlQXJnIH0gZnJvbSBcIi4vdmFsaWRhdGUuanNcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi4vLi4vaW5kZXguanNcIjtcbmltcG9ydCB7IHBhdGNoVmFsdWVUb0pzb24gfSBmcm9tIFwiLi4vLi4vdmFsdWVzL3ZhbHVlLmpzXCI7XG5cbmFzeW5jIGZ1bmN0aW9uIGdldChcbiAgdGFibGU6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgaWQ6IEdlbmVyaWNJZDxzdHJpbmc+LFxuICBpc1N5c3RlbTogYm9vbGVhbixcbikge1xuICAvLyBJZiB0aGUgdXNlciBkb2VzbuKAmXQgcHJvdmlkZSBhbnkgYXJndW1lbnRzLCB3ZSB1c2UgdGhlIG5ldyBzaWduYXR1cmUgaW4gdGhlIGVycm9yIG1lc3NhZ2UuXG4gIC8vIFdlIGRvbuKAmXQgZG8gYXJndW1lbnQgdmFsaWRhdGlvbiBvbiB0aGUgdGFibGUgYXJndW1lbnQgc2luY2UgaXTigJlzIG5vdCBwcm92aWRlZCB3aGVuIHVzaW5nIHRoZSBvbGQgc2lnbmF0dXJlLlxuICB2YWxpZGF0ZUFyZyhpZCwgMSwgXCJnZXRcIiwgXCJpZFwiKTtcbiAgaWYgKHR5cGVvZiBpZCAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbnZhbGlkIGFyZ3VtZW50IFxcYGlkXFxgIGZvciBcXGBkYi5nZXRcXGAsIGV4cGVjdGVkIHN0cmluZyBidXQgZ290ICcke3R5cGVvZiBpZH0nOiAke1xuICAgICAgICBpZCBhcyBhbnlcbiAgICAgIH1gLFxuICAgICk7XG4gIH1cbiAgY29uc3QgYXJncyA9IHtcbiAgICBpZDogY29udmV4VG9Kc29uKGlkKSxcbiAgICBpc1N5c3RlbSxcbiAgICB2ZXJzaW9uLFxuICAgIHRhYmxlLFxuICB9O1xuICBjb25zdCBzeXNjYWxsSlNPTiA9IGF3YWl0IHBlcmZvcm1Bc3luY1N5c2NhbGwoXCIxLjAvZ2V0XCIsIGFyZ3MpO1xuXG4gIHJldHVybiBqc29uVG9Db252ZXgoc3lzY2FsbEpTT04pIGFzIEdlbmVyaWNEb2N1bWVudDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldHVwUmVhZGVyKCk6IEdlbmVyaWNEYXRhYmFzZVJlYWRlcjxHZW5lcmljRGF0YU1vZGVsPiB7XG4gIGNvbnN0IHJlYWRlciA9IChcbiAgICBpc1N5c3RlbSA9IGZhbHNlLFxuICApOiBHZW5lcmljRGF0YWJhc2VSZWFkZXI8R2VuZXJpY0RhdGFNb2RlbD4gJlxuICAgIEdlbmVyaWNEYXRhYmFzZVJlYWRlcldpdGhUYWJsZTxHZW5lcmljRGF0YU1vZGVsPiA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldDogYXN5bmMgKGFyZzA6IGFueSwgYXJnMT86IGFueSkgPT4ge1xuICAgICAgICByZXR1cm4gYXJnMSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyBhd2FpdCBnZXQoYXJnMCwgYXJnMSwgaXNTeXN0ZW0pXG4gICAgICAgICAgOiBhd2FpdCBnZXQodW5kZWZpbmVkLCBhcmcwLCBpc1N5c3RlbSk7XG4gICAgICB9LFxuICAgICAgcXVlcnk6ICh0YWJsZU5hbWU6IHN0cmluZykgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFRhYmxlUmVhZGVyKHRhYmxlTmFtZSwgaXNTeXN0ZW0pLnF1ZXJ5KCk7XG4gICAgICB9LFxuICAgICAgbm9ybWFsaXplSWQ6IDxUYWJsZU5hbWUgZXh0ZW5kcyBzdHJpbmc+KFxuICAgICAgICB0YWJsZU5hbWU6IFRhYmxlTmFtZSxcbiAgICAgICAgaWQ6IHN0cmluZyxcbiAgICAgICk6IEdlbmVyaWNJZDxUYWJsZU5hbWU+IHwgbnVsbCA9PiB7XG4gICAgICAgIHZhbGlkYXRlQXJnKHRhYmxlTmFtZSwgMSwgXCJub3JtYWxpemVJZFwiLCBcInRhYmxlTmFtZVwiKTtcbiAgICAgICAgdmFsaWRhdGVBcmcoaWQsIDIsIFwibm9ybWFsaXplSWRcIiwgXCJpZFwiKTtcbiAgICAgICAgY29uc3QgYWNjZXNzaW5nU3lzdGVtVGFibGUgPSB0YWJsZU5hbWUuc3RhcnRzV2l0aChcIl9cIik7XG4gICAgICAgIGlmIChhY2Nlc3NpbmdTeXN0ZW1UYWJsZSAhPT0gaXNTeXN0ZW0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgJHtcbiAgICAgICAgICAgICAgYWNjZXNzaW5nU3lzdGVtVGFibGUgPyBcIlN5c3RlbVwiIDogXCJVc2VyXCJcbiAgICAgICAgICAgIH0gdGFibGVzIGNhbiBvbmx5IGJlIGFjY2Vzc2VkIGZyb20gZGIuJHtcbiAgICAgICAgICAgICAgaXNTeXN0ZW0gPyBcIlwiIDogXCJzeXN0ZW0uXCJcbiAgICAgICAgICAgIH1ub3JtYWxpemVJZCgpLmAsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzeXNjYWxsSlNPTiA9IHBlcmZvcm1TeXNjYWxsKFwiMS4wL2RiL25vcm1hbGl6ZUlkXCIsIHtcbiAgICAgICAgICB0YWJsZTogdGFibGVOYW1lLFxuICAgICAgICAgIGlkU3RyaW5nOiBpZCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHN5c2NhbGxSZXN1bHQgPSBqc29uVG9Db252ZXgoc3lzY2FsbEpTT04pIGFzIGFueTtcbiAgICAgICAgcmV0dXJuIHN5c2NhbGxSZXN1bHQuaWQ7XG4gICAgICB9LFxuICAgICAgLy8gV2Ugc2V0IHRoZSBzeXN0ZW0gcmVhZGVyIG9uIHRoZSBuZXh0IGxpbmVcbiAgICAgIHN5c3RlbTogbnVsbCBhcyBhbnksXG4gICAgICB0YWJsZTogKHRhYmxlTmFtZSkgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFRhYmxlUmVhZGVyKHRhYmxlTmFtZSwgaXNTeXN0ZW0pO1xuICAgICAgfSxcbiAgICB9O1xuICB9O1xuICBjb25zdCB7IHN5c3RlbTogXywgLi4ucmVzdCB9ID0gcmVhZGVyKHRydWUpO1xuICBjb25zdCByID0gcmVhZGVyKCk7XG4gIHIuc3lzdGVtID0gcmVzdCBhcyBhbnk7XG4gIHJldHVybiByO1xufVxuXG5hc3luYyBmdW5jdGlvbiBpbnNlcnQodGFibGVOYW1lOiBzdHJpbmcsIHZhbHVlOiBhbnkpIHtcbiAgaWYgKHRhYmxlTmFtZS5zdGFydHNXaXRoKFwiX1wiKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlN5c3RlbSB0YWJsZXMgKHByZWZpeGVkIHdpdGggYF9gKSBhcmUgcmVhZC1vbmx5LlwiKTtcbiAgfVxuICB2YWxpZGF0ZUFyZyh0YWJsZU5hbWUsIDEsIFwiaW5zZXJ0XCIsIFwidGFibGVcIik7XG4gIHZhbGlkYXRlQXJnKHZhbHVlLCAyLCBcImluc2VydFwiLCBcInZhbHVlXCIpO1xuICBjb25zdCBzeXNjYWxsSlNPTiA9IGF3YWl0IHBlcmZvcm1Bc3luY1N5c2NhbGwoXCIxLjAvaW5zZXJ0XCIsIHtcbiAgICB0YWJsZTogdGFibGVOYW1lLFxuICAgIHZhbHVlOiBjb252ZXhUb0pzb24odmFsdWUpLFxuICB9KTtcbiAgY29uc3Qgc3lzY2FsbFJlc3VsdCA9IGpzb25Ub0NvbnZleChzeXNjYWxsSlNPTikgYXMgYW55O1xuICByZXR1cm4gc3lzY2FsbFJlc3VsdC5faWQ7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHBhdGNoKHRhYmxlOiBzdHJpbmcgfCB1bmRlZmluZWQsIGlkOiBhbnksIHZhbHVlOiBhbnkpIHtcbiAgdmFsaWRhdGVBcmcoaWQsIDEsIFwicGF0Y2hcIiwgXCJpZFwiKTtcbiAgdmFsaWRhdGVBcmcodmFsdWUsIDIsIFwicGF0Y2hcIiwgXCJ2YWx1ZVwiKTtcbiAgYXdhaXQgcGVyZm9ybUFzeW5jU3lzY2FsbChcIjEuMC9zaGFsbG93TWVyZ2VcIiwge1xuICAgIGlkOiBjb252ZXhUb0pzb24oaWQpLFxuICAgIHZhbHVlOiBwYXRjaFZhbHVlVG9Kc29uKHZhbHVlIGFzIFZhbHVlKSxcbiAgICB0YWJsZSxcbiAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlcGxhY2UodGFibGU6IHN0cmluZyB8IHVuZGVmaW5lZCwgaWQ6IGFueSwgdmFsdWU6IGFueSkge1xuICB2YWxpZGF0ZUFyZyhpZCwgMSwgXCJyZXBsYWNlXCIsIFwiaWRcIik7XG4gIHZhbGlkYXRlQXJnKHZhbHVlLCAyLCBcInJlcGxhY2VcIiwgXCJ2YWx1ZVwiKTtcbiAgYXdhaXQgcGVyZm9ybUFzeW5jU3lzY2FsbChcIjEuMC9yZXBsYWNlXCIsIHtcbiAgICBpZDogY29udmV4VG9Kc29uKGlkKSxcbiAgICB2YWx1ZTogY29udmV4VG9Kc29uKHZhbHVlKSxcbiAgICB0YWJsZSxcbiAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGRlbGV0ZV8odGFibGU6IHN0cmluZyB8IHVuZGVmaW5lZCwgaWQ6IGFueSkge1xuICB2YWxpZGF0ZUFyZyhpZCwgMSwgXCJkZWxldGVcIiwgXCJpZFwiKTtcbiAgYXdhaXQgcGVyZm9ybUFzeW5jU3lzY2FsbChcIjEuMC9yZW1vdmVcIiwge1xuICAgIGlkOiBjb252ZXhUb0pzb24oaWQpLFxuICAgIHRhYmxlLFxuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldHVwV3JpdGVyKCk6IEdlbmVyaWNEYXRhYmFzZVdyaXRlcjxHZW5lcmljRGF0YU1vZGVsPiAmXG4gIEdlbmVyaWNEYXRhYmFzZVdyaXRlcldpdGhUYWJsZTxHZW5lcmljRGF0YU1vZGVsPiB7XG4gIGNvbnN0IHJlYWRlciA9IHNldHVwUmVhZGVyKCk7XG4gIHJldHVybiB7XG4gICAgZ2V0OiByZWFkZXIuZ2V0LFxuICAgIHF1ZXJ5OiByZWFkZXIucXVlcnksXG4gICAgbm9ybWFsaXplSWQ6IHJlYWRlci5ub3JtYWxpemVJZCxcbiAgICBzeXN0ZW06IHJlYWRlci5zeXN0ZW0gYXMgYW55LFxuICAgIGluc2VydDogYXN5bmMgKHRhYmxlLCB2YWx1ZSkgPT4ge1xuICAgICAgcmV0dXJuIGF3YWl0IGluc2VydCh0YWJsZSwgdmFsdWUpO1xuICAgIH0sXG4gICAgcGF0Y2g6IGFzeW5jIChhcmcwOiBhbnksIGFyZzE6IGFueSwgYXJnMj86IGFueSkgPT4ge1xuICAgICAgcmV0dXJuIGFyZzIgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IGF3YWl0IHBhdGNoKGFyZzAsIGFyZzEsIGFyZzIpXG4gICAgICAgIDogYXdhaXQgcGF0Y2godW5kZWZpbmVkLCBhcmcwLCBhcmcxKTtcbiAgICB9LFxuICAgIHJlcGxhY2U6IGFzeW5jIChhcmcwOiBhbnksIGFyZzE6IGFueSwgYXJnMj86IGFueSkgPT4ge1xuICAgICAgcmV0dXJuIGFyZzIgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IGF3YWl0IHJlcGxhY2UoYXJnMCwgYXJnMSwgYXJnMilcbiAgICAgICAgOiBhd2FpdCByZXBsYWNlKHVuZGVmaW5lZCwgYXJnMCwgYXJnMSk7XG4gICAgfSxcbiAgICBkZWxldGU6IGFzeW5jIChhcmcwOiBhbnksIGFyZzE/OiBhbnkpID0+IHtcbiAgICAgIHJldHVybiBhcmcxICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBhd2FpdCBkZWxldGVfKGFyZzAsIGFyZzEpXG4gICAgICAgIDogYXdhaXQgZGVsZXRlXyh1bmRlZmluZWQsIGFyZzApO1xuICAgIH0sXG4gICAgdGFibGU6ICh0YWJsZU5hbWUpID0+IHtcbiAgICAgIHJldHVybiBuZXcgVGFibGVXcml0ZXIodGFibGVOYW1lLCBmYWxzZSk7XG4gICAgfSxcbiAgfTtcbn1cblxuY2xhc3MgVGFibGVSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgdGFibGVOYW1lOiBzdHJpbmcsXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IGlzU3lzdGVtOiBib29sZWFuLFxuICApIHt9XG5cbiAgYXN5bmMgZ2V0KGlkOiBHZW5lcmljSWQ8c3RyaW5nPikge1xuICAgIHJldHVybiBnZXQodGhpcy50YWJsZU5hbWUsIGlkLCB0aGlzLmlzU3lzdGVtKTtcbiAgfVxuXG4gIHF1ZXJ5KCkge1xuICAgIGNvbnN0IGFjY2Vzc2luZ1N5c3RlbVRhYmxlID0gdGhpcy50YWJsZU5hbWUuc3RhcnRzV2l0aChcIl9cIik7XG4gICAgaWYgKGFjY2Vzc2luZ1N5c3RlbVRhYmxlICE9PSB0aGlzLmlzU3lzdGVtKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGAke1xuICAgICAgICAgIGFjY2Vzc2luZ1N5c3RlbVRhYmxlID8gXCJTeXN0ZW1cIiA6IFwiVXNlclwiXG4gICAgICAgIH0gdGFibGVzIGNhbiBvbmx5IGJlIGFjY2Vzc2VkIGZyb20gZGIuJHtcbiAgICAgICAgICB0aGlzLmlzU3lzdGVtID8gXCJcIiA6IFwic3lzdGVtLlwiXG4gICAgICAgIH1xdWVyeSgpLmAsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFF1ZXJ5SW5pdGlhbGl6ZXJJbXBsKHRoaXMudGFibGVOYW1lKTtcbiAgfVxufVxuXG5jbGFzcyBUYWJsZVdyaXRlciBleHRlbmRzIFRhYmxlUmVhZGVyIHtcbiAgYXN5bmMgaW5zZXJ0KHZhbHVlOiBhbnkpIHtcbiAgICByZXR1cm4gaW5zZXJ0KHRoaXMudGFibGVOYW1lLCB2YWx1ZSk7XG4gIH1cbiAgYXN5bmMgcGF0Y2goaWQ6IGFueSwgdmFsdWU6IGFueSkge1xuICAgIHJldHVybiBwYXRjaCh0aGlzLnRhYmxlTmFtZSwgaWQsIHZhbHVlKTtcbiAgfVxuICBhc3luYyByZXBsYWNlKGlkOiBhbnksIHZhbHVlOiBhbnkpIHtcbiAgICByZXR1cm4gcmVwbGFjZSh0aGlzLnRhYmxlTmFtZSwgaWQsIHZhbHVlKTtcbiAgfVxuICBhc3luYyBkZWxldGUoaWQ6IGFueSkge1xuICAgIHJldHVybiBkZWxldGVfKHRoaXMudGFibGVOYW1lLCBpZCk7XG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4gX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbmltcG9ydCB7IGpzb25Ub0NvbnZleCB9IGZyb20gXCIuLi8uLi92YWx1ZXMvaW5kZXguanNcIjtcbmltcG9ydCB7IHBlcmZvcm1Bc3luY1N5c2NhbGwsIHBlcmZvcm1TeXNjYWxsIH0gZnJvbSBcIi4vc3lzY2FsbC5qc1wiO1xuaW1wb3J0IHtcbiAgZmlsdGVyQnVpbGRlckltcGwsXG4gIHNlcmlhbGl6ZUV4cHJlc3Npb25cbn0gZnJvbSBcIi4vZmlsdGVyX2J1aWxkZXJfaW1wbC5qc1wiO1xuaW1wb3J0IHtcbiAgSW5kZXhSYW5nZUJ1aWxkZXJJbXBsXG59IGZyb20gXCIuL2luZGV4X3JhbmdlX2J1aWxkZXJfaW1wbC5qc1wiO1xuaW1wb3J0IHtcbiAgU2VhcmNoRmlsdGVyQnVpbGRlckltcGxcbn0gZnJvbSBcIi4vc2VhcmNoX2ZpbHRlcl9idWlsZGVyX2ltcGwuanNcIjtcbmltcG9ydCB7IHZhbGlkYXRlQXJnLCB2YWxpZGF0ZUFyZ0lzTm9uTmVnYXRpdmVJbnRlZ2VyIH0gZnJvbSBcIi4vdmFsaWRhdGUuanNcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi4vLi4vaW5kZXguanNcIjtcbmNvbnN0IE1BWF9RVUVSWV9PUEVSQVRPUlMgPSAyNTY7XG5leHBvcnQgY2xhc3MgUXVlcnlJbml0aWFsaXplckltcGwge1xuICBjb25zdHJ1Y3Rvcih0YWJsZU5hbWUpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidGFibGVOYW1lXCIpO1xuICAgIHRoaXMudGFibGVOYW1lID0gdGFibGVOYW1lO1xuICB9XG4gIHdpdGhJbmRleChpbmRleE5hbWUsIGluZGV4UmFuZ2UpIHtcbiAgICB2YWxpZGF0ZUFyZyhpbmRleE5hbWUsIDEsIFwid2l0aEluZGV4XCIsIFwiaW5kZXhOYW1lXCIpO1xuICAgIGxldCByYW5nZUJ1aWxkZXIgPSBJbmRleFJhbmdlQnVpbGRlckltcGwubmV3KCk7XG4gICAgaWYgKGluZGV4UmFuZ2UgIT09IHZvaWQgMCkge1xuICAgICAgcmFuZ2VCdWlsZGVyID0gaW5kZXhSYW5nZShyYW5nZUJ1aWxkZXIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbCh7XG4gICAgICBzb3VyY2U6IHtcbiAgICAgICAgdHlwZTogXCJJbmRleFJhbmdlXCIsXG4gICAgICAgIGluZGV4TmFtZTogdGhpcy50YWJsZU5hbWUgKyBcIi5cIiArIGluZGV4TmFtZSxcbiAgICAgICAgcmFuZ2U6IHJhbmdlQnVpbGRlci5leHBvcnQoKSxcbiAgICAgICAgb3JkZXI6IG51bGxcbiAgICAgIH0sXG4gICAgICBvcGVyYXRvcnM6IFtdXG4gICAgfSk7XG4gIH1cbiAgd2l0aFNlYXJjaEluZGV4KGluZGV4TmFtZSwgc2VhcmNoRmlsdGVyKSB7XG4gICAgdmFsaWRhdGVBcmcoaW5kZXhOYW1lLCAxLCBcIndpdGhTZWFyY2hJbmRleFwiLCBcImluZGV4TmFtZVwiKTtcbiAgICB2YWxpZGF0ZUFyZyhzZWFyY2hGaWx0ZXIsIDIsIFwid2l0aFNlYXJjaEluZGV4XCIsIFwic2VhcmNoRmlsdGVyXCIpO1xuICAgIGNvbnN0IHNlYXJjaEZpbHRlckJ1aWxkZXIgPSBTZWFyY2hGaWx0ZXJCdWlsZGVySW1wbC5uZXcoKTtcbiAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbCh7XG4gICAgICBzb3VyY2U6IHtcbiAgICAgICAgdHlwZTogXCJTZWFyY2hcIixcbiAgICAgICAgaW5kZXhOYW1lOiB0aGlzLnRhYmxlTmFtZSArIFwiLlwiICsgaW5kZXhOYW1lLFxuICAgICAgICBmaWx0ZXJzOiBzZWFyY2hGaWx0ZXIoc2VhcmNoRmlsdGVyQnVpbGRlcikuZXhwb3J0KClcbiAgICAgIH0sXG4gICAgICBvcGVyYXRvcnM6IFtdXG4gICAgfSk7XG4gIH1cbiAgZnVsbFRhYmxlU2NhbigpIHtcbiAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbCh7XG4gICAgICBzb3VyY2U6IHtcbiAgICAgICAgdHlwZTogXCJGdWxsVGFibGVTY2FuXCIsXG4gICAgICAgIHRhYmxlTmFtZTogdGhpcy50YWJsZU5hbWUsXG4gICAgICAgIG9yZGVyOiBudWxsXG4gICAgICB9LFxuICAgICAgb3BlcmF0b3JzOiBbXVxuICAgIH0pO1xuICB9XG4gIG9yZGVyKG9yZGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZnVsbFRhYmxlU2NhbigpLm9yZGVyKG9yZGVyKTtcbiAgfVxuICAvLyBUaGlzIGlzIGludGVybmFsIEFQSSBhbmQgc2hvdWxkIG5vdCBiZSBleHBvc2VkIHRvIGRldmVsb3BlcnMgeWV0LlxuICBhc3luYyBjb3VudCgpIHtcbiAgICBjb25zdCBzeXNjYWxsSlNPTiA9IGF3YWl0IHBlcmZvcm1Bc3luY1N5c2NhbGwoXCIxLjAvY291bnRcIiwge1xuICAgICAgdGFibGU6IHRoaXMudGFibGVOYW1lXG4gICAgfSk7XG4gICAgY29uc3Qgc3lzY2FsbFJlc3VsdCA9IGpzb25Ub0NvbnZleChzeXNjYWxsSlNPTik7XG4gICAgcmV0dXJuIHN5c2NhbGxSZXN1bHQ7XG4gIH1cbiAgZmlsdGVyKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiB0aGlzLmZ1bGxUYWJsZVNjYW4oKS5maWx0ZXIocHJlZGljYXRlKTtcbiAgfVxuICBsaW1pdChuKSB7XG4gICAgcmV0dXJuIHRoaXMuZnVsbFRhYmxlU2NhbigpLmxpbWl0KG4pO1xuICB9XG4gIGNvbGxlY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuZnVsbFRhYmxlU2NhbigpLmNvbGxlY3QoKTtcbiAgfVxuICB0YWtlKG4pIHtcbiAgICByZXR1cm4gdGhpcy5mdWxsVGFibGVTY2FuKCkudGFrZShuKTtcbiAgfVxuICBwYWdpbmF0ZShwYWdpbmF0aW9uT3B0cykge1xuICAgIHJldHVybiB0aGlzLmZ1bGxUYWJsZVNjYW4oKS5wYWdpbmF0ZShwYWdpbmF0aW9uT3B0cyk7XG4gIH1cbiAgZmlyc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuZnVsbFRhYmxlU2NhbigpLmZpcnN0KCk7XG4gIH1cbiAgdW5pcXVlKCkge1xuICAgIHJldHVybiB0aGlzLmZ1bGxUYWJsZVNjYW4oKS51bmlxdWUoKTtcbiAgfVxuICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzLmZ1bGxUYWJsZVNjYW4oKVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgfVxufVxuZnVuY3Rpb24gdGhyb3dDbG9zZWRFcnJvcih0eXBlKSB7XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICB0eXBlID09PSBcImNvbnN1bWVkXCIgPyBcIlRoaXMgcXVlcnkgaXMgY2xvc2VkIGFuZCBjYW4ndCBlbWl0IGFueSBtb3JlIHZhbHVlcy5cIiA6IFwiVGhpcyBxdWVyeSBoYXMgYmVlbiBjaGFpbmVkIHdpdGggYW5vdGhlciBvcGVyYXRvciBhbmQgY2FuJ3QgYmUgcmV1c2VkLlwiXG4gICk7XG59XG5leHBvcnQgY2xhc3MgUXVlcnlJbXBsIHtcbiAgY29uc3RydWN0b3IocXVlcnkpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic3RhdGVcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInRhYmxlTmFtZUZvckVycm9yTWVzc2FnZXNcIik7XG4gICAgdGhpcy5zdGF0ZSA9IHsgdHlwZTogXCJwcmVwYXJpbmdcIiwgcXVlcnkgfTtcbiAgICBpZiAocXVlcnkuc291cmNlLnR5cGUgPT09IFwiRnVsbFRhYmxlU2NhblwiKSB7XG4gICAgICB0aGlzLnRhYmxlTmFtZUZvckVycm9yTWVzc2FnZXMgPSBxdWVyeS5zb3VyY2UudGFibGVOYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRhYmxlTmFtZUZvckVycm9yTWVzc2FnZXMgPSBxdWVyeS5zb3VyY2UuaW5kZXhOYW1lLnNwbGl0KFwiLlwiKVswXTtcbiAgICB9XG4gIH1cbiAgdGFrZVF1ZXJ5KCkge1xuICAgIGlmICh0aGlzLnN0YXRlLnR5cGUgIT09IFwicHJlcGFyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJBIHF1ZXJ5IGNhbiBvbmx5IGJlIGNoYWluZWQgb25jZSBhbmQgY2FuJ3QgYmUgY2hhaW5lZCBhZnRlciBpdGVyYXRpb24gYmVnaW5zLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBxdWVyeSA9IHRoaXMuc3RhdGUucXVlcnk7XG4gICAgdGhpcy5zdGF0ZSA9IHsgdHlwZTogXCJjbG9zZWRcIiB9O1xuICAgIHJldHVybiBxdWVyeTtcbiAgfVxuICBzdGFydFF1ZXJ5KCkge1xuICAgIGlmICh0aGlzLnN0YXRlLnR5cGUgPT09IFwiZXhlY3V0aW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkl0ZXJhdGlvbiBjYW4gb25seSBiZWdpbiBvbiBhIHF1ZXJ5IG9uY2UuXCIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdGF0ZS50eXBlID09PSBcImNsb3NlZFwiIHx8IHRoaXMuc3RhdGUudHlwZSA9PT0gXCJjb25zdW1lZFwiKSB7XG4gICAgICB0aHJvd0Nsb3NlZEVycm9yKHRoaXMuc3RhdGUudHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5zdGF0ZS5xdWVyeTtcbiAgICBjb25zdCB7IHF1ZXJ5SWQgfSA9IHBlcmZvcm1TeXNjYWxsKFwiMS4wL3F1ZXJ5U3RyZWFtXCIsIHsgcXVlcnksIHZlcnNpb24gfSk7XG4gICAgdGhpcy5zdGF0ZSA9IHsgdHlwZTogXCJleGVjdXRpbmdcIiwgcXVlcnlJZCB9O1xuICAgIHJldHVybiBxdWVyeUlkO1xuICB9XG4gIGNsb3NlUXVlcnkoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUudHlwZSA9PT0gXCJleGVjdXRpbmdcIikge1xuICAgICAgY29uc3QgcXVlcnlJZCA9IHRoaXMuc3RhdGUucXVlcnlJZDtcbiAgICAgIHBlcmZvcm1TeXNjYWxsKFwiMS4wL3F1ZXJ5Q2xlYW51cFwiLCB7IHF1ZXJ5SWQgfSk7XG4gICAgfVxuICAgIHRoaXMuc3RhdGUgPSB7IHR5cGU6IFwiY29uc3VtZWRcIiB9O1xuICB9XG4gIG9yZGVyKG9yZGVyKSB7XG4gICAgdmFsaWRhdGVBcmcob3JkZXIsIDEsIFwib3JkZXJcIiwgXCJvcmRlclwiKTtcbiAgICBjb25zdCBxdWVyeSA9IHRoaXMudGFrZVF1ZXJ5KCk7XG4gICAgaWYgKHF1ZXJ5LnNvdXJjZS50eXBlID09PSBcIlNlYXJjaFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiU2VhcmNoIHF1ZXJpZXMgbXVzdCBhbHdheXMgYmUgaW4gcmVsZXZhbmNlIG9yZGVyLiBDYW4gbm90IHNldCBvcmRlciBtYW51YWxseS5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5LnNvdXJjZS5vcmRlciAhPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUXVlcmllcyBtYXkgb25seSBzcGVjaWZ5IG9yZGVyIGF0IG1vc3Qgb25jZVwiKTtcbiAgICB9XG4gICAgcXVlcnkuc291cmNlLm9yZGVyID0gb3JkZXI7XG4gICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocXVlcnkpO1xuICB9XG4gIGZpbHRlcihwcmVkaWNhdGUpIHtcbiAgICB2YWxpZGF0ZUFyZyhwcmVkaWNhdGUsIDEsIFwiZmlsdGVyXCIsIFwicHJlZGljYXRlXCIpO1xuICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy50YWtlUXVlcnkoKTtcbiAgICBpZiAocXVlcnkub3BlcmF0b3JzLmxlbmd0aCA+PSBNQVhfUVVFUllfT1BFUkFUT1JTKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW4ndCBjb25zdHJ1Y3QgcXVlcnkgd2l0aCBtb3JlIHRoYW4gJHtNQVhfUVVFUllfT1BFUkFUT1JTfSBvcGVyYXRvcnNgXG4gICAgICApO1xuICAgIH1cbiAgICBxdWVyeS5vcGVyYXRvcnMucHVzaCh7XG4gICAgICBmaWx0ZXI6IHNlcmlhbGl6ZUV4cHJlc3Npb24ocHJlZGljYXRlKGZpbHRlckJ1aWxkZXJJbXBsKSlcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChxdWVyeSk7XG4gIH1cbiAgbGltaXQobikge1xuICAgIHZhbGlkYXRlQXJnKG4sIDEsIFwibGltaXRcIiwgXCJuXCIpO1xuICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy50YWtlUXVlcnkoKTtcbiAgICBxdWVyeS5vcGVyYXRvcnMucHVzaCh7IGxpbWl0OiBuIH0pO1xuICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHF1ZXJ5KTtcbiAgfVxuICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgIHRoaXMuc3RhcnRRdWVyeSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFzeW5jIG5leHQoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUudHlwZSA9PT0gXCJjbG9zZWRcIiB8fCB0aGlzLnN0YXRlLnR5cGUgPT09IFwiY29uc3VtZWRcIikge1xuICAgICAgdGhyb3dDbG9zZWRFcnJvcih0aGlzLnN0YXRlLnR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBxdWVyeUlkID0gdGhpcy5zdGF0ZS50eXBlID09PSBcInByZXBhcmluZ1wiID8gdGhpcy5zdGFydFF1ZXJ5KCkgOiB0aGlzLnN0YXRlLnF1ZXJ5SWQ7XG4gICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgcGVyZm9ybUFzeW5jU3lzY2FsbChcIjEuMC9xdWVyeVN0cmVhbU5leHRcIiwge1xuICAgICAgcXVlcnlJZFxuICAgIH0pO1xuICAgIGlmIChkb25lKSB7XG4gICAgICB0aGlzLmNsb3NlUXVlcnkoKTtcbiAgICB9XG4gICAgY29uc3QgY29udmV4VmFsdWUgPSBqc29uVG9Db252ZXgodmFsdWUpO1xuICAgIHJldHVybiB7IHZhbHVlOiBjb252ZXhWYWx1ZSwgZG9uZSB9O1xuICB9XG4gIHJldHVybigpIHtcbiAgICB0aGlzLmNsb3NlUXVlcnkoKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHZvaWQgMCB9KTtcbiAgfVxuICBhc3luYyBwYWdpbmF0ZShwYWdpbmF0aW9uT3B0cykge1xuICAgIHZhbGlkYXRlQXJnKHBhZ2luYXRpb25PcHRzLCAxLCBcInBhZ2luYXRlXCIsIFwib3B0aW9uc1wiKTtcbiAgICBpZiAodHlwZW9mIHBhZ2luYXRpb25PcHRzPy5udW1JdGVtcyAhPT0gXCJudW1iZXJcIiB8fCBwYWdpbmF0aW9uT3B0cy5udW1JdGVtcyA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFxcYG9wdGlvbnMubnVtSXRlbXNcXGAgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlci4gUmVjZWl2ZWQgXFxgJHtwYWdpbmF0aW9uT3B0cz8ubnVtSXRlbXN9XFxgLmBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy50YWtlUXVlcnkoKTtcbiAgICBjb25zdCBwYWdlU2l6ZSA9IHBhZ2luYXRpb25PcHRzLm51bUl0ZW1zO1xuICAgIGNvbnN0IGN1cnNvciA9IHBhZ2luYXRpb25PcHRzLmN1cnNvcjtcbiAgICBjb25zdCBlbmRDdXJzb3IgPSBwYWdpbmF0aW9uT3B0cz8uZW5kQ3Vyc29yID8/IG51bGw7XG4gICAgY29uc3QgbWF4aW11bVJvd3NSZWFkID0gcGFnaW5hdGlvbk9wdHMubWF4aW11bVJvd3NSZWFkID8/IG51bGw7XG4gICAgY29uc3QgeyBwYWdlLCBpc0RvbmUsIGNvbnRpbnVlQ3Vyc29yLCBzcGxpdEN1cnNvciwgcGFnZVN0YXR1cyB9ID0gYXdhaXQgcGVyZm9ybUFzeW5jU3lzY2FsbChcIjEuMC9xdWVyeVBhZ2VcIiwge1xuICAgICAgcXVlcnksXG4gICAgICBjdXJzb3IsXG4gICAgICBlbmRDdXJzb3IsXG4gICAgICBwYWdlU2l6ZSxcbiAgICAgIG1heGltdW1Sb3dzUmVhZCxcbiAgICAgIG1heGltdW1CeXRlc1JlYWQ6IHBhZ2luYXRpb25PcHRzLm1heGltdW1CeXRlc1JlYWQsXG4gICAgICB2ZXJzaW9uXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhZ2U6IHBhZ2UubWFwKChqc29uKSA9PiBqc29uVG9Db252ZXgoanNvbikpLFxuICAgICAgaXNEb25lLFxuICAgICAgY29udGludWVDdXJzb3IsXG4gICAgICBzcGxpdEN1cnNvcixcbiAgICAgIHBhZ2VTdGF0dXNcbiAgICB9O1xuICB9XG4gIGFzeW5jIGNvbGxlY3QoKSB7XG4gICAgY29uc3Qgb3V0ID0gW107XG4gICAgZm9yIGF3YWl0IChjb25zdCBpdGVtIG9mIHRoaXMpIHtcbiAgICAgIG91dC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIGFzeW5jIHRha2Uobikge1xuICAgIHZhbGlkYXRlQXJnKG4sIDEsIFwidGFrZVwiLCBcIm5cIik7XG4gICAgdmFsaWRhdGVBcmdJc05vbk5lZ2F0aXZlSW50ZWdlcihuLCAxLCBcInRha2VcIiwgXCJuXCIpO1xuICAgIHJldHVybiB0aGlzLmxpbWl0KG4pLmNvbGxlY3QoKTtcbiAgfVxuICBhc3luYyBmaXJzdCgpIHtcbiAgICBjb25zdCBmaXJzdF9hcnJheSA9IGF3YWl0IHRoaXMudGFrZSgxKTtcbiAgICByZXR1cm4gZmlyc3RfYXJyYXkubGVuZ3RoID09PSAwID8gbnVsbCA6IGZpcnN0X2FycmF5WzBdO1xuICB9XG4gIGFzeW5jIHVuaXF1ZSgpIHtcbiAgICBjb25zdCBmaXJzdF90d29fYXJyYXkgPSBhd2FpdCB0aGlzLnRha2UoMik7XG4gICAgaWYgKGZpcnN0X3R3b19hcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoZmlyc3RfdHdvX2FycmF5Lmxlbmd0aCA9PT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmlxdWUoKSBxdWVyeSByZXR1cm5lZCBtb3JlIHRoYW4gb25lIHJlc3VsdCBmcm9tIHRhYmxlICR7dGhpcy50YWJsZU5hbWVGb3JFcnJvck1lc3NhZ2VzfTpcbiBbJHtmaXJzdF90d29fYXJyYXlbMF0uX2lkfSwgJHtmaXJzdF90d29fYXJyYXlbMV0uX2lkfSwgLi4uXWApO1xuICAgIH1cbiAgICByZXR1cm4gZmlyc3RfdHdvX2FycmF5WzBdO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeV9pbXBsLmpzLm1hcFxuIiwiaW1wb3J0IHsgVmFsdWUsIEpTT05WYWx1ZSwganNvblRvQ29udmV4IH0gZnJvbSBcIi4uLy4uL3ZhbHVlcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgUGFnaW5hdGlvblJlc3VsdCwgUGFnaW5hdGlvbk9wdGlvbnMgfSBmcm9tIFwiLi4vcGFnaW5hdGlvbi5qc1wiO1xuaW1wb3J0IHsgcGVyZm9ybUFzeW5jU3lzY2FsbCwgcGVyZm9ybVN5c2NhbGwgfSBmcm9tIFwiLi9zeXNjYWxsLmpzXCI7XG5pbXBvcnQge1xuICBmaWx0ZXJCdWlsZGVySW1wbCxcbiAgc2VyaWFsaXplRXhwcmVzc2lvbixcbn0gZnJvbSBcIi4vZmlsdGVyX2J1aWxkZXJfaW1wbC5qc1wiO1xuaW1wb3J0IHsgUXVlcnksIFF1ZXJ5SW5pdGlhbGl6ZXIgfSBmcm9tIFwiLi4vcXVlcnkuanNcIjtcbmltcG9ydCB7IEV4cHJlc3Npb25PclZhbHVlLCBGaWx0ZXJCdWlsZGVyIH0gZnJvbSBcIi4uL2ZpbHRlcl9idWlsZGVyLmpzXCI7XG5pbXBvcnQgeyBHZW5lcmljVGFibGVJbmZvIH0gZnJvbSBcIi4uL2RhdGFfbW9kZWwuanNcIjtcbmltcG9ydCB7XG4gIEluZGV4UmFuZ2VCdWlsZGVySW1wbCxcbiAgU2VyaWFsaXplZFJhbmdlRXhwcmVzc2lvbixcbn0gZnJvbSBcIi4vaW5kZXhfcmFuZ2VfYnVpbGRlcl9pbXBsLmpzXCI7XG5pbXBvcnQge1xuICBTZWFyY2hGaWx0ZXJCdWlsZGVySW1wbCxcbiAgU2VyaWFsaXplZFNlYXJjaEZpbHRlcixcbn0gZnJvbSBcIi4vc2VhcmNoX2ZpbHRlcl9idWlsZGVyX2ltcGwuanNcIjtcbmltcG9ydCB7IHZhbGlkYXRlQXJnLCB2YWxpZGF0ZUFyZ0lzTm9uTmVnYXRpdmVJbnRlZ2VyIH0gZnJvbSBcIi4vdmFsaWRhdGUuanNcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi4vLi4vaW5kZXguanNcIjtcblxuY29uc3QgTUFYX1FVRVJZX09QRVJBVE9SUyA9IDI1NjtcblxudHlwZSBRdWVyeU9wZXJhdG9yID0geyBmaWx0ZXI6IEpTT05WYWx1ZSB9IHwgeyBsaW1pdDogbnVtYmVyIH07XG50eXBlIFNvdXJjZSA9XG4gIHwgeyB0eXBlOiBcIkZ1bGxUYWJsZVNjYW5cIjsgdGFibGVOYW1lOiBzdHJpbmc7IG9yZGVyOiBcImFzY1wiIHwgXCJkZXNjXCIgfCBudWxsIH1cbiAgfCB7XG4gICAgICB0eXBlOiBcIkluZGV4UmFuZ2VcIjtcbiAgICAgIGluZGV4TmFtZTogc3RyaW5nO1xuICAgICAgcmFuZ2U6IFJlYWRvbmx5QXJyYXk8U2VyaWFsaXplZFJhbmdlRXhwcmVzc2lvbj47XG4gICAgICBvcmRlcjogXCJhc2NcIiB8IFwiZGVzY1wiIHwgbnVsbDtcbiAgICB9XG4gIHwge1xuICAgICAgdHlwZTogXCJTZWFyY2hcIjtcbiAgICAgIGluZGV4TmFtZTogc3RyaW5nO1xuICAgICAgZmlsdGVyczogUmVhZG9ubHlBcnJheTxTZXJpYWxpemVkU2VhcmNoRmlsdGVyPjtcbiAgICB9O1xuXG50eXBlIFNlcmlhbGl6ZWRRdWVyeSA9IHtcbiAgc291cmNlOiBTb3VyY2U7XG4gIG9wZXJhdG9yczogQXJyYXk8UXVlcnlPcGVyYXRvcj47XG59O1xuXG5leHBvcnQgY2xhc3MgUXVlcnlJbml0aWFsaXplckltcGxcbiAgaW1wbGVtZW50cyBRdWVyeUluaXRpYWxpemVyPEdlbmVyaWNUYWJsZUluZm8+XG57XG4gIHByaXZhdGUgdGFibGVOYW1lOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IodGFibGVOYW1lOiBzdHJpbmcpIHtcbiAgICB0aGlzLnRhYmxlTmFtZSA9IHRhYmxlTmFtZTtcbiAgfVxuXG4gIHdpdGhJbmRleChcbiAgICBpbmRleE5hbWU6IHN0cmluZyxcbiAgICBpbmRleFJhbmdlPzogKHE6IEluZGV4UmFuZ2VCdWlsZGVySW1wbCkgPT4gSW5kZXhSYW5nZUJ1aWxkZXJJbXBsLFxuICApOiBRdWVyeUltcGwge1xuICAgIHZhbGlkYXRlQXJnKGluZGV4TmFtZSwgMSwgXCJ3aXRoSW5kZXhcIiwgXCJpbmRleE5hbWVcIik7XG4gICAgbGV0IHJhbmdlQnVpbGRlciA9IEluZGV4UmFuZ2VCdWlsZGVySW1wbC5uZXcoKTtcbiAgICBpZiAoaW5kZXhSYW5nZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByYW5nZUJ1aWxkZXIgPSBpbmRleFJhbmdlKHJhbmdlQnVpbGRlcik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHtcbiAgICAgIHNvdXJjZToge1xuICAgICAgICB0eXBlOiBcIkluZGV4UmFuZ2VcIixcbiAgICAgICAgaW5kZXhOYW1lOiB0aGlzLnRhYmxlTmFtZSArIFwiLlwiICsgaW5kZXhOYW1lLFxuICAgICAgICByYW5nZTogcmFuZ2VCdWlsZGVyLmV4cG9ydCgpLFxuICAgICAgICBvcmRlcjogbnVsbCxcbiAgICAgIH0sXG4gICAgICBvcGVyYXRvcnM6IFtdLFxuICAgIH0pO1xuICB9XG5cbiAgd2l0aFNlYXJjaEluZGV4KFxuICAgIGluZGV4TmFtZTogc3RyaW5nLFxuICAgIHNlYXJjaEZpbHRlcjogKHE6IFNlYXJjaEZpbHRlckJ1aWxkZXJJbXBsKSA9PiBTZWFyY2hGaWx0ZXJCdWlsZGVySW1wbCxcbiAgKTogUXVlcnlJbXBsIHtcbiAgICB2YWxpZGF0ZUFyZyhpbmRleE5hbWUsIDEsIFwid2l0aFNlYXJjaEluZGV4XCIsIFwiaW5kZXhOYW1lXCIpO1xuICAgIHZhbGlkYXRlQXJnKHNlYXJjaEZpbHRlciwgMiwgXCJ3aXRoU2VhcmNoSW5kZXhcIiwgXCJzZWFyY2hGaWx0ZXJcIik7XG4gICAgY29uc3Qgc2VhcmNoRmlsdGVyQnVpbGRlciA9IFNlYXJjaEZpbHRlckJ1aWxkZXJJbXBsLm5ldygpO1xuICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHtcbiAgICAgIHNvdXJjZToge1xuICAgICAgICB0eXBlOiBcIlNlYXJjaFwiLFxuICAgICAgICBpbmRleE5hbWU6IHRoaXMudGFibGVOYW1lICsgXCIuXCIgKyBpbmRleE5hbWUsXG4gICAgICAgIGZpbHRlcnM6IHNlYXJjaEZpbHRlcihzZWFyY2hGaWx0ZXJCdWlsZGVyKS5leHBvcnQoKSxcbiAgICAgIH0sXG4gICAgICBvcGVyYXRvcnM6IFtdLFxuICAgIH0pO1xuICB9XG5cbiAgZnVsbFRhYmxlU2NhbigpOiBRdWVyeUltcGwge1xuICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHtcbiAgICAgIHNvdXJjZToge1xuICAgICAgICB0eXBlOiBcIkZ1bGxUYWJsZVNjYW5cIixcbiAgICAgICAgdGFibGVOYW1lOiB0aGlzLnRhYmxlTmFtZSxcbiAgICAgICAgb3JkZXI6IG51bGwsXG4gICAgICB9LFxuICAgICAgb3BlcmF0b3JzOiBbXSxcbiAgICB9KTtcbiAgfVxuXG4gIG9yZGVyKG9yZGVyOiBcImFzY1wiIHwgXCJkZXNjXCIpOiBRdWVyeUltcGwge1xuICAgIHJldHVybiB0aGlzLmZ1bGxUYWJsZVNjYW4oKS5vcmRlcihvcmRlcik7XG4gIH1cblxuICAvLyBUaGlzIGlzIGludGVybmFsIEFQSSBhbmQgc2hvdWxkIG5vdCBiZSBleHBvc2VkIHRvIGRldmVsb3BlcnMgeWV0LlxuICBhc3luYyBjb3VudCgpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIGNvbnN0IHN5c2NhbGxKU09OID0gYXdhaXQgcGVyZm9ybUFzeW5jU3lzY2FsbChcIjEuMC9jb3VudFwiLCB7XG4gICAgICB0YWJsZTogdGhpcy50YWJsZU5hbWUsXG4gICAgfSk7XG4gICAgY29uc3Qgc3lzY2FsbFJlc3VsdCA9IGpzb25Ub0NvbnZleChzeXNjYWxsSlNPTikgYXMgbnVtYmVyO1xuICAgIHJldHVybiBzeXNjYWxsUmVzdWx0O1xuICB9XG5cbiAgZmlsdGVyKFxuICAgIHByZWRpY2F0ZTogKFxuICAgICAgcTogRmlsdGVyQnVpbGRlcjxHZW5lcmljVGFibGVJbmZvPixcbiAgICApID0+IEV4cHJlc3Npb25PclZhbHVlPGJvb2xlYW4+LFxuICApIHtcbiAgICByZXR1cm4gdGhpcy5mdWxsVGFibGVTY2FuKCkuZmlsdGVyKHByZWRpY2F0ZSk7XG4gIH1cblxuICBsaW1pdChuOiBudW1iZXIpIHtcbiAgICByZXR1cm4gdGhpcy5mdWxsVGFibGVTY2FuKCkubGltaXQobik7XG4gIH1cblxuICBjb2xsZWN0KCk6IFByb21pc2U8YW55W10+IHtcbiAgICByZXR1cm4gdGhpcy5mdWxsVGFibGVTY2FuKCkuY29sbGVjdCgpO1xuICB9XG5cbiAgdGFrZShuOiBudW1iZXIpOiBQcm9taXNlPEFycmF5PGFueT4+IHtcbiAgICByZXR1cm4gdGhpcy5mdWxsVGFibGVTY2FuKCkudGFrZShuKTtcbiAgfVxuXG4gIHBhZ2luYXRlKHBhZ2luYXRpb25PcHRzOiBQYWdpbmF0aW9uT3B0aW9ucyk6IFByb21pc2U8UGFnaW5hdGlvblJlc3VsdDxhbnk+PiB7XG4gICAgcmV0dXJuIHRoaXMuZnVsbFRhYmxlU2NhbigpLnBhZ2luYXRlKHBhZ2luYXRpb25PcHRzKTtcbiAgfVxuXG4gIGZpcnN0KCk6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuZnVsbFRhYmxlU2NhbigpLmZpcnN0KCk7XG4gIH1cblxuICB1bmlxdWUoKTogUHJvbWlzZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5mdWxsVGFibGVTY2FuKCkudW5pcXVlKCk7XG4gIH1cblxuICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk6IEFzeW5jSXRlcmFibGVJdGVyYXRvcjxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5mdWxsVGFibGVTY2FuKClbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0gdHlwZSBXaGV0aGVyIHRoZSBxdWVyeSB3YXMgY29uc3VtZWQgb3IgY2xvc2VkLlxuICogQHRocm93cyBBbiBlcnJvciBpbmRpY2F0aW5nIHRoZSBxdWVyeSBoYXMgYmVlbiBjbG9zZWQuXG4gKi9cbmZ1bmN0aW9uIHRocm93Q2xvc2VkRXJyb3IodHlwZTogXCJjbG9zZWRcIiB8IFwiY29uc3VtZWRcIik6IG5ldmVyIHtcbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgIHR5cGUgPT09IFwiY29uc3VtZWRcIlxuICAgICAgPyBcIlRoaXMgcXVlcnkgaXMgY2xvc2VkIGFuZCBjYW4ndCBlbWl0IGFueSBtb3JlIHZhbHVlcy5cIlxuICAgICAgOiBcIlRoaXMgcXVlcnkgaGFzIGJlZW4gY2hhaW5lZCB3aXRoIGFub3RoZXIgb3BlcmF0b3IgYW5kIGNhbid0IGJlIHJldXNlZC5cIixcbiAgKTtcbn1cblxuZXhwb3J0IGNsYXNzIFF1ZXJ5SW1wbCBpbXBsZW1lbnRzIFF1ZXJ5PEdlbmVyaWNUYWJsZUluZm8+IHtcbiAgcHJpdmF0ZSBzdGF0ZTpcbiAgICB8IHsgdHlwZTogXCJwcmVwYXJpbmdcIjsgcXVlcnk6IFNlcmlhbGl6ZWRRdWVyeSB9XG4gICAgfCB7IHR5cGU6IFwiZXhlY3V0aW5nXCI7IHF1ZXJ5SWQ6IG51bWJlciB9XG4gICAgfCB7IHR5cGU6IFwiY2xvc2VkXCIgfVxuICAgIHwgeyB0eXBlOiBcImNvbnN1bWVkXCIgfTtcbiAgcHJpdmF0ZSB0YWJsZU5hbWVGb3JFcnJvck1lc3NhZ2VzOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IocXVlcnk6IFNlcmlhbGl6ZWRRdWVyeSkge1xuICAgIHRoaXMuc3RhdGUgPSB7IHR5cGU6IFwicHJlcGFyaW5nXCIsIHF1ZXJ5IH07XG4gICAgaWYgKHF1ZXJ5LnNvdXJjZS50eXBlID09PSBcIkZ1bGxUYWJsZVNjYW5cIikge1xuICAgICAgdGhpcy50YWJsZU5hbWVGb3JFcnJvck1lc3NhZ2VzID0gcXVlcnkuc291cmNlLnRhYmxlTmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50YWJsZU5hbWVGb3JFcnJvck1lc3NhZ2VzID0gcXVlcnkuc291cmNlLmluZGV4TmFtZS5zcGxpdChcIi5cIilbMF07XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB0YWtlUXVlcnkoKTogU2VyaWFsaXplZFF1ZXJ5IHtcbiAgICBpZiAodGhpcy5zdGF0ZS50eXBlICE9PSBcInByZXBhcmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQSBxdWVyeSBjYW4gb25seSBiZSBjaGFpbmVkIG9uY2UgYW5kIGNhbid0IGJlIGNoYWluZWQgYWZ0ZXIgaXRlcmF0aW9uIGJlZ2lucy5cIixcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5zdGF0ZS5xdWVyeTtcbiAgICB0aGlzLnN0YXRlID0geyB0eXBlOiBcImNsb3NlZFwiIH07XG4gICAgcmV0dXJuIHF1ZXJ5O1xuICB9XG5cbiAgcHJpdmF0ZSBzdGFydFF1ZXJ5KCk6IG51bWJlciB7XG4gICAgaWYgKHRoaXMuc3RhdGUudHlwZSA9PT0gXCJleGVjdXRpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSXRlcmF0aW9uIGNhbiBvbmx5IGJlZ2luIG9uIGEgcXVlcnkgb25jZS5cIik7XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YXRlLnR5cGUgPT09IFwiY2xvc2VkXCIgfHwgdGhpcy5zdGF0ZS50eXBlID09PSBcImNvbnN1bWVkXCIpIHtcbiAgICAgIHRocm93Q2xvc2VkRXJyb3IodGhpcy5zdGF0ZS50eXBlKTtcbiAgICB9XG4gICAgY29uc3QgcXVlcnkgPSB0aGlzLnN0YXRlLnF1ZXJ5O1xuICAgIGNvbnN0IHsgcXVlcnlJZCB9ID0gcGVyZm9ybVN5c2NhbGwoXCIxLjAvcXVlcnlTdHJlYW1cIiwgeyBxdWVyeSwgdmVyc2lvbiB9KTtcbiAgICB0aGlzLnN0YXRlID0geyB0eXBlOiBcImV4ZWN1dGluZ1wiLCBxdWVyeUlkIH07XG4gICAgcmV0dXJuIHF1ZXJ5SWQ7XG4gIH1cblxuICBwcml2YXRlIGNsb3NlUXVlcnkoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUudHlwZSA9PT0gXCJleGVjdXRpbmdcIikge1xuICAgICAgY29uc3QgcXVlcnlJZCA9IHRoaXMuc3RhdGUucXVlcnlJZDtcbiAgICAgIHBlcmZvcm1TeXNjYWxsKFwiMS4wL3F1ZXJ5Q2xlYW51cFwiLCB7IHF1ZXJ5SWQgfSk7XG4gICAgfVxuICAgIHRoaXMuc3RhdGUgPSB7IHR5cGU6IFwiY29uc3VtZWRcIiB9O1xuICB9XG5cbiAgb3JkZXIob3JkZXI6IFwiYXNjXCIgfCBcImRlc2NcIik6IFF1ZXJ5SW1wbCB7XG4gICAgdmFsaWRhdGVBcmcob3JkZXIsIDEsIFwib3JkZXJcIiwgXCJvcmRlclwiKTtcbiAgICBjb25zdCBxdWVyeSA9IHRoaXMudGFrZVF1ZXJ5KCk7XG4gICAgaWYgKHF1ZXJ5LnNvdXJjZS50eXBlID09PSBcIlNlYXJjaFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiU2VhcmNoIHF1ZXJpZXMgbXVzdCBhbHdheXMgYmUgaW4gcmVsZXZhbmNlIG9yZGVyLiBDYW4gbm90IHNldCBvcmRlciBtYW51YWxseS5cIixcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChxdWVyeS5zb3VyY2Uub3JkZXIgIT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlF1ZXJpZXMgbWF5IG9ubHkgc3BlY2lmeSBvcmRlciBhdCBtb3N0IG9uY2VcIik7XG4gICAgfVxuICAgIHF1ZXJ5LnNvdXJjZS5vcmRlciA9IG9yZGVyO1xuICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHF1ZXJ5KTtcbiAgfVxuXG4gIGZpbHRlcihcbiAgICBwcmVkaWNhdGU6IChcbiAgICAgIHE6IEZpbHRlckJ1aWxkZXI8R2VuZXJpY1RhYmxlSW5mbz4sXG4gICAgKSA9PiBFeHByZXNzaW9uT3JWYWx1ZTxib29sZWFuPixcbiAgKTogYW55IHtcbiAgICB2YWxpZGF0ZUFyZyhwcmVkaWNhdGUsIDEsIFwiZmlsdGVyXCIsIFwicHJlZGljYXRlXCIpO1xuICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy50YWtlUXVlcnkoKTtcbiAgICBpZiAocXVlcnkub3BlcmF0b3JzLmxlbmd0aCA+PSBNQVhfUVVFUllfT1BFUkFUT1JTKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW4ndCBjb25zdHJ1Y3QgcXVlcnkgd2l0aCBtb3JlIHRoYW4gJHtNQVhfUVVFUllfT1BFUkFUT1JTfSBvcGVyYXRvcnNgLFxuICAgICAgKTtcbiAgICB9XG4gICAgcXVlcnkub3BlcmF0b3JzLnB1c2goe1xuICAgICAgZmlsdGVyOiBzZXJpYWxpemVFeHByZXNzaW9uKHByZWRpY2F0ZShmaWx0ZXJCdWlsZGVySW1wbCkpLFxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHF1ZXJ5KTtcbiAgfVxuXG4gIGxpbWl0KG46IG51bWJlcik6IGFueSB7XG4gICAgdmFsaWRhdGVBcmcobiwgMSwgXCJsaW1pdFwiLCBcIm5cIik7XG4gICAgY29uc3QgcXVlcnkgPSB0aGlzLnRha2VRdWVyeSgpO1xuICAgIHF1ZXJ5Lm9wZXJhdG9ycy5wdXNoKHsgbGltaXQ6IG4gfSk7XG4gICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocXVlcnkpO1xuICB9XG5cbiAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpOiBBc3luY0l0ZXJhYmxlSXRlcmF0b3I8YW55PiB7XG4gICAgdGhpcy5zdGFydFF1ZXJ5KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBhc3luYyBuZXh0KCk6IFByb21pc2U8SXRlcmF0b3JSZXN1bHQ8YW55Pj4ge1xuICAgIGlmICh0aGlzLnN0YXRlLnR5cGUgPT09IFwiY2xvc2VkXCIgfHwgdGhpcy5zdGF0ZS50eXBlID09PSBcImNvbnN1bWVkXCIpIHtcbiAgICAgIHRocm93Q2xvc2VkRXJyb3IodGhpcy5zdGF0ZS50eXBlKTtcbiAgICB9XG4gICAgLy8gQWxsb3cgY2FsbGluZyBgLm5leHQoKWAgd2hlbiB0aGUgcXVlcnkgaXMgaW4gXCJwcmVwYXJpbmdcIiBzdGF0ZSB0byBpbXBsaWNpdGx5IHN0YXJ0IHRoZVxuICAgIC8vIHF1ZXJ5LiBUaGlzIGFsbG93cyB0aGUgZGV2ZWxvcGVyIHRvIGNhbGwgYC5uZXh0KClgIG9uIHRoZSBxdWVyeSB3aXRob3V0IGhhdmluZyB0byB1c2VcbiAgICAvLyBhIGBmb3IgYXdhaXRgIHN0YXRlbWVudC5cbiAgICBjb25zdCBxdWVyeUlkID1cbiAgICAgIHRoaXMuc3RhdGUudHlwZSA9PT0gXCJwcmVwYXJpbmdcIiA/IHRoaXMuc3RhcnRRdWVyeSgpIDogdGhpcy5zdGF0ZS5xdWVyeUlkO1xuICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IHBlcmZvcm1Bc3luY1N5c2NhbGwoXCIxLjAvcXVlcnlTdHJlYW1OZXh0XCIsIHtcbiAgICAgIHF1ZXJ5SWQsXG4gICAgfSk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIHRoaXMuY2xvc2VRdWVyeSgpO1xuICAgIH1cbiAgICBjb25zdCBjb252ZXhWYWx1ZSA9IGpzb25Ub0NvbnZleCh2YWx1ZSk7XG4gICAgcmV0dXJuIHsgdmFsdWU6IGNvbnZleFZhbHVlLCBkb25lIH07XG4gIH1cblxuICByZXR1cm4oKSB7XG4gICAgdGhpcy5jbG9zZVF1ZXJ5KCk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfSk7XG4gIH1cblxuICBhc3luYyBwYWdpbmF0ZShcbiAgICBwYWdpbmF0aW9uT3B0czogUGFnaW5hdGlvbk9wdGlvbnMsXG4gICk6IFByb21pc2U8UGFnaW5hdGlvblJlc3VsdDxhbnk+PiB7XG4gICAgdmFsaWRhdGVBcmcocGFnaW5hdGlvbk9wdHMsIDEsIFwicGFnaW5hdGVcIiwgXCJvcHRpb25zXCIpO1xuICAgIGlmIChcbiAgICAgIHR5cGVvZiBwYWdpbmF0aW9uT3B0cz8ubnVtSXRlbXMgIT09IFwibnVtYmVyXCIgfHxcbiAgICAgIHBhZ2luYXRpb25PcHRzLm51bUl0ZW1zIDwgMFxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgXFxgb3B0aW9ucy5udW1JdGVtc1xcYCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyLiBSZWNlaXZlZCBcXGAke3BhZ2luYXRpb25PcHRzPy5udW1JdGVtc31cXGAuYCxcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy50YWtlUXVlcnkoKTtcbiAgICBjb25zdCBwYWdlU2l6ZSA9IHBhZ2luYXRpb25PcHRzLm51bUl0ZW1zO1xuICAgIGNvbnN0IGN1cnNvciA9IHBhZ2luYXRpb25PcHRzLmN1cnNvcjtcbiAgICBjb25zdCBlbmRDdXJzb3IgPSBwYWdpbmF0aW9uT3B0cz8uZW5kQ3Vyc29yID8/IG51bGw7XG4gICAgY29uc3QgbWF4aW11bVJvd3NSZWFkID0gcGFnaW5hdGlvbk9wdHMubWF4aW11bVJvd3NSZWFkID8/IG51bGw7XG4gICAgY29uc3QgeyBwYWdlLCBpc0RvbmUsIGNvbnRpbnVlQ3Vyc29yLCBzcGxpdEN1cnNvciwgcGFnZVN0YXR1cyB9ID1cbiAgICAgIGF3YWl0IHBlcmZvcm1Bc3luY1N5c2NhbGwoXCIxLjAvcXVlcnlQYWdlXCIsIHtcbiAgICAgICAgcXVlcnksXG4gICAgICAgIGN1cnNvcixcbiAgICAgICAgZW5kQ3Vyc29yLFxuICAgICAgICBwYWdlU2l6ZSxcbiAgICAgICAgbWF4aW11bVJvd3NSZWFkLFxuICAgICAgICBtYXhpbXVtQnl0ZXNSZWFkOiBwYWdpbmF0aW9uT3B0cy5tYXhpbXVtQnl0ZXNSZWFkLFxuICAgICAgICB2ZXJzaW9uLFxuICAgICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhZ2U6IHBhZ2UubWFwKChqc29uOiBzdHJpbmcpID0+IGpzb25Ub0NvbnZleChqc29uKSksXG4gICAgICBpc0RvbmUsXG4gICAgICBjb250aW51ZUN1cnNvcixcbiAgICAgIHNwbGl0Q3Vyc29yLFxuICAgICAgcGFnZVN0YXR1cyxcbiAgICB9O1xuICB9XG5cbiAgYXN5bmMgY29sbGVjdCgpOiBQcm9taXNlPEFycmF5PGFueT4+IHtcbiAgICBjb25zdCBvdXQ6IFZhbHVlW10gPSBbXTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGl0ZW0gb2YgdGhpcykge1xuICAgICAgb3V0LnB1c2goaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH1cblxuICBhc3luYyB0YWtlKG46IG51bWJlcik6IFByb21pc2U8QXJyYXk8YW55Pj4ge1xuICAgIHZhbGlkYXRlQXJnKG4sIDEsIFwidGFrZVwiLCBcIm5cIik7XG4gICAgdmFsaWRhdGVBcmdJc05vbk5lZ2F0aXZlSW50ZWdlcihuLCAxLCBcInRha2VcIiwgXCJuXCIpO1xuICAgIHJldHVybiB0aGlzLmxpbWl0KG4pLmNvbGxlY3QoKTtcbiAgfVxuXG4gIGFzeW5jIGZpcnN0KCk6IFByb21pc2U8YW55IHwgbnVsbD4ge1xuICAgIGNvbnN0IGZpcnN0X2FycmF5ID0gYXdhaXQgdGhpcy50YWtlKDEpO1xuICAgIHJldHVybiBmaXJzdF9hcnJheS5sZW5ndGggPT09IDAgPyBudWxsIDogZmlyc3RfYXJyYXlbMF07XG4gIH1cblxuICBhc3luYyB1bmlxdWUoKTogUHJvbWlzZTxhbnkgfCBudWxsPiB7XG4gICAgY29uc3QgZmlyc3RfdHdvX2FycmF5ID0gYXdhaXQgdGhpcy50YWtlKDIpO1xuICAgIGlmIChmaXJzdF90d29fYXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGZpcnN0X3R3b19hcnJheS5sZW5ndGggPT09IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5pcXVlKCkgcXVlcnkgcmV0dXJuZWQgbW9yZSB0aGFuIG9uZSByZXN1bHQgZnJvbSB0YWJsZSAke3RoaXMudGFibGVOYW1lRm9yRXJyb3JNZXNzYWdlc306XG4gWyR7Zmlyc3RfdHdvX2FycmF5WzBdLl9pZH0sICR7Zmlyc3RfdHdvX2FycmF5WzFdLl9pZH0sIC4uLl1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpcnN0X3R3b19hcnJheVswXTtcbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuaW1wb3J0IHsgY29udmV4T3JVbmRlZmluZWRUb0pzb24gfSBmcm9tIFwiLi4vLi4vdmFsdWVzL3ZhbHVlLmpzXCI7XG5pbXBvcnQge1xuICBFeHByZXNzaW9uXG59IGZyb20gXCIuLi9maWx0ZXJfYnVpbGRlci5qc1wiO1xuZXhwb3J0IGNsYXNzIEV4cHJlc3Npb25JbXBsIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gIGNvbnN0cnVjdG9yKGlubmVyKSB7XG4gICAgc3VwZXIoKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaW5uZXJcIik7XG4gICAgdGhpcy5pbm5lciA9IGlubmVyO1xuICB9XG4gIHNlcmlhbGl6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbm5lcjtcbiAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZUV4cHJlc3Npb24oZXhwcikge1xuICBpZiAoZXhwciBpbnN0YW5jZW9mIEV4cHJlc3Npb25JbXBsKSB7XG4gICAgcmV0dXJuIGV4cHIuc2VyaWFsaXplKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgJGxpdGVyYWw6IGNvbnZleE9yVW5kZWZpbmVkVG9Kc29uKGV4cHIpIH07XG4gIH1cbn1cbmV4cG9ydCBjb25zdCBmaWx0ZXJCdWlsZGVySW1wbCA9IHtcbiAgLy8gIENvbXBhcmlzb25zICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIGVxKGwsIHIpIHtcbiAgICByZXR1cm4gbmV3IEV4cHJlc3Npb25JbXBsKHtcbiAgICAgICRlcTogW3NlcmlhbGl6ZUV4cHJlc3Npb24obCksIHNlcmlhbGl6ZUV4cHJlc3Npb24ocildXG4gICAgfSk7XG4gIH0sXG4gIG5lcShsLCByKSB7XG4gICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uSW1wbCh7XG4gICAgICAkbmVxOiBbc2VyaWFsaXplRXhwcmVzc2lvbihsKSwgc2VyaWFsaXplRXhwcmVzc2lvbihyKV1cbiAgICB9KTtcbiAgfSxcbiAgbHQobCwgcikge1xuICAgIHJldHVybiBuZXcgRXhwcmVzc2lvbkltcGwoe1xuICAgICAgJGx0OiBbc2VyaWFsaXplRXhwcmVzc2lvbihsKSwgc2VyaWFsaXplRXhwcmVzc2lvbihyKV1cbiAgICB9KTtcbiAgfSxcbiAgbHRlKGwsIHIpIHtcbiAgICByZXR1cm4gbmV3IEV4cHJlc3Npb25JbXBsKHtcbiAgICAgICRsdGU6IFtzZXJpYWxpemVFeHByZXNzaW9uKGwpLCBzZXJpYWxpemVFeHByZXNzaW9uKHIpXVxuICAgIH0pO1xuICB9LFxuICBndChsLCByKSB7XG4gICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uSW1wbCh7XG4gICAgICAkZ3Q6IFtzZXJpYWxpemVFeHByZXNzaW9uKGwpLCBzZXJpYWxpemVFeHByZXNzaW9uKHIpXVxuICAgIH0pO1xuICB9LFxuICBndGUobCwgcikge1xuICAgIHJldHVybiBuZXcgRXhwcmVzc2lvbkltcGwoe1xuICAgICAgJGd0ZTogW3NlcmlhbGl6ZUV4cHJlc3Npb24obCksIHNlcmlhbGl6ZUV4cHJlc3Npb24ocildXG4gICAgfSk7XG4gIH0sXG4gIC8vICBBcml0aG1ldGljICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICBhZGQobCwgcikge1xuICAgIHJldHVybiBuZXcgRXhwcmVzc2lvbkltcGwoe1xuICAgICAgJGFkZDogW3NlcmlhbGl6ZUV4cHJlc3Npb24obCksIHNlcmlhbGl6ZUV4cHJlc3Npb24ocildXG4gICAgfSk7XG4gIH0sXG4gIHN1YihsLCByKSB7XG4gICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uSW1wbCh7XG4gICAgICAkc3ViOiBbc2VyaWFsaXplRXhwcmVzc2lvbihsKSwgc2VyaWFsaXplRXhwcmVzc2lvbihyKV1cbiAgICB9KTtcbiAgfSxcbiAgbXVsKGwsIHIpIHtcbiAgICByZXR1cm4gbmV3IEV4cHJlc3Npb25JbXBsKHtcbiAgICAgICRtdWw6IFtzZXJpYWxpemVFeHByZXNzaW9uKGwpLCBzZXJpYWxpemVFeHByZXNzaW9uKHIpXVxuICAgIH0pO1xuICB9LFxuICBkaXYobCwgcikge1xuICAgIHJldHVybiBuZXcgRXhwcmVzc2lvbkltcGwoe1xuICAgICAgJGRpdjogW3NlcmlhbGl6ZUV4cHJlc3Npb24obCksIHNlcmlhbGl6ZUV4cHJlc3Npb24ocildXG4gICAgfSk7XG4gIH0sXG4gIG1vZChsLCByKSB7XG4gICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uSW1wbCh7XG4gICAgICAkbW9kOiBbc2VyaWFsaXplRXhwcmVzc2lvbihsKSwgc2VyaWFsaXplRXhwcmVzc2lvbihyKV1cbiAgICB9KTtcbiAgfSxcbiAgbmVnKHgpIHtcbiAgICByZXR1cm4gbmV3IEV4cHJlc3Npb25JbXBsKHsgJG5lZzogc2VyaWFsaXplRXhwcmVzc2lvbih4KSB9KTtcbiAgfSxcbiAgLy8gIExvZ2ljICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIGFuZCguLi5leHBycykge1xuICAgIHJldHVybiBuZXcgRXhwcmVzc2lvbkltcGwoeyAkYW5kOiBleHBycy5tYXAoc2VyaWFsaXplRXhwcmVzc2lvbikgfSk7XG4gIH0sXG4gIG9yKC4uLmV4cHJzKSB7XG4gICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uSW1wbCh7ICRvcjogZXhwcnMubWFwKHNlcmlhbGl6ZUV4cHJlc3Npb24pIH0pO1xuICB9LFxuICBub3QoeCkge1xuICAgIHJldHVybiBuZXcgRXhwcmVzc2lvbkltcGwoeyAkbm90OiBzZXJpYWxpemVFeHByZXNzaW9uKHgpIH0pO1xuICB9LFxuICAvLyAgT3RoZXIgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgZmllbGQoZmllbGRQYXRoKSB7XG4gICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uSW1wbCh7ICRmaWVsZDogZmllbGRQYXRoIH0pO1xuICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsdGVyX2J1aWxkZXJfaW1wbC5qcy5tYXBcbiIsImltcG9ydCB7IEpTT05WYWx1ZSwgVmFsdWUsIE51bWVyaWNWYWx1ZSB9IGZyb20gXCIuLi8uLi92YWx1ZXMvaW5kZXguanNcIjtcbmltcG9ydCB7IGNvbnZleE9yVW5kZWZpbmVkVG9Kc29uIH0gZnJvbSBcIi4uLy4uL3ZhbHVlcy92YWx1ZS5qc1wiO1xuaW1wb3J0IHsgR2VuZXJpY1RhYmxlSW5mbyB9IGZyb20gXCIuLi9kYXRhX21vZGVsLmpzXCI7XG5pbXBvcnQge1xuICBFeHByZXNzaW9uLFxuICBFeHByZXNzaW9uT3JWYWx1ZSxcbiAgRmlsdGVyQnVpbGRlcixcbn0gZnJvbSBcIi4uL2ZpbHRlcl9idWlsZGVyLmpzXCI7XG5cbi8vIFRoZSBgYW55YCB0eXBlIHBhcmFtZXRlciBpbiBgRXhwcmVzc2lvbjxhbnk+YCBhbGxvd3MgdXMgdG8gdXNlIHRoaXMgY2xhc3Ncbi8vIGluIHBsYWNlIG9mIGFueSBgRXhwcmVzc2lvbmAgdHlwZSBpbiBgZmlsdGVyQnVpbGRlckltcGxgLlxuZXhwb3J0IGNsYXNzIEV4cHJlc3Npb25JbXBsIGV4dGVuZHMgRXhwcmVzc2lvbjxhbnk+IHtcbiAgcHJpdmF0ZSBpbm5lcjogSlNPTlZhbHVlO1xuICBjb25zdHJ1Y3Rvcihpbm5lcjogSlNPTlZhbHVlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmlubmVyID0gaW5uZXI7XG4gIH1cblxuICBzZXJpYWxpemUoKTogSlNPTlZhbHVlIHtcbiAgICByZXR1cm4gdGhpcy5pbm5lcjtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplRXhwcmVzc2lvbihcbiAgZXhwcjogRXhwcmVzc2lvbk9yVmFsdWU8VmFsdWUgfCB1bmRlZmluZWQ+LFxuKTogSlNPTlZhbHVlIHtcbiAgaWYgKGV4cHIgaW5zdGFuY2VvZiBFeHByZXNzaW9uSW1wbCkge1xuICAgIHJldHVybiBleHByLnNlcmlhbGl6ZSgpO1xuICB9IGVsc2Uge1xuICAgIC8vIEFzc3VtZSB0aGF0IHRoZSBleHByZXNzaW9uIGlzIGEgbGl0ZXJhbCBDb252ZXggdmFsdWUsIHdoaWNoIHdlJ2xsIHNlcmlhbGl6ZVxuICAgIC8vIHRvIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLlxuICAgIHJldHVybiB7ICRsaXRlcmFsOiBjb252ZXhPclVuZGVmaW5lZFRvSnNvbihleHByIGFzIFZhbHVlIHwgdW5kZWZpbmVkKSB9O1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBmaWx0ZXJCdWlsZGVySW1wbDogRmlsdGVyQnVpbGRlcjxHZW5lcmljVGFibGVJbmZvPiA9IHtcbiAgLy8gIENvbXBhcmlzb25zICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgZXE8VCBleHRlbmRzIFZhbHVlIHwgdW5kZWZpbmVkPihcbiAgICBsOiBFeHByZXNzaW9uT3JWYWx1ZTxUPixcbiAgICByOiBFeHByZXNzaW9uT3JWYWx1ZTxUPixcbiAgKTogRXhwcmVzc2lvbjxib29sZWFuPiB7XG4gICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uSW1wbCh7XG4gICAgICAkZXE6IFtzZXJpYWxpemVFeHByZXNzaW9uKGwpLCBzZXJpYWxpemVFeHByZXNzaW9uKHIpXSxcbiAgICB9KTtcbiAgfSxcblxuICBuZXE8VCBleHRlbmRzIFZhbHVlIHwgdW5kZWZpbmVkPihcbiAgICBsOiBFeHByZXNzaW9uT3JWYWx1ZTxUPixcbiAgICByOiBFeHByZXNzaW9uT3JWYWx1ZTxUPixcbiAgKTogRXhwcmVzc2lvbjxib29sZWFuPiB7XG4gICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uSW1wbCh7XG4gICAgICAkbmVxOiBbc2VyaWFsaXplRXhwcmVzc2lvbihsKSwgc2VyaWFsaXplRXhwcmVzc2lvbihyKV0sXG4gICAgfSk7XG4gIH0sXG5cbiAgbHQ8VCBleHRlbmRzIFZhbHVlPihcbiAgICBsOiBFeHByZXNzaW9uT3JWYWx1ZTxUPixcbiAgICByOiBFeHByZXNzaW9uT3JWYWx1ZTxUPixcbiAgKTogRXhwcmVzc2lvbjxib29sZWFuPiB7XG4gICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uSW1wbCh7XG4gICAgICAkbHQ6IFtzZXJpYWxpemVFeHByZXNzaW9uKGwpLCBzZXJpYWxpemVFeHByZXNzaW9uKHIpXSxcbiAgICB9KTtcbiAgfSxcblxuICBsdGU8VCBleHRlbmRzIFZhbHVlPihcbiAgICBsOiBFeHByZXNzaW9uT3JWYWx1ZTxUPixcbiAgICByOiBFeHByZXNzaW9uT3JWYWx1ZTxUPixcbiAgKTogRXhwcmVzc2lvbjxib29sZWFuPiB7XG4gICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uSW1wbCh7XG4gICAgICAkbHRlOiBbc2VyaWFsaXplRXhwcmVzc2lvbihsKSwgc2VyaWFsaXplRXhwcmVzc2lvbihyKV0sXG4gICAgfSk7XG4gIH0sXG5cbiAgZ3Q8VCBleHRlbmRzIFZhbHVlPihcbiAgICBsOiBFeHByZXNzaW9uT3JWYWx1ZTxUPixcbiAgICByOiBFeHByZXNzaW9uT3JWYWx1ZTxUPixcbiAgKTogRXhwcmVzc2lvbjxib29sZWFuPiB7XG4gICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uSW1wbCh7XG4gICAgICAkZ3Q6IFtzZXJpYWxpemVFeHByZXNzaW9uKGwpLCBzZXJpYWxpemVFeHByZXNzaW9uKHIpXSxcbiAgICB9KTtcbiAgfSxcblxuICBndGU8VCBleHRlbmRzIFZhbHVlPihcbiAgICBsOiBFeHByZXNzaW9uT3JWYWx1ZTxUPixcbiAgICByOiBFeHByZXNzaW9uT3JWYWx1ZTxUPixcbiAgKTogRXhwcmVzc2lvbjxib29sZWFuPiB7XG4gICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uSW1wbCh7XG4gICAgICAkZ3RlOiBbc2VyaWFsaXplRXhwcmVzc2lvbihsKSwgc2VyaWFsaXplRXhwcmVzc2lvbihyKV0sXG4gICAgfSk7XG4gIH0sXG5cbiAgLy8gIEFyaXRobWV0aWMgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgYWRkPFQgZXh0ZW5kcyBOdW1lcmljVmFsdWU+KFxuICAgIGw6IEV4cHJlc3Npb25PclZhbHVlPFQ+LFxuICAgIHI6IEV4cHJlc3Npb25PclZhbHVlPFQ+LFxuICApOiBFeHByZXNzaW9uPFQ+IHtcbiAgICByZXR1cm4gbmV3IEV4cHJlc3Npb25JbXBsKHtcbiAgICAgICRhZGQ6IFtzZXJpYWxpemVFeHByZXNzaW9uKGwpLCBzZXJpYWxpemVFeHByZXNzaW9uKHIpXSxcbiAgICB9KTtcbiAgfSxcblxuICBzdWI8VCBleHRlbmRzIE51bWVyaWNWYWx1ZT4oXG4gICAgbDogRXhwcmVzc2lvbk9yVmFsdWU8VD4sXG4gICAgcjogRXhwcmVzc2lvbk9yVmFsdWU8VD4sXG4gICk6IEV4cHJlc3Npb248VD4ge1xuICAgIHJldHVybiBuZXcgRXhwcmVzc2lvbkltcGwoe1xuICAgICAgJHN1YjogW3NlcmlhbGl6ZUV4cHJlc3Npb24obCksIHNlcmlhbGl6ZUV4cHJlc3Npb24ocildLFxuICAgIH0pO1xuICB9LFxuXG4gIG11bDxUIGV4dGVuZHMgTnVtZXJpY1ZhbHVlPihcbiAgICBsOiBFeHByZXNzaW9uT3JWYWx1ZTxUPixcbiAgICByOiBFeHByZXNzaW9uT3JWYWx1ZTxUPixcbiAgKTogRXhwcmVzc2lvbjxUPiB7XG4gICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uSW1wbCh7XG4gICAgICAkbXVsOiBbc2VyaWFsaXplRXhwcmVzc2lvbihsKSwgc2VyaWFsaXplRXhwcmVzc2lvbihyKV0sXG4gICAgfSk7XG4gIH0sXG5cbiAgZGl2PFQgZXh0ZW5kcyBOdW1lcmljVmFsdWU+KFxuICAgIGw6IEV4cHJlc3Npb25PclZhbHVlPFQ+LFxuICAgIHI6IEV4cHJlc3Npb25PclZhbHVlPFQ+LFxuICApOiBFeHByZXNzaW9uPFQ+IHtcbiAgICByZXR1cm4gbmV3IEV4cHJlc3Npb25JbXBsKHtcbiAgICAgICRkaXY6IFtzZXJpYWxpemVFeHByZXNzaW9uKGwpLCBzZXJpYWxpemVFeHByZXNzaW9uKHIpXSxcbiAgICB9KTtcbiAgfSxcblxuICBtb2Q8VCBleHRlbmRzIE51bWVyaWNWYWx1ZT4oXG4gICAgbDogRXhwcmVzc2lvbk9yVmFsdWU8VD4sXG4gICAgcjogRXhwcmVzc2lvbk9yVmFsdWU8VD4sXG4gICk6IEV4cHJlc3Npb248VD4ge1xuICAgIHJldHVybiBuZXcgRXhwcmVzc2lvbkltcGwoe1xuICAgICAgJG1vZDogW3NlcmlhbGl6ZUV4cHJlc3Npb24obCksIHNlcmlhbGl6ZUV4cHJlc3Npb24ocildLFxuICAgIH0pO1xuICB9LFxuXG4gIG5lZzxUIGV4dGVuZHMgTnVtZXJpY1ZhbHVlPih4OiBFeHByZXNzaW9uT3JWYWx1ZTxUPik6IEV4cHJlc3Npb248VD4ge1xuICAgIHJldHVybiBuZXcgRXhwcmVzc2lvbkltcGwoeyAkbmVnOiBzZXJpYWxpemVFeHByZXNzaW9uKHgpIH0pO1xuICB9LFxuXG4gIC8vICBMb2dpYyAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIGFuZCguLi5leHByczogQXJyYXk8RXhwcmVzc2lvbk9yVmFsdWU8Ym9vbGVhbj4+KTogRXhwcmVzc2lvbjxib29sZWFuPiB7XG4gICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uSW1wbCh7ICRhbmQ6IGV4cHJzLm1hcChzZXJpYWxpemVFeHByZXNzaW9uKSB9KTtcbiAgfSxcblxuICBvciguLi5leHByczogQXJyYXk8RXhwcmVzc2lvbk9yVmFsdWU8Ym9vbGVhbj4+KTogRXhwcmVzc2lvbjxib29sZWFuPiB7XG4gICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uSW1wbCh7ICRvcjogZXhwcnMubWFwKHNlcmlhbGl6ZUV4cHJlc3Npb24pIH0pO1xuICB9LFxuXG4gIG5vdCh4OiBFeHByZXNzaW9uT3JWYWx1ZTxib29sZWFuPik6IEV4cHJlc3Npb248Ym9vbGVhbj4ge1xuICAgIHJldHVybiBuZXcgRXhwcmVzc2lvbkltcGwoeyAkbm90OiBzZXJpYWxpemVFeHByZXNzaW9uKHgpIH0pO1xuICB9LFxuXG4gIC8vICBPdGhlciAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICBmaWVsZChmaWVsZFBhdGg6IHN0cmluZyk6IEV4cHJlc3Npb248YW55PiB7XG4gICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uSW1wbCh7ICRmaWVsZDogZmllbGRQYXRoIH0pO1xuICB9LFxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4gX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbmV4cG9ydCBjbGFzcyBFeHByZXNzaW9uIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLy8gUHJvcGVydHkgZm9yIG5vbWluYWwgdHlwZSBzdXBwb3J0LlxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfaXNFeHByZXNzaW9uXCIpO1xuICAgIC8vIFByb3BlcnR5IHRvIGRpc3Rpbmd1aXNoIGV4cHJlc3Npb25zIGJ5IHRoZSB0eXBlIHRoZXkgcmVzb2x2ZSB0by5cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX3ZhbHVlXCIpO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWx0ZXJfYnVpbGRlci5qcy5tYXBcbiIsImltcG9ydCB7IFZhbHVlLCBOdW1lcmljVmFsdWUgfSBmcm9tIFwiLi4vdmFsdWVzL2luZGV4LmpzXCI7XG5pbXBvcnQge1xuICBEb2N1bWVudEJ5SW5mbyxcbiAgRmllbGRQYXRocyxcbiAgRmllbGRUeXBlRnJvbUZpZWxkUGF0aCxcbiAgR2VuZXJpY1RhYmxlSW5mbyxcbn0gZnJvbSBcIi4vZGF0YV9tb2RlbC5qc1wiO1xuXG4vKipcbiAqIEV4cHJlc3Npb25zIGFyZSBldmFsdWF0ZWQgdG8gcHJvZHVjZSBhIHtAbGluayB2YWx1ZXMuVmFsdWV9IGluIHRoZSBjb3Vyc2Ugb2YgZXhlY3V0aW5nIGEgcXVlcnkuXG4gKlxuICogVG8gY29uc3RydWN0IGFuIGV4cHJlc3Npb24sIHVzZSB0aGUge0BsaW5rIEZpbHRlckJ1aWxkZXJ9IHByb3ZpZGVkIHdpdGhpblxuICoge0BsaW5rIE9yZGVyZWRRdWVyeS5maWx0ZXJ9LlxuICpcbiAqIEB0eXBlUGFyYW0gVCAtIFRoZSB0eXBlIHRoYXQgdGhpcyBleHByZXNzaW9uIGV2YWx1YXRlcyB0by5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEV4cHJlc3Npb248VCBleHRlbmRzIFZhbHVlIHwgdW5kZWZpbmVkPiB7XG4gIC8vIFByb3BlcnR5IGZvciBub21pbmFsIHR5cGUgc3VwcG9ydC5cbiAgcHJpdmF0ZSBfaXNFeHByZXNzaW9uOiB1bmRlZmluZWQ7XG5cbiAgLy8gUHJvcGVydHkgdG8gZGlzdGluZ3Vpc2ggZXhwcmVzc2lvbnMgYnkgdGhlIHR5cGUgdGhleSByZXNvbHZlIHRvLlxuICBwcml2YXRlIF92YWx1ZSE6IFQ7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLy8gb25seSBkZWZpbmluZyB0aGUgY29uc3RydWN0b3Igc28gd2UgY2FuIG1hcmsgaXQgYXMgaW50ZXJuYWwgYW5kIGtlZXBcbiAgICAvLyBpdCBvdXQgb2YgdGhlIGRvY3MuXG4gIH1cbn1cbi8qKlxuICogQW4ge0BsaW5rIEV4cHJlc3Npb259IG9yIGEgY29uc3RhbnQge0BsaW5rIHZhbHVlcy5WYWx1ZX1cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCB0eXBlIEV4cHJlc3Npb25PclZhbHVlPFQgZXh0ZW5kcyBWYWx1ZSB8IHVuZGVmaW5lZD4gPSBFeHByZXNzaW9uPFQ+IHwgVDtcblxuLyoqXG4gKiBBbiBpbnRlcmZhY2UgZm9yIGRlZmluaW5nIGZpbHRlcnMgaW4gcXVlcmllcy5cbiAqXG4gKiBgRmlsdGVyQnVpbGRlcmAgaGFzIHZhcmlvdXMgbWV0aG9kcyB0aGF0IHByb2R1Y2Uge0BsaW5rIEV4cHJlc3Npb259cy5cbiAqIFRoZXNlIGV4cHJlc3Npb25zIGNhbiBiZSBuZXN0ZWQgdG9nZXRoZXIgYWxvbmcgd2l0aCBjb25zdGFudHMgdG8gZXhwcmVzc1xuICogYSBmaWx0ZXIgcHJlZGljYXRlLlxuICpcbiAqIGBGaWx0ZXJCdWlsZGVyYCBpcyB1c2VkIHdpdGhpbiB7QGxpbmsgT3JkZXJlZFF1ZXJ5LmZpbHRlcn0gdG8gY3JlYXRlIHF1ZXJ5XG4gKiBmaWx0ZXJzLlxuICpcbiAqIEhlcmUgYXJlIHRoZSBhdmFpbGFibGUgbWV0aG9kczpcbiAqXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICogfCAqKkNvbXBhcmlzb25zKiogICAgICAgICAgICAgICB8IEVycm9yIHdoZW4gYGxgIGFuZCBgcmAgYXJlIG5vdCB0aGUgc2FtZSB0eXBlLiB8XG4gKiB8IFtgZXEobCwgcilgXSgjZXEpICAgICAgICAgICAgIHwgYGwgPT09IHJgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgW2BuZXEobCwgcilgXSgjbmVxKSAgICAgICAgICAgfCBgbCAhPT0gcmAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCBbYGx0KGwsIHIpYF0oI2x0KSAgICAgICAgICAgICB8IGBsIDwgcmAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IFtgbHRlKGwsIHIpYF0oI2x0ZSkgICAgICAgICAgIHwgYGwgPD0gcmAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgW2BndChsLCByKWBdKCNndCkgICAgICAgICAgICAgfCBgbCA+IHJgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCBbYGd0ZShsLCByKWBdKCNndGUpICAgICAgICAgICB8IGBsID49IHJgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgKipBcml0aG1ldGljKiogICAgICAgICAgICAgICAgfCBFcnJvciB3aGVuIGBsYCBhbmQgYHJgIGFyZSBub3QgdGhlIHNhbWUgdHlwZS4gfFxuICogfCBbYGFkZChsLCByKWBdKCNhZGQpICAgICAgICAgICB8IGBsICsgcmAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IFtgc3ViKGwsIHIpYF0oI3N1YikgICAgICAgICAgIHwgYGwgLSByYCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgW2BtdWwobCwgcilgXSgjbXVsKSAgICAgICAgICAgfCBgbCAqIHJgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCBbYGRpdihsLCByKWBdKCNkaXYpICAgICAgICAgICB8IGBsIC8gcmAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IFtgbW9kKGwsIHIpYF0oI21vZCkgICAgICAgICAgIHwgYGwgJSByYCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgW2BuZWcoeClgXSgjbmVnKSAgICAgICAgICAgICAgfCBgLXhgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICoqTG9naWMqKiAgICAgICAgICAgICAgICAgICAgIHwgRXJyb3IgaWYgYW55IHBhcmFtIGlzIG5vdCBhIGBib29sYC4gICAgICAgICAgIHxcbiAqIHwgW2Bub3QoeClgXSgjbm90KSAgICAgICAgICAgICAgfCBgIXhgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCBbYGFuZChhLCBiLCAuLi4sIHopYF0oI2FuZCkgICB8IGBhICYmIGIgJiYgLi4uICYmIHpgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IFtgb3IoYSwgYiwgLi4uLCB6KWBdKCNvcikgICAgIHwgPGNvZGU+YSAmIzEyNDsmIzEyNDsgYiAmIzEyNDsmIzEyNDsgLi4uICYjMTI0OyYjMTI0OyB6PC9jb2RlPiB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgKipPdGhlcioqICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCBbYGZpZWxkKGZpZWxkUGF0aClgXSgjZmllbGQpICB8IEV2YWx1YXRlcyB0byB0aGUgZmllbGQgYXQgYGZpZWxkUGF0aGAuICAgICAgICB8XG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRmlsdGVyQnVpbGRlcjxUYWJsZUluZm8gZXh0ZW5kcyBHZW5lcmljVGFibGVJbmZvPiB7XG4gIC8vICBDb21wYXJpc29ucyAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIC8qKlxuICAgKiBgbCA9PT0gcmBcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKiAqL1xuICBlcTxUIGV4dGVuZHMgVmFsdWUgfCB1bmRlZmluZWQ+KFxuICAgIGw6IEV4cHJlc3Npb25PclZhbHVlPFQ+LFxuICAgIHI6IEV4cHJlc3Npb25PclZhbHVlPFQ+LFxuICApOiBFeHByZXNzaW9uPGJvb2xlYW4+O1xuXG4gIC8qKlxuICAgKiBgbCAhPT0gcmBcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKiAqL1xuICBuZXE8VCBleHRlbmRzIFZhbHVlIHwgdW5kZWZpbmVkPihcbiAgICBsOiBFeHByZXNzaW9uT3JWYWx1ZTxUPixcbiAgICByOiBFeHByZXNzaW9uT3JWYWx1ZTxUPixcbiAgKTogRXhwcmVzc2lvbjxib29sZWFuPjtcblxuICAvKipcbiAgICogYGwgPCByYFxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBsdDxUIGV4dGVuZHMgVmFsdWU+KFxuICAgIGw6IEV4cHJlc3Npb25PclZhbHVlPFQ+LFxuICAgIHI6IEV4cHJlc3Npb25PclZhbHVlPFQ+LFxuICApOiBFeHByZXNzaW9uPGJvb2xlYW4+O1xuXG4gIC8qKlxuICAgKiBgbCA8PSByYFxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBsdGU8VCBleHRlbmRzIFZhbHVlPihcbiAgICBsOiBFeHByZXNzaW9uT3JWYWx1ZTxUPixcbiAgICByOiBFeHByZXNzaW9uT3JWYWx1ZTxUPixcbiAgKTogRXhwcmVzc2lvbjxib29sZWFuPjtcblxuICAvKipcbiAgICogYGwgPiByYFxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBndDxUIGV4dGVuZHMgVmFsdWU+KFxuICAgIGw6IEV4cHJlc3Npb25PclZhbHVlPFQ+LFxuICAgIHI6IEV4cHJlc3Npb25PclZhbHVlPFQ+LFxuICApOiBFeHByZXNzaW9uPGJvb2xlYW4+O1xuXG4gIC8qKlxuICAgKiBgbCA+PSByYFxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBndGU8VCBleHRlbmRzIFZhbHVlPihcbiAgICBsOiBFeHByZXNzaW9uT3JWYWx1ZTxUPixcbiAgICByOiBFeHByZXNzaW9uT3JWYWx1ZTxUPixcbiAgKTogRXhwcmVzc2lvbjxib29sZWFuPjtcblxuICAvLyAgQXJpdGhtZXRpYyAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAvKipcbiAgICogYGwgKyByYFxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBhZGQ8VCBleHRlbmRzIE51bWVyaWNWYWx1ZT4oXG4gICAgbDogRXhwcmVzc2lvbk9yVmFsdWU8VD4sXG4gICAgcjogRXhwcmVzc2lvbk9yVmFsdWU8VD4sXG4gICk6IEV4cHJlc3Npb248VD47XG5cbiAgLyoqXG4gICAqIGBsIC0gcmBcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgc3ViPFQgZXh0ZW5kcyBOdW1lcmljVmFsdWU+KFxuICAgIGw6IEV4cHJlc3Npb25PclZhbHVlPFQ+LFxuICAgIHI6IEV4cHJlc3Npb25PclZhbHVlPFQ+LFxuICApOiBFeHByZXNzaW9uPFQ+O1xuXG4gIC8qKlxuICAgKiBgbCAqIHJgXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIG11bDxUIGV4dGVuZHMgTnVtZXJpY1ZhbHVlPihcbiAgICBsOiBFeHByZXNzaW9uT3JWYWx1ZTxUPixcbiAgICByOiBFeHByZXNzaW9uT3JWYWx1ZTxUPixcbiAgKTogRXhwcmVzc2lvbjxUPjtcblxuICAvKipcbiAgICogYGwgLyByYFxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBkaXY8VCBleHRlbmRzIE51bWVyaWNWYWx1ZT4oXG4gICAgbDogRXhwcmVzc2lvbk9yVmFsdWU8VD4sXG4gICAgcjogRXhwcmVzc2lvbk9yVmFsdWU8VD4sXG4gICk6IEV4cHJlc3Npb248VD47XG5cbiAgLyoqXG4gICAqIGBsICUgcmBcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgbW9kPFQgZXh0ZW5kcyBOdW1lcmljVmFsdWU+KFxuICAgIGw6IEV4cHJlc3Npb25PclZhbHVlPFQ+LFxuICAgIHI6IEV4cHJlc3Npb25PclZhbHVlPFQ+LFxuICApOiBFeHByZXNzaW9uPFQ+O1xuXG4gIC8qKlxuICAgKiBgLXhgXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIG5lZzxUIGV4dGVuZHMgTnVtZXJpY1ZhbHVlPih4OiBFeHByZXNzaW9uT3JWYWx1ZTxUPik6IEV4cHJlc3Npb248VD47XG5cbiAgLy8gIExvZ2ljICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgLyoqXG4gICAqIGBleHByc1swXSAmJiBleHByc1sxXSAmJiAuLi4gJiYgZXhwcnNbbl1gXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFuZCguLi5leHByczogQXJyYXk8RXhwcmVzc2lvbk9yVmFsdWU8Ym9vbGVhbj4+KTogRXhwcmVzc2lvbjxib29sZWFuPjtcblxuICAvKipcbiAgICogYGV4cHJzWzBdIHx8IGV4cHJzWzFdIHx8IC4uLiB8fCBleHByc1tuXWBcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgb3IoLi4uZXhwcnM6IEFycmF5PEV4cHJlc3Npb25PclZhbHVlPGJvb2xlYW4+Pik6IEV4cHJlc3Npb248Ym9vbGVhbj47XG5cbiAgLyoqXG4gICAqIGAheGBcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgbm90KHg6IEV4cHJlc3Npb25PclZhbHVlPGJvb2xlYW4+KTogRXhwcmVzc2lvbjxib29sZWFuPjtcblxuICAvLyAgT3RoZXIgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAvKipcbiAgICogRXZhbHVhdGVzIHRvIHRoZSBmaWVsZCBhdCB0aGUgZ2l2ZW4gYGZpZWxkUGF0aGAuXG4gICAqXG4gICAqIEZvciBleGFtcGxlLCBpbiB7QGxpbmsgT3JkZXJlZFF1ZXJ5LmZpbHRlcn0gdGhpcyBjYW4gYmUgdXNlZCB0byBleGFtaW5lIHRoZSB2YWx1ZXMgYmVpbmcgZmlsdGVyZWQuXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZVxuICAgKlxuICAgKiBPbiB0aGlzIG9iamVjdDpcbiAgICogYGBgXG4gICAqIHtcbiAgICogICBcInVzZXJcIjoge1xuICAgKiAgICAgXCJpc0FjdGl2ZVwiOiB0cnVlXG4gICAqICAgfVxuICAgKiB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBgZmllbGQoXCJ1c2VyLmlzQWN0aXZlXCIpYCBldmFsdWF0ZXMgdG8gYHRydWVgLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBmaWVsZDxGaWVsZFBhdGggZXh0ZW5kcyBGaWVsZFBhdGhzPFRhYmxlSW5mbz4+KFxuICAgIGZpZWxkUGF0aDogRmllbGRQYXRoLFxuICApOiBFeHByZXNzaW9uPEZpZWxkVHlwZUZyb21GaWVsZFBhdGg8RG9jdW1lbnRCeUluZm88VGFibGVJbmZvPiwgRmllbGRQYXRoPj47XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG5pbXBvcnQgeyBjb252ZXhPclVuZGVmaW5lZFRvSnNvbiB9IGZyb20gXCIuLi8uLi92YWx1ZXMvdmFsdWUuanNcIjtcbmltcG9ydCB7XG4gIEluZGV4UmFuZ2Vcbn0gZnJvbSBcIi4uL2luZGV4X3JhbmdlX2J1aWxkZXIuanNcIjtcbmV4cG9ydCBjbGFzcyBJbmRleFJhbmdlQnVpbGRlckltcGwgZXh0ZW5kcyBJbmRleFJhbmdlIHtcbiAgY29uc3RydWN0b3IocmFuZ2VFeHByZXNzaW9ucykge1xuICAgIHN1cGVyKCk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJhbmdlRXhwcmVzc2lvbnNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImlzQ29uc3VtZWRcIik7XG4gICAgdGhpcy5yYW5nZUV4cHJlc3Npb25zID0gcmFuZ2VFeHByZXNzaW9ucztcbiAgICB0aGlzLmlzQ29uc3VtZWQgPSBmYWxzZTtcbiAgfVxuICBzdGF0aWMgbmV3KCkge1xuICAgIHJldHVybiBuZXcgSW5kZXhSYW5nZUJ1aWxkZXJJbXBsKFtdKTtcbiAgfVxuICBjb25zdW1lKCkge1xuICAgIGlmICh0aGlzLmlzQ29uc3VtZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJJbmRleFJhbmdlQnVpbGRlciBoYXMgYWxyZWFkeSBiZWVuIHVzZWQhIENoYWluIHlvdXIgbWV0aG9kIGNhbGxzIGxpa2UgYHEgPT4gcS5lcSguLi4pLmVxKC4uLilgLiBTZWUgaHR0cHM6Ly9kb2NzLmNvbnZleC5kZXYvdXNpbmcvaW5kZXhlc1wiXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmlzQ29uc3VtZWQgPSB0cnVlO1xuICB9XG4gIGVxKGZpZWxkTmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICByZXR1cm4gbmV3IEluZGV4UmFuZ2VCdWlsZGVySW1wbChcbiAgICAgIHRoaXMucmFuZ2VFeHByZXNzaW9ucy5jb25jYXQoe1xuICAgICAgICB0eXBlOiBcIkVxXCIsXG4gICAgICAgIGZpZWxkUGF0aDogZmllbGROYW1lLFxuICAgICAgICB2YWx1ZTogY29udmV4T3JVbmRlZmluZWRUb0pzb24odmFsdWUpXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgZ3QoZmllbGROYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMuY29uc3VtZSgpO1xuICAgIHJldHVybiBuZXcgSW5kZXhSYW5nZUJ1aWxkZXJJbXBsKFxuICAgICAgdGhpcy5yYW5nZUV4cHJlc3Npb25zLmNvbmNhdCh7XG4gICAgICAgIHR5cGU6IFwiR3RcIixcbiAgICAgICAgZmllbGRQYXRoOiBmaWVsZE5hbWUsXG4gICAgICAgIHZhbHVlOiBjb252ZXhPclVuZGVmaW5lZFRvSnNvbih2YWx1ZSlcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBndGUoZmllbGROYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMuY29uc3VtZSgpO1xuICAgIHJldHVybiBuZXcgSW5kZXhSYW5nZUJ1aWxkZXJJbXBsKFxuICAgICAgdGhpcy5yYW5nZUV4cHJlc3Npb25zLmNvbmNhdCh7XG4gICAgICAgIHR5cGU6IFwiR3RlXCIsXG4gICAgICAgIGZpZWxkUGF0aDogZmllbGROYW1lLFxuICAgICAgICB2YWx1ZTogY29udmV4T3JVbmRlZmluZWRUb0pzb24odmFsdWUpXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgbHQoZmllbGROYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMuY29uc3VtZSgpO1xuICAgIHJldHVybiBuZXcgSW5kZXhSYW5nZUJ1aWxkZXJJbXBsKFxuICAgICAgdGhpcy5yYW5nZUV4cHJlc3Npb25zLmNvbmNhdCh7XG4gICAgICAgIHR5cGU6IFwiTHRcIixcbiAgICAgICAgZmllbGRQYXRoOiBmaWVsZE5hbWUsXG4gICAgICAgIHZhbHVlOiBjb252ZXhPclVuZGVmaW5lZFRvSnNvbih2YWx1ZSlcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBsdGUoZmllbGROYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMuY29uc3VtZSgpO1xuICAgIHJldHVybiBuZXcgSW5kZXhSYW5nZUJ1aWxkZXJJbXBsKFxuICAgICAgdGhpcy5yYW5nZUV4cHJlc3Npb25zLmNvbmNhdCh7XG4gICAgICAgIHR5cGU6IFwiTHRlXCIsXG4gICAgICAgIGZpZWxkUGF0aDogZmllbGROYW1lLFxuICAgICAgICB2YWx1ZTogY29udmV4T3JVbmRlZmluZWRUb0pzb24odmFsdWUpXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgZXhwb3J0KCkge1xuICAgIHRoaXMuY29uc3VtZSgpO1xuICAgIHJldHVybiB0aGlzLnJhbmdlRXhwcmVzc2lvbnM7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4X3JhbmdlX2J1aWxkZXJfaW1wbC5qcy5tYXBcbiIsImltcG9ydCB7IEpTT05WYWx1ZSwgVmFsdWUgfSBmcm9tIFwiLi4vLi4vdmFsdWVzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBjb252ZXhPclVuZGVmaW5lZFRvSnNvbiB9IGZyb20gXCIuLi8uLi92YWx1ZXMvdmFsdWUuanNcIjtcbmltcG9ydCB7IEdlbmVyaWNEb2N1bWVudCwgR2VuZXJpY0luZGV4RmllbGRzIH0gZnJvbSBcIi4uL2RhdGFfbW9kZWwuanNcIjtcbmltcG9ydCB7XG4gIEluZGV4UmFuZ2UsXG4gIEluZGV4UmFuZ2VCdWlsZGVyLFxuICBMb3dlckJvdW5kSW5kZXhSYW5nZUJ1aWxkZXIsXG4gIFVwcGVyQm91bmRJbmRleFJhbmdlQnVpbGRlcixcbn0gZnJvbSBcIi4uL2luZGV4X3JhbmdlX2J1aWxkZXIuanNcIjtcblxuZXhwb3J0IHR5cGUgU2VyaWFsaXplZFJhbmdlRXhwcmVzc2lvbiA9IHtcbiAgdHlwZTogXCJFcVwiIHwgXCJHdFwiIHwgXCJHdGVcIiB8IFwiTHRcIiB8IFwiTHRlXCI7XG4gIGZpZWxkUGF0aDogc3RyaW5nO1xuICB2YWx1ZTogSlNPTlZhbHVlO1xufTtcblxuZXhwb3J0IGNsYXNzIEluZGV4UmFuZ2VCdWlsZGVySW1wbFxuICBleHRlbmRzIEluZGV4UmFuZ2VcbiAgaW1wbGVtZW50c1xuICAgIEluZGV4UmFuZ2VCdWlsZGVyPEdlbmVyaWNEb2N1bWVudCwgR2VuZXJpY0luZGV4RmllbGRzPixcbiAgICBMb3dlckJvdW5kSW5kZXhSYW5nZUJ1aWxkZXI8R2VuZXJpY0RvY3VtZW50LCBzdHJpbmc+LFxuICAgIFVwcGVyQm91bmRJbmRleFJhbmdlQnVpbGRlcjxHZW5lcmljRG9jdW1lbnQsIHN0cmluZz5cbntcbiAgcHJpdmF0ZSByYW5nZUV4cHJlc3Npb25zOiBSZWFkb25seUFycmF5PFNlcmlhbGl6ZWRSYW5nZUV4cHJlc3Npb24+O1xuICBwcml2YXRlIGlzQ29uc3VtZWQ6IGJvb2xlYW47XG4gIHByaXZhdGUgY29uc3RydWN0b3IoXG4gICAgcmFuZ2VFeHByZXNzaW9uczogUmVhZG9ubHlBcnJheTxTZXJpYWxpemVkUmFuZ2VFeHByZXNzaW9uPixcbiAgKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnJhbmdlRXhwcmVzc2lvbnMgPSByYW5nZUV4cHJlc3Npb25zO1xuICAgIHRoaXMuaXNDb25zdW1lZCA9IGZhbHNlO1xuICB9XG5cbiAgc3RhdGljIG5ldygpOiBJbmRleFJhbmdlQnVpbGRlckltcGwge1xuICAgIHJldHVybiBuZXcgSW5kZXhSYW5nZUJ1aWxkZXJJbXBsKFtdKTtcbiAgfVxuXG4gIHByaXZhdGUgY29uc3VtZSgpIHtcbiAgICBpZiAodGhpcy5pc0NvbnN1bWVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiSW5kZXhSYW5nZUJ1aWxkZXIgaGFzIGFscmVhZHkgYmVlbiB1c2VkISBDaGFpbiB5b3VyIG1ldGhvZCBjYWxscyBsaWtlIGBxID0+IHEuZXEoLi4uKS5lcSguLi4pYC4gU2VlIGh0dHBzOi8vZG9jcy5jb252ZXguZGV2L3VzaW5nL2luZGV4ZXNcIixcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuaXNDb25zdW1lZCA9IHRydWU7XG4gIH1cblxuICBlcShmaWVsZE5hbWU6IHN0cmluZywgdmFsdWU6IFZhbHVlKSB7XG4gICAgdGhpcy5jb25zdW1lKCk7XG4gICAgcmV0dXJuIG5ldyBJbmRleFJhbmdlQnVpbGRlckltcGwoXG4gICAgICB0aGlzLnJhbmdlRXhwcmVzc2lvbnMuY29uY2F0KHtcbiAgICAgICAgdHlwZTogXCJFcVwiLFxuICAgICAgICBmaWVsZFBhdGg6IGZpZWxkTmFtZSxcbiAgICAgICAgdmFsdWU6IGNvbnZleE9yVW5kZWZpbmVkVG9Kc29uKHZhbHVlKSxcbiAgICAgIH0pLFxuICAgICk7XG4gIH1cblxuICBndChmaWVsZE5hbWU6IHN0cmluZywgdmFsdWU6IFZhbHVlKSB7XG4gICAgdGhpcy5jb25zdW1lKCk7XG4gICAgcmV0dXJuIG5ldyBJbmRleFJhbmdlQnVpbGRlckltcGwoXG4gICAgICB0aGlzLnJhbmdlRXhwcmVzc2lvbnMuY29uY2F0KHtcbiAgICAgICAgdHlwZTogXCJHdFwiLFxuICAgICAgICBmaWVsZFBhdGg6IGZpZWxkTmFtZSxcbiAgICAgICAgdmFsdWU6IGNvbnZleE9yVW5kZWZpbmVkVG9Kc29uKHZhbHVlKSxcbiAgICAgIH0pLFxuICAgICk7XG4gIH1cbiAgZ3RlKGZpZWxkTmFtZTogc3RyaW5nLCB2YWx1ZTogVmFsdWUpIHtcbiAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICByZXR1cm4gbmV3IEluZGV4UmFuZ2VCdWlsZGVySW1wbChcbiAgICAgIHRoaXMucmFuZ2VFeHByZXNzaW9ucy5jb25jYXQoe1xuICAgICAgICB0eXBlOiBcIkd0ZVwiLFxuICAgICAgICBmaWVsZFBhdGg6IGZpZWxkTmFtZSxcbiAgICAgICAgdmFsdWU6IGNvbnZleE9yVW5kZWZpbmVkVG9Kc29uKHZhbHVlKSxcbiAgICAgIH0pLFxuICAgICk7XG4gIH1cbiAgbHQoZmllbGROYW1lOiBzdHJpbmcsIHZhbHVlOiBWYWx1ZSkge1xuICAgIHRoaXMuY29uc3VtZSgpO1xuICAgIHJldHVybiBuZXcgSW5kZXhSYW5nZUJ1aWxkZXJJbXBsKFxuICAgICAgdGhpcy5yYW5nZUV4cHJlc3Npb25zLmNvbmNhdCh7XG4gICAgICAgIHR5cGU6IFwiTHRcIixcbiAgICAgICAgZmllbGRQYXRoOiBmaWVsZE5hbWUsXG4gICAgICAgIHZhbHVlOiBjb252ZXhPclVuZGVmaW5lZFRvSnNvbih2YWx1ZSksXG4gICAgICB9KSxcbiAgICApO1xuICB9XG4gIGx0ZShmaWVsZE5hbWU6IHN0cmluZywgdmFsdWU6IFZhbHVlKSB7XG4gICAgdGhpcy5jb25zdW1lKCk7XG4gICAgcmV0dXJuIG5ldyBJbmRleFJhbmdlQnVpbGRlckltcGwoXG4gICAgICB0aGlzLnJhbmdlRXhwcmVzc2lvbnMuY29uY2F0KHtcbiAgICAgICAgdHlwZTogXCJMdGVcIixcbiAgICAgICAgZmllbGRQYXRoOiBmaWVsZE5hbWUsXG4gICAgICAgIHZhbHVlOiBjb252ZXhPclVuZGVmaW5lZFRvSnNvbih2YWx1ZSksXG4gICAgICB9KSxcbiAgICApO1xuICB9XG5cbiAgZXhwb3J0KCkge1xuICAgIHRoaXMuY29uc3VtZSgpO1xuICAgIHJldHVybiB0aGlzLnJhbmdlRXhwcmVzc2lvbnM7XG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4gX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbmV4cG9ydCBjbGFzcyBJbmRleFJhbmdlIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLy8gUHJvcGVydHkgZm9yIG5vbWluYWwgdHlwZSBzdXBwb3J0LlxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfaXNJbmRleFJhbmdlXCIpO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleF9yYW5nZV9idWlsZGVyLmpzLm1hcFxuIiwiaW1wb3J0IHtcbiAgR2VuZXJpY0luZGV4RmllbGRzLFxuICBHZW5lcmljRG9jdW1lbnQsXG4gIEZpZWxkVHlwZUZyb21GaWVsZFBhdGgsXG59IGZyb20gXCIuL2RhdGFfbW9kZWwuanNcIjtcblxuLyoqXG4gKiBBIHR5cGUgdGhhdCBhZGRzIDEgdG8gYSBudW1iZXIgbGl0ZXJhbCB0eXBlICh1cCB0byAxNCkuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgdG8gc3RlcCB0aHJvdWdoIHRoZSBmaWVsZHMgaW4gYW4gaW5kZXguXG4gKi9cbnR5cGUgUGx1c09uZTxOIGV4dGVuZHMgbnVtYmVyPiA9IFtcbiAgMSxcbiAgMixcbiAgMyxcbiAgNCxcbiAgNSxcbiAgNixcbiAgNyxcbiAgOCxcbiAgOSxcbiAgMTAsXG4gIDExLFxuICAxMixcbiAgMTMsXG4gIDE0LFxuICAxNSxcbl1bTl07XG5cbi8qKlxuICogQnVpbGRlciB0byBkZWZpbmUgYW4gaW5kZXggcmFuZ2UgdG8gcXVlcnkuXG4gKlxuICogQW4gaW5kZXggcmFuZ2UgaXMgYSBkZXNjcmlwdGlvbiBvZiB3aGljaCBkb2N1bWVudHMgQ29udmV4IHNob3VsZCBjb25zaWRlclxuICogd2hlbiBydW5uaW5nIHRoZSBxdWVyeS5cbiAqXG4gKiBBbiBpbmRleCByYW5nZSBpcyBhbHdheXMgYSBjaGFpbmVkIGxpc3Qgb2Y6XG4gKiAxLiAwIG9yIG1vcmUgZXF1YWxpdHkgZXhwcmVzc2lvbnMgZGVmaW5lZCB3aXRoIGAuZXFgLlxuICogMi4gW09wdGlvbmFsbHldIEEgbG93ZXIgYm91bmQgZXhwcmVzc2lvbiBkZWZpbmVkIHdpdGggYC5ndGAgb3IgYC5ndGVgLlxuICogMy4gW09wdGlvbmFsbHldIEFuIHVwcGVyIGJvdW5kIGV4cHJlc3Npb24gZGVmaW5lZCB3aXRoIGAubHRgIG9yIGAubHRlYC5cbiAqXG4gKiAqKllvdSBtdXN0IHN0ZXAgdGhyb3VnaCBmaWVsZHMgaW4gaW5kZXggb3JkZXIuKipcbiAqXG4gKiBFYWNoIGVxdWFsaXR5IGV4cHJlc3Npb24gbXVzdCBjb21wYXJlIGEgZGlmZmVyZW50IGluZGV4IGZpZWxkLCBzdGFydGluZyBmcm9tXG4gKiB0aGUgYmVnaW5uaW5nIGFuZCBpbiBvcmRlci4gVGhlIHVwcGVyIGFuZCBsb3dlciBib3VuZHMgbXVzdCBmb2xsb3cgdGhlXG4gKiBlcXVhbGl0eSBleHByZXNzaW9ucyBhbmQgY29tcGFyZSB0aGUgbmV4dCBmaWVsZC5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgaWYgdGhlcmUgaXMgYW4gaW5kZXggb2YgbWVzc2FnZXMgb25cbiAqIGBbXCJwcm9qZWN0SWRcIiwgXCJwcmlvcml0eVwiXWAsIGEgcmFuZ2Ugc2VhcmNoaW5nIGZvciBcIm1lc3NhZ2VzIGluICdteVByb2plY3RJZCdcbiAqIHdpdGggcHJpb3JpdHkgYXQgbGVhc3QgMTAwXCIgd291bGQgbG9vayBsaWtlOlxuICogYGBgdHNcbiAqIHEuZXEoXCJwcm9qZWN0SWRcIiwgbXlQcm9qZWN0SWQpXG4gKiAgLmd0ZShcInByaW9yaXR5XCIsIDEwMClcbiAqIGBgYFxuICpcbiAqICoqVGhlIHBlcmZvcm1hbmNlIG9mIHlvdXIgcXVlcnkgaXMgYmFzZWQgb24gdGhlIHNwZWNpZmljaXR5IG9mIHRoZSByYW5nZS4qKlxuICpcbiAqIFRoaXMgY2xhc3MgaXMgZGVzaWduZWQgdG8gb25seSBhbGxvdyB5b3UgdG8gc3BlY2lmeSByYW5nZXMgdGhhdCBDb252ZXggY2FuXG4gKiBlZmZpY2llbnRseSB1c2UgeW91ciBpbmRleCB0byBmaW5kLiBGb3IgYWxsIG90aGVyIGZpbHRlcmluZyB1c2VcbiAqIHtAbGluayBPcmRlcmVkUXVlcnkuZmlsdGVyfS5cbiAqXG4gKiBUbyBsZWFybiBhYm91dCBpbmRleGVzLCBzZWUgW0luZGV4ZXNdKGh0dHBzOi8vZG9jcy5jb252ZXguZGV2L3VzaW5nL2luZGV4ZXMpLlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEluZGV4UmFuZ2VCdWlsZGVyPFxuICBEb2N1bWVudCBleHRlbmRzIEdlbmVyaWNEb2N1bWVudCxcbiAgSW5kZXhGaWVsZHMgZXh0ZW5kcyBHZW5lcmljSW5kZXhGaWVsZHMsXG4gIEZpZWxkTnVtIGV4dGVuZHMgbnVtYmVyID0gMCxcbj4gZXh0ZW5kcyBMb3dlckJvdW5kSW5kZXhSYW5nZUJ1aWxkZXI8RG9jdW1lbnQsIEluZGV4RmllbGRzW0ZpZWxkTnVtXT4ge1xuICAvKipcbiAgICogUmVzdHJpY3QgdGhpcyByYW5nZSB0byBkb2N1bWVudHMgd2hlcmUgYGRvY1tmaWVsZE5hbWVdID09PSB2YWx1ZWAuXG4gICAqXG4gICAqIEBwYXJhbSBmaWVsZE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gY29tcGFyZS4gTXVzdCBiZSB0aGUgbmV4dCBmaWVsZFxuICAgKiBpbiB0aGUgaW5kZXguXG4gICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjb21wYXJlIGFnYWluc3QuXG4gICAqL1xuICBlcShcbiAgICBmaWVsZE5hbWU6IEluZGV4RmllbGRzW0ZpZWxkTnVtXSxcbiAgICB2YWx1ZTogRmllbGRUeXBlRnJvbUZpZWxkUGF0aDxEb2N1bWVudCwgSW5kZXhGaWVsZHNbRmllbGROdW1dPixcbiAgKTogTmV4dEluZGV4UmFuZ2VCdWlsZGVyPERvY3VtZW50LCBJbmRleEZpZWxkcywgRmllbGROdW0+O1xufVxuXG4vKipcbiAqIEFuIHtAbGluayBJbmRleFJhbmdlQnVpbGRlcn0gZm9yIHRoZSBuZXh0IGZpZWxkIG9mIHRoZSBpbmRleC5cbiAqXG4gKiBUaGlzIHR5cGUgaXMgY2FyZWZ1bCB0byBjaGVjayBpZiBhZGRpbmcgb25lIHRvIHRoZSBgRmllbGROdW1gIHdpbGwgZXhjZWVkXG4gKiB0aGUgbGVuZ3RoIG9mIHRoZSBgSW5kZXhGaWVsZHNgLlxuICovXG50eXBlIE5leHRJbmRleFJhbmdlQnVpbGRlcjxcbiAgRG9jdW1lbnQgZXh0ZW5kcyBHZW5lcmljRG9jdW1lbnQsXG4gIEluZGV4RmllbGRzIGV4dGVuZHMgR2VuZXJpY0luZGV4RmllbGRzLFxuICBGaWVsZE51bSBleHRlbmRzIG51bWJlcixcbj4gPVxuICBQbHVzT25lPEZpZWxkTnVtPiBleHRlbmRzIEluZGV4RmllbGRzW1wibGVuZ3RoXCJdXG4gICAgPyBJbmRleFJhbmdlXG4gICAgOiBJbmRleFJhbmdlQnVpbGRlcjxEb2N1bWVudCwgSW5kZXhGaWVsZHMsIFBsdXNPbmU8RmllbGROdW0+PjtcblxuLyoqXG4gKiBCdWlsZGVyIHRvIGRlZmluZSB0aGUgbG93ZXIgYm91bmQgb2YgYW4gaW5kZXggcmFuZ2UuXG4gKlxuICogU2VlIHtAbGluayBJbmRleFJhbmdlQnVpbGRlcn0uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIExvd2VyQm91bmRJbmRleFJhbmdlQnVpbGRlcjxcbiAgRG9jdW1lbnQgZXh0ZW5kcyBHZW5lcmljRG9jdW1lbnQsXG4gIEluZGV4RmllbGROYW1lIGV4dGVuZHMgc3RyaW5nLFxuPiBleHRlbmRzIFVwcGVyQm91bmRJbmRleFJhbmdlQnVpbGRlcjxEb2N1bWVudCwgSW5kZXhGaWVsZE5hbWU+IHtcbiAgLyoqXG4gICAqIFJlc3RyaWN0IHRoaXMgcmFuZ2UgdG8gZG9jdW1lbnRzIHdoZXJlIGBkb2NbZmllbGROYW1lXSA+IHZhbHVlYC5cbiAgICpcbiAgICogQHBhcmFtIGZpZWxkTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBjb21wYXJlLiBNdXN0IGJlIHRoZSBuZXh0IGZpZWxkXG4gICAqIGluIHRoZSBpbmRleC5cbiAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNvbXBhcmUgYWdhaW5zdC5cbiAgICovXG4gIGd0KFxuICAgIGZpZWxkTmFtZTogSW5kZXhGaWVsZE5hbWUsXG4gICAgdmFsdWU6IEZpZWxkVHlwZUZyb21GaWVsZFBhdGg8RG9jdW1lbnQsIEluZGV4RmllbGROYW1lPixcbiAgKTogVXBwZXJCb3VuZEluZGV4UmFuZ2VCdWlsZGVyPERvY3VtZW50LCBJbmRleEZpZWxkTmFtZT47XG4gIC8qKlxuICAgKiBSZXN0cmljdCB0aGlzIHJhbmdlIHRvIGRvY3VtZW50cyB3aGVyZSBgZG9jW2ZpZWxkTmFtZV0gPj0gdmFsdWVgLlxuICAgKlxuICAgKiBAcGFyYW0gZmllbGROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGNvbXBhcmUuIE11c3QgYmUgdGhlIG5leHQgZmllbGRcbiAgICogaW4gdGhlIGluZGV4LlxuICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY29tcGFyZSBhZ2FpbnN0LlxuICAgKi9cbiAgZ3RlKFxuICAgIGZpZWxkTmFtZTogSW5kZXhGaWVsZE5hbWUsXG4gICAgdmFsdWU6IEZpZWxkVHlwZUZyb21GaWVsZFBhdGg8RG9jdW1lbnQsIEluZGV4RmllbGROYW1lPixcbiAgKTogVXBwZXJCb3VuZEluZGV4UmFuZ2VCdWlsZGVyPERvY3VtZW50LCBJbmRleEZpZWxkTmFtZT47XG59XG5cbi8qKlxuICogQnVpbGRlciB0byBkZWZpbmUgdGhlIHVwcGVyIGJvdW5kIG9mIGFuIGluZGV4IHJhbmdlLlxuICpcbiAqIFNlZSB7QGxpbmsgSW5kZXhSYW5nZUJ1aWxkZXJ9LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVcHBlckJvdW5kSW5kZXhSYW5nZUJ1aWxkZXI8XG4gIERvY3VtZW50IGV4dGVuZHMgR2VuZXJpY0RvY3VtZW50LFxuICBJbmRleEZpZWxkTmFtZSBleHRlbmRzIHN0cmluZyxcbj4gZXh0ZW5kcyBJbmRleFJhbmdlIHtcbiAgLyoqXG4gICAqIFJlc3RyaWN0IHRoaXMgcmFuZ2UgdG8gZG9jdW1lbnRzIHdoZXJlIGBkb2NbZmllbGROYW1lXSA8IHZhbHVlYC5cbiAgICpcbiAgICogQHBhcmFtIGZpZWxkTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBjb21wYXJlLiBNdXN0IGJlIHRoZSBzYW1lIGluZGV4XG4gICAqIGZpZWxkIHVzZWQgaW4gdGhlIGxvd2VyIGJvdW5kIChgLmd0YCBvciBgLmd0ZWApIG9yIHRoZSBuZXh0IGZpZWxkIGlmIG5vXG4gICAqIGxvd2VyIGJvdW5kIHdhcyBzcGVjaWZpZWQuXG4gICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjb21wYXJlIGFnYWluc3QuXG4gICAqL1xuICBsdChcbiAgICBmaWVsZE5hbWU6IEluZGV4RmllbGROYW1lLFxuICAgIHZhbHVlOiBGaWVsZFR5cGVGcm9tRmllbGRQYXRoPERvY3VtZW50LCBJbmRleEZpZWxkTmFtZT4sXG4gICk6IEluZGV4UmFuZ2U7XG5cbiAgLyoqXG4gICAqIFJlc3RyaWN0IHRoaXMgcmFuZ2UgdG8gZG9jdW1lbnRzIHdoZXJlIGBkb2NbZmllbGROYW1lXSA8PSB2YWx1ZWAuXG4gICAqXG4gICAqIEBwYXJhbSBmaWVsZE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gY29tcGFyZS4gTXVzdCBiZSB0aGUgc2FtZSBpbmRleFxuICAgKiBmaWVsZCB1c2VkIGluIHRoZSBsb3dlciBib3VuZCAoYC5ndGAgb3IgYC5ndGVgKSBvciB0aGUgbmV4dCBmaWVsZCBpZiBub1xuICAgKiBsb3dlciBib3VuZCB3YXMgc3BlY2lmaWVkLlxuICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY29tcGFyZSBhZ2FpbnN0LlxuICAgKi9cbiAgbHRlKFxuICAgIGZpZWxkTmFtZTogSW5kZXhGaWVsZE5hbWUsXG4gICAgdmFsdWU6IEZpZWxkVHlwZUZyb21GaWVsZFBhdGg8RG9jdW1lbnQsIEluZGV4RmllbGROYW1lPixcbiAgKTogSW5kZXhSYW5nZTtcbn1cblxuLyoqXG4gKiBBbiBleHByZXNzaW9uIHJlcHJlc2VudGluZyBhbiBpbmRleCByYW5nZSBjcmVhdGVkIGJ5XG4gKiB7QGxpbmsgSW5kZXhSYW5nZUJ1aWxkZXJ9LlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgSW5kZXhSYW5nZSB7XG4gIC8vIFByb3BlcnR5IGZvciBub21pbmFsIHR5cGUgc3VwcG9ydC5cbiAgcHJpdmF0ZSBfaXNJbmRleFJhbmdlOiB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLy8gb25seSBkZWZpbmluZyB0aGUgY29uc3RydWN0b3Igc28gd2UgY2FuIG1hcmsgaXQgYXMgaW50ZXJuYWwgYW5kIGtlZXBcbiAgICAvLyBpdCBvdXQgb2YgdGhlIGRvY3MuXG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4gX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbmltcG9ydCB7IGNvbnZleE9yVW5kZWZpbmVkVG9Kc29uIH0gZnJvbSBcIi4uLy4uL3ZhbHVlcy92YWx1ZS5qc1wiO1xuaW1wb3J0IHtcbiAgU2VhcmNoRmlsdGVyXG59IGZyb20gXCIuLi9zZWFyY2hfZmlsdGVyX2J1aWxkZXIuanNcIjtcbmltcG9ydCB7IHZhbGlkYXRlQXJnIH0gZnJvbSBcIi4vdmFsaWRhdGUuanNcIjtcbmV4cG9ydCBjbGFzcyBTZWFyY2hGaWx0ZXJCdWlsZGVySW1wbCBleHRlbmRzIFNlYXJjaEZpbHRlciB7XG4gIGNvbnN0cnVjdG9yKGZpbHRlcnMpIHtcbiAgICBzdXBlcigpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJmaWx0ZXJzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJpc0NvbnN1bWVkXCIpO1xuICAgIHRoaXMuZmlsdGVycyA9IGZpbHRlcnM7XG4gICAgdGhpcy5pc0NvbnN1bWVkID0gZmFsc2U7XG4gIH1cbiAgc3RhdGljIG5ldygpIHtcbiAgICByZXR1cm4gbmV3IFNlYXJjaEZpbHRlckJ1aWxkZXJJbXBsKFtdKTtcbiAgfVxuICBjb25zdW1lKCkge1xuICAgIGlmICh0aGlzLmlzQ29uc3VtZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJTZWFyY2hGaWx0ZXJCdWlsZGVyIGhhcyBhbHJlYWR5IGJlZW4gdXNlZCEgQ2hhaW4geW91ciBtZXRob2QgY2FsbHMgbGlrZSBgcSA9PiBxLnNlYXJjaCguLi4pLmVxKC4uLilgLlwiXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmlzQ29uc3VtZWQgPSB0cnVlO1xuICB9XG4gIHNlYXJjaChmaWVsZE5hbWUsIHF1ZXJ5KSB7XG4gICAgdmFsaWRhdGVBcmcoZmllbGROYW1lLCAxLCBcInNlYXJjaFwiLCBcImZpZWxkTmFtZVwiKTtcbiAgICB2YWxpZGF0ZUFyZyhxdWVyeSwgMiwgXCJzZWFyY2hcIiwgXCJxdWVyeVwiKTtcbiAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICByZXR1cm4gbmV3IFNlYXJjaEZpbHRlckJ1aWxkZXJJbXBsKFxuICAgICAgdGhpcy5maWx0ZXJzLmNvbmNhdCh7XG4gICAgICAgIHR5cGU6IFwiU2VhcmNoXCIsXG4gICAgICAgIGZpZWxkUGF0aDogZmllbGROYW1lLFxuICAgICAgICB2YWx1ZTogcXVlcnlcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBlcShmaWVsZE5hbWUsIHZhbHVlKSB7XG4gICAgdmFsaWRhdGVBcmcoZmllbGROYW1lLCAxLCBcImVxXCIsIFwiZmllbGROYW1lXCIpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICB2YWxpZGF0ZUFyZyh2YWx1ZSwgMiwgXCJzZWFyY2hcIiwgXCJ2YWx1ZVwiKTtcbiAgICB9XG4gICAgdGhpcy5jb25zdW1lKCk7XG4gICAgcmV0dXJuIG5ldyBTZWFyY2hGaWx0ZXJCdWlsZGVySW1wbChcbiAgICAgIHRoaXMuZmlsdGVycy5jb25jYXQoe1xuICAgICAgICB0eXBlOiBcIkVxXCIsXG4gICAgICAgIGZpZWxkUGF0aDogZmllbGROYW1lLFxuICAgICAgICB2YWx1ZTogY29udmV4T3JVbmRlZmluZWRUb0pzb24odmFsdWUpXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgZXhwb3J0KCkge1xuICAgIHRoaXMuY29uc3VtZSgpO1xuICAgIHJldHVybiB0aGlzLmZpbHRlcnM7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlYXJjaF9maWx0ZXJfYnVpbGRlcl9pbXBsLmpzLm1hcFxuIiwiaW1wb3J0IHsgSlNPTlZhbHVlLCBjb252ZXhPclVuZGVmaW5lZFRvSnNvbiB9IGZyb20gXCIuLi8uLi92YWx1ZXMvdmFsdWUuanNcIjtcbmltcG9ydCB7XG4gIEZpZWxkVHlwZUZyb21GaWVsZFBhdGgsXG4gIEdlbmVyaWNEb2N1bWVudCxcbiAgR2VuZXJpY1NlYXJjaEluZGV4Q29uZmlnLFxufSBmcm9tIFwiLi4vZGF0YV9tb2RlbC5qc1wiO1xuaW1wb3J0IHtcbiAgU2VhcmNoRmlsdGVyLFxuICBTZWFyY2hGaWx0ZXJCdWlsZGVyLFxuICBTZWFyY2hGaWx0ZXJGaW5hbGl6ZXIsXG59IGZyb20gXCIuLi9zZWFyY2hfZmlsdGVyX2J1aWxkZXIuanNcIjtcbmltcG9ydCB7IHZhbGlkYXRlQXJnIH0gZnJvbSBcIi4vdmFsaWRhdGUuanNcIjtcblxuZXhwb3J0IHR5cGUgU2VyaWFsaXplZFNlYXJjaEZpbHRlciA9XG4gIHwge1xuICAgICAgdHlwZTogXCJTZWFyY2hcIjtcbiAgICAgIGZpZWxkUGF0aDogc3RyaW5nO1xuICAgICAgdmFsdWU6IHN0cmluZztcbiAgICB9XG4gIHwge1xuICAgICAgdHlwZTogXCJFcVwiO1xuICAgICAgZmllbGRQYXRoOiBzdHJpbmc7XG4gICAgICB2YWx1ZTogSlNPTlZhbHVlO1xuICAgIH07XG5cbmV4cG9ydCBjbGFzcyBTZWFyY2hGaWx0ZXJCdWlsZGVySW1wbFxuICBleHRlbmRzIFNlYXJjaEZpbHRlclxuICBpbXBsZW1lbnRzXG4gICAgU2VhcmNoRmlsdGVyQnVpbGRlcjxHZW5lcmljRG9jdW1lbnQsIEdlbmVyaWNTZWFyY2hJbmRleENvbmZpZz4sXG4gICAgU2VhcmNoRmlsdGVyRmluYWxpemVyPEdlbmVyaWNEb2N1bWVudCwgR2VuZXJpY1NlYXJjaEluZGV4Q29uZmlnPlxue1xuICBwcml2YXRlIGZpbHRlcnM6IFJlYWRvbmx5QXJyYXk8U2VyaWFsaXplZFNlYXJjaEZpbHRlcj47XG4gIHByaXZhdGUgaXNDb25zdW1lZDogYm9vbGVhbjtcbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihmaWx0ZXJzOiBSZWFkb25seUFycmF5PFNlcmlhbGl6ZWRTZWFyY2hGaWx0ZXI+KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmZpbHRlcnMgPSBmaWx0ZXJzO1xuICAgIHRoaXMuaXNDb25zdW1lZCA9IGZhbHNlO1xuICB9XG5cbiAgc3RhdGljIG5ldygpOiBTZWFyY2hGaWx0ZXJCdWlsZGVySW1wbCB7XG4gICAgcmV0dXJuIG5ldyBTZWFyY2hGaWx0ZXJCdWlsZGVySW1wbChbXSk7XG4gIH1cblxuICBwcml2YXRlIGNvbnN1bWUoKSB7XG4gICAgaWYgKHRoaXMuaXNDb25zdW1lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIlNlYXJjaEZpbHRlckJ1aWxkZXIgaGFzIGFscmVhZHkgYmVlbiB1c2VkISBDaGFpbiB5b3VyIG1ldGhvZCBjYWxscyBsaWtlIGBxID0+IHEuc2VhcmNoKC4uLikuZXEoLi4uKWAuXCIsXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmlzQ29uc3VtZWQgPSB0cnVlO1xuICB9XG5cbiAgc2VhcmNoKFxuICAgIGZpZWxkTmFtZTogc3RyaW5nLFxuICAgIHF1ZXJ5OiBzdHJpbmcsXG4gICk6IFNlYXJjaEZpbHRlckZpbmFsaXplcjxHZW5lcmljRG9jdW1lbnQsIEdlbmVyaWNTZWFyY2hJbmRleENvbmZpZz4ge1xuICAgIHZhbGlkYXRlQXJnKGZpZWxkTmFtZSwgMSwgXCJzZWFyY2hcIiwgXCJmaWVsZE5hbWVcIik7XG4gICAgdmFsaWRhdGVBcmcocXVlcnksIDIsIFwic2VhcmNoXCIsIFwicXVlcnlcIik7XG4gICAgdGhpcy5jb25zdW1lKCk7XG4gICAgcmV0dXJuIG5ldyBTZWFyY2hGaWx0ZXJCdWlsZGVySW1wbChcbiAgICAgIHRoaXMuZmlsdGVycy5jb25jYXQoe1xuICAgICAgICB0eXBlOiBcIlNlYXJjaFwiLFxuICAgICAgICBmaWVsZFBhdGg6IGZpZWxkTmFtZSxcbiAgICAgICAgdmFsdWU6IHF1ZXJ5LFxuICAgICAgfSksXG4gICAgKTtcbiAgfVxuICBlcTxGaWVsZE5hbWUgZXh0ZW5kcyBzdHJpbmc+KFxuICAgIGZpZWxkTmFtZTogRmllbGROYW1lLFxuICAgIHZhbHVlOiBGaWVsZFR5cGVGcm9tRmllbGRQYXRoPEdlbmVyaWNEb2N1bWVudCwgRmllbGROYW1lPixcbiAgKTogU2VhcmNoRmlsdGVyRmluYWxpemVyPEdlbmVyaWNEb2N1bWVudCwgR2VuZXJpY1NlYXJjaEluZGV4Q29uZmlnPiB7XG4gICAgdmFsaWRhdGVBcmcoZmllbGROYW1lLCAxLCBcImVxXCIsIFwiZmllbGROYW1lXCIpO1xuICAgIC8vIHdoZW4gYHVuZGVmaW5lZGAgaXMgcGFzc2VkIGV4cGxpY2l0bHksIGl0IGlzIGFsbG93ZWQuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDIpIHtcbiAgICAgIHZhbGlkYXRlQXJnKHZhbHVlLCAyLCBcInNlYXJjaFwiLCBcInZhbHVlXCIpO1xuICAgIH1cbiAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICByZXR1cm4gbmV3IFNlYXJjaEZpbHRlckJ1aWxkZXJJbXBsKFxuICAgICAgdGhpcy5maWx0ZXJzLmNvbmNhdCh7XG4gICAgICAgIHR5cGU6IFwiRXFcIixcbiAgICAgICAgZmllbGRQYXRoOiBmaWVsZE5hbWUsXG4gICAgICAgIHZhbHVlOiBjb252ZXhPclVuZGVmaW5lZFRvSnNvbih2YWx1ZSksXG4gICAgICB9KSxcbiAgICApO1xuICB9XG5cbiAgZXhwb3J0KCkge1xuICAgIHRoaXMuY29uc3VtZSgpO1xuICAgIHJldHVybiB0aGlzLmZpbHRlcnM7XG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4gX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbmV4cG9ydCBjbGFzcyBTZWFyY2hGaWx0ZXIge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvLyBQcm9wZXJ0eSBmb3Igbm9taW5hbCB0eXBlIHN1cHBvcnQuXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9pc1NlYXJjaEZpbHRlclwiKTtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VhcmNoX2ZpbHRlcl9idWlsZGVyLmpzLm1hcFxuIiwiaW1wb3J0IHtcbiAgRmllbGRUeXBlRnJvbUZpZWxkUGF0aCxcbiAgR2VuZXJpY0RvY3VtZW50LFxuICBHZW5lcmljU2VhcmNoSW5kZXhDb25maWcsXG59IGZyb20gXCIuL2RhdGFfbW9kZWwuanNcIjtcblxuLyoqXG4gKiBCdWlsZGVyIGZvciBkZWZpbmluZyBzZWFyY2ggZmlsdGVycy5cbiAqXG4gKiBBIHNlYXJjaCBmaWx0ZXIgaXMgYSBjaGFpbmVkIGxpc3Qgb2Y6XG4gKiAxLiBPbmUgc2VhcmNoIGV4cHJlc3Npb24gY29uc3RydWN0ZWQgd2l0aCBgLnNlYXJjaGAuXG4gKiAyLiBaZXJvIG9yIG1vcmUgZXF1YWxpdHkgZXhwcmVzc2lvbnMgY29uc3RydWN0ZWQgd2l0aCBgLmVxYC5cbiAqXG4gKiBUaGUgc2VhcmNoIGV4cHJlc3Npb24gbXVzdCBzZWFyY2ggZm9yIHRleHQgaW4gdGhlIGluZGV4J3MgYHNlYXJjaEZpZWxkYC4gVGhlXG4gKiBmaWx0ZXIgZXhwcmVzc2lvbnMgY2FuIHVzZSBhbnkgb2YgdGhlIGBmaWx0ZXJGaWVsZHNgIGRlZmluZWQgaW4gdGhlIGluZGV4LlxuICpcbiAqIEZvciBhbGwgb3RoZXIgZmlsdGVyaW5nIHVzZSB7QGxpbmsgT3JkZXJlZFF1ZXJ5LmZpbHRlcn0uXG4gKlxuICogVG8gbGVhcm4gYWJvdXQgZnVsbCB0ZXh0IHNlYXJjaCwgc2VlIFtJbmRleGVzXShodHRwczovL2RvY3MuY29udmV4LmRldi90ZXh0LXNlYXJjaCkuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2VhcmNoRmlsdGVyQnVpbGRlcjxcbiAgRG9jdW1lbnQgZXh0ZW5kcyBHZW5lcmljRG9jdW1lbnQsXG4gIFNlYXJjaEluZGV4Q29uZmlnIGV4dGVuZHMgR2VuZXJpY1NlYXJjaEluZGV4Q29uZmlnLFxuPiB7XG4gIC8qKlxuICAgKiBTZWFyY2ggZm9yIHRoZSB0ZXJtcyBpbiBgcXVlcnlgIHdpdGhpbiBgZG9jW2ZpZWxkTmFtZV1gLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgZG8gYSBmdWxsIHRleHQgc2VhcmNoIHRoYXQgcmV0dXJucyByZXN1bHRzIHdoZXJlIGFueSB3b3JkIG9mIG9mXG4gICAqIGBxdWVyeWAgYXBwZWFycyBpbiB0aGUgZmllbGQuXG4gICAqXG4gICAqIERvY3VtZW50cyB3aWxsIGJlIHJldHVybmVkIGJhc2VkIG9uIHRoZWlyIHJlbGV2YW5jZSB0byB0aGUgcXVlcnkuIFRoaXNcbiAgICogdGFrZXMgaW50byBhY2NvdW50OlxuICAgKiAtIEhvdyBtYW55IHdvcmRzIGluIHRoZSBxdWVyeSBhcHBlYXIgaW4gdGhlIHRleHQ/XG4gICAqIC0gSG93IG1hbnkgdGltZXMgZG8gdGhleSBhcHBlYXI/XG4gICAqIC0gSG93IGxvbmcgaXMgdGhlIHRleHQgZmllbGQ/XG4gICAqXG4gICAqIEBwYXJhbSBmaWVsZE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gc2VhcmNoIGluLiBUaGlzIG11c3QgYmUgbGlzdGVkXG4gICAqIGFzIHRoZSBpbmRleCdzIGBzZWFyY2hGaWVsZGAuXG4gICAqIEBwYXJhbSBxdWVyeSAtIFRoZSBxdWVyeSB0ZXh0IHRvIHNlYXJjaCBmb3IuXG4gICAqL1xuICBzZWFyY2goXG4gICAgZmllbGROYW1lOiBTZWFyY2hJbmRleENvbmZpZ1tcInNlYXJjaEZpZWxkXCJdLFxuICAgIHF1ZXJ5OiBzdHJpbmcsXG4gICk6IFNlYXJjaEZpbHRlckZpbmFsaXplcjxEb2N1bWVudCwgU2VhcmNoSW5kZXhDb25maWc+O1xufVxuXG4vKipcbiAqIEJ1aWxkZXIgdG8gZGVmaW5lIGVxdWFsaXR5IGV4cHJlc3Npb25zIGFzIHBhcnQgb2YgYSBzZWFyY2ggZmlsdGVyLlxuICpcbiAqIFNlZSB7QGxpbmsgU2VhcmNoRmlsdGVyQnVpbGRlcn0uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFNlYXJjaEZpbHRlckZpbmFsaXplcjxcbiAgRG9jdW1lbnQgZXh0ZW5kcyBHZW5lcmljRG9jdW1lbnQsXG4gIFNlYXJjaEluZGV4Q29uZmlnIGV4dGVuZHMgR2VuZXJpY1NlYXJjaEluZGV4Q29uZmlnLFxuPiBleHRlbmRzIFNlYXJjaEZpbHRlciB7XG4gIC8qKlxuICAgKiBSZXN0cmljdCB0aGlzIHF1ZXJ5IHRvIGRvY3VtZW50cyB3aGVyZSBgZG9jW2ZpZWxkTmFtZV0gPT09IHZhbHVlYC5cbiAgICpcbiAgICogQHBhcmFtIGZpZWxkTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBjb21wYXJlLiBUaGlzIG11c3QgYmUgbGlzdGVkIGluXG4gICAqIHRoZSBzZWFyY2ggaW5kZXgncyBgZmlsdGVyRmllbGRzYC5cbiAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNvbXBhcmUgYWdhaW5zdC5cbiAgICovXG4gIGVxPEZpZWxkTmFtZSBleHRlbmRzIFNlYXJjaEluZGV4Q29uZmlnW1wiZmlsdGVyRmllbGRzXCJdPihcbiAgICBmaWVsZE5hbWU6IEZpZWxkTmFtZSxcbiAgICB2YWx1ZTogRmllbGRUeXBlRnJvbUZpZWxkUGF0aDxEb2N1bWVudCwgRmllbGROYW1lPixcbiAgKTogU2VhcmNoRmlsdGVyRmluYWxpemVyPERvY3VtZW50LCBTZWFyY2hJbmRleENvbmZpZz47XG59XG5cbi8qKlxuICogQW4gZXhwcmVzc2lvbiByZXByZXNlbnRpbmcgYSBzZWFyY2ggZmlsdGVyIGNyZWF0ZWQgYnlcbiAqIHtAbGluayBTZWFyY2hGaWx0ZXJCdWlsZGVyfS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTZWFyY2hGaWx0ZXIge1xuICAvLyBQcm9wZXJ0eSBmb3Igbm9taW5hbCB0eXBlIHN1cHBvcnQuXG4gIHByaXZhdGUgX2lzU2VhcmNoRmlsdGVyOiB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLy8gb25seSBkZWZpbmluZyB0aGUgY29uc3RydWN0b3Igc28gd2UgY2FuIG1hcmsgaXQgYXMgaW50ZXJuYWwgYW5kIGtlZXBcbiAgICAvLyBpdCBvdXQgb2YgdGhlIGRvY3MuXG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgY29udmV4VG9Kc29uIH0gZnJvbSBcIi4uLy4uL3ZhbHVlcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuLi8uLi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgcGVyZm9ybUFzeW5jU3lzY2FsbCB9IGZyb20gXCIuL3N5c2NhbGwuanNcIjtcbmltcG9ydCB7IHBhcnNlQXJncyB9IGZyb20gXCIuLi8uLi9jb21tb24vaW5kZXguanNcIjtcbmltcG9ydCB7IHZhbGlkYXRlQXJnIH0gZnJvbSBcIi4vdmFsaWRhdGUuanNcIjtcbmltcG9ydCB7IGdldEZ1bmN0aW9uQWRkcmVzcyB9IGZyb20gXCIuLi9jb21wb25lbnRzL3BhdGhzLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gc2V0dXBNdXRhdGlvblNjaGVkdWxlcigpIHtcbiAgcmV0dXJuIHtcbiAgICBydW5BZnRlcjogYXN5bmMgKGRlbGF5TXMsIGZ1bmN0aW9uUmVmZXJlbmNlLCBhcmdzKSA9PiB7XG4gICAgICBjb25zdCBzeXNjYWxsQXJncyA9IHJ1bkFmdGVyU3lzY2FsbEFyZ3MoZGVsYXlNcywgZnVuY3Rpb25SZWZlcmVuY2UsIGFyZ3MpO1xuICAgICAgcmV0dXJuIGF3YWl0IHBlcmZvcm1Bc3luY1N5c2NhbGwoXCIxLjAvc2NoZWR1bGVcIiwgc3lzY2FsbEFyZ3MpO1xuICAgIH0sXG4gICAgcnVuQXQ6IGFzeW5jIChtc19zaW5jZV9lcG9jaF9vcl9kYXRlLCBmdW5jdGlvblJlZmVyZW5jZSwgYXJncykgPT4ge1xuICAgICAgY29uc3Qgc3lzY2FsbEFyZ3MgPSBydW5BdFN5c2NhbGxBcmdzKFxuICAgICAgICBtc19zaW5jZV9lcG9jaF9vcl9kYXRlLFxuICAgICAgICBmdW5jdGlvblJlZmVyZW5jZSxcbiAgICAgICAgYXJnc1xuICAgICAgKTtcbiAgICAgIHJldHVybiBhd2FpdCBwZXJmb3JtQXN5bmNTeXNjYWxsKFwiMS4wL3NjaGVkdWxlXCIsIHN5c2NhbGxBcmdzKTtcbiAgICB9LFxuICAgIGNhbmNlbDogYXN5bmMgKGlkKSA9PiB7XG4gICAgICB2YWxpZGF0ZUFyZyhpZCwgMSwgXCJjYW5jZWxcIiwgXCJpZFwiKTtcbiAgICAgIGNvbnN0IGFyZ3MgPSB7IGlkOiBjb252ZXhUb0pzb24oaWQpIH07XG4gICAgICBhd2FpdCBwZXJmb3JtQXN5bmNTeXNjYWxsKFwiMS4wL2NhbmNlbF9qb2JcIiwgYXJncyk7XG4gICAgfVxuICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNldHVwQWN0aW9uU2NoZWR1bGVyKHJlcXVlc3RJZCkge1xuICByZXR1cm4ge1xuICAgIHJ1bkFmdGVyOiBhc3luYyAoZGVsYXlNcywgZnVuY3Rpb25SZWZlcmVuY2UsIGFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IHN5c2NhbGxBcmdzID0ge1xuICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgIC4uLnJ1bkFmdGVyU3lzY2FsbEFyZ3MoZGVsYXlNcywgZnVuY3Rpb25SZWZlcmVuY2UsIGFyZ3MpXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGF3YWl0IHBlcmZvcm1Bc3luY1N5c2NhbGwoXCIxLjAvYWN0aW9ucy9zY2hlZHVsZVwiLCBzeXNjYWxsQXJncyk7XG4gICAgfSxcbiAgICBydW5BdDogYXN5bmMgKG1zX3NpbmNlX2Vwb2NoX29yX2RhdGUsIGZ1bmN0aW9uUmVmZXJlbmNlLCBhcmdzKSA9PiB7XG4gICAgICBjb25zdCBzeXNjYWxsQXJncyA9IHtcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAuLi5ydW5BdFN5c2NhbGxBcmdzKG1zX3NpbmNlX2Vwb2NoX29yX2RhdGUsIGZ1bmN0aW9uUmVmZXJlbmNlLCBhcmdzKVxuICAgICAgfTtcbiAgICAgIHJldHVybiBhd2FpdCBwZXJmb3JtQXN5bmNTeXNjYWxsKFwiMS4wL2FjdGlvbnMvc2NoZWR1bGVcIiwgc3lzY2FsbEFyZ3MpO1xuICAgIH0sXG4gICAgY2FuY2VsOiBhc3luYyAoaWQpID0+IHtcbiAgICAgIHZhbGlkYXRlQXJnKGlkLCAxLCBcImNhbmNlbFwiLCBcImlkXCIpO1xuICAgICAgY29uc3Qgc3lzY2FsbEFyZ3MgPSB7IGlkOiBjb252ZXhUb0pzb24oaWQpIH07XG4gICAgICByZXR1cm4gYXdhaXQgcGVyZm9ybUFzeW5jU3lzY2FsbChcIjEuMC9hY3Rpb25zL2NhbmNlbF9qb2JcIiwgc3lzY2FsbEFyZ3MpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHJ1bkFmdGVyU3lzY2FsbEFyZ3MoZGVsYXlNcywgZnVuY3Rpb25SZWZlcmVuY2UsIGFyZ3MpIHtcbiAgaWYgKHR5cGVvZiBkZWxheU1zICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYGRlbGF5TXNgIG11c3QgYmUgYSBudW1iZXJcIik7XG4gIH1cbiAgaWYgKCFpc0Zpbml0ZShkZWxheU1zKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImBkZWxheU1zYCBtdXN0IGJlIGEgZmluaXRlIG51bWJlclwiKTtcbiAgfVxuICBpZiAoZGVsYXlNcyA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJgZGVsYXlNc2AgbXVzdCBiZSBub24tbmVnYXRpdmVcIik7XG4gIH1cbiAgY29uc3QgZnVuY3Rpb25BcmdzID0gcGFyc2VBcmdzKGFyZ3MpO1xuICBjb25zdCBhZGRyZXNzID0gZ2V0RnVuY3Rpb25BZGRyZXNzKGZ1bmN0aW9uUmVmZXJlbmNlKTtcbiAgY29uc3QgdHMgPSAoRGF0ZS5ub3coKSArIGRlbGF5TXMpIC8gMWUzO1xuICByZXR1cm4ge1xuICAgIC4uLmFkZHJlc3MsXG4gICAgdHMsXG4gICAgYXJnczogY29udmV4VG9Kc29uKGZ1bmN0aW9uQXJncyksXG4gICAgdmVyc2lvblxuICB9O1xufVxuZnVuY3Rpb24gcnVuQXRTeXNjYWxsQXJncyhtc19zaW5jZV9lcG9jaF9vcl9kYXRlLCBmdW5jdGlvblJlZmVyZW5jZSwgYXJncykge1xuICBsZXQgdHM7XG4gIGlmIChtc19zaW5jZV9lcG9jaF9vcl9kYXRlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHRzID0gbXNfc2luY2VfZXBvY2hfb3JfZGF0ZS52YWx1ZU9mKCkgLyAxZTM7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1zX3NpbmNlX2Vwb2NoX29yX2RhdGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICB0cyA9IG1zX3NpbmNlX2Vwb2NoX29yX2RhdGUgLyAxZTM7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGludm9rZSB0aW1lIG11c3QgYSBEYXRlIG9yIGEgdGltZXN0YW1wXCIpO1xuICB9XG4gIGNvbnN0IGFkZHJlc3MgPSBnZXRGdW5jdGlvbkFkZHJlc3MoZnVuY3Rpb25SZWZlcmVuY2UpO1xuICBjb25zdCBmdW5jdGlvbkFyZ3MgPSBwYXJzZUFyZ3MoYXJncyk7XG4gIHJldHVybiB7XG4gICAgLi4uYWRkcmVzcyxcbiAgICB0cyxcbiAgICBhcmdzOiBjb252ZXhUb0pzb24oZnVuY3Rpb25BcmdzKSxcbiAgICB2ZXJzaW9uXG4gIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY2hlZHVsZXJfaW1wbC5qcy5tYXBcbiIsImltcG9ydCB7IGNvbnZleFRvSnNvbiwgVmFsdWUgfSBmcm9tIFwiLi4vLi4vdmFsdWVzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4uLy4uL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBwZXJmb3JtQXN5bmNTeXNjYWxsIH0gZnJvbSBcIi4vc3lzY2FsbC5qc1wiO1xuaW1wb3J0IHsgcGFyc2VBcmdzIH0gZnJvbSBcIi4uLy4uL2NvbW1vbi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgU2NoZWR1bGFibGVGdW5jdGlvblJlZmVyZW5jZSwgU2NoZWR1bGVyIH0gZnJvbSBcIi4uL3NjaGVkdWxlci5qc1wiO1xuaW1wb3J0IHsgSWQgfSBmcm9tIFwiLi4vLi4vdmFsdWVzL3ZhbHVlLmpzXCI7XG5pbXBvcnQgeyB2YWxpZGF0ZUFyZyB9IGZyb20gXCIuL3ZhbGlkYXRlLmpzXCI7XG5pbXBvcnQgeyBnZXRGdW5jdGlvbkFkZHJlc3MgfSBmcm9tIFwiLi4vY29tcG9uZW50cy9wYXRocy5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0dXBNdXRhdGlvblNjaGVkdWxlcigpOiBTY2hlZHVsZXIge1xuICByZXR1cm4ge1xuICAgIHJ1bkFmdGVyOiBhc3luYyAoXG4gICAgICBkZWxheU1zOiBudW1iZXIsXG4gICAgICBmdW5jdGlvblJlZmVyZW5jZTogU2NoZWR1bGFibGVGdW5jdGlvblJlZmVyZW5jZSxcbiAgICAgIGFyZ3M/OiBSZWNvcmQ8c3RyaW5nLCBWYWx1ZT4sXG4gICAgKSA9PiB7XG4gICAgICBjb25zdCBzeXNjYWxsQXJncyA9IHJ1bkFmdGVyU3lzY2FsbEFyZ3MoZGVsYXlNcywgZnVuY3Rpb25SZWZlcmVuY2UsIGFyZ3MpO1xuICAgICAgcmV0dXJuIGF3YWl0IHBlcmZvcm1Bc3luY1N5c2NhbGwoXCIxLjAvc2NoZWR1bGVcIiwgc3lzY2FsbEFyZ3MpO1xuICAgIH0sXG4gICAgcnVuQXQ6IGFzeW5jIChcbiAgICAgIG1zX3NpbmNlX2Vwb2NoX29yX2RhdGU6IG51bWJlciB8IERhdGUsXG4gICAgICBmdW5jdGlvblJlZmVyZW5jZTogU2NoZWR1bGFibGVGdW5jdGlvblJlZmVyZW5jZSxcbiAgICAgIGFyZ3M/OiBSZWNvcmQ8c3RyaW5nLCBWYWx1ZT4sXG4gICAgKSA9PiB7XG4gICAgICBjb25zdCBzeXNjYWxsQXJncyA9IHJ1bkF0U3lzY2FsbEFyZ3MoXG4gICAgICAgIG1zX3NpbmNlX2Vwb2NoX29yX2RhdGUsXG4gICAgICAgIGZ1bmN0aW9uUmVmZXJlbmNlLFxuICAgICAgICBhcmdzLFxuICAgICAgKTtcbiAgICAgIHJldHVybiBhd2FpdCBwZXJmb3JtQXN5bmNTeXNjYWxsKFwiMS4wL3NjaGVkdWxlXCIsIHN5c2NhbGxBcmdzKTtcbiAgICB9LFxuICAgIGNhbmNlbDogYXN5bmMgKGlkOiBJZDxcIl9zY2hlZHVsZWRfZnVuY3Rpb25zXCI+KSA9PiB7XG4gICAgICB2YWxpZGF0ZUFyZyhpZCwgMSwgXCJjYW5jZWxcIiwgXCJpZFwiKTtcbiAgICAgIGNvbnN0IGFyZ3MgPSB7IGlkOiBjb252ZXhUb0pzb24oaWQpIH07XG4gICAgICBhd2FpdCBwZXJmb3JtQXN5bmNTeXNjYWxsKFwiMS4wL2NhbmNlbF9qb2JcIiwgYXJncyk7XG4gICAgfSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldHVwQWN0aW9uU2NoZWR1bGVyKHJlcXVlc3RJZDogc3RyaW5nKTogU2NoZWR1bGVyIHtcbiAgcmV0dXJuIHtcbiAgICBydW5BZnRlcjogYXN5bmMgKFxuICAgICAgZGVsYXlNczogbnVtYmVyLFxuICAgICAgZnVuY3Rpb25SZWZlcmVuY2U6IFNjaGVkdWxhYmxlRnVuY3Rpb25SZWZlcmVuY2UsXG4gICAgICBhcmdzPzogUmVjb3JkPHN0cmluZywgVmFsdWU+LFxuICAgICkgPT4ge1xuICAgICAgY29uc3Qgc3lzY2FsbEFyZ3MgPSB7XG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgLi4ucnVuQWZ0ZXJTeXNjYWxsQXJncyhkZWxheU1zLCBmdW5jdGlvblJlZmVyZW5jZSwgYXJncyksXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGF3YWl0IHBlcmZvcm1Bc3luY1N5c2NhbGwoXCIxLjAvYWN0aW9ucy9zY2hlZHVsZVwiLCBzeXNjYWxsQXJncyk7XG4gICAgfSxcbiAgICBydW5BdDogYXN5bmMgKFxuICAgICAgbXNfc2luY2VfZXBvY2hfb3JfZGF0ZTogbnVtYmVyIHwgRGF0ZSxcbiAgICAgIGZ1bmN0aW9uUmVmZXJlbmNlOiBTY2hlZHVsYWJsZUZ1bmN0aW9uUmVmZXJlbmNlLFxuICAgICAgYXJncz86IFJlY29yZDxzdHJpbmcsIFZhbHVlPixcbiAgICApID0+IHtcbiAgICAgIGNvbnN0IHN5c2NhbGxBcmdzID0ge1xuICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgIC4uLnJ1bkF0U3lzY2FsbEFyZ3MobXNfc2luY2VfZXBvY2hfb3JfZGF0ZSwgZnVuY3Rpb25SZWZlcmVuY2UsIGFyZ3MpLFxuICAgICAgfTtcbiAgICAgIHJldHVybiBhd2FpdCBwZXJmb3JtQXN5bmNTeXNjYWxsKFwiMS4wL2FjdGlvbnMvc2NoZWR1bGVcIiwgc3lzY2FsbEFyZ3MpO1xuICAgIH0sXG4gICAgY2FuY2VsOiBhc3luYyAoaWQ6IElkPFwiX3NjaGVkdWxlZF9mdW5jdGlvbnNcIj4pID0+IHtcbiAgICAgIHZhbGlkYXRlQXJnKGlkLCAxLCBcImNhbmNlbFwiLCBcImlkXCIpO1xuICAgICAgY29uc3Qgc3lzY2FsbEFyZ3MgPSB7IGlkOiBjb252ZXhUb0pzb24oaWQpIH07XG4gICAgICByZXR1cm4gYXdhaXQgcGVyZm9ybUFzeW5jU3lzY2FsbChcIjEuMC9hY3Rpb25zL2NhbmNlbF9qb2JcIiwgc3lzY2FsbEFyZ3MpO1xuICAgIH0sXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJ1bkFmdGVyU3lzY2FsbEFyZ3MoXG4gIGRlbGF5TXM6IG51bWJlcixcbiAgZnVuY3Rpb25SZWZlcmVuY2U6IFNjaGVkdWxhYmxlRnVuY3Rpb25SZWZlcmVuY2UsXG4gIGFyZ3M/OiBSZWNvcmQ8c3RyaW5nLCBWYWx1ZT4sXG4pIHtcbiAgaWYgKHR5cGVvZiBkZWxheU1zICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYGRlbGF5TXNgIG11c3QgYmUgYSBudW1iZXJcIik7XG4gIH1cbiAgaWYgKCFpc0Zpbml0ZShkZWxheU1zKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImBkZWxheU1zYCBtdXN0IGJlIGEgZmluaXRlIG51bWJlclwiKTtcbiAgfVxuICBpZiAoZGVsYXlNcyA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJgZGVsYXlNc2AgbXVzdCBiZSBub24tbmVnYXRpdmVcIik7XG4gIH1cbiAgY29uc3QgZnVuY3Rpb25BcmdzID0gcGFyc2VBcmdzKGFyZ3MpO1xuICBjb25zdCBhZGRyZXNzID0gZ2V0RnVuY3Rpb25BZGRyZXNzKGZ1bmN0aW9uUmVmZXJlbmNlKTtcbiAgLy8gTm90ZSB0aGUgc3lzY2FsbCBleHBlY3RzIGEgdW5peCB0aW1lc3RhbXAsIG1lYXN1cmVkIGluIHNlY29uZHMuXG4gIGNvbnN0IHRzID0gKERhdGUubm93KCkgKyBkZWxheU1zKSAvIDEwMDAuMDtcbiAgcmV0dXJuIHtcbiAgICAuLi5hZGRyZXNzLFxuICAgIHRzLFxuICAgIGFyZ3M6IGNvbnZleFRvSnNvbihmdW5jdGlvbkFyZ3MpLFxuICAgIHZlcnNpb24sXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJ1bkF0U3lzY2FsbEFyZ3MoXG4gIG1zX3NpbmNlX2Vwb2NoX29yX2RhdGU6IG51bWJlciB8IERhdGUsXG4gIGZ1bmN0aW9uUmVmZXJlbmNlOiBTY2hlZHVsYWJsZUZ1bmN0aW9uUmVmZXJlbmNlLFxuICBhcmdzPzogUmVjb3JkPHN0cmluZywgVmFsdWU+LFxuKSB7XG4gIGxldCB0cztcbiAgaWYgKG1zX3NpbmNlX2Vwb2NoX29yX2RhdGUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgdHMgPSBtc19zaW5jZV9lcG9jaF9vcl9kYXRlLnZhbHVlT2YoKSAvIDEwMDAuMDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbXNfc2luY2VfZXBvY2hfb3JfZGF0ZSA9PT0gXCJudW1iZXJcIikge1xuICAgIC8vIFRoZSB0aW1lc3RhbXAgdGhlIGRldmVsb3BlciBwYXNzZXMgaXMgaW4gbWlsbGlzZWNvbmRzLCB3aGlsZSB0aGUgc3lzY2FsbFxuICAgIC8vIGFjY2VwdHMgc2Vjb25kcyBzaW5jZSB0aGUgZXBvY2guXG4gICAgdHMgPSBtc19zaW5jZV9lcG9jaF9vcl9kYXRlIC8gMTAwMDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgaW52b2tlIHRpbWUgbXVzdCBhIERhdGUgb3IgYSB0aW1lc3RhbXBcIik7XG4gIH1cbiAgY29uc3QgYWRkcmVzcyA9IGdldEZ1bmN0aW9uQWRkcmVzcyhmdW5jdGlvblJlZmVyZW5jZSk7XG4gIGNvbnN0IGZ1bmN0aW9uQXJncyA9IHBhcnNlQXJncyhhcmdzKTtcbiAgcmV0dXJuIHtcbiAgICAuLi5hZGRyZXNzLFxuICAgIHRzLFxuICAgIGFyZ3M6IGNvbnZleFRvSnNvbihmdW5jdGlvbkFyZ3MpLFxuICAgIHZlcnNpb24sXG4gIH07XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi4vLi4vaW5kZXguanNcIjtcbmltcG9ydCB7IHBlcmZvcm1Bc3luY1N5c2NhbGwsIHBlcmZvcm1Kc1N5c2NhbGwgfSBmcm9tIFwiLi9zeXNjYWxsLmpzXCI7XG5pbXBvcnQgeyB2YWxpZGF0ZUFyZyB9IGZyb20gXCIuL3ZhbGlkYXRlLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gc2V0dXBTdG9yYWdlUmVhZGVyKHJlcXVlc3RJZCkge1xuICByZXR1cm4ge1xuICAgIGdldFVybDogYXN5bmMgKHN0b3JhZ2VJZCkgPT4ge1xuICAgICAgdmFsaWRhdGVBcmcoc3RvcmFnZUlkLCAxLCBcImdldFVybFwiLCBcInN0b3JhZ2VJZFwiKTtcbiAgICAgIHJldHVybiBhd2FpdCBwZXJmb3JtQXN5bmNTeXNjYWxsKFwiMS4wL3N0b3JhZ2VHZXRVcmxcIiwge1xuICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgIHZlcnNpb24sXG4gICAgICAgIHN0b3JhZ2VJZFxuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXRNZXRhZGF0YTogYXN5bmMgKHN0b3JhZ2VJZCkgPT4ge1xuICAgICAgcmV0dXJuIGF3YWl0IHBlcmZvcm1Bc3luY1N5c2NhbGwoXCIxLjAvc3RvcmFnZUdldE1ldGFkYXRhXCIsIHtcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICB2ZXJzaW9uLFxuICAgICAgICBzdG9yYWdlSWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXR1cFN0b3JhZ2VXcml0ZXIocmVxdWVzdElkKSB7XG4gIGNvbnN0IHJlYWRlciA9IHNldHVwU3RvcmFnZVJlYWRlcihyZXF1ZXN0SWQpO1xuICByZXR1cm4ge1xuICAgIGdlbmVyYXRlVXBsb2FkVXJsOiBhc3luYyAoKSA9PiB7XG4gICAgICByZXR1cm4gYXdhaXQgcGVyZm9ybUFzeW5jU3lzY2FsbChcIjEuMC9zdG9yYWdlR2VuZXJhdGVVcGxvYWRVcmxcIiwge1xuICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgIHZlcnNpb25cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZGVsZXRlOiBhc3luYyAoc3RvcmFnZUlkKSA9PiB7XG4gICAgICBhd2FpdCBwZXJmb3JtQXN5bmNTeXNjYWxsKFwiMS4wL3N0b3JhZ2VEZWxldGVcIiwge1xuICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgIHZlcnNpb24sXG4gICAgICAgIHN0b3JhZ2VJZFxuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXRVcmw6IHJlYWRlci5nZXRVcmwsXG4gICAgZ2V0TWV0YWRhdGE6IHJlYWRlci5nZXRNZXRhZGF0YVxuICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNldHVwU3RvcmFnZUFjdGlvbldyaXRlcihyZXF1ZXN0SWQpIHtcbiAgY29uc3Qgd3JpdGVyID0gc2V0dXBTdG9yYWdlV3JpdGVyKHJlcXVlc3RJZCk7XG4gIHJldHVybiB7XG4gICAgLi4ud3JpdGVyLFxuICAgIHN0b3JlOiBhc3luYyAoYmxvYiwgb3B0aW9ucykgPT4ge1xuICAgICAgcmV0dXJuIGF3YWl0IHBlcmZvcm1Kc1N5c2NhbGwoXCJzdG9yYWdlL3N0b3JlQmxvYlwiLCB7XG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgdmVyc2lvbixcbiAgICAgICAgYmxvYixcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXQ6IGFzeW5jIChzdG9yYWdlSWQpID0+IHtcbiAgICAgIHJldHVybiBhd2FpdCBwZXJmb3JtSnNTeXNjYWxsKFwic3RvcmFnZS9nZXRCbG9iXCIsIHtcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICB2ZXJzaW9uLFxuICAgICAgICBzdG9yYWdlSWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0b3JhZ2VfaW1wbC5qcy5tYXBcbiIsImltcG9ydCB7XG4gIEZpbGVNZXRhZGF0YSxcbiAgU3RvcmFnZUFjdGlvbldyaXRlcixcbiAgRmlsZVN0b3JhZ2VJZCxcbiAgU3RvcmFnZVJlYWRlcixcbiAgU3RvcmFnZVdyaXRlcixcbn0gZnJvbSBcIi4uL3N0b3JhZ2UuanNcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi4vLi4vaW5kZXguanNcIjtcbmltcG9ydCB7IHBlcmZvcm1Bc3luY1N5c2NhbGwsIHBlcmZvcm1Kc1N5c2NhbGwgfSBmcm9tIFwiLi9zeXNjYWxsLmpzXCI7XG5pbXBvcnQgeyB2YWxpZGF0ZUFyZyB9IGZyb20gXCIuL3ZhbGlkYXRlLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXR1cFN0b3JhZ2VSZWFkZXIocmVxdWVzdElkOiBzdHJpbmcpOiBTdG9yYWdlUmVhZGVyIHtcbiAgcmV0dXJuIHtcbiAgICBnZXRVcmw6IGFzeW5jIChzdG9yYWdlSWQ6IEZpbGVTdG9yYWdlSWQpID0+IHtcbiAgICAgIHZhbGlkYXRlQXJnKHN0b3JhZ2VJZCwgMSwgXCJnZXRVcmxcIiwgXCJzdG9yYWdlSWRcIik7XG4gICAgICByZXR1cm4gYXdhaXQgcGVyZm9ybUFzeW5jU3lzY2FsbChcIjEuMC9zdG9yYWdlR2V0VXJsXCIsIHtcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICB2ZXJzaW9uLFxuICAgICAgICBzdG9yYWdlSWQsXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGdldE1ldGFkYXRhOiBhc3luYyAoc3RvcmFnZUlkOiBGaWxlU3RvcmFnZUlkKTogUHJvbWlzZTxGaWxlTWV0YWRhdGE+ID0+IHtcbiAgICAgIHJldHVybiBhd2FpdCBwZXJmb3JtQXN5bmNTeXNjYWxsKFwiMS4wL3N0b3JhZ2VHZXRNZXRhZGF0YVwiLCB7XG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgdmVyc2lvbixcbiAgICAgICAgc3RvcmFnZUlkLFxuICAgICAgfSk7XG4gICAgfSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldHVwU3RvcmFnZVdyaXRlcihyZXF1ZXN0SWQ6IHN0cmluZyk6IFN0b3JhZ2VXcml0ZXIge1xuICBjb25zdCByZWFkZXIgPSBzZXR1cFN0b3JhZ2VSZWFkZXIocmVxdWVzdElkKTtcbiAgcmV0dXJuIHtcbiAgICBnZW5lcmF0ZVVwbG9hZFVybDogYXN5bmMgKCkgPT4ge1xuICAgICAgcmV0dXJuIGF3YWl0IHBlcmZvcm1Bc3luY1N5c2NhbGwoXCIxLjAvc3RvcmFnZUdlbmVyYXRlVXBsb2FkVXJsXCIsIHtcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICB2ZXJzaW9uLFxuICAgICAgfSk7XG4gICAgfSxcbiAgICBkZWxldGU6IGFzeW5jIChzdG9yYWdlSWQ6IEZpbGVTdG9yYWdlSWQpID0+IHtcbiAgICAgIGF3YWl0IHBlcmZvcm1Bc3luY1N5c2NhbGwoXCIxLjAvc3RvcmFnZURlbGV0ZVwiLCB7XG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgdmVyc2lvbixcbiAgICAgICAgc3RvcmFnZUlkLFxuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXRVcmw6IHJlYWRlci5nZXRVcmwsXG4gICAgZ2V0TWV0YWRhdGE6IHJlYWRlci5nZXRNZXRhZGF0YSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldHVwU3RvcmFnZUFjdGlvbldyaXRlcihcbiAgcmVxdWVzdElkOiBzdHJpbmcsXG4pOiBTdG9yYWdlQWN0aW9uV3JpdGVyIHtcbiAgY29uc3Qgd3JpdGVyID0gc2V0dXBTdG9yYWdlV3JpdGVyKHJlcXVlc3RJZCk7XG4gIHJldHVybiB7XG4gICAgLi4ud3JpdGVyLFxuICAgIHN0b3JlOiBhc3luYyAoYmxvYjogQmxvYiwgb3B0aW9ucz86IHsgc2hhMjU2Pzogc3RyaW5nIH0pID0+IHtcbiAgICAgIHJldHVybiBhd2FpdCBwZXJmb3JtSnNTeXNjYWxsKFwic3RvcmFnZS9zdG9yZUJsb2JcIiwge1xuICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgIHZlcnNpb24sXG4gICAgICAgIGJsb2IsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGdldDogYXN5bmMgKHN0b3JhZ2VJZDogRmlsZVN0b3JhZ2VJZCkgPT4ge1xuICAgICAgcmV0dXJuIGF3YWl0IHBlcmZvcm1Kc1N5c2NhbGwoXCJzdG9yYWdlL2dldEJsb2JcIiwge1xuICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgIHZlcnNpb24sXG4gICAgICAgIHN0b3JhZ2VJZCxcbiAgICAgIH0pO1xuICAgIH0sXG4gIH07XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IHYgfSBmcm9tIFwiLi4vdmFsdWVzL3ZhbGlkYXRvci5qc1wiO1xuZXhwb3J0IGNvbnN0IHBhZ2luYXRpb25PcHRzVmFsaWRhdG9yID0gdi5vYmplY3Qoe1xuICBudW1JdGVtczogdi5udW1iZXIoKSxcbiAgY3Vyc29yOiB2LnVuaW9uKHYuc3RyaW5nKCksIHYubnVsbCgpKSxcbiAgZW5kQ3Vyc29yOiB2Lm9wdGlvbmFsKHYudW5pb24odi5zdHJpbmcoKSwgdi5udWxsKCkpKSxcbiAgaWQ6IHYub3B0aW9uYWwodi5udW1iZXIoKSksXG4gIG1heGltdW1Sb3dzUmVhZDogdi5vcHRpb25hbCh2Lm51bWJlcigpKSxcbiAgbWF4aW11bUJ5dGVzUmVhZDogdi5vcHRpb25hbCh2Lm51bWJlcigpKVxufSk7XG5leHBvcnQgZnVuY3Rpb24gcGFnaW5hdGlvblJlc3VsdFZhbGlkYXRvcihpdGVtVmFsaWRhdG9yKSB7XG4gIHJldHVybiB2Lm9iamVjdCh7XG4gICAgcGFnZTogdi5hcnJheShpdGVtVmFsaWRhdG9yKSxcbiAgICBjb250aW51ZUN1cnNvcjogdi5zdHJpbmcoKSxcbiAgICBpc0RvbmU6IHYuYm9vbGVhbigpLFxuICAgIHNwbGl0Q3Vyc29yOiB2Lm9wdGlvbmFsKHYudW5pb24odi5zdHJpbmcoKSwgdi5udWxsKCkpKSxcbiAgICBwYWdlU3RhdHVzOiB2Lm9wdGlvbmFsKFxuICAgICAgdi51bmlvbihcbiAgICAgICAgdi5saXRlcmFsKFwiU3BsaXRSZWNvbW1lbmRlZFwiKSxcbiAgICAgICAgdi5saXRlcmFsKFwiU3BsaXRSZXF1aXJlZFwiKSxcbiAgICAgICAgdi5udWxsKClcbiAgICAgIClcbiAgICApXG4gIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFnaW5hdGlvbi5qcy5tYXBcbiIsImltcG9ydCB7IHYgfSBmcm9tIFwiLi4vdmFsdWVzL3ZhbGlkYXRvci5qc1wiO1xuaW1wb3J0IHR5cGUgeyBWYWxpZGF0b3IgfSBmcm9tIFwiLi4vdmFsdWVzL3ZhbGlkYXRvcnMuanNcIjtcbmltcG9ydCB0eXBlIHsgVmFsdWUgfSBmcm9tIFwiLi4vdmFsdWVzL3ZhbHVlLmpzXCI7XG5cbi8qKlxuICogQW4gb3BhcXVlIGlkZW50aWZpZXIgdXNlZCBmb3IgcGFnaW5hdGluZyBhIGRhdGFiYXNlIHF1ZXJ5LlxuICpcbiAqIEN1cnNvcnMgYXJlIHJldHVybmVkIGZyb20ge0BsaW5rIE9yZGVyZWRRdWVyeS5wYWdpbmF0ZX0gYW5kIHJlcHJlc2VudCB0aGVcbiAqIHBvaW50IG9mIHRoZSBxdWVyeSB3aGVyZSB0aGUgcGFnZSBvZiByZXN1bHRzIGVuZGVkLlxuICpcbiAqIFRvIGNvbnRpbnVlIHBhZ2luYXRpbmcsIHBhc3MgdGhlIGN1cnNvciBiYWNrIGludG9cbiAqIHtAbGluayBPcmRlcmVkUXVlcnkucGFnaW5hdGV9IGluIHRoZSB7QGxpbmsgUGFnaW5hdGlvbk9wdGlvbnN9IG9iamVjdCB0b1xuICogZmV0Y2ggYW5vdGhlciBwYWdlIG9mIHJlc3VsdHMuXG4gKlxuICogTm90ZTogQ3Vyc29ycyBjYW4gb25seSBiZSBwYXNzZWQgdG8gX2V4YWN0bHlfIHRoZSBzYW1lIGRhdGFiYXNlIHF1ZXJ5IHRoYXRcbiAqIHRoZXkgd2VyZSBnZW5lcmF0ZWQgZnJvbS4gWW91IG1heSBub3QgcmV1c2UgYSBjdXJzb3IgYmV0d2VlbiBkaWZmZXJlbnRcbiAqIGRhdGFiYXNlIHF1ZXJpZXMuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgdHlwZSBDdXJzb3IgPSBzdHJpbmc7XG5cbi8qKlxuICogVGhlIHJlc3VsdCBvZiBwYWdpbmF0aW5nIHVzaW5nIHtAbGluayBPcmRlcmVkUXVlcnkucGFnaW5hdGV9LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQYWdpbmF0aW9uUmVzdWx0PFQ+IHtcbiAgLyoqXG4gICAqIFRoZSBwYWdlIG9mIHJlc3VsdHMuXG4gICAqL1xuICBwYWdlOiBUW107XG5cbiAgLyoqXG4gICAqIEhhdmUgd2UgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSByZXN1bHRzP1xuICAgKi9cbiAgaXNEb25lOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBBIHtAbGluayBDdXJzb3J9IHRvIGNvbnRpbnVlIGxvYWRpbmcgbW9yZSByZXN1bHRzLlxuICAgKi9cbiAgY29udGludWVDdXJzb3I6IEN1cnNvcjtcblxuICAvKipcbiAgICogQSB7QGxpbmsgQ3Vyc29yfSB0byBzcGxpdCB0aGUgcGFnZSBpbnRvIHR3bywgc28gdGhlIHBhZ2UgZnJvbVxuICAgKiAoY3Vyc29yLCBjb250aW51ZUN1cnNvcl0gY2FuIGJlIHJlcGxhY2VkIGJ5IHR3byBwYWdlcyAoY3Vyc29yLCBzcGxpdEN1cnNvcl1cbiAgICogYW5kIChzcGxpdEN1cnNvciwgY29udGludWVDdXJzb3JdLlxuICAgKi9cbiAgc3BsaXRDdXJzb3I/OiBDdXJzb3IgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBXaGVuIGEgcXVlcnkgcmVhZHMgdG9vIG11Y2ggZGF0YSwgaXQgbWF5IHJldHVybiAnU3BsaXRSZWNvbW1lbmRlZCcgdG9cbiAgICogaW5kaWNhdGUgdGhhdCB0aGUgcGFnZSBzaG91bGQgYmUgc3BsaXQgaW50byB0d28gd2l0aCBgc3BsaXRDdXJzb3JgLlxuICAgKiBXaGVuIGEgcXVlcnkgcmVhZHMgc28gbXVjaCBkYXRhIHRoYXQgYHBhZ2VgIG1pZ2h0IGJlIGluY29tcGxldGUsIGl0cyBzdGF0dXNcbiAgICogYmVjb21lcyAnU3BsaXRSZXF1aXJlZCcuXG4gICAqL1xuICBwYWdlU3RhdHVzPzogXCJTcGxpdFJlY29tbWVuZGVkXCIgfCBcIlNwbGl0UmVxdWlyZWRcIiB8IG51bGw7XG59XG5cbi8qKlxuICogVGhlIG9wdGlvbnMgcGFzc2VkIHRvIHtAbGluayBPcmRlcmVkUXVlcnkucGFnaW5hdGV9LlxuICpcbiAqIFRvIHVzZSB0aGlzIHR5cGUgaW4gW2FyZ3VtZW50IHZhbGlkYXRpb25dKGh0dHBzOi8vZG9jcy5jb252ZXguZGV2L2Z1bmN0aW9ucy92YWxpZGF0aW9uKSxcbiAqIHVzZSB0aGUge0BsaW5rIHBhZ2luYXRpb25PcHRzVmFsaWRhdG9yfS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGFnaW5hdGlvbk9wdGlvbnMge1xuICAvKipcbiAgICogTnVtYmVyIG9mIGl0ZW1zIHRvIGxvYWQgaW4gdGhpcyBwYWdlIG9mIHJlc3VsdHMuXG4gICAqXG4gICAqIE5vdGU6IFRoaXMgaXMgb25seSBhbiBpbml0aWFsIHZhbHVlIVxuICAgKlxuICAgKiBJZiB5b3UgYXJlIHJ1bm5pbmcgdGhpcyBwYWdpbmF0ZWQgcXVlcnkgaW4gYSByZWFjdGl2ZSBxdWVyeSBmdW5jdGlvbiwgeW91XG4gICAqIG1heSByZWNlaXZlIG1vcmUgb3IgbGVzcyBpdGVtcyB0aGFuIHRoaXMgaWYgaXRlbXMgd2VyZSBhZGRlZCB0byBvciByZW1vdmVkXG4gICAqIGZyb20gdGhlIHF1ZXJ5IHJhbmdlLlxuICAgKi9cbiAgbnVtSXRlbXM6IG51bWJlcjtcblxuICAvKipcbiAgICogQSB7QGxpbmsgQ3Vyc29yfSByZXByZXNlbnRpbmcgdGhlIHN0YXJ0IG9mIHRoaXMgcGFnZSBvciBgbnVsbGAgdG8gc3RhcnRcbiAgICogYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgcXVlcnkgcmVzdWx0cy5cbiAgICovXG4gIGN1cnNvcjogQ3Vyc29yIHwgbnVsbDtcblxuICAvKipcbiAgICogQSB7QGxpbmsgQ3Vyc29yfSByZXByZXNlbnRpbmcgdGhlIGVuZCBvZiB0aGlzIHBhZ2Ugb3IgYG51bGwgfCB1bmRlZmluZWRgIHRvXG4gICAqIHVzZSBgbnVtSXRlbXNgIGluc3RlYWQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5kQ3Vyc29yPzogQ3Vyc29yIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHJvd3MgdGhhdCBzaG91bGQgYmUgcmVhZCBmcm9tIHRoZSBkYXRhYmFzZS5cbiAgICpcbiAgICogVGhpcyBvcHRpb24gaXMgZGlmZmVyZW50IGZyb20gYG51bUl0ZW1zYCBpbiB0aGF0IGl0IGNvbnRyb2xzIHRoZSBudW1iZXIgb2Ygcm93cyBlbnRlcmluZyBhIHF1ZXJ5J3NcbiAgICogcGlwZWxpbmUsIHdoZXJlIGBudW1JdGVtc2AgY29udHJvbHMgdGhlIG51bWJlciBvZiByb3dzIGNvbWluZyBvdXQuIEZvciBleGFtcGxlLCBhIGBmaWx0ZXJgXG4gICAqIG1heSBkaXNxdWFsaWZ5IG1vc3Qgb2YgdGhlIHJvd3MgY29taW5nIGluLCBzbyBzZXR0aW5nIGEgbG93IGBudW1JdGVtc2Agd291bGQgbm90IGhlbHBcbiAgICogYm91bmQgaXRzIGV4ZWN1dGlvbiB0aW1lLiBJbnN0ZWFkLCBzZXQgYSBsb3cgYG1heGltdW1Sb3dzUmVhZGAgdG8gZWZmaWNpZW50bHkgcGFnaW5hdGVcbiAgICogdGhyb3VnaCB0aGUgZmlsdGVyLlxuICAgKlxuICAgKiBDdXJyZW50bHkgdGhpcyBpcyBub3QgZW5mb3JjZWQgZm9yIHNlYXJjaCBxdWVyaWVzLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG1heGltdW1Sb3dzUmVhZD86IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIGJ5dGVzIHRoYXQgc2hvdWxkIGJlIHJlYWQgZnJvbSB0aGUgZGF0YWJhc2UuXG4gICAqXG4gICAqIEFzIHdpdGgge0BsaW5rIFBhZ2luYXRpb25PcHRpb25zLm1heGltdW1Sb3dzUmVhZH0sIHRoaXMgYWZmZWN0cyB0aGUgbnVtYmVyXG4gICAqIG9mIHJvd3MgZW50ZXJpbmcgYSBxdWVyeSdzIHBpcGVsaW5lLlxuICAgKlxuICAgKiBPbmNlIGEgcGFnaW5hdGVkIHF1ZXJ5IGhpdHMgaXRzIGJ5dGVzIHJlYWQgYnVkZ2V0LCBhbiBpbmNvbXBsZXRlIHBhZ2VcbiAgICogd2lsbCBiZSByZXR1cm5lZC5cbiAgICpcbiAgICogQ3VycmVudGx5IHRoaXMgaXMgbm90IGVuZm9yY2VkIGZvciBzZWFyY2ggcXVlcmllcy5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBtYXhpbXVtQnl0ZXNSZWFkPzogbnVtYmVyO1xufVxuXG4vKipcbiAqIEEge0BsaW5rIHZhbHVlcy5WYWxpZGF0b3J9IGZvciB7QGxpbmsgUGFnaW5hdGlvbk9wdGlvbnN9LlxuICpcbiAqIFRoaXMgaW5jbHVkZXMgdGhlIHN0YW5kYXJkIHtAbGluayBQYWdpbmF0aW9uT3B0aW9uc30gcHJvcGVydGllcyBhbG9uZyB3aXRoXG4gKiBhbiBvcHRpb25hbCBjYWNoZS1idXN0aW5nIGBpZGAgcHJvcGVydHkgdXNlZCBieSB7QGxpbmsgcmVhY3QudXNlUGFnaW5hdGVkUXVlcnl9LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHBhZ2luYXRpb25PcHRzVmFsaWRhdG9yID0gdi5vYmplY3Qoe1xuICBudW1JdGVtczogdi5udW1iZXIoKSxcbiAgY3Vyc29yOiB2LnVuaW9uKHYuc3RyaW5nKCksIHYubnVsbCgpKSxcbiAgZW5kQ3Vyc29yOiB2Lm9wdGlvbmFsKHYudW5pb24odi5zdHJpbmcoKSwgdi5udWxsKCkpKSxcbiAgaWQ6IHYub3B0aW9uYWwodi5udW1iZXIoKSksXG4gIG1heGltdW1Sb3dzUmVhZDogdi5vcHRpb25hbCh2Lm51bWJlcigpKSxcbiAgbWF4aW11bUJ5dGVzUmVhZDogdi5vcHRpb25hbCh2Lm51bWJlcigpKSxcbn0pO1xuXG4vKipcbiAqIEEge0BsaW5rIHZhbHVlcy5WYWxpZGF0b3J9IGZhY3RvcnkgZm9yIHtAbGluayBQYWdpbmF0aW9uUmVzdWx0fS5cbiAqXG4gKiBDcmVhdGUgYSB2YWxpZGF0b3IgZm9yIHRoZSByZXN1bHQgb2YgY2FsbGluZyB7QGxpbmsgT3JkZXJlZFF1ZXJ5LnBhZ2luYXRlfVxuICogd2l0aCBhIGdpdmVuIGl0ZW0gdmFsaWRhdG9yLlxuICpcbiAqIEZvciBleGFtcGxlOlxuICogYGBgdHNcbiAqIGNvbnN0IHBhZ2luYXRpb25SZXN1bHRWYWxpZGF0b3IgPSBwYWdpbmF0aW9uUmVzdWx0VmFsaWRhdG9yKHYub2JqZWN0KHtcbiAqICAgX2lkOiB2LmlkKFwidXNlcnNcIiksXG4gKiAgIF9jcmVhdGlvblRpbWU6IHYubnVtYmVyKCksXG4gKiAgIG5hbWU6IHYuc3RyaW5nKCksXG4gKiB9KSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gaXRlbVZhbGlkYXRvciAtIEEgdmFsaWRhdG9yIGZvciB0aGUgaXRlbXMgaW4gdGhlIHBhZ2VcbiAqIEByZXR1cm5zIEEgdmFsaWRhdG9yIGZvciB0aGUgcGFnaW5hdGlvbiByZXN1bHRcbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYWdpbmF0aW9uUmVzdWx0VmFsaWRhdG9yPFxuICBUIGV4dGVuZHMgVmFsaWRhdG9yPFZhbHVlLCBcInJlcXVpcmVkXCIsIHN0cmluZz4sXG4+KGl0ZW1WYWxpZGF0b3I6IFQpIHtcbiAgcmV0dXJuIHYub2JqZWN0KHtcbiAgICBwYWdlOiB2LmFycmF5KGl0ZW1WYWxpZGF0b3IpLFxuICAgIGNvbnRpbnVlQ3Vyc29yOiB2LnN0cmluZygpLFxuICAgIGlzRG9uZTogdi5ib29sZWFuKCksXG4gICAgc3BsaXRDdXJzb3I6IHYub3B0aW9uYWwodi51bmlvbih2LnN0cmluZygpLCB2Lm51bGwoKSkpLFxuICAgIHBhZ2VTdGF0dXM6IHYub3B0aW9uYWwoXG4gICAgICB2LnVuaW9uKFxuICAgICAgICB2LmxpdGVyYWwoXCJTcGxpdFJlY29tbWVuZGVkXCIpLFxuICAgICAgICB2LmxpdGVyYWwoXCJTcGxpdFJlcXVpcmVkXCIpLFxuICAgICAgICB2Lm51bGwoKSxcbiAgICAgICksXG4gICAgKSxcbiAgfSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0b3JhZ2UuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG5pbXBvcnQgeyBnZXRGdW5jdGlvbk5hbWUgfSBmcm9tIFwiLi4vc2VydmVyL2FwaS5qc1wiO1xuaW1wb3J0IHsgcGFyc2VBcmdzIH0gZnJvbSBcIi4uL2NvbW1vbi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgY29udmV4VG9Kc29uIH0gZnJvbSBcIi4uL3ZhbHVlcy9pbmRleC5qc1wiO1xuY29uc3QgREFZU19PRl9XRUVLID0gW1xuICBcInN1bmRheVwiLFxuICBcIm1vbmRheVwiLFxuICBcInR1ZXNkYXlcIixcbiAgXCJ3ZWRuZXNkYXlcIixcbiAgXCJ0aHVyc2RheVwiLFxuICBcImZyaWRheVwiLFxuICBcInNhdHVyZGF5XCJcbl07XG5leHBvcnQgY29uc3QgY3JvbkpvYnMgPSAoKSA9PiBuZXcgQ3JvbnMoKTtcbmZ1bmN0aW9uIHZhbGlkYXRlSW50ZXJ2YWxOdW1iZXIobikge1xuICBpZiAoIU51bWJlci5pc0ludGVnZXIobikgfHwgbiA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW50ZXJ2YWwgbXVzdCBiZSBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiAwXCIpO1xuICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZWREYXlPZk1vbnRoKG4pIHtcbiAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG4pIHx8IG4gPCAxIHx8IG4gPiAzMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkRheSBvZiBtb250aCBtdXN0IGJlIGFuIGludGVnZXIgZnJvbSAxIHRvIDMxXCIpO1xuICB9XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVkRGF5T2ZXZWVrKHMpIHtcbiAgaWYgKCFEQVlTX09GX1dFRUsuaW5jbHVkZXMocykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RheSBvZiB3ZWVrIG11c3QgYmUgYSBzdHJpbmcgbGlrZSBcIm1vbmRheVwiLicpO1xuICB9XG4gIHJldHVybiBzO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVkSG91ck9mRGF5KG4pIHtcbiAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG4pIHx8IG4gPCAwIHx8IG4gPiAyMykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkhvdXIgb2YgZGF5IG11c3QgYmUgYW4gaW50ZWdlciBmcm9tIDAgdG8gMjNcIik7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiB2YWxpZGF0ZWRNaW51dGVPZkhvdXIobikge1xuICBpZiAoIU51bWJlci5pc0ludGVnZXIobikgfHwgbiA8IDAgfHwgbiA+IDU5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWludXRlIG9mIGhvdXIgbXVzdCBiZSBhbiBpbnRlZ2VyIGZyb20gMCB0byA1OVwiKTtcbiAgfVxuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlZENyb25TdHJpbmcocykge1xuICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlZENyb25JZGVudGlmaWVyKHMpIHtcbiAgaWYgKCFzLm1hdGNoKC9eWyAtfl0qJC8pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFsaWQgY3JvbiBpZGVudGlmaWVyICR7c306IHVzZSBBU0NJSSBsZXR0ZXJzIHRoYXQgYXJlIG5vdCBjb250cm9sIGNoYXJhY3RlcnNgXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcztcbn1cbmV4cG9ydCBjbGFzcyBDcm9ucyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjcm9uc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaXNDcm9uc1wiKTtcbiAgICB0aGlzLmlzQ3JvbnMgPSB0cnVlO1xuICAgIHRoaXMuY3JvbnMgPSB7fTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHNjaGVkdWxlKGNyb25JZGVudGlmaWVyLCBzY2hlZHVsZSwgZnVuY3Rpb25SZWZlcmVuY2UsIGFyZ3MpIHtcbiAgICBjb25zdCBjcm9uQXJncyA9IHBhcnNlQXJncyhhcmdzKTtcbiAgICB2YWxpZGF0ZWRDcm9uSWRlbnRpZmllcihjcm9uSWRlbnRpZmllcik7XG4gICAgaWYgKGNyb25JZGVudGlmaWVyIGluIHRoaXMuY3JvbnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ3JvbiBpZGVudGlmaWVyIHJlZ2lzdGVyZWQgdHdpY2U6ICR7Y3JvbklkZW50aWZpZXJ9YCk7XG4gICAgfVxuICAgIHRoaXMuY3JvbnNbY3JvbklkZW50aWZpZXJdID0ge1xuICAgICAgbmFtZTogZ2V0RnVuY3Rpb25OYW1lKGZ1bmN0aW9uUmVmZXJlbmNlKSxcbiAgICAgIGFyZ3M6IFtjb252ZXhUb0pzb24oY3JvbkFyZ3MpXSxcbiAgICAgIHNjaGVkdWxlXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogU2NoZWR1bGUgYSBtdXRhdGlvbiBvciBhY3Rpb24gdG8gcnVuIGF0IHNvbWUgaW50ZXJ2YWwuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGNyb25zLmludGVydmFsKFwiQ2xlYXIgcHJlc2VuY2UgZGF0YVwiLCB7c2Vjb25kczogMzB9LCBhcGkucHJlc2VuY2UuY2xlYXIpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIGlkZW50aWZpZXIgLSBBIHVuaXF1ZSBuYW1lIGZvciB0aGlzIHNjaGVkdWxlZCBqb2IuXG4gICAqIEBwYXJhbSBzY2hlZHVsZSAtIFRoZSB0aW1lIGJldHdlZW4gcnVucyBmb3IgdGhpcyBzY2hlZHVsZWQgam9iLlxuICAgKiBAcGFyYW0gZnVuY3Rpb25SZWZlcmVuY2UgLSBBIHtAbGluayBGdW5jdGlvblJlZmVyZW5jZX0gZm9yIHRoZSBmdW5jdGlvblxuICAgKiB0byBzY2hlZHVsZS5cbiAgICogQHBhcmFtIGFyZ3MgLSBUaGUgYXJndW1lbnRzIHRvIHRoZSBmdW5jdGlvbi5cbiAgICovXG4gIGludGVydmFsKGNyb25JZGVudGlmaWVyLCBzY2hlZHVsZSwgZnVuY3Rpb25SZWZlcmVuY2UsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBzID0gc2NoZWR1bGU7XG4gICAgY29uc3QgaGFzU2Vjb25kcyA9ICsoXCJzZWNvbmRzXCIgaW4gcyAmJiBzLnNlY29uZHMgIT09IHZvaWQgMCk7XG4gICAgY29uc3QgaGFzTWludXRlcyA9ICsoXCJtaW51dGVzXCIgaW4gcyAmJiBzLm1pbnV0ZXMgIT09IHZvaWQgMCk7XG4gICAgY29uc3QgaGFzSG91cnMgPSArKFwiaG91cnNcIiBpbiBzICYmIHMuaG91cnMgIT09IHZvaWQgMCk7XG4gICAgY29uc3QgdG90YWwgPSBoYXNTZWNvbmRzICsgaGFzTWludXRlcyArIGhhc0hvdXJzO1xuICAgIGlmICh0b3RhbCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBzcGVjaWZ5IG9uZSBvZiBzZWNvbmRzLCBtaW51dGVzLCBvciBob3Vyc1wiKTtcbiAgICB9XG4gICAgaWYgKGhhc1NlY29uZHMpIHtcbiAgICAgIHZhbGlkYXRlSW50ZXJ2YWxOdW1iZXIoc2NoZWR1bGUuc2Vjb25kcyk7XG4gICAgfSBlbHNlIGlmIChoYXNNaW51dGVzKSB7XG4gICAgICB2YWxpZGF0ZUludGVydmFsTnVtYmVyKHNjaGVkdWxlLm1pbnV0ZXMpO1xuICAgIH0gZWxzZSBpZiAoaGFzSG91cnMpIHtcbiAgICAgIHZhbGlkYXRlSW50ZXJ2YWxOdW1iZXIoc2NoZWR1bGUuaG91cnMpO1xuICAgIH1cbiAgICB0aGlzLnNjaGVkdWxlKFxuICAgICAgY3JvbklkZW50aWZpZXIsXG4gICAgICB7IC4uLnNjaGVkdWxlLCB0eXBlOiBcImludGVydmFsXCIgfSxcbiAgICAgIGZ1bmN0aW9uUmVmZXJlbmNlLFxuICAgICAgLi4uYXJnc1xuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFNjaGVkdWxlIGEgbXV0YXRpb24gb3IgYWN0aW9uIHRvIHJ1biBvbiBhbiBob3VybHkgYmFzaXMuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGNyb25zLmhvdXJseShcbiAgICogICBcIlJlc2V0IGhpZ2ggc2NvcmVzXCIsXG4gICAqICAge1xuICAgKiAgICAgbWludXRlVVRDOiAzMCxcbiAgICogICB9LFxuICAgKiAgIGFwaS5zY29yZXMucmVzZXRcbiAgICogKVxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIGNyb25JZGVudGlmaWVyIC0gQSB1bmlxdWUgbmFtZSBmb3IgdGhpcyBzY2hlZHVsZWQgam9iLlxuICAgKiBAcGFyYW0gc2NoZWR1bGUgLSBXaGF0IHRpbWUgKFVUQykgZWFjaCBkYXkgdG8gcnVuIHRoaXMgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSBmdW5jdGlvblJlZmVyZW5jZSAtIEEge0BsaW5rIEZ1bmN0aW9uUmVmZXJlbmNlfSBmb3IgdGhlIGZ1bmN0aW9uXG4gICAqIHRvIHNjaGVkdWxlLlxuICAgKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgdG8gdGhlIGZ1bmN0aW9uLlxuICAgKi9cbiAgaG91cmx5KGNyb25JZGVudGlmaWVyLCBzY2hlZHVsZSwgZnVuY3Rpb25SZWZlcmVuY2UsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBtaW51dGVVVEMgPSB2YWxpZGF0ZWRNaW51dGVPZkhvdXIoc2NoZWR1bGUubWludXRlVVRDKTtcbiAgICB0aGlzLnNjaGVkdWxlKFxuICAgICAgY3JvbklkZW50aWZpZXIsXG4gICAgICB7IG1pbnV0ZVVUQywgdHlwZTogXCJob3VybHlcIiB9LFxuICAgICAgZnVuY3Rpb25SZWZlcmVuY2UsXG4gICAgICAuLi5hcmdzXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogU2NoZWR1bGUgYSBtdXRhdGlvbiBvciBhY3Rpb24gdG8gcnVuIG9uIGEgZGFpbHkgYmFzaXMuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGNyb25zLmRhaWx5KFxuICAgKiAgIFwiUmVzZXQgaGlnaCBzY29yZXNcIixcbiAgICogICB7XG4gICAqICAgICBob3VyVVRDOiAxNywgLy8gKDk6MzBhbSBQYWNpZmljLzEwOjMwYW0gRGF5bGlnaHQgU2F2aW5ncyBQYWNpZmljKVxuICAgKiAgICAgbWludXRlVVRDOiAzMCxcbiAgICogICB9LFxuICAgKiAgIGFwaS5zY29yZXMucmVzZXRcbiAgICogKVxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIGNyb25JZGVudGlmaWVyIC0gQSB1bmlxdWUgbmFtZSBmb3IgdGhpcyBzY2hlZHVsZWQgam9iLlxuICAgKiBAcGFyYW0gc2NoZWR1bGUgLSBXaGF0IHRpbWUgKFVUQykgZWFjaCBkYXkgdG8gcnVuIHRoaXMgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSBmdW5jdGlvblJlZmVyZW5jZSAtIEEge0BsaW5rIEZ1bmN0aW9uUmVmZXJlbmNlfSBmb3IgdGhlIGZ1bmN0aW9uXG4gICAqIHRvIHNjaGVkdWxlLlxuICAgKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgdG8gdGhlIGZ1bmN0aW9uLlxuICAgKi9cbiAgZGFpbHkoY3JvbklkZW50aWZpZXIsIHNjaGVkdWxlLCBmdW5jdGlvblJlZmVyZW5jZSwgLi4uYXJncykge1xuICAgIGNvbnN0IGhvdXJVVEMgPSB2YWxpZGF0ZWRIb3VyT2ZEYXkoc2NoZWR1bGUuaG91clVUQyk7XG4gICAgY29uc3QgbWludXRlVVRDID0gdmFsaWRhdGVkTWludXRlT2ZIb3VyKHNjaGVkdWxlLm1pbnV0ZVVUQyk7XG4gICAgdGhpcy5zY2hlZHVsZShcbiAgICAgIGNyb25JZGVudGlmaWVyLFxuICAgICAgeyBob3VyVVRDLCBtaW51dGVVVEMsIHR5cGU6IFwiZGFpbHlcIiB9LFxuICAgICAgZnVuY3Rpb25SZWZlcmVuY2UsXG4gICAgICAuLi5hcmdzXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogU2NoZWR1bGUgYSBtdXRhdGlvbiBvciBhY3Rpb24gdG8gcnVuIG9uIGEgd2Vla2x5IGJhc2lzLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBjcm9ucy53ZWVrbHkoXG4gICAqICAgXCJXZWVrbHkgcmUtZW5nYWdlbWVudCBlbWFpbFwiLFxuICAgKiAgIHtcbiAgICogICAgIGRheU9mV2VlazogXCJUdWVzZGF5XCIsXG4gICAqICAgICBob3VyVVRDOiAxNywgLy8gKDk6MzBhbSBQYWNpZmljLzEwOjMwYW0gRGF5bGlnaHQgU2F2aW5ncyBQYWNpZmljKVxuICAgKiAgICAgbWludXRlVVRDOiAzMCxcbiAgICogICB9LFxuICAgKiAgIGFwaS5lbWFpbHMuc2VuZFxuICAgKiApXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gY3JvbklkZW50aWZpZXIgLSBBIHVuaXF1ZSBuYW1lIGZvciB0aGlzIHNjaGVkdWxlZCBqb2IuXG4gICAqIEBwYXJhbSBzY2hlZHVsZSAtIFdoYXQgZGF5IGFuZCB0aW1lIChVVEMpIGVhY2ggd2VlayB0byBydW4gdGhpcyBmdW5jdGlvbi5cbiAgICogQHBhcmFtIGZ1bmN0aW9uUmVmZXJlbmNlIC0gQSB7QGxpbmsgRnVuY3Rpb25SZWZlcmVuY2V9IGZvciB0aGUgZnVuY3Rpb25cbiAgICogdG8gc2NoZWR1bGUuXG4gICAqL1xuICB3ZWVrbHkoY3JvbklkZW50aWZpZXIsIHNjaGVkdWxlLCBmdW5jdGlvblJlZmVyZW5jZSwgLi4uYXJncykge1xuICAgIGNvbnN0IGRheU9mV2VlayA9IHZhbGlkYXRlZERheU9mV2VlayhzY2hlZHVsZS5kYXlPZldlZWspO1xuICAgIGNvbnN0IGhvdXJVVEMgPSB2YWxpZGF0ZWRIb3VyT2ZEYXkoc2NoZWR1bGUuaG91clVUQyk7XG4gICAgY29uc3QgbWludXRlVVRDID0gdmFsaWRhdGVkTWludXRlT2ZIb3VyKHNjaGVkdWxlLm1pbnV0ZVVUQyk7XG4gICAgdGhpcy5zY2hlZHVsZShcbiAgICAgIGNyb25JZGVudGlmaWVyLFxuICAgICAgeyBkYXlPZldlZWssIGhvdXJVVEMsIG1pbnV0ZVVUQywgdHlwZTogXCJ3ZWVrbHlcIiB9LFxuICAgICAgZnVuY3Rpb25SZWZlcmVuY2UsXG4gICAgICAuLi5hcmdzXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogU2NoZWR1bGUgYSBtdXRhdGlvbiBvciBhY3Rpb24gdG8gcnVuIG9uIGEgbW9udGhseSBiYXNpcy5cbiAgICpcbiAgICogTm90ZSB0aGF0IHNvbWUgbW9udGhzIGhhdmUgZmV3ZXIgZGF5cyB0aGFuIG90aGVycywgc28gZS5nLiBhIGZ1bmN0aW9uXG4gICAqIHNjaGVkdWxlZCB0byBydW4gb24gdGhlIDMwdGggd2lsbCBub3QgcnVuIGluIEZlYnJ1YXJ5LlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBjcm9ucy5tb250aGx5KFxuICAgKiAgIFwiQmlsbCBjdXN0b21lcnMgYXQgXCIsXG4gICAqICAge1xuICAgKiAgICAgaG91clVUQzogMTcsIC8vICg5OjMwYW0gUGFjaWZpYy8xMDozMGFtIERheWxpZ2h0IFNhdmluZ3MgUGFjaWZpYylcbiAgICogICAgIG1pbnV0ZVVUQzogMzAsXG4gICAqICAgICBkYXk6IDEsXG4gICAqICAgfSxcbiAgICogICBhcGkuYmlsbGluZy5iaWxsQ3VzdG9tZXJzXG4gICAqIClcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBjcm9uSWRlbnRpZmllciAtIEEgdW5pcXVlIG5hbWUgZm9yIHRoaXMgc2NoZWR1bGVkIGpvYi5cbiAgICogQHBhcmFtIHNjaGVkdWxlIC0gV2hhdCBkYXkgYW5kIHRpbWUgKFVUQykgZWFjaCBtb250aCB0byBydW4gdGhpcyBmdW5jdGlvbi5cbiAgICogQHBhcmFtIGZ1bmN0aW9uUmVmZXJlbmNlIC0gQSB7QGxpbmsgRnVuY3Rpb25SZWZlcmVuY2V9IGZvciB0aGUgZnVuY3Rpb25cbiAgICogdG8gc2NoZWR1bGUuXG4gICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyB0byB0aGUgZnVuY3Rpb24uXG4gICAqL1xuICBtb250aGx5KGNyb25JZGVudGlmaWVyLCBzY2hlZHVsZSwgZnVuY3Rpb25SZWZlcmVuY2UsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBkYXkgPSB2YWxpZGF0ZWREYXlPZk1vbnRoKHNjaGVkdWxlLmRheSk7XG4gICAgY29uc3QgaG91clVUQyA9IHZhbGlkYXRlZEhvdXJPZkRheShzY2hlZHVsZS5ob3VyVVRDKTtcbiAgICBjb25zdCBtaW51dGVVVEMgPSB2YWxpZGF0ZWRNaW51dGVPZkhvdXIoc2NoZWR1bGUubWludXRlVVRDKTtcbiAgICB0aGlzLnNjaGVkdWxlKFxuICAgICAgY3JvbklkZW50aWZpZXIsXG4gICAgICB7IGRheSwgaG91clVUQywgbWludXRlVVRDLCB0eXBlOiBcIm1vbnRobHlcIiB9LFxuICAgICAgZnVuY3Rpb25SZWZlcmVuY2UsXG4gICAgICAuLi5hcmdzXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogU2NoZWR1bGUgYSBtdXRhdGlvbiBvciBhY3Rpb24gdG8gcnVuIG9uIGEgcmVjdXJyaW5nIGJhc2lzLlxuICAgKlxuICAgKiBMaWtlIHRoZSB1bml4IGNvbW1hbmQgYGNyb25gLCBTdW5kYXkgaXMgMCwgTW9uZGF5IGlzIDEsIGV0Yy5cbiAgICpcbiAgICogYGBgXG4gICAqICDilIzilIAgbWludXRlICgwIC0gNTkpXG4gICAqICDilIIg4pSM4pSAIGhvdXIgKDAgLSAyMylcbiAgICogIOKUgiDilIIg4pSM4pSAIGRheSBvZiB0aGUgbW9udGggKDEgLSAzMSlcbiAgICogIOKUgiDilIIg4pSCIOKUjOKUgCBtb250aCAoMSAtIDEyKVxuICAgKiAg4pSCIOKUgiDilIIg4pSCIOKUjOKUgCBkYXkgb2YgdGhlIHdlZWsgKDAgLSA2KSAoU3VuZGF5IHRvIFNhdHVyZGF5KVxuICAgKiBcIiogKiAqICogKlwiXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gY3JvbklkZW50aWZpZXIgLSBBIHVuaXF1ZSBuYW1lIGZvciB0aGlzIHNjaGVkdWxlZCBqb2IuXG4gICAqIEBwYXJhbSBjcm9uIC0gQ3JvbiBzdHJpbmcgbGlrZSBgXCIxNSA3ICogKiAqXCJgIChFdmVyeSBkYXkgYXQgNzoxNSBVVEMpXG4gICAqIEBwYXJhbSBmdW5jdGlvblJlZmVyZW5jZSAtIEEge0BsaW5rIEZ1bmN0aW9uUmVmZXJlbmNlfSBmb3IgdGhlIGZ1bmN0aW9uXG4gICAqIHRvIHNjaGVkdWxlLlxuICAgKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgdG8gdGhlIGZ1bmN0aW9uLlxuICAgKi9cbiAgY3Jvbihjcm9uSWRlbnRpZmllciwgY3JvbiwgZnVuY3Rpb25SZWZlcmVuY2UsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBjID0gdmFsaWRhdGVkQ3JvblN0cmluZyhjcm9uKTtcbiAgICB0aGlzLnNjaGVkdWxlKFxuICAgICAgY3JvbklkZW50aWZpZXIsXG4gICAgICB7IGNyb246IGMsIHR5cGU6IFwiY3JvblwiIH0sXG4gICAgICBmdW5jdGlvblJlZmVyZW5jZSxcbiAgICAgIC4uLmFyZ3NcbiAgICApO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZXhwb3J0KCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLmNyb25zKTtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3Jvbi5qcy5tYXBcbiIsImltcG9ydCB7IGdldEZ1bmN0aW9uTmFtZSwgT3B0aW9uYWxSZXN0QXJncyB9IGZyb20gXCIuLi9zZXJ2ZXIvYXBpLmpzXCI7XG5pbXBvcnQgeyBwYXJzZUFyZ3MgfSBmcm9tIFwiLi4vY29tbW9uL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBjb252ZXhUb0pzb24sIEpTT05WYWx1ZSwgVmFsdWUgfSBmcm9tIFwiLi4vdmFsdWVzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBTY2hlZHVsYWJsZUZ1bmN0aW9uUmVmZXJlbmNlIH0gZnJvbSBcIi4vc2NoZWR1bGVyLmpzXCI7XG5cbnR5cGUgQ3JvblNjaGVkdWxlID0ge1xuICB0eXBlOiBcImNyb25cIjtcbiAgY3Jvbjogc3RyaW5nO1xufTtcbi8qKiBAcHVibGljICovXG5leHBvcnQgdHlwZSBJbnRlcnZhbFNjaGVkdWxlID1cbiAgfCB7IHR5cGU6IFwiaW50ZXJ2YWxcIjsgc2Vjb25kczogbnVtYmVyIH1cbiAgfCB7IHR5cGU6IFwiaW50ZXJ2YWxcIjsgbWludXRlczogbnVtYmVyIH1cbiAgfCB7IHR5cGU6IFwiaW50ZXJ2YWxcIjsgaG91cnM6IG51bWJlciB9O1xuLyoqIEBwdWJsaWMgKi9cbmV4cG9ydCB0eXBlIEhvdXJseVNjaGVkdWxlID0ge1xuICB0eXBlOiBcImhvdXJseVwiO1xuICBtaW51dGVVVEM6IG51bWJlcjtcbn07XG4vKiogQHB1YmxpYyAqL1xuZXhwb3J0IHR5cGUgRGFpbHlTY2hlZHVsZSA9IHtcbiAgdHlwZTogXCJkYWlseVwiO1xuICBob3VyVVRDOiBudW1iZXI7XG4gIG1pbnV0ZVVUQzogbnVtYmVyO1xufTtcbmNvbnN0IERBWVNfT0ZfV0VFSyA9IFtcbiAgXCJzdW5kYXlcIixcbiAgXCJtb25kYXlcIixcbiAgXCJ0dWVzZGF5XCIsXG4gIFwid2VkbmVzZGF5XCIsXG4gIFwidGh1cnNkYXlcIixcbiAgXCJmcmlkYXlcIixcbiAgXCJzYXR1cmRheVwiLFxuXSBhcyBjb25zdDtcbnR5cGUgRGF5T2ZXZWVrID0gKHR5cGVvZiBEQVlTX09GX1dFRUspW251bWJlcl07XG4vKiogQHB1YmxpYyAqL1xuZXhwb3J0IHR5cGUgV2Vla2x5U2NoZWR1bGUgPSB7XG4gIHR5cGU6IFwid2Vla2x5XCI7XG4gIGRheU9mV2VlazogRGF5T2ZXZWVrO1xuICBob3VyVVRDOiBudW1iZXI7XG4gIG1pbnV0ZVVUQzogbnVtYmVyO1xufTtcbi8qKiBAcHVibGljICovXG5leHBvcnQgdHlwZSBNb250aGx5U2NoZWR1bGUgPSB7XG4gIHR5cGU6IFwibW9udGhseVwiO1xuICBkYXk6IG51bWJlcjtcbiAgaG91clVUQzogbnVtYmVyO1xuICBtaW51dGVVVEM6IG51bWJlcjtcbn07XG5cbi8vIER1cGxpY2F0aW5nIHR5cGVzIHNvIGRvY3N0cmluZ3MgYXJlIHZpc2libGUgaW4gc2lnbmF0dXJlczpcbi8vIGBFeHBhbmQ8T21pdDxNb250aGx5U2NoZWR1bGUsIFwidHlwZVwiPj5gIGRvZXNuJ3QgcHJlc2VydmUgZG9jc3RyaW5ncy5cbi8vIFdoZW4gd2UgZ2V0IHRvIFR5cGVTY3JpcHQgNC45LCBgc2F0aXNmaWVzYCB3b3VsZCBnbyBuaWNlbHkgaGVyZS5cblxuLyoqIEBwdWJsaWMgKi9cbmV4cG9ydCB0eXBlIEludGVydmFsID1cbiAgfCB7XG4gICAgICAvKipcbiAgICAgICAqIFJ1biBhIGpvYiBldmVyeSBgc2Vjb25kc2Agc2Vjb25kcywgYmVnaW5uaW5nXG4gICAgICAgKiB3aGVuIHRoZSBqb2IgaXMgZmlyc3QgZGVwbG95ZWQgdG8gQ29udmV4LlxuICAgICAgICovXG4gICAgICBzZWNvbmRzOiBudW1iZXI7XG4gICAgICBtaW51dGVzPzogdW5kZWZpbmVkO1xuICAgICAgaG91cnM/OiB1bmRlZmluZWQ7XG4gICAgfVxuICB8IHtcbiAgICAgIC8qKlxuICAgICAgICogUnVuIGEgam9iIGV2ZXJ5IGBtaW51dGVzYCBtaW51dGVzLCBiZWdpbm5pbmdcbiAgICAgICAqIHdoZW4gdGhlIGpvYiBpcyBmaXJzdCBkZXBsb3llZCB0byBDb252ZXguXG4gICAgICAgKi9cbiAgICAgIG1pbnV0ZXM6IG51bWJlcjtcbiAgICAgIHNlY29uZHM/OiB1bmRlZmluZWQ7XG4gICAgICBob3Vycz86IHVuZGVmaW5lZDtcbiAgICB9XG4gIHwge1xuICAgICAgLyoqXG4gICAgICAgKiBSdW4gYSBqb2IgZXZlcnkgYGhvdXJzYCBob3VycywgYmVnaW5uaW5nIHdoZW5cbiAgICAgICAqIHdoZW4gdGhlIGpvYiBpcyBmaXJzdCBkZXBsb3llZCB0byBDb252ZXguXG4gICAgICAgKi9cbiAgICAgIGhvdXJzOiBudW1iZXI7XG4gICAgICBzZWNvbmRzPzogdW5kZWZpbmVkO1xuICAgICAgbWludXRlcz86IHVuZGVmaW5lZDtcbiAgICB9O1xuXG4vKiogQHB1YmxpYyAqL1xuZXhwb3J0IHR5cGUgSG91cmx5ID0ge1xuICAvKipcbiAgICogTWludXRlcyBwYXN0IHRoZSBob3VyLCAwLTU5LlxuICAgKi9cbiAgbWludXRlVVRDOiBudW1iZXI7XG59O1xuXG4vKiogQHB1YmxpYyAqL1xuZXhwb3J0IHR5cGUgRGFpbHkgPSB7XG4gIC8qKlxuICAgKiAwLTIzLCBob3VyIG9mIGRheS4gUmVtZW1iZXIsIHRoaXMgaXMgVVRDLlxuICAgKi9cbiAgaG91clVUQzogbnVtYmVyO1xuICAvKipcbiAgICogMC01OSwgbWludXRlIG9mIGhvdXIuIFJlbWVtYmVyLCB0aGlzIGlzIFVUQy5cbiAgICovXG4gIG1pbnV0ZVVUQzogbnVtYmVyO1xufTtcblxuLyoqIEBwdWJsaWMgKi9cbmV4cG9ydCB0eXBlIE1vbnRobHkgPSB7XG4gIC8qKlxuICAgKiAxLTMxLCBkYXkgb2YgbW9udGguIERheXMgZ3JlYXRlciB0aGF0IDI4IHdpbGwgbm90IHJ1biBldmVyeSBtb250aC5cbiAgICovXG4gIGRheTogbnVtYmVyO1xuICAvKipcbiAgICogMC0yMywgaG91ciBvZiBkYXkuIFJlbWVtYmVyIHRvIGNvbnZlcnQgZnJvbSB5b3VyIG93biB0aW1lIHpvbmUgdG8gVVRDLlxuICAgKi9cbiAgaG91clVUQzogbnVtYmVyO1xuICAvKipcbiAgICogMC01OSwgbWludXRlIG9mIGhvdXIuIFJlbWVtYmVyIHRvIGNvbnZlcnQgZnJvbSB5b3VyIG93biB0aW1lIHpvbmUgdG8gVVRDLlxuICAgKi9cbiAgbWludXRlVVRDOiBudW1iZXI7XG59O1xuLyoqIEBwdWJsaWMgKi9cbmV4cG9ydCB0eXBlIFdlZWtseSA9IHtcbiAgLyoqXG4gICAqIFwibW9uZGF5XCIsIFwidHVlc2RheVwiLCBldGMuXG4gICAqL1xuICBkYXlPZldlZWs6IERheU9mV2VlaztcbiAgLyoqXG4gICAqIDAtMjMsIGhvdXIgb2YgZGF5LiBSZW1lbWJlciB0byBjb252ZXJ0IGZyb20geW91ciBvd24gdGltZSB6b25lIHRvIFVUQy5cbiAgICovXG4gIGhvdXJVVEM6IG51bWJlcjtcbiAgLyoqXG4gICAqIDAtNTksIG1pbnV0ZSBvZiBob3VyLiBSZW1lbWJlciB0byBjb252ZXJ0IGZyb20geW91ciBvd24gdGltZSB6b25lIHRvIFVUQy5cbiAgICovXG4gIG1pbnV0ZVVUQzogbnVtYmVyO1xufTtcblxuLyoqIEBwdWJsaWMgKi9cbmV4cG9ydCB0eXBlIFNjaGVkdWxlID1cbiAgfCBDcm9uU2NoZWR1bGVcbiAgfCBJbnRlcnZhbFNjaGVkdWxlXG4gIHwgSG91cmx5U2NoZWR1bGVcbiAgfCBEYWlseVNjaGVkdWxlXG4gIHwgV2Vla2x5U2NoZWR1bGVcbiAgfCBNb250aGx5U2NoZWR1bGU7XG5cbi8qKlxuICogQSBzY2hlZHVsZSB0byBydW4gYSBDb252ZXggbXV0YXRpb24gb3IgYWN0aW9uIG9uLlxuICogWW91IGNhbiBzY2hlZHVsZSBDb252ZXggZnVuY3Rpb25zIHRvIHJ1biByZWd1bGFybHkgd2l0aFxuICoge0BsaW5rIGludGVydmFsfSBhbmQgZXhwb3J0aW5nIGl0LlxuICpcbiAqIEBwdWJsaWNcbiAqKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ3JvbkpvYiB7XG4gIG5hbWU6IHN0cmluZztcbiAgYXJnczogSlNPTlZhbHVlO1xuICBzY2hlZHVsZTogU2NoZWR1bGU7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgQ3JvbkpvYnMgb2JqZWN0IHRvIHNjaGVkdWxlIHJlY3VycmluZyB0YXNrcy5cbiAqXG4gKiBgYGBqc1xuICogLy8gY29udmV4L2Nyb25zLmpzXG4gKiBpbXBvcnQgeyBjcm9uSm9icyB9IGZyb20gJ2NvbnZleC9zZXJ2ZXInO1xuICogaW1wb3J0IHsgYXBpIH0gZnJvbSBcIi4vX2dlbmVyYXRlZC9hcGlcIjtcbiAqXG4gKiBjb25zdCBjcm9ucyA9IGNyb25Kb2JzKCk7XG4gKiBjcm9ucy53ZWVrbHkoXG4gKiAgIFwid2Vla2x5IHJlLWVuZ2FnZW1lbnQgZW1haWxcIixcbiAqICAge1xuICogICAgIGhvdXJVVEM6IDE3LCAvLyAoOTozMGFtIFBhY2lmaWMvMTA6MzBhbSBEYXlsaWdodCBTYXZpbmdzIFBhY2lmaWMpXG4gKiAgICAgbWludXRlVVRDOiAzMCxcbiAqICAgfSxcbiAqICAgYXBpLmVtYWlscy5zZW5kXG4gKiApXG4gKiBleHBvcnQgZGVmYXVsdCBjcm9ucztcbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGNyb25Kb2JzID0gKCkgPT4gbmV3IENyb25zKCk7XG5cbi8qKlxuICogQHB1YmxpY1xuICpcbiAqIFRoaXMgaXMgYSBjcm9uIHN0cmluZy4gVGhleSdyZSBjb21wbGljYXRlZCFcbiAqL1xudHlwZSBDcm9uU3RyaW5nID0gc3RyaW5nO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZUludGVydmFsTnVtYmVyKG46IG51bWJlcikge1xuICBpZiAoIU51bWJlci5pc0ludGVnZXIobikgfHwgbiA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW50ZXJ2YWwgbXVzdCBiZSBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiAwXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlZERheU9mTW9udGgobjogbnVtYmVyKSB7XG4gIGlmICghTnVtYmVyLmlzSW50ZWdlcihuKSB8fCBuIDwgMSB8fCBuID4gMzEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXkgb2YgbW9udGggbXVzdCBiZSBhbiBpbnRlZ2VyIGZyb20gMSB0byAzMVwiKTtcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVkRGF5T2ZXZWVrKHM6IHN0cmluZykge1xuICBpZiAoIURBWVNfT0ZfV0VFSy5pbmNsdWRlcyhzIGFzIERheU9mV2VlaykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RheSBvZiB3ZWVrIG11c3QgYmUgYSBzdHJpbmcgbGlrZSBcIm1vbmRheVwiLicpO1xuICB9XG4gIHJldHVybiBzIGFzIERheU9mV2Vlaztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVkSG91ck9mRGF5KG46IG51bWJlcikge1xuICBpZiAoIU51bWJlci5pc0ludGVnZXIobikgfHwgbiA8IDAgfHwgbiA+IDIzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSG91ciBvZiBkYXkgbXVzdCBiZSBhbiBpbnRlZ2VyIGZyb20gMCB0byAyM1wiKTtcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVkTWludXRlT2ZIb3VyKG46IG51bWJlcikge1xuICBpZiAoIU51bWJlci5pc0ludGVnZXIobikgfHwgbiA8IDAgfHwgbiA+IDU5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWludXRlIG9mIGhvdXIgbXVzdCBiZSBhbiBpbnRlZ2VyIGZyb20gMCB0byA1OVwiKTtcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVkQ3JvblN0cmluZyhzOiBzdHJpbmcpIHtcbiAgcmV0dXJuIHM7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlZENyb25JZGVudGlmaWVyKHM6IHN0cmluZykge1xuICBpZiAoIXMubWF0Y2goL15bIC1+XSokLykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgSW52YWxpZCBjcm9uIGlkZW50aWZpZXIgJHtzfTogdXNlIEFTQ0lJIGxldHRlcnMgdGhhdCBhcmUgbm90IGNvbnRyb2wgY2hhcmFjdGVyc2AsXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcztcbn1cblxuLyoqXG4gKiBBIGNsYXNzIGZvciBzY2hlZHVsaW5nIGNyb24gam9icy5cbiAqXG4gKiBUbyBsZWFybiBtb3JlIHNlZSB0aGUgZG9jdW1lbnRhdGlvbiBhdCBodHRwczovL2RvY3MuY29udmV4LmRldi9zY2hlZHVsaW5nL2Nyb24tam9ic1xuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIENyb25zIHtcbiAgY3JvbnM6IFJlY29yZDxzdHJpbmcsIENyb25Kb2I+O1xuICBpc0Nyb25zOiB0cnVlO1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmlzQ3JvbnMgPSB0cnVlO1xuICAgIHRoaXMuY3JvbnMgPSB7fTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2NoZWR1bGUoXG4gICAgY3JvbklkZW50aWZpZXI6IHN0cmluZyxcbiAgICBzY2hlZHVsZTogU2NoZWR1bGUsXG4gICAgZnVuY3Rpb25SZWZlcmVuY2U6IFNjaGVkdWxhYmxlRnVuY3Rpb25SZWZlcmVuY2UsXG4gICAgYXJncz86IFJlY29yZDxzdHJpbmcsIFZhbHVlPixcbiAgKSB7XG4gICAgY29uc3QgY3JvbkFyZ3MgPSBwYXJzZUFyZ3MoYXJncyk7XG4gICAgdmFsaWRhdGVkQ3JvbklkZW50aWZpZXIoY3JvbklkZW50aWZpZXIpO1xuICAgIGlmIChjcm9uSWRlbnRpZmllciBpbiB0aGlzLmNyb25zKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENyb24gaWRlbnRpZmllciByZWdpc3RlcmVkIHR3aWNlOiAke2Nyb25JZGVudGlmaWVyfWApO1xuICAgIH1cbiAgICB0aGlzLmNyb25zW2Nyb25JZGVudGlmaWVyXSA9IHtcbiAgICAgIG5hbWU6IGdldEZ1bmN0aW9uTmFtZShmdW5jdGlvblJlZmVyZW5jZSksXG4gICAgICBhcmdzOiBbY29udmV4VG9Kc29uKGNyb25BcmdzKV0sXG4gICAgICBzY2hlZHVsZTogc2NoZWR1bGUsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTY2hlZHVsZSBhIG11dGF0aW9uIG9yIGFjdGlvbiB0byBydW4gYXQgc29tZSBpbnRlcnZhbC5cbiAgICpcbiAgICogYGBganNcbiAgICogY3JvbnMuaW50ZXJ2YWwoXCJDbGVhciBwcmVzZW5jZSBkYXRhXCIsIHtzZWNvbmRzOiAzMH0sIGFwaS5wcmVzZW5jZS5jbGVhcik7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gaWRlbnRpZmllciAtIEEgdW5pcXVlIG5hbWUgZm9yIHRoaXMgc2NoZWR1bGVkIGpvYi5cbiAgICogQHBhcmFtIHNjaGVkdWxlIC0gVGhlIHRpbWUgYmV0d2VlbiBydW5zIGZvciB0aGlzIHNjaGVkdWxlZCBqb2IuXG4gICAqIEBwYXJhbSBmdW5jdGlvblJlZmVyZW5jZSAtIEEge0BsaW5rIEZ1bmN0aW9uUmVmZXJlbmNlfSBmb3IgdGhlIGZ1bmN0aW9uXG4gICAqIHRvIHNjaGVkdWxlLlxuICAgKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgdG8gdGhlIGZ1bmN0aW9uLlxuICAgKi9cbiAgaW50ZXJ2YWw8RnVuY1JlZiBleHRlbmRzIFNjaGVkdWxhYmxlRnVuY3Rpb25SZWZlcmVuY2U+KFxuICAgIGNyb25JZGVudGlmaWVyOiBzdHJpbmcsXG4gICAgc2NoZWR1bGU6IEludGVydmFsLFxuICAgIGZ1bmN0aW9uUmVmZXJlbmNlOiBGdW5jUmVmLFxuICAgIC4uLmFyZ3M6IE9wdGlvbmFsUmVzdEFyZ3M8RnVuY1JlZj5cbiAgKSB7XG4gICAgY29uc3QgcyA9IHNjaGVkdWxlO1xuICAgIGNvbnN0IGhhc1NlY29uZHMgPSArKFwic2Vjb25kc1wiIGluIHMgJiYgcy5zZWNvbmRzICE9PSB1bmRlZmluZWQpO1xuICAgIGNvbnN0IGhhc01pbnV0ZXMgPSArKFwibWludXRlc1wiIGluIHMgJiYgcy5taW51dGVzICE9PSB1bmRlZmluZWQpO1xuICAgIGNvbnN0IGhhc0hvdXJzID0gKyhcImhvdXJzXCIgaW4gcyAmJiBzLmhvdXJzICE9PSB1bmRlZmluZWQpO1xuICAgIGNvbnN0IHRvdGFsID0gaGFzU2Vjb25kcyArIGhhc01pbnV0ZXMgKyBoYXNIb3VycztcbiAgICBpZiAodG90YWwgIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3Qgc3BlY2lmeSBvbmUgb2Ygc2Vjb25kcywgbWludXRlcywgb3IgaG91cnNcIik7XG4gICAgfVxuICAgIGlmIChoYXNTZWNvbmRzKSB7XG4gICAgICB2YWxpZGF0ZUludGVydmFsTnVtYmVyKHNjaGVkdWxlLnNlY29uZHMhKTtcbiAgICB9IGVsc2UgaWYgKGhhc01pbnV0ZXMpIHtcbiAgICAgIHZhbGlkYXRlSW50ZXJ2YWxOdW1iZXIoc2NoZWR1bGUubWludXRlcyEpO1xuICAgIH0gZWxzZSBpZiAoaGFzSG91cnMpIHtcbiAgICAgIHZhbGlkYXRlSW50ZXJ2YWxOdW1iZXIoc2NoZWR1bGUuaG91cnMhKTtcbiAgICB9XG4gICAgdGhpcy5zY2hlZHVsZShcbiAgICAgIGNyb25JZGVudGlmaWVyLFxuICAgICAgeyAuLi5zY2hlZHVsZSwgdHlwZTogXCJpbnRlcnZhbFwiIH0sXG4gICAgICBmdW5jdGlvblJlZmVyZW5jZSxcbiAgICAgIC4uLmFyZ3MsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTY2hlZHVsZSBhIG11dGF0aW9uIG9yIGFjdGlvbiB0byBydW4gb24gYW4gaG91cmx5IGJhc2lzLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBjcm9ucy5ob3VybHkoXG4gICAqICAgXCJSZXNldCBoaWdoIHNjb3Jlc1wiLFxuICAgKiAgIHtcbiAgICogICAgIG1pbnV0ZVVUQzogMzAsXG4gICAqICAgfSxcbiAgICogICBhcGkuc2NvcmVzLnJlc2V0XG4gICAqIClcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBjcm9uSWRlbnRpZmllciAtIEEgdW5pcXVlIG5hbWUgZm9yIHRoaXMgc2NoZWR1bGVkIGpvYi5cbiAgICogQHBhcmFtIHNjaGVkdWxlIC0gV2hhdCB0aW1lIChVVEMpIGVhY2ggZGF5IHRvIHJ1biB0aGlzIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gZnVuY3Rpb25SZWZlcmVuY2UgLSBBIHtAbGluayBGdW5jdGlvblJlZmVyZW5jZX0gZm9yIHRoZSBmdW5jdGlvblxuICAgKiB0byBzY2hlZHVsZS5cbiAgICogQHBhcmFtIGFyZ3MgLSBUaGUgYXJndW1lbnRzIHRvIHRoZSBmdW5jdGlvbi5cbiAgICovXG4gIGhvdXJseTxGdW5jUmVmIGV4dGVuZHMgU2NoZWR1bGFibGVGdW5jdGlvblJlZmVyZW5jZT4oXG4gICAgY3JvbklkZW50aWZpZXI6IHN0cmluZyxcbiAgICBzY2hlZHVsZTogSG91cmx5LFxuICAgIGZ1bmN0aW9uUmVmZXJlbmNlOiBGdW5jUmVmLFxuICAgIC4uLmFyZ3M6IE9wdGlvbmFsUmVzdEFyZ3M8RnVuY1JlZj5cbiAgKSB7XG4gICAgY29uc3QgbWludXRlVVRDID0gdmFsaWRhdGVkTWludXRlT2ZIb3VyKHNjaGVkdWxlLm1pbnV0ZVVUQyk7XG4gICAgdGhpcy5zY2hlZHVsZShcbiAgICAgIGNyb25JZGVudGlmaWVyLFxuICAgICAgeyBtaW51dGVVVEMsIHR5cGU6IFwiaG91cmx5XCIgfSxcbiAgICAgIGZ1bmN0aW9uUmVmZXJlbmNlLFxuICAgICAgLi4uYXJncyxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNjaGVkdWxlIGEgbXV0YXRpb24gb3IgYWN0aW9uIHRvIHJ1biBvbiBhIGRhaWx5IGJhc2lzLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBjcm9ucy5kYWlseShcbiAgICogICBcIlJlc2V0IGhpZ2ggc2NvcmVzXCIsXG4gICAqICAge1xuICAgKiAgICAgaG91clVUQzogMTcsIC8vICg5OjMwYW0gUGFjaWZpYy8xMDozMGFtIERheWxpZ2h0IFNhdmluZ3MgUGFjaWZpYylcbiAgICogICAgIG1pbnV0ZVVUQzogMzAsXG4gICAqICAgfSxcbiAgICogICBhcGkuc2NvcmVzLnJlc2V0XG4gICAqIClcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBjcm9uSWRlbnRpZmllciAtIEEgdW5pcXVlIG5hbWUgZm9yIHRoaXMgc2NoZWR1bGVkIGpvYi5cbiAgICogQHBhcmFtIHNjaGVkdWxlIC0gV2hhdCB0aW1lIChVVEMpIGVhY2ggZGF5IHRvIHJ1biB0aGlzIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gZnVuY3Rpb25SZWZlcmVuY2UgLSBBIHtAbGluayBGdW5jdGlvblJlZmVyZW5jZX0gZm9yIHRoZSBmdW5jdGlvblxuICAgKiB0byBzY2hlZHVsZS5cbiAgICogQHBhcmFtIGFyZ3MgLSBUaGUgYXJndW1lbnRzIHRvIHRoZSBmdW5jdGlvbi5cbiAgICovXG4gIGRhaWx5PEZ1bmNSZWYgZXh0ZW5kcyBTY2hlZHVsYWJsZUZ1bmN0aW9uUmVmZXJlbmNlPihcbiAgICBjcm9uSWRlbnRpZmllcjogc3RyaW5nLFxuICAgIHNjaGVkdWxlOiBEYWlseSxcbiAgICBmdW5jdGlvblJlZmVyZW5jZTogRnVuY1JlZixcbiAgICAuLi5hcmdzOiBPcHRpb25hbFJlc3RBcmdzPEZ1bmNSZWY+XG4gICkge1xuICAgIGNvbnN0IGhvdXJVVEMgPSB2YWxpZGF0ZWRIb3VyT2ZEYXkoc2NoZWR1bGUuaG91clVUQyk7XG4gICAgY29uc3QgbWludXRlVVRDID0gdmFsaWRhdGVkTWludXRlT2ZIb3VyKHNjaGVkdWxlLm1pbnV0ZVVUQyk7XG4gICAgdGhpcy5zY2hlZHVsZShcbiAgICAgIGNyb25JZGVudGlmaWVyLFxuICAgICAgeyBob3VyVVRDLCBtaW51dGVVVEMsIHR5cGU6IFwiZGFpbHlcIiB9LFxuICAgICAgZnVuY3Rpb25SZWZlcmVuY2UsXG4gICAgICAuLi5hcmdzLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogU2NoZWR1bGUgYSBtdXRhdGlvbiBvciBhY3Rpb24gdG8gcnVuIG9uIGEgd2Vla2x5IGJhc2lzLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBjcm9ucy53ZWVrbHkoXG4gICAqICAgXCJXZWVrbHkgcmUtZW5nYWdlbWVudCBlbWFpbFwiLFxuICAgKiAgIHtcbiAgICogICAgIGRheU9mV2VlazogXCJUdWVzZGF5XCIsXG4gICAqICAgICBob3VyVVRDOiAxNywgLy8gKDk6MzBhbSBQYWNpZmljLzEwOjMwYW0gRGF5bGlnaHQgU2F2aW5ncyBQYWNpZmljKVxuICAgKiAgICAgbWludXRlVVRDOiAzMCxcbiAgICogICB9LFxuICAgKiAgIGFwaS5lbWFpbHMuc2VuZFxuICAgKiApXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gY3JvbklkZW50aWZpZXIgLSBBIHVuaXF1ZSBuYW1lIGZvciB0aGlzIHNjaGVkdWxlZCBqb2IuXG4gICAqIEBwYXJhbSBzY2hlZHVsZSAtIFdoYXQgZGF5IGFuZCB0aW1lIChVVEMpIGVhY2ggd2VlayB0byBydW4gdGhpcyBmdW5jdGlvbi5cbiAgICogQHBhcmFtIGZ1bmN0aW9uUmVmZXJlbmNlIC0gQSB7QGxpbmsgRnVuY3Rpb25SZWZlcmVuY2V9IGZvciB0aGUgZnVuY3Rpb25cbiAgICogdG8gc2NoZWR1bGUuXG4gICAqL1xuICB3ZWVrbHk8RnVuY1JlZiBleHRlbmRzIFNjaGVkdWxhYmxlRnVuY3Rpb25SZWZlcmVuY2U+KFxuICAgIGNyb25JZGVudGlmaWVyOiBzdHJpbmcsXG4gICAgc2NoZWR1bGU6IFdlZWtseSxcbiAgICBmdW5jdGlvblJlZmVyZW5jZTogRnVuY1JlZixcbiAgICAuLi5hcmdzOiBPcHRpb25hbFJlc3RBcmdzPEZ1bmNSZWY+XG4gICkge1xuICAgIGNvbnN0IGRheU9mV2VlayA9IHZhbGlkYXRlZERheU9mV2VlayhzY2hlZHVsZS5kYXlPZldlZWspO1xuICAgIGNvbnN0IGhvdXJVVEMgPSB2YWxpZGF0ZWRIb3VyT2ZEYXkoc2NoZWR1bGUuaG91clVUQyk7XG4gICAgY29uc3QgbWludXRlVVRDID0gdmFsaWRhdGVkTWludXRlT2ZIb3VyKHNjaGVkdWxlLm1pbnV0ZVVUQyk7XG4gICAgdGhpcy5zY2hlZHVsZShcbiAgICAgIGNyb25JZGVudGlmaWVyLFxuICAgICAgeyBkYXlPZldlZWssIGhvdXJVVEMsIG1pbnV0ZVVUQywgdHlwZTogXCJ3ZWVrbHlcIiB9LFxuICAgICAgZnVuY3Rpb25SZWZlcmVuY2UsXG4gICAgICAuLi5hcmdzLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogU2NoZWR1bGUgYSBtdXRhdGlvbiBvciBhY3Rpb24gdG8gcnVuIG9uIGEgbW9udGhseSBiYXNpcy5cbiAgICpcbiAgICogTm90ZSB0aGF0IHNvbWUgbW9udGhzIGhhdmUgZmV3ZXIgZGF5cyB0aGFuIG90aGVycywgc28gZS5nLiBhIGZ1bmN0aW9uXG4gICAqIHNjaGVkdWxlZCB0byBydW4gb24gdGhlIDMwdGggd2lsbCBub3QgcnVuIGluIEZlYnJ1YXJ5LlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBjcm9ucy5tb250aGx5KFxuICAgKiAgIFwiQmlsbCBjdXN0b21lcnMgYXQgXCIsXG4gICAqICAge1xuICAgKiAgICAgaG91clVUQzogMTcsIC8vICg5OjMwYW0gUGFjaWZpYy8xMDozMGFtIERheWxpZ2h0IFNhdmluZ3MgUGFjaWZpYylcbiAgICogICAgIG1pbnV0ZVVUQzogMzAsXG4gICAqICAgICBkYXk6IDEsXG4gICAqICAgfSxcbiAgICogICBhcGkuYmlsbGluZy5iaWxsQ3VzdG9tZXJzXG4gICAqIClcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBjcm9uSWRlbnRpZmllciAtIEEgdW5pcXVlIG5hbWUgZm9yIHRoaXMgc2NoZWR1bGVkIGpvYi5cbiAgICogQHBhcmFtIHNjaGVkdWxlIC0gV2hhdCBkYXkgYW5kIHRpbWUgKFVUQykgZWFjaCBtb250aCB0byBydW4gdGhpcyBmdW5jdGlvbi5cbiAgICogQHBhcmFtIGZ1bmN0aW9uUmVmZXJlbmNlIC0gQSB7QGxpbmsgRnVuY3Rpb25SZWZlcmVuY2V9IGZvciB0aGUgZnVuY3Rpb25cbiAgICogdG8gc2NoZWR1bGUuXG4gICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyB0byB0aGUgZnVuY3Rpb24uXG4gICAqL1xuICBtb250aGx5PEZ1bmNSZWYgZXh0ZW5kcyBTY2hlZHVsYWJsZUZ1bmN0aW9uUmVmZXJlbmNlPihcbiAgICBjcm9uSWRlbnRpZmllcjogc3RyaW5nLFxuICAgIHNjaGVkdWxlOiBNb250aGx5LFxuICAgIGZ1bmN0aW9uUmVmZXJlbmNlOiBGdW5jUmVmLFxuICAgIC4uLmFyZ3M6IE9wdGlvbmFsUmVzdEFyZ3M8RnVuY1JlZj5cbiAgKSB7XG4gICAgY29uc3QgZGF5ID0gdmFsaWRhdGVkRGF5T2ZNb250aChzY2hlZHVsZS5kYXkpO1xuICAgIGNvbnN0IGhvdXJVVEMgPSB2YWxpZGF0ZWRIb3VyT2ZEYXkoc2NoZWR1bGUuaG91clVUQyk7XG4gICAgY29uc3QgbWludXRlVVRDID0gdmFsaWRhdGVkTWludXRlT2ZIb3VyKHNjaGVkdWxlLm1pbnV0ZVVUQyk7XG4gICAgdGhpcy5zY2hlZHVsZShcbiAgICAgIGNyb25JZGVudGlmaWVyLFxuICAgICAgeyBkYXksIGhvdXJVVEMsIG1pbnV0ZVVUQywgdHlwZTogXCJtb250aGx5XCIgfSxcbiAgICAgIGZ1bmN0aW9uUmVmZXJlbmNlLFxuICAgICAgLi4uYXJncyxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNjaGVkdWxlIGEgbXV0YXRpb24gb3IgYWN0aW9uIHRvIHJ1biBvbiBhIHJlY3VycmluZyBiYXNpcy5cbiAgICpcbiAgICogTGlrZSB0aGUgdW5peCBjb21tYW5kIGBjcm9uYCwgU3VuZGF5IGlzIDAsIE1vbmRheSBpcyAxLCBldGMuXG4gICAqXG4gICAqIGBgYFxuICAgKiAg4pSM4pSAIG1pbnV0ZSAoMCAtIDU5KVxuICAgKiAg4pSCIOKUjOKUgCBob3VyICgwIC0gMjMpXG4gICAqICDilIIg4pSCIOKUjOKUgCBkYXkgb2YgdGhlIG1vbnRoICgxIC0gMzEpXG4gICAqICDilIIg4pSCIOKUgiDilIzilIAgbW9udGggKDEgLSAxMilcbiAgICogIOKUgiDilIIg4pSCIOKUgiDilIzilIAgZGF5IG9mIHRoZSB3ZWVrICgwIC0gNikgKFN1bmRheSB0byBTYXR1cmRheSlcbiAgICogXCIqICogKiAqICpcIlxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIGNyb25JZGVudGlmaWVyIC0gQSB1bmlxdWUgbmFtZSBmb3IgdGhpcyBzY2hlZHVsZWQgam9iLlxuICAgKiBAcGFyYW0gY3JvbiAtIENyb24gc3RyaW5nIGxpa2UgYFwiMTUgNyAqICogKlwiYCAoRXZlcnkgZGF5IGF0IDc6MTUgVVRDKVxuICAgKiBAcGFyYW0gZnVuY3Rpb25SZWZlcmVuY2UgLSBBIHtAbGluayBGdW5jdGlvblJlZmVyZW5jZX0gZm9yIHRoZSBmdW5jdGlvblxuICAgKiB0byBzY2hlZHVsZS5cbiAgICogQHBhcmFtIGFyZ3MgLSBUaGUgYXJndW1lbnRzIHRvIHRoZSBmdW5jdGlvbi5cbiAgICovXG4gIGNyb248RnVuY1JlZiBleHRlbmRzIFNjaGVkdWxhYmxlRnVuY3Rpb25SZWZlcmVuY2U+KFxuICAgIGNyb25JZGVudGlmaWVyOiBzdHJpbmcsXG4gICAgY3JvbjogQ3JvblN0cmluZyxcbiAgICBmdW5jdGlvblJlZmVyZW5jZTogRnVuY1JlZixcbiAgICAuLi5hcmdzOiBPcHRpb25hbFJlc3RBcmdzPEZ1bmNSZWY+XG4gICkge1xuICAgIGNvbnN0IGMgPSB2YWxpZGF0ZWRDcm9uU3RyaW5nKGNyb24pO1xuICAgIHRoaXMuc2NoZWR1bGUoXG4gICAgICBjcm9uSWRlbnRpZmllcixcbiAgICAgIHsgY3JvbjogYywgdHlwZTogXCJjcm9uXCIgfSxcbiAgICAgIGZ1bmN0aW9uUmVmZXJlbmNlLFxuICAgICAgLi4uYXJncyxcbiAgICApO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBleHBvcnQoKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuY3JvbnMpO1xuICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG5pbXBvcnQgeyBwZXJmb3JtSnNTeXNjYWxsIH0gZnJvbSBcIi4vaW1wbC9zeXNjYWxsLmpzXCI7XG5leHBvcnQgY29uc3QgUk9VVEFCTEVfSFRUUF9NRVRIT0RTID0gW1xuICBcIkdFVFwiLFxuICBcIlBPU1RcIixcbiAgXCJQVVRcIixcbiAgXCJERUxFVEVcIixcbiAgXCJPUFRJT05TXCIsXG4gIFwiUEFUQ0hcIlxuXTtcbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVNZXRob2QobWV0aG9kKSB7XG4gIGlmIChtZXRob2QgPT09IFwiSEVBRFwiKSByZXR1cm4gXCJHRVRcIjtcbiAgcmV0dXJuIG1ldGhvZDtcbn1cbmV4cG9ydCBjb25zdCBodHRwUm91dGVyID0gKCkgPT4gbmV3IEh0dHBSb3V0ZXIoKTtcbmV4cG9ydCBjbGFzcyBIdHRwUm91dGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImV4YWN0Um91dGVzXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJwcmVmaXhSb3V0ZXNcIiwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImlzUm91dGVyXCIsIHRydWUpO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgYW4gSHR0cEFjdGlvbiB0byBiZSB1c2VkIHRvIHJlc3BvbmQgdG8gcmVxdWVzdHNcbiAgICAgKiBmb3IgYW4gSFRUUCBtZXRob2QgKGUuZy4gXCJHRVRcIikgYW5kIGEgcGF0aCBvciBwYXRoUHJlZml4LlxuICAgICAqXG4gICAgICogUGF0aHMgbXVzdCBiZWdpbiB3aXRoIGEgc2xhc2guIFBhdGggcHJlZml4ZXMgbXVzdCBhbHNvIGVuZCBpbiBhIHNsYXNoLlxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiAvLyBtYXRjaGVzIGAvcHJvZmlsZWAgKGJ1dCBub3QgYC9wcm9maWxlL2ApXG4gICAgICogaHR0cC5yb3V0ZSh7IHBhdGg6IFwiL3Byb2ZpbGVcIiwgbWV0aG9kOiBcIkdFVFwiLCBoYW5kbGVyOiBnZXRQcm9maWxlfSlcbiAgICAgKlxuICAgICAqIC8vIG1hdGNoZXMgYC9wcm9maWxlcy9gLCBgL3Byb2ZpbGVzL2FiY2AsIGFuZCBgL3Byb2ZpbGVzL2EvYy9iYCAoYnV0IG5vdCBgL3Byb2ZpbGVgKVxuICAgICAqIGh0dHAucm91dGUoeyBwYXRoUHJlZml4OiBcIi9wcm9maWxlL1wiLCBtZXRob2Q6IFwiR0VUXCIsIGhhbmRsZXI6IGdldFByb2ZpbGV9KVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyb3V0ZVwiLCAoc3BlYykgPT4ge1xuICAgICAgaWYgKCFzcGVjLmhhbmRsZXIpIHRocm93IG5ldyBFcnJvcihgcm91dGUgcmVxdWlyZXMgaGFuZGxlcmApO1xuICAgICAgaWYgKCFzcGVjLm1ldGhvZCkgdGhyb3cgbmV3IEVycm9yKGByb3V0ZSByZXF1aXJlcyBtZXRob2RgKTtcbiAgICAgIGNvbnN0IHsgbWV0aG9kLCBoYW5kbGVyIH0gPSBzcGVjO1xuICAgICAgaWYgKCFST1VUQUJMRV9IVFRQX01FVEhPRFMuaW5jbHVkZXMobWV0aG9kKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYCcke21ldGhvZH0nIGlzIG5vdCBhbiBhbGxvd2VkIEhUVFAgbWV0aG9kIChsaWtlIEdFVCwgUE9TVCwgUFVUIGV0Yy4pYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKFwicGF0aFwiIGluIHNwZWMpIHtcbiAgICAgICAgaWYgKFwicGF0aFByZWZpeFwiIGluIHNwZWMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgSW52YWxpZCBodHRwUm91dGVyIHJvdXRlOiBjYW5ub3QgY29udGFpbiBib3RoICdwYXRoJyBhbmQgJ3BhdGhQcmVmaXgnYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzcGVjLnBhdGguc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhdGggJyR7c3BlYy5wYXRofScgZG9lcyBub3Qgc3RhcnQgd2l0aCBhIC9gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3BlYy5wYXRoLnN0YXJ0c1dpdGgoXCIvLmZpbGVzL1wiKSB8fCBzcGVjLnBhdGggPT09IFwiLy5maWxlc1wiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYXRoICcke3NwZWMucGF0aH0nIGlzIHJlc2VydmVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kcyA9IHRoaXMuZXhhY3RSb3V0ZXMuaGFzKHNwZWMucGF0aCkgPyB0aGlzLmV4YWN0Um91dGVzLmdldChzcGVjLnBhdGgpIDogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKG1ldGhvZHMuaGFzKG1ldGhvZCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgUGF0aCAnJHtzcGVjLnBhdGh9JyBmb3IgbWV0aG9kICR7bWV0aG9kfSBhbHJlYWR5IGluIHVzZWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIG1ldGhvZHMuc2V0KG1ldGhvZCwgaGFuZGxlcik7XG4gICAgICAgIHRoaXMuZXhhY3RSb3V0ZXMuc2V0KHNwZWMucGF0aCwgbWV0aG9kcyk7XG4gICAgICB9IGVsc2UgaWYgKFwicGF0aFByZWZpeFwiIGluIHNwZWMpIHtcbiAgICAgICAgaWYgKCFzcGVjLnBhdGhQcmVmaXguc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgcGF0aFByZWZpeCAnJHtzcGVjLnBhdGhQcmVmaXh9JyBkb2VzIG5vdCBzdGFydCB3aXRoIGEgL2BcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3BlYy5wYXRoUHJlZml4LmVuZHNXaXRoKFwiL1wiKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcGF0aFByZWZpeCAke3NwZWMucGF0aFByZWZpeH0gbXVzdCBlbmQgd2l0aCBhIC9gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3BlYy5wYXRoUHJlZml4LnN0YXJ0c1dpdGgoXCIvLmZpbGVzL1wiKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcGF0aFByZWZpeCAnJHtzcGVjLnBhdGhQcmVmaXh9JyBpcyByZXNlcnZlZGApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZWZpeGVzID0gdGhpcy5wcmVmaXhSb3V0ZXMuZ2V0KG1ldGhvZCkgfHwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKHByZWZpeGVzLmhhcyhzcGVjLnBhdGhQcmVmaXgpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYCR7c3BlYy5tZXRob2R9IHBhdGhQcmVmaXggJHtzcGVjLnBhdGhQcmVmaXh9IGlzIGFscmVhZHkgZGVmaW5lZGBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHByZWZpeGVzLnNldChzcGVjLnBhdGhQcmVmaXgsIGhhbmRsZXIpO1xuICAgICAgICB0aGlzLnByZWZpeFJvdXRlcy5zZXQobWV0aG9kLCBwcmVmaXhlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEludmFsaWQgaHR0cFJvdXRlciByb3V0ZSBlbnRyeTogbXVzdCBjb250YWluIGVpdGhlciBmaWVsZCAncGF0aCcgb3IgJ3BhdGhQcmVmaXgnYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIHJvdXRlZCBIVFRQIGFjdGlvbnMuXG4gICAgICpcbiAgICAgKiBUaGVzZSBhcmUgdXNlZCB0byBwb3B1bGF0ZSB0aGUgbGlzdCBvZiByb3V0ZXMgc2hvd24gaW4gdGhlIEZ1bmN0aW9ucyBwYWdlIG9mIHRoZSBDb252ZXggZGFzaGJvYXJkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgLSBhbiBhcnJheSBvZiBbcGF0aCwgbWV0aG9kLCBlbmRwb2ludF0gdHVwbGVzLlxuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJnZXRSb3V0ZXNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgZXhhY3RQYXRocyA9IFsuLi50aGlzLmV4YWN0Um91dGVzLmtleXMoKV0uc29ydCgpO1xuICAgICAgY29uc3QgZXhhY3QgPSBleGFjdFBhdGhzLmZsYXRNYXAoXG4gICAgICAgIChwYXRoKSA9PiBbLi4udGhpcy5leGFjdFJvdXRlcy5nZXQocGF0aCkua2V5cygpXS5zb3J0KCkubWFwKFxuICAgICAgICAgIChtZXRob2QpID0+IFtwYXRoLCBtZXRob2QsIHRoaXMuZXhhY3RSb3V0ZXMuZ2V0KHBhdGgpLmdldChtZXRob2QpXVxuICAgICAgICApXG4gICAgICApO1xuICAgICAgY29uc3QgcHJlZml4UGF0aE1ldGhvZHMgPSBbLi4udGhpcy5wcmVmaXhSb3V0ZXMua2V5cygpXS5zb3J0KCk7XG4gICAgICBjb25zdCBwcmVmaXhlcyA9IHByZWZpeFBhdGhNZXRob2RzLmZsYXRNYXAoXG4gICAgICAgIChtZXRob2QpID0+IFsuLi50aGlzLnByZWZpeFJvdXRlcy5nZXQobWV0aG9kKS5rZXlzKCldLnNvcnQoKS5tYXAoXG4gICAgICAgICAgKHBhdGhQcmVmaXgpID0+IFtcbiAgICAgICAgICAgIGAke3BhdGhQcmVmaXh9KmAsXG4gICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICB0aGlzLnByZWZpeFJvdXRlcy5nZXQobWV0aG9kKS5nZXQocGF0aFByZWZpeClcbiAgICAgICAgICBdXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICByZXR1cm4gWy4uLmV4YWN0LCAuLi5wcmVmaXhlc107XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYXBwcm9wcmlhdGUgSFRUUCBhY3Rpb24gYW5kIGl0cyByb3V0ZWQgcmVxdWVzdCBwYXRoIGFuZCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBUaGUgcGF0aCBhbmQgbWV0aG9kIHJldHVybmVkIGFyZSB1c2VkIGZvciBsb2dnaW5nIGFuZCBtZXRyaWNzLCBhbmQgc2hvdWxkXG4gICAgICogbWF0Y2ggdXAgd2l0aCBvbmUgb2YgdGhlIHJvdXRlcyByZXR1cm5lZCBieSBgZ2V0Um91dGVzYC5cbiAgICAgKlxuICAgICAqIEZvciBleGFtcGxlLFxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiBodHRwLnJvdXRlKHsgcGF0aFByZWZpeDogXCIvcHJvZmlsZS9cIiwgbWV0aG9kOiBcIkdFVFwiLCBoYW5kbGVyOiBnZXRQcm9maWxlfSk7XG4gICAgICpcbiAgICAgKiBodHRwLmxvb2t1cChcIi9wcm9maWxlL2FiY1wiLCBcIkdFVFwiKSAvLyByZXR1cm5zIFtnZXRQcm9maWxlLCBcIkdFVFwiLCBcIi9wcm9maWxlLypcIl1cbiAgICAgKmBgYFxuICAgICAqXG4gICAgICogQHJldHVybnMgLSBhIHR1cGxlIFt7QGxpbmsgUHVibGljSHR0cEFjdGlvbn0sIG1ldGhvZCwgcGF0aF0gb3IgbnVsbC5cbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibG9va3VwXCIsIChwYXRoLCBtZXRob2QpID0+IHtcbiAgICAgIG1ldGhvZCA9IG5vcm1hbGl6ZU1ldGhvZChtZXRob2QpO1xuICAgICAgY29uc3QgZXhhY3RNYXRjaCA9IHRoaXMuZXhhY3RSb3V0ZXMuZ2V0KHBhdGgpPy5nZXQobWV0aG9kKTtcbiAgICAgIGlmIChleGFjdE1hdGNoKSByZXR1cm4gW2V4YWN0TWF0Y2gsIG1ldGhvZCwgcGF0aF07XG4gICAgICBjb25zdCBwcmVmaXhlcyA9IHRoaXMucHJlZml4Um91dGVzLmdldChtZXRob2QpIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBjb25zdCBwcmVmaXhlc1NvcnRlZCA9IFsuLi5wcmVmaXhlcy5lbnRyaWVzKCldLnNvcnQoXG4gICAgICAgIChbcHJlZml4QSwgX2FdLCBbcHJlZml4QiwgX2JdKSA9PiBwcmVmaXhCLmxlbmd0aCAtIHByZWZpeEEubGVuZ3RoXG4gICAgICApO1xuICAgICAgZm9yIChjb25zdCBbcGF0aFByZWZpeCwgZW5kcG9pbnRdIG9mIHByZWZpeGVzU29ydGVkKSB7XG4gICAgICAgIGlmIChwYXRoLnN0YXJ0c1dpdGgocGF0aFByZWZpeCkpIHtcbiAgICAgICAgICByZXR1cm4gW2VuZHBvaW50LCBtZXRob2QsIGAke3BhdGhQcmVmaXh9KmBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIEpTT04gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgUmVxdWVzdCBvYmplY3QsIHJldHVybiBhIFJlc3BvbnNlXG4gICAgICogYnkgcm91dGluZyB0aGUgcmVxdWVzdCBhbmQgcnVubmluZyB0aGUgYXBwcm9wcmlhdGUgZW5kcG9pbnQgb3IgcmV0dXJuaW5nXG4gICAgICogYSA0MDQgUmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJnc1N0ciAtIGEgSlNPTiBzdHJpbmcgcmVwcmVzZW50aW5nIGEgUmVxdWVzdCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIGEgUmVzcG9uc2Ugb2JqZWN0LlxuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJydW5SZXF1ZXN0XCIsIGFzeW5jIChhcmdzU3RyLCByZXF1ZXN0Um91dGUpID0+IHtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBwZXJmb3JtSnNTeXNjYWxsKFwicmVxdWVzdEZyb21Db252ZXhKc29uXCIsIHtcbiAgICAgICAgY29udmV4SnNvbjogSlNPTi5wYXJzZShhcmdzU3RyKVxuICAgICAgfSk7XG4gICAgICBsZXQgcGF0aG5hbWUgPSByZXF1ZXN0Um91dGU7XG4gICAgICBpZiAoIXBhdGhuYW1lIHx8IHR5cGVvZiBwYXRobmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBwYXRobmFtZSA9IG5ldyBVUkwocmVxdWVzdC51cmwpLnBhdGhuYW1lO1xuICAgICAgfVxuICAgICAgY29uc3QgbWV0aG9kID0gcmVxdWVzdC5tZXRob2Q7XG4gICAgICBjb25zdCBtYXRjaCA9IHRoaXMubG9va3VwKHBhdGhuYW1lLCBtZXRob2QpO1xuICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICBjb25zdCByZXNwb25zZTIgPSBuZXcgUmVzcG9uc2UoYE5vIEh0dHBBY3Rpb24gcm91dGVkIGZvciAke3BhdGhuYW1lfWAsIHtcbiAgICAgICAgICBzdGF0dXM6IDQwNFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgIHBlcmZvcm1Kc1N5c2NhbGwoXCJjb252ZXhKc29uRnJvbVJlc3BvbnNlXCIsIHsgcmVzcG9uc2U6IHJlc3BvbnNlMiB9KVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgW2VuZHBvaW50LCBfbWV0aG9kLCBfcGF0aF0gPSBtYXRjaDtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZW5kcG9pbnQuaW52b2tlSHR0cEFjdGlvbihyZXF1ZXN0KTtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgcGVyZm9ybUpzU3lzY2FsbChcImNvbnZleEpzb25Gcm9tUmVzcG9uc2VcIiwgeyByZXNwb25zZSB9KVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGVyLmpzLm1hcFxuIiwiaW1wb3J0IHsgcGVyZm9ybUpzU3lzY2FsbCB9IGZyb20gXCIuL2ltcGwvc3lzY2FsbC5qc1wiO1xuaW1wb3J0IHsgUHVibGljSHR0cEFjdGlvbiB9IGZyb20gXCIuL3JlZ2lzdHJhdGlvbi5qc1wiO1xuXG4vLyBOb3RlOiB0aGlzIGxpc3QgaXMgZHVwbGljYXRlZCBpbiB0aGUgZGFzaGJvYXJkLlxuLyoqXG4gKiBBIGxpc3Qgb2YgdGhlIG1ldGhvZHMgc3VwcG9ydGVkIGJ5IENvbnZleCBIVFRQIGFjdGlvbnMuXG4gKlxuICogSEVBRCBpcyBoYW5kbGVkIGJ5IENvbnZleCBieSBydW5uaW5nIEdFVCBhbmQgc3RyaXBwaW5nIHRoZSBib2R5LlxuICogQ09OTkVDVCBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIG5vdCBiZSBzdXBwb3J0ZWQuXG4gKiBUUkFDRSBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIG5vdCBiZSBzdXBwb3J0ZWQuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgUk9VVEFCTEVfSFRUUF9NRVRIT0RTID0gW1xuICBcIkdFVFwiLFxuICBcIlBPU1RcIixcbiAgXCJQVVRcIixcbiAgXCJERUxFVEVcIixcbiAgXCJPUFRJT05TXCIsXG4gIFwiUEFUQ0hcIixcbl0gYXMgY29uc3Q7XG4vKipcbiAqIEEgdHlwZSByZXByZXNlbnRpbmcgdGhlIG1ldGhvZHMgc3VwcG9ydGVkIGJ5IENvbnZleCBIVFRQIGFjdGlvbnMuXG4gKlxuICogSEVBRCBpcyBoYW5kbGVkIGJ5IENvbnZleCBieSBydW5uaW5nIEdFVCBhbmQgc3RyaXBwaW5nIHRoZSBib2R5LlxuICogQ09OTkVDVCBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIG5vdCBiZSBzdXBwb3J0ZWQuXG4gKiBUUkFDRSBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIG5vdCBiZSBzdXBwb3J0ZWQuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgdHlwZSBSb3V0YWJsZU1ldGhvZCA9ICh0eXBlb2YgUk9VVEFCTEVfSFRUUF9NRVRIT0RTKVtudW1iZXJdO1xuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplTWV0aG9kKFxuICBtZXRob2Q6IFJvdXRhYmxlTWV0aG9kIHwgXCJIRUFEXCIsXG4pOiBSb3V0YWJsZU1ldGhvZCB7XG4gIC8vIFRoaXMgcm91dGVyIHJvdXRlcyBIRUFEIHJlcXVlc3RzIGFzIEdFVHMsIGxldHRpbmcgQXh1bSBzdHJpcCB0aGVlIHJlc3BvbnNlXG4gIC8vIGJvZGllcyBhcmUgcmVzcG9uc2UgYm9kaWVzIGFmdGVyd2FyZC5cbiAgaWYgKG1ldGhvZCA9PT0gXCJIRUFEXCIpIHJldHVybiBcIkdFVFwiO1xuICByZXR1cm4gbWV0aG9kO1xufVxuXG4vKipcbiAqIFJldHVybiBhIG5ldyB7QGxpbmsgSHR0cFJvdXRlcn0gb2JqZWN0LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGh0dHBSb3V0ZXIgPSAoKSA9PiBuZXcgSHR0cFJvdXRlcigpO1xuXG4vKipcbiAqIEEgdHlwZSByZXByZXNlbnRpbmcgYSByb3V0ZSB0byBhbiBIVFRQIGFjdGlvbiB1c2luZyBhbiBleGFjdCByZXF1ZXN0IFVSTCBwYXRoIG1hdGNoLlxuICpcbiAqIFVzZWQgYnkge0BsaW5rIEh0dHBSb3V0ZXJ9IHRvIHJvdXRlIHJlcXVlc3RzIHRvIEhUVFAgYWN0aW9ucy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCB0eXBlIFJvdXRlU3BlY1dpdGhQYXRoID0ge1xuICAvKipcbiAgICogRXhhY3QgSFRUUCByZXF1ZXN0IHBhdGggdG8gcm91dGUuXG4gICAqL1xuICBwYXRoOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBIVFRQIG1ldGhvZCAoXCJHRVRcIiwgXCJQT1NUXCIsIC4uLikgdG8gcm91dGUuXG4gICAqL1xuICBtZXRob2Q6IFJvdXRhYmxlTWV0aG9kO1xuICAvKipcbiAgICogVGhlIEhUVFAgYWN0aW9uIHRvIGV4ZWN1dGUuXG4gICAqL1xuICBoYW5kbGVyOiBQdWJsaWNIdHRwQWN0aW9uO1xufTtcblxuLyoqXG4gKiBBIHR5cGUgcmVwcmVzZW50aW5nIGEgcm91dGUgdG8gYW4gSFRUUCBhY3Rpb24gdXNpbmcgYSByZXF1ZXN0IFVSTCBwYXRoIHByZWZpeCBtYXRjaC5cbiAqXG4gKiBVc2VkIGJ5IHtAbGluayBIdHRwUm91dGVyfSB0byByb3V0ZSByZXF1ZXN0cyB0byBIVFRQIGFjdGlvbnMuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgdHlwZSBSb3V0ZVNwZWNXaXRoUGF0aFByZWZpeCA9IHtcbiAgLyoqXG4gICAqIEFuIEhUVFAgcmVxdWVzdCBwYXRoIHByZWZpeCB0byByb3V0ZS4gUmVxdWVzdHMgd2l0aCBhIHBhdGggc3RhcnRpbmcgd2l0aCB0aGlzIHZhbHVlXG4gICAqIHdpbGwgYmUgcm91dGVkIHRvIHRoZSBIVFRQIGFjdGlvbi5cbiAgICovXG4gIHBhdGhQcmVmaXg6IHN0cmluZztcbiAgLyoqXG4gICAqIEhUVFAgbWV0aG9kIChcIkdFVFwiLCBcIlBPU1RcIiwgLi4uKSB0byByb3V0ZS5cbiAgICovXG4gIG1ldGhvZDogUm91dGFibGVNZXRob2Q7XG4gIC8qKlxuICAgKiBUaGUgSFRUUCBhY3Rpb24gdG8gZXhlY3V0ZS5cbiAgICovXG4gIGhhbmRsZXI6IFB1YmxpY0h0dHBBY3Rpb247XG59O1xuXG4vKipcbiAqIEEgdHlwZSByZXByZXNlbnRpbmcgYSByb3V0ZSB0byBhbiBIVFRQIGFjdGlvbi5cbiAqXG4gKiBVc2VkIGJ5IHtAbGluayBIdHRwUm91dGVyfSB0byByb3V0ZSByZXF1ZXN0cyB0byBIVFRQIGFjdGlvbnMuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgdHlwZSBSb3V0ZVNwZWMgPSBSb3V0ZVNwZWNXaXRoUGF0aCB8IFJvdXRlU3BlY1dpdGhQYXRoUHJlZml4O1xuXG4vKipcbiAqIEhUVFAgcm91dGVyIGZvciBzcGVjaWZ5aW5nIHRoZSBwYXRocyBhbmQgbWV0aG9kcyBvZiB7QGxpbmsgaHR0cEFjdGlvbkdlbmVyaWN9c1xuICpcbiAqIEFuIGV4YW1wbGUgYGNvbnZleC9odHRwLmpzYCBmaWxlIG1pZ2h0IGxvb2sgbGlrZSB0aGlzLlxuICpcbiAqIGBgYGpzXG4gKiBpbXBvcnQgeyBodHRwUm91dGVyIH0gZnJvbSBcImNvbnZleC9zZXJ2ZXJcIjtcbiAqIGltcG9ydCB7IGdldE1lc3NhZ2VzQnlBdXRob3IgfSBmcm9tIFwiLi9nZXRNZXNzYWdlc0J5QXV0aG9yXCI7XG4gKiBpbXBvcnQgeyBodHRwQWN0aW9uIH0gZnJvbSBcIi4vX2dlbmVyYXRlZC9zZXJ2ZXJcIjtcbiAqXG4gKiBjb25zdCBodHRwID0gaHR0cFJvdXRlcigpO1xuICpcbiAqIC8vIEhUVFAgYWN0aW9ucyBjYW4gYmUgZGVmaW5lZCBpbmxpbmUuLi5cbiAqIGh0dHAucm91dGUoe1xuICogICBwYXRoOiBcIi9tZXNzYWdlXCIsXG4gKiAgIG1ldGhvZDogXCJQT1NUXCIsXG4gKiAgIGhhbmRsZXI6IGh0dHBBY3Rpb24oYXN5bmMgKHsgcnVuTXV0YXRpb24gfSwgcmVxdWVzdCkgPT4ge1xuICogICAgIGNvbnN0IHsgYXV0aG9yLCBib2R5IH0gPSBhd2FpdCByZXF1ZXN0Lmpzb24oKTtcbiAqXG4gKiAgICAgYXdhaXQgcnVuTXV0YXRpb24oYXBpLnNlbmRNZXNzYWdlLmRlZmF1bHQsIHsgYm9keSwgYXV0aG9yIH0pO1xuICogICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge1xuICogICAgICAgc3RhdHVzOiAyMDAsXG4gKiAgICAgfSk7XG4gKiAgIH0pXG4gKiB9KTtcbiAqXG4gKiAvLyAuLi5vciB0aGV5IGNhbiBiZSBpbXBvcnRlZCBmcm9tIG90aGVyIGZpbGVzLlxuICogaHR0cC5yb3V0ZSh7XG4gKiAgIHBhdGg6IFwiL2dldE1lc3NhZ2VzQnlBdXRob3JcIixcbiAqICAgbWV0aG9kOiBcIkdFVFwiLFxuICogICBoYW5kbGVyOiBnZXRNZXNzYWdlc0J5QXV0aG9yLFxuICogfSk7XG4gKlxuICogLy8gQ29udmV4IGV4cGVjdHMgdGhlIHJvdXRlciB0byBiZSB0aGUgZGVmYXVsdCBleHBvcnQgb2YgYGNvbnZleC9odHRwLmpzYC5cbiAqIGV4cG9ydCBkZWZhdWx0IGh0dHA7XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBIdHRwUm91dGVyIHtcbiAgZXhhY3RSb3V0ZXM6IE1hcDxzdHJpbmcsIE1hcDxSb3V0YWJsZU1ldGhvZCwgUHVibGljSHR0cEFjdGlvbj4+ID0gbmV3IE1hcCgpO1xuICBwcmVmaXhSb3V0ZXM6IE1hcDxSb3V0YWJsZU1ldGhvZCwgTWFwPHN0cmluZywgUHVibGljSHR0cEFjdGlvbj4+ID0gbmV3IE1hcCgpO1xuICBpc1JvdXRlcjogdHJ1ZSA9IHRydWU7XG5cbiAgLyoqXG4gICAqIFNwZWNpZnkgYW4gSHR0cEFjdGlvbiB0byBiZSB1c2VkIHRvIHJlc3BvbmQgdG8gcmVxdWVzdHNcbiAgICogZm9yIGFuIEhUVFAgbWV0aG9kIChlLmcuIFwiR0VUXCIpIGFuZCBhIHBhdGggb3IgcGF0aFByZWZpeC5cbiAgICpcbiAgICogUGF0aHMgbXVzdCBiZWdpbiB3aXRoIGEgc2xhc2guIFBhdGggcHJlZml4ZXMgbXVzdCBhbHNvIGVuZCBpbiBhIHNsYXNoLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiAvLyBtYXRjaGVzIGAvcHJvZmlsZWAgKGJ1dCBub3QgYC9wcm9maWxlL2ApXG4gICAqIGh0dHAucm91dGUoeyBwYXRoOiBcIi9wcm9maWxlXCIsIG1ldGhvZDogXCJHRVRcIiwgaGFuZGxlcjogZ2V0UHJvZmlsZX0pXG4gICAqXG4gICAqIC8vIG1hdGNoZXMgYC9wcm9maWxlcy9gLCBgL3Byb2ZpbGVzL2FiY2AsIGFuZCBgL3Byb2ZpbGVzL2EvYy9iYCAoYnV0IG5vdCBgL3Byb2ZpbGVgKVxuICAgKiBodHRwLnJvdXRlKHsgcGF0aFByZWZpeDogXCIvcHJvZmlsZS9cIiwgbWV0aG9kOiBcIkdFVFwiLCBoYW5kbGVyOiBnZXRQcm9maWxlfSlcbiAgICogYGBgXG4gICAqL1xuICByb3V0ZSA9IChzcGVjOiBSb3V0ZVNwZWMpID0+IHtcbiAgICBpZiAoIXNwZWMuaGFuZGxlcikgdGhyb3cgbmV3IEVycm9yKGByb3V0ZSByZXF1aXJlcyBoYW5kbGVyYCk7XG4gICAgaWYgKCFzcGVjLm1ldGhvZCkgdGhyb3cgbmV3IEVycm9yKGByb3V0ZSByZXF1aXJlcyBtZXRob2RgKTtcbiAgICBjb25zdCB7IG1ldGhvZCwgaGFuZGxlciB9ID0gc3BlYztcbiAgICBpZiAoIVJPVVRBQkxFX0hUVFBfTUVUSE9EUy5pbmNsdWRlcyhtZXRob2QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGAnJHttZXRob2R9JyBpcyBub3QgYW4gYWxsb3dlZCBIVFRQIG1ldGhvZCAobGlrZSBHRVQsIFBPU1QsIFBVVCBldGMuKWAsXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChcInBhdGhcIiBpbiBzcGVjKSB7XG4gICAgICBpZiAoXCJwYXRoUHJlZml4XCIgaW4gc3BlYykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEludmFsaWQgaHR0cFJvdXRlciByb3V0ZTogY2Fubm90IGNvbnRhaW4gYm90aCAncGF0aCcgYW5kICdwYXRoUHJlZml4J2AsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoIXNwZWMucGF0aC5zdGFydHNXaXRoKFwiL1wiKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhdGggJyR7c3BlYy5wYXRofScgZG9lcyBub3Qgc3RhcnQgd2l0aCBhIC9gKTtcbiAgICAgIH1cbiAgICAgIGlmIChzcGVjLnBhdGguc3RhcnRzV2l0aChcIi8uZmlsZXMvXCIpIHx8IHNwZWMucGF0aCA9PT0gXCIvLmZpbGVzXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYXRoICcke3NwZWMucGF0aH0nIGlzIHJlc2VydmVkYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBtZXRob2RzOiBNYXA8Um91dGFibGVNZXRob2QsIFB1YmxpY0h0dHBBY3Rpb24+ID1cbiAgICAgICAgdGhpcy5leGFjdFJvdXRlcy5oYXMoc3BlYy5wYXRoKVxuICAgICAgICAgID8gdGhpcy5leGFjdFJvdXRlcy5nZXQoc3BlYy5wYXRoKSFcbiAgICAgICAgICA6IG5ldyBNYXAoKTtcbiAgICAgIGlmIChtZXRob2RzLmhhcyhtZXRob2QpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgUGF0aCAnJHtzcGVjLnBhdGh9JyBmb3IgbWV0aG9kICR7bWV0aG9kfSBhbHJlYWR5IGluIHVzZWAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBtZXRob2RzLnNldChtZXRob2QsIGhhbmRsZXIpO1xuICAgICAgdGhpcy5leGFjdFJvdXRlcy5zZXQoc3BlYy5wYXRoLCBtZXRob2RzKTtcbiAgICB9IGVsc2UgaWYgKFwicGF0aFByZWZpeFwiIGluIHNwZWMpIHtcbiAgICAgIGlmICghc3BlYy5wYXRoUHJlZml4LnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgcGF0aFByZWZpeCAnJHtzcGVjLnBhdGhQcmVmaXh9JyBkb2VzIG5vdCBzdGFydCB3aXRoIGEgL2AsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoIXNwZWMucGF0aFByZWZpeC5lbmRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYXRoUHJlZml4ICR7c3BlYy5wYXRoUHJlZml4fSBtdXN0IGVuZCB3aXRoIGEgL2ApO1xuICAgICAgfVxuICAgICAgaWYgKHNwZWMucGF0aFByZWZpeC5zdGFydHNXaXRoKFwiLy5maWxlcy9cIikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYXRoUHJlZml4ICcke3NwZWMucGF0aFByZWZpeH0nIGlzIHJlc2VydmVkYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBwcmVmaXhlcyA9XG4gICAgICAgIHRoaXMucHJlZml4Um91dGVzLmdldChtZXRob2QpIHx8IG5ldyBNYXA8c3RyaW5nLCBQdWJsaWNIdHRwQWN0aW9uPigpO1xuICAgICAgaWYgKHByZWZpeGVzLmhhcyhzcGVjLnBhdGhQcmVmaXgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgJHtzcGVjLm1ldGhvZH0gcGF0aFByZWZpeCAke3NwZWMucGF0aFByZWZpeH0gaXMgYWxyZWFkeSBkZWZpbmVkYCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHByZWZpeGVzLnNldChzcGVjLnBhdGhQcmVmaXgsIGhhbmRsZXIpO1xuICAgICAgdGhpcy5wcmVmaXhSb3V0ZXMuc2V0KG1ldGhvZCwgcHJlZml4ZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIGh0dHBSb3V0ZXIgcm91dGUgZW50cnk6IG11c3QgY29udGFpbiBlaXRoZXIgZmllbGQgJ3BhdGgnIG9yICdwYXRoUHJlZml4J2AsXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhIGxpc3Qgb2Ygcm91dGVkIEhUVFAgYWN0aW9ucy5cbiAgICpcbiAgICogVGhlc2UgYXJlIHVzZWQgdG8gcG9wdWxhdGUgdGhlIGxpc3Qgb2Ygcm91dGVzIHNob3duIGluIHRoZSBGdW5jdGlvbnMgcGFnZSBvZiB0aGUgQ29udmV4IGRhc2hib2FyZC5cbiAgICpcbiAgICogQHJldHVybnMgLSBhbiBhcnJheSBvZiBbcGF0aCwgbWV0aG9kLCBlbmRwb2ludF0gdHVwbGVzLlxuICAgKi9cbiAgZ2V0Um91dGVzID0gKCk6IEFycmF5PFxuICAgIFJlYWRvbmx5PFtzdHJpbmcsIFJvdXRhYmxlTWV0aG9kLCBQdWJsaWNIdHRwQWN0aW9uXT5cbiAgPiA9PiB7XG4gICAgY29uc3QgZXhhY3RQYXRoczogc3RyaW5nW10gPSBbLi4udGhpcy5leGFjdFJvdXRlcy5rZXlzKCldLnNvcnQoKTtcbiAgICBjb25zdCBleGFjdCA9IGV4YWN0UGF0aHMuZmxhdE1hcCgocGF0aCkgPT5cbiAgICAgIFsuLi50aGlzLmV4YWN0Um91dGVzLmdldChwYXRoKSEua2V5cygpXVxuICAgICAgICAuc29ydCgpXG4gICAgICAgIC5tYXAoXG4gICAgICAgICAgKG1ldGhvZCkgPT5cbiAgICAgICAgICAgIFtwYXRoLCBtZXRob2QsIHRoaXMuZXhhY3RSb3V0ZXMuZ2V0KHBhdGgpIS5nZXQobWV0aG9kKSFdIGFzIGNvbnN0LFxuICAgICAgICApLFxuICAgICk7XG5cbiAgICBjb25zdCBwcmVmaXhQYXRoTWV0aG9kcyA9IFsuLi50aGlzLnByZWZpeFJvdXRlcy5rZXlzKCldLnNvcnQoKTtcbiAgICBjb25zdCBwcmVmaXhlcyA9IHByZWZpeFBhdGhNZXRob2RzLmZsYXRNYXAoKG1ldGhvZCkgPT5cbiAgICAgIFsuLi50aGlzLnByZWZpeFJvdXRlcy5nZXQobWV0aG9kKSEua2V5cygpXVxuICAgICAgICAuc29ydCgpXG4gICAgICAgIC5tYXAoXG4gICAgICAgICAgKHBhdGhQcmVmaXgpID0+XG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgIGAke3BhdGhQcmVmaXh9KmAsXG4gICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgdGhpcy5wcmVmaXhSb3V0ZXMuZ2V0KG1ldGhvZCkhLmdldChwYXRoUHJlZml4KSEsXG4gICAgICAgICAgICBdIGFzIGNvbnN0LFxuICAgICAgICApLFxuICAgICk7XG5cbiAgICByZXR1cm4gWy4uLmV4YWN0LCAuLi5wcmVmaXhlc107XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwcHJvcHJpYXRlIEhUVFAgYWN0aW9uIGFuZCBpdHMgcm91dGVkIHJlcXVlc3QgcGF0aCBhbmQgbWV0aG9kLlxuICAgKlxuICAgKiBUaGUgcGF0aCBhbmQgbWV0aG9kIHJldHVybmVkIGFyZSB1c2VkIGZvciBsb2dnaW5nIGFuZCBtZXRyaWNzLCBhbmQgc2hvdWxkXG4gICAqIG1hdGNoIHVwIHdpdGggb25lIG9mIHRoZSByb3V0ZXMgcmV0dXJuZWQgYnkgYGdldFJvdXRlc2AuXG4gICAqXG4gICAqIEZvciBleGFtcGxlLFxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBodHRwLnJvdXRlKHsgcGF0aFByZWZpeDogXCIvcHJvZmlsZS9cIiwgbWV0aG9kOiBcIkdFVFwiLCBoYW5kbGVyOiBnZXRQcm9maWxlfSk7XG4gICAqXG4gICAqIGh0dHAubG9va3VwKFwiL3Byb2ZpbGUvYWJjXCIsIFwiR0VUXCIpIC8vIHJldHVybnMgW2dldFByb2ZpbGUsIFwiR0VUXCIsIFwiL3Byb2ZpbGUvKlwiXVxuICAgKmBgYFxuICAgKlxuICAgKiBAcmV0dXJucyAtIGEgdHVwbGUgW3tAbGluayBQdWJsaWNIdHRwQWN0aW9ufSwgbWV0aG9kLCBwYXRoXSBvciBudWxsLlxuICAgKi9cbiAgbG9va3VwID0gKFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICBtZXRob2Q6IFJvdXRhYmxlTWV0aG9kIHwgXCJIRUFEXCIsXG4gICk6IFJlYWRvbmx5PFtQdWJsaWNIdHRwQWN0aW9uLCBSb3V0YWJsZU1ldGhvZCwgc3RyaW5nXT4gfCBudWxsID0+IHtcbiAgICBtZXRob2QgPSBub3JtYWxpemVNZXRob2QobWV0aG9kKTtcbiAgICBjb25zdCBleGFjdE1hdGNoID0gdGhpcy5leGFjdFJvdXRlcy5nZXQocGF0aCk/LmdldChtZXRob2QpO1xuICAgIGlmIChleGFjdE1hdGNoKSByZXR1cm4gW2V4YWN0TWF0Y2gsIG1ldGhvZCwgcGF0aF07XG5cbiAgICBjb25zdCBwcmVmaXhlcyA9IHRoaXMucHJlZml4Um91dGVzLmdldChtZXRob2QpIHx8IG5ldyBNYXAoKTtcbiAgICBjb25zdCBwcmVmaXhlc1NvcnRlZCA9IFsuLi5wcmVmaXhlcy5lbnRyaWVzKCldLnNvcnQoXG4gICAgICAoW3ByZWZpeEEsIF9hXSwgW3ByZWZpeEIsIF9iXSkgPT4gcHJlZml4Qi5sZW5ndGggLSBwcmVmaXhBLmxlbmd0aCxcbiAgICApO1xuICAgIGZvciAoY29uc3QgW3BhdGhQcmVmaXgsIGVuZHBvaW50XSBvZiBwcmVmaXhlc1NvcnRlZCkge1xuICAgICAgaWYgKHBhdGguc3RhcnRzV2l0aChwYXRoUHJlZml4KSkge1xuICAgICAgICByZXR1cm4gW2VuZHBvaW50LCBtZXRob2QsIGAke3BhdGhQcmVmaXh9KmBdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogR2l2ZW4gYSBKU09OIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIFJlcXVlc3Qgb2JqZWN0LCByZXR1cm4gYSBSZXNwb25zZVxuICAgKiBieSByb3V0aW5nIHRoZSByZXF1ZXN0IGFuZCBydW5uaW5nIHRoZSBhcHByb3ByaWF0ZSBlbmRwb2ludCBvciByZXR1cm5pbmdcbiAgICogYSA0MDQgUmVzcG9uc2UuXG4gICAqXG4gICAqIEBwYXJhbSBhcmdzU3RyIC0gYSBKU09OIHN0cmluZyByZXByZXNlbnRpbmcgYSBSZXF1ZXN0IG9iamVjdC5cbiAgICpcbiAgICogQHJldHVybnMgLSBhIFJlc3BvbnNlIG9iamVjdC5cbiAgICovXG4gIHJ1blJlcXVlc3QgPSBhc3luYyAoXG4gICAgYXJnc1N0cjogc3RyaW5nLFxuICAgIHJlcXVlc3RSb3V0ZTogc3RyaW5nLFxuICApOiBQcm9taXNlPHN0cmluZz4gPT4ge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBwZXJmb3JtSnNTeXNjYWxsKFwicmVxdWVzdEZyb21Db252ZXhKc29uXCIsIHtcbiAgICAgIGNvbnZleEpzb246IEpTT04ucGFyc2UoYXJnc1N0ciksXG4gICAgfSk7XG5cbiAgICBsZXQgcGF0aG5hbWUgPSByZXF1ZXN0Um91dGU7XG4gICAgaWYgKCFwYXRobmFtZSB8fCB0eXBlb2YgcGF0aG5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHBhdGhuYW1lID0gbmV3IFVSTChyZXF1ZXN0LnVybCkucGF0aG5hbWU7XG4gICAgfVxuXG4gICAgY29uc3QgbWV0aG9kID0gcmVxdWVzdC5tZXRob2Q7XG4gICAgY29uc3QgbWF0Y2ggPSB0aGlzLmxvb2t1cChwYXRobmFtZSwgbWV0aG9kIGFzIFJvdXRhYmxlTWV0aG9kKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IG5ldyBSZXNwb25zZShgTm8gSHR0cEFjdGlvbiByb3V0ZWQgZm9yICR7cGF0aG5hbWV9YCwge1xuICAgICAgICBzdGF0dXM6IDQwNCxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFxuICAgICAgICBwZXJmb3JtSnNTeXNjYWxsKFwiY29udmV4SnNvbkZyb21SZXNwb25zZVwiLCB7IHJlc3BvbnNlIH0pLFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgW2VuZHBvaW50LCBfbWV0aG9kLCBfcGF0aF0gPSBtYXRjaDtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGVuZHBvaW50Lmludm9rZUh0dHBBY3Rpb24ocmVxdWVzdCk7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFxuICAgICAgcGVyZm9ybUpzU3lzY2FsbChcImNvbnZleEpzb25Gcm9tUmVzcG9uc2VcIiwgeyByZXNwb25zZSB9KSxcbiAgICApO1xuICB9O1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuaW1wb3J0IHsgY29udmV4VG9Kc29uIH0gZnJvbSBcIi4uLy4uL3ZhbHVlcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuLi8uLi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgcGVyZm9ybUFzeW5jU3lzY2FsbCB9IGZyb20gXCIuLi9pbXBsL3N5c2NhbGwuanNcIjtcbmltcG9ydCB7XG4gIGdldEZ1bmN0aW9uQWRkcmVzcyxcbiAgc2V0UmVmZXJlbmNlUGF0aCxcbiAgdG9SZWZlcmVuY2VQYXRoXG59IGZyb20gXCIuL3BhdGhzLmpzXCI7XG5leHBvcnQgeyBnZXRGdW5jdGlvbkFkZHJlc3MgfSBmcm9tIFwiLi9wYXRocy5qc1wiO1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uSGFuZGxlKGZ1bmN0aW9uUmVmZXJlbmNlKSB7XG4gIGNvbnN0IGFkZHJlc3MgPSBnZXRGdW5jdGlvbkFkZHJlc3MoZnVuY3Rpb25SZWZlcmVuY2UpO1xuICByZXR1cm4gYXdhaXQgcGVyZm9ybUFzeW5jU3lzY2FsbChcIjEuMC9jcmVhdGVGdW5jdGlvbkhhbmRsZVwiLCB7XG4gICAgLi4uYWRkcmVzcyxcbiAgICB2ZXJzaW9uXG4gIH0pO1xufVxuY2xhc3MgSW5zdGFsbGVkQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoZGVmaW5pdGlvbiwgbmFtZSkge1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfZGVmaW5pdGlvblwiKTtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX25hbWVcIik7XG4gICAgdGhpcy5fZGVmaW5pdGlvbiA9IGRlZmluaXRpb247XG4gICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgc2V0UmVmZXJlbmNlUGF0aCh0aGlzLCBgX3JlZmVyZW5jZS9jaGlsZENvbXBvbmVudC8ke25hbWV9YCk7XG4gIH1cbiAgZ2V0IGV4cG9ydHMoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUV4cG9ydHModGhpcy5fbmFtZSwgW10pO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVFeHBvcnRzKG5hbWUsIHBhdGhQYXJ0cykge1xuICBjb25zdCBoYW5kbGVyID0ge1xuICAgIGdldChfLCBwcm9wKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3AgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgbmV3UGFydHMgPSBbLi4ucGF0aFBhcnRzLCBwcm9wXTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUV4cG9ydHMobmFtZSwgbmV3UGFydHMpO1xuICAgICAgfSBlbHNlIGlmIChwcm9wID09PSB0b1JlZmVyZW5jZVBhdGgpIHtcbiAgICAgICAgbGV0IHJlZmVyZW5jZSA9IGBfcmVmZXJlbmNlL2NoaWxkQ29tcG9uZW50LyR7bmFtZX1gO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGF0aFBhcnRzKSB7XG4gICAgICAgICAgcmVmZXJlbmNlICs9IGAvJHtwYXJ0fWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZmVyZW5jZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gbmV3IFByb3h5KHt9LCBoYW5kbGVyKTtcbn1cbmZ1bmN0aW9uIHVzZShkZWZpbml0aW9uLCBvcHRpb25zKSB7XG4gIGNvbnN0IGltcG9ydGVkQ29tcG9uZW50RGVmaW5pdGlvbiA9IGRlZmluaXRpb247XG4gIGlmICh0eXBlb2YgaW1wb3J0ZWRDb21wb25lbnREZWZpbml0aW9uLmNvbXBvbmVudERlZmluaXRpb25QYXRoICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJDb21wb25lbnQgZGVmaW5pdGlvbiBkb2VzIG5vdCBoYXZlIHRoZSByZXF1aXJlZCBjb21wb25lbnREZWZpbml0aW9uUGF0aCBwcm9wZXJ0eS4gVGhpcyBjb2RlIG9ubHkgd29ya3MgaW4gQ29udmV4IHJ1bnRpbWUuXCJcbiAgICApO1xuICB9XG4gIGNvbnN0IG5hbWUgPSBvcHRpb25zPy5uYW1lIHx8IC8vIGFkZGVkIHJlY2VudGx5XG4gIGltcG9ydGVkQ29tcG9uZW50RGVmaW5pdGlvbi5kZWZhdWx0TmFtZSB8fCAvLyBjYW4gYmUgcmVtb3ZlZCBvbmNlIGJhY2tlbmQgaXMgb3V0XG4gIGltcG9ydGVkQ29tcG9uZW50RGVmaW5pdGlvbi5jb21wb25lbnREZWZpbml0aW9uUGF0aC5zcGxpdChcIi9cIikucG9wKCk7XG4gIHRoaXMuX2NoaWxkQ29tcG9uZW50cy5wdXNoKFtuYW1lLCBpbXBvcnRlZENvbXBvbmVudERlZmluaXRpb24sIHt9XSk7XG4gIHJldHVybiBuZXcgSW5zdGFsbGVkQ29tcG9uZW50KGRlZmluaXRpb24sIG5hbWUpO1xufVxuZnVuY3Rpb24gZXhwb3J0QXBwRm9yQW5hbHlzaXMoKSB7XG4gIGNvbnN0IGRlZmluaXRpb25UeXBlID0geyB0eXBlOiBcImFwcFwiIH07XG4gIGNvbnN0IGNoaWxkQ29tcG9uZW50cyA9IHNlcmlhbGl6ZUNoaWxkQ29tcG9uZW50cyh0aGlzLl9jaGlsZENvbXBvbmVudHMpO1xuICByZXR1cm4ge1xuICAgIGRlZmluaXRpb25UeXBlLFxuICAgIGNoaWxkQ29tcG9uZW50cyxcbiAgICBodHRwTW91bnRzOiB7fSxcbiAgICBleHBvcnRzOiBzZXJpYWxpemVFeHBvcnRUcmVlKHRoaXMuX2V4cG9ydFRyZWUpXG4gIH07XG59XG5mdW5jdGlvbiBzZXJpYWxpemVFeHBvcnRUcmVlKHRyZWUpIHtcbiAgY29uc3QgYnJhbmNoID0gW107XG4gIGZvciAoY29uc3QgW2tleSwgY2hpbGRdIG9mIE9iamVjdC5lbnRyaWVzKHRyZWUpKSB7XG4gICAgbGV0IG5vZGU7XG4gICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgbm9kZSA9IHsgdHlwZTogXCJsZWFmXCIsIGxlYWY6IGNoaWxkIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUgPSBzZXJpYWxpemVFeHBvcnRUcmVlKGNoaWxkKTtcbiAgICB9XG4gICAgYnJhbmNoLnB1c2goW2tleSwgbm9kZV0pO1xuICB9XG4gIHJldHVybiB7IHR5cGU6IFwiYnJhbmNoXCIsIGJyYW5jaCB9O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplQ2hpbGRDb21wb25lbnRzKGNoaWxkQ29tcG9uZW50cykge1xuICByZXR1cm4gY2hpbGRDb21wb25lbnRzLm1hcCgoW25hbWUsIGRlZmluaXRpb24sIHBdKSA9PiB7XG4gICAgbGV0IGFyZ3MgPSBudWxsO1xuICAgIGlmIChwICE9PSBudWxsKSB7XG4gICAgICBhcmdzID0gW107XG4gICAgICBmb3IgKGNvbnN0IFtuYW1lMiwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHApKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgYXJncy5wdXNoKFtcbiAgICAgICAgICAgIG5hbWUyLFxuICAgICAgICAgICAgeyB0eXBlOiBcInZhbHVlXCIsIHZhbHVlOiBKU09OLnN0cmluZ2lmeShjb252ZXhUb0pzb24odmFsdWUpKSB9XG4gICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcGF0aCA9IGRlZmluaXRpb24uY29tcG9uZW50RGVmaW5pdGlvblBhdGg7XG4gICAgaWYgKCFwYXRoKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIm5vIC5jb21wb25lbnRQYXRoIGZvciBjb21wb25lbnQgZGVmaW5pdGlvbiBcIiArIEpTT04uc3RyaW5naWZ5KGRlZmluaXRpb24sIG51bGwsIDIpXG4gICAgICApO1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lLFxuICAgICAgcGF0aCxcbiAgICAgIGFyZ3NcbiAgICB9O1xuICB9KTtcbn1cbmZ1bmN0aW9uIGV4cG9ydENvbXBvbmVudEZvckFuYWx5c2lzKCkge1xuICBjb25zdCBhcmdzID0gT2JqZWN0LmVudHJpZXMoXG4gICAgdGhpcy5fYXJnc1xuICApLm1hcCgoW25hbWUsIHZhbGlkYXRvcl0pID0+IFtcbiAgICBuYW1lLFxuICAgIHtcbiAgICAgIHR5cGU6IFwidmFsdWVcIixcbiAgICAgIHZhbHVlOiBKU09OLnN0cmluZ2lmeSh2YWxpZGF0b3IuanNvbilcbiAgICB9XG4gIF0pO1xuICBjb25zdCBkZWZpbml0aW9uVHlwZSA9IHtcbiAgICB0eXBlOiBcImNoaWxkQ29tcG9uZW50XCIsXG4gICAgbmFtZTogdGhpcy5fbmFtZSxcbiAgICBhcmdzXG4gIH07XG4gIGNvbnN0IGNoaWxkQ29tcG9uZW50cyA9IHNlcmlhbGl6ZUNoaWxkQ29tcG9uZW50cyh0aGlzLl9jaGlsZENvbXBvbmVudHMpO1xuICByZXR1cm4ge1xuICAgIG5hbWU6IHRoaXMuX25hbWUsXG4gICAgZGVmaW5pdGlvblR5cGUsXG4gICAgY2hpbGRDb21wb25lbnRzLFxuICAgIGh0dHBNb3VudHM6IHt9LFxuICAgIGV4cG9ydHM6IHNlcmlhbGl6ZUV4cG9ydFRyZWUodGhpcy5fZXhwb3J0VHJlZSlcbiAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWZpbmVDb21wb25lbnQobmFtZSkge1xuICBjb25zdCByZXQgPSB7XG4gICAgX2lzUm9vdDogZmFsc2UsXG4gICAgX25hbWU6IG5hbWUsXG4gICAgX2FyZ3M6IHt9LFxuICAgIF9jaGlsZENvbXBvbmVudHM6IFtdLFxuICAgIF9leHBvcnRUcmVlOiB7fSxcbiAgICBfb25Jbml0Q2FsbGJhY2tzOiB7fSxcbiAgICBleHBvcnQ6IGV4cG9ydENvbXBvbmVudEZvckFuYWx5c2lzLFxuICAgIHVzZSxcbiAgICAvLyBwcmV0ZW5kIHRvIGNvbmZvcm0gdG8gQ29tcG9uZW50RGVmaW5pdGlvbiwgd2hpY2ggdGVtcG9yYXJpbHkgZXhwZWN0cyBfX2FyZ3NcbiAgICAuLi57fVxuICB9O1xuICByZXR1cm4gcmV0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlZmluZUFwcCgpIHtcbiAgY29uc3QgcmV0ID0ge1xuICAgIF9pc1Jvb3Q6IHRydWUsXG4gICAgX2NoaWxkQ29tcG9uZW50czogW10sXG4gICAgX2V4cG9ydFRyZWU6IHt9LFxuICAgIGV4cG9ydDogZXhwb3J0QXBwRm9yQW5hbHlzaXMsXG4gICAgdXNlXG4gIH07XG4gIHJldHVybiByZXQ7XG59XG5leHBvcnQgZnVuY3Rpb24gY3VycmVudFN5c3RlbVVkZkluQ29tcG9uZW50KGNvbXBvbmVudElkKSB7XG4gIHJldHVybiB7XG4gICAgW3RvUmVmZXJlbmNlUGF0aF06IGBfcmVmZXJlbmNlL2N1cnJlbnRTeXN0ZW1VZGZJbkNvbXBvbmVudC8ke2NvbXBvbmVudElkfWBcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNoaWxkQ29tcG9uZW50cyhyb290LCBwYXRoUGFydHMpIHtcbiAgY29uc3QgaGFuZGxlciA9IHtcbiAgICBnZXQoXywgcHJvcCkge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnN0IG5ld1BhcnRzID0gWy4uLnBhdGhQYXJ0cywgcHJvcF07XG4gICAgICAgIHJldHVybiBjcmVhdGVDaGlsZENvbXBvbmVudHMocm9vdCwgbmV3UGFydHMpO1xuICAgICAgfSBlbHNlIGlmIChwcm9wID09PSB0b1JlZmVyZW5jZVBhdGgpIHtcbiAgICAgICAgaWYgKHBhdGhQYXJ0cy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgY29uc3QgZm91bmQgPSBbcm9vdCwgLi4ucGF0aFBhcnRzXS5qb2luKFwiLlwiKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgQVBJIHBhdGggaXMgZXhwZWN0ZWQgdG8gYmUgb2YgdGhlIGZvcm0gXFxgJHtyb290fS5jaGlsZENvbXBvbmVudC5mdW5jdGlvbk5hbWVcXGAuIEZvdW5kOiBcXGAke2ZvdW5kfVxcYGBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgX3JlZmVyZW5jZS9jaGlsZENvbXBvbmVudC9gICsgcGF0aFBhcnRzLmpvaW4oXCIvXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBuZXcgUHJveHkoe30sIGhhbmRsZXIpO1xufVxuZXhwb3J0IGNvbnN0IGNvbXBvbmVudHNHZW5lcmljID0gKCkgPT4gY3JlYXRlQ2hpbGRDb21wb25lbnRzKFwiY29tcG9uZW50c1wiLCBbXSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsImltcG9ydCB7IFByb3BlcnR5VmFsaWRhdG9ycywgY29udmV4VG9Kc29uIH0gZnJvbSBcIi4uLy4uL3ZhbHVlcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuLi8uLi9pbmRleC5qc1wiO1xuaW1wb3J0IHtcbiAgQW55RnVuY3Rpb25SZWZlcmVuY2UsXG4gIEZ1bmN0aW9uUmVmZXJlbmNlLFxuICBGdW5jdGlvblR5cGUsXG59IGZyb20gXCIuLi9hcGkuanNcIjtcbmltcG9ydCB7IHBlcmZvcm1Bc3luY1N5c2NhbGwgfSBmcm9tIFwiLi4vaW1wbC9zeXNjYWxsLmpzXCI7XG5pbXBvcnQgeyBEZWZhdWx0RnVuY3Rpb25BcmdzIH0gZnJvbSBcIi4uL3JlZ2lzdHJhdGlvbi5qc1wiO1xuaW1wb3J0IHtcbiAgQXBwRGVmaW5pdGlvbkFuYWx5c2lzLFxuICBDb21wb25lbnREZWZpbml0aW9uQW5hbHlzaXMsXG4gIENvbXBvbmVudERlZmluaXRpb25UeXBlLFxufSBmcm9tIFwiLi9kZWZpbml0aW9uLmpzXCI7XG5pbXBvcnQge1xuICBnZXRGdW5jdGlvbkFkZHJlc3MsXG4gIHNldFJlZmVyZW5jZVBhdGgsXG4gIHRvUmVmZXJlbmNlUGF0aCxcbn0gZnJvbSBcIi4vcGF0aHMuanNcIjtcbmV4cG9ydCB7IGdldEZ1bmN0aW9uQWRkcmVzcyB9IGZyb20gXCIuL3BhdGhzLmpzXCI7XG5cbi8qKlxuICogQSBzZXJpYWxpemFibGUgcmVmZXJlbmNlIHRvIGEgQ29udmV4IGZ1bmN0aW9uLlxuICogUGFzc2luZyBhIHRoaXMgcmVmZXJlbmNlIHRvIGFub3RoZXIgY29tcG9uZW50IGFsbG93cyB0aGF0IGNvbXBvbmVudCB0byBjYWxsIHRoaXNcbiAqIGZ1bmN0aW9uIGR1cmluZyB0aGUgY3VycmVudCBmdW5jdGlvbiBleGVjdXRpb24gb3IgYXQgYW55IGxhdGVyIHRpbWUuXG4gKiBGdW5jdGlvbiBoYW5kbGVzIGFyZSB1c2VkIGxpa2UgYGFwaS5mb2xkZXIuZnVuY3Rpb25gIEZ1bmN0aW9uUmVmZXJlbmNlcyxcbiAqIGUuZy4gYGN0eC5zY2hlZHVsZXIucnVuQWZ0ZXIoMCwgZnVuY3Rpb25SZWZlcmVuY2UsIGFyZ3MpYC5cbiAqXG4gKiBBIGZ1bmN0aW9uIHJlZmVyZW5jZSBpcyBzdGFibGUgYWNyb3NzIGNvZGUgcHVzaGVzIGJ1dCBpdCdzIHBvc3NpYmxlXG4gKiB0aGUgQ29udmV4IGZ1bmN0aW9uIGl0IHJlZmVycyB0byBtaWdodCBubyBsb25nZXIgZXhpc3QuXG4gKlxuICogVGhpcyBpcyBhIGZlYXR1cmUgb2YgY29tcG9uZW50cywgd2hpY2ggYXJlIGluIGJldGEuXG4gKiBUaGlzIEFQSSBpcyB1bnN0YWJsZSBhbmQgbWF5IGNoYW5nZSBpbiBzdWJzZXF1ZW50IHJlbGVhc2VzLlxuICovXG5leHBvcnQgdHlwZSBGdW5jdGlvbkhhbmRsZTxcbiAgVHlwZSBleHRlbmRzIEZ1bmN0aW9uVHlwZSxcbiAgQXJncyBleHRlbmRzIERlZmF1bHRGdW5jdGlvbkFyZ3MgPSBhbnksXG4gIFJldHVyblR5cGUgPSBhbnksXG4+ID0gc3RyaW5nICYgRnVuY3Rpb25SZWZlcmVuY2U8VHlwZSwgXCJpbnRlcm5hbFwiLCBBcmdzLCBSZXR1cm5UeXBlPjtcblxuLyoqXG4gKiBDcmVhdGUgYSBzZXJpYWxpemFibGUgcmVmZXJlbmNlIHRvIGEgQ29udmV4IGZ1bmN0aW9uLlxuICogUGFzc2luZyBhIHRoaXMgcmVmZXJlbmNlIHRvIGFub3RoZXIgY29tcG9uZW50IGFsbG93cyB0aGF0IGNvbXBvbmVudCB0byBjYWxsIHRoaXNcbiAqIGZ1bmN0aW9uIGR1cmluZyB0aGUgY3VycmVudCBmdW5jdGlvbiBleGVjdXRpb24gb3IgYXQgYW55IGxhdGVyIHRpbWUuXG4gKiBGdW5jdGlvbiBoYW5kbGVzIGFyZSB1c2VkIGxpa2UgYGFwaS5mb2xkZXIuZnVuY3Rpb25gIEZ1bmN0aW9uUmVmZXJlbmNlcyxcbiAqIGUuZy4gYGN0eC5zY2hlZHVsZXIucnVuQWZ0ZXIoMCwgZnVuY3Rpb25SZWZlcmVuY2UsIGFyZ3MpYC5cbiAqXG4gKiBBIGZ1bmN0aW9uIHJlZmVyZW5jZSBpcyBzdGFibGUgYWNyb3NzIGNvZGUgcHVzaGVzIGJ1dCBpdCdzIHBvc3NpYmxlXG4gKiB0aGUgQ29udmV4IGZ1bmN0aW9uIGl0IHJlZmVycyB0byBtaWdodCBubyBsb25nZXIgZXhpc3QuXG4gKlxuICogVGhpcyBpcyBhIGZlYXR1cmUgb2YgY29tcG9uZW50cywgd2hpY2ggYXJlIGluIGJldGEuXG4gKiBUaGlzIEFQSSBpcyB1bnN0YWJsZSBhbmQgbWF5IGNoYW5nZSBpbiBzdWJzZXF1ZW50IHJlbGVhc2VzLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25IYW5kbGU8XG4gIFR5cGUgZXh0ZW5kcyBGdW5jdGlvblR5cGUsXG4gIEFyZ3MgZXh0ZW5kcyBEZWZhdWx0RnVuY3Rpb25BcmdzLFxuICBSZXR1cm5UeXBlLFxuPihcbiAgZnVuY3Rpb25SZWZlcmVuY2U6IEZ1bmN0aW9uUmVmZXJlbmNlPFxuICAgIFR5cGUsXG4gICAgXCJwdWJsaWNcIiB8IFwiaW50ZXJuYWxcIixcbiAgICBBcmdzLFxuICAgIFJldHVyblR5cGVcbiAgPixcbik6IFByb21pc2U8RnVuY3Rpb25IYW5kbGU8VHlwZSwgQXJncywgUmV0dXJuVHlwZT4+IHtcbiAgY29uc3QgYWRkcmVzcyA9IGdldEZ1bmN0aW9uQWRkcmVzcyhmdW5jdGlvblJlZmVyZW5jZSk7XG4gIHJldHVybiBhd2FpdCBwZXJmb3JtQXN5bmNTeXNjYWxsKFwiMS4wL2NyZWF0ZUZ1bmN0aW9uSGFuZGxlXCIsIHtcbiAgICAuLi5hZGRyZXNzLFxuICAgIHZlcnNpb24sXG4gIH0pO1xufVxuXG5pbnRlcmZhY2UgQ29tcG9uZW50RXhwb3J0cyB7XG4gIFtrZXk6IHN0cmluZ106IEZ1bmN0aW9uUmVmZXJlbmNlPGFueSwgYW55LCBhbnksIGFueT4gfCBDb21wb25lbnRFeHBvcnRzO1xufVxuXG4vKipcbiAqIEFuIG9iamVjdCBvZiB0aGlzIHR5cGUgc2hvdWxkIGJlIHRoZSBkZWZhdWx0IGV4cG9ydCBvZiBhXG4gKiBjb252ZXguY29uZmlnLnRzIGZpbGUgaW4gYSBjb21wb25lbnQgZGVmaW5pdGlvbiBkaXJlY3RvcnkuXG4gKlxuICogVGhpcyBpcyBhIGZlYXR1cmUgb2YgY29tcG9uZW50cywgd2hpY2ggYXJlIGluIGJldGEuXG4gKiBUaGlzIEFQSSBpcyB1bnN0YWJsZSBhbmQgbWF5IGNoYW5nZSBpbiBzdWJzZXF1ZW50IHJlbGVhc2VzLlxuICovXG5leHBvcnQgdHlwZSBDb21wb25lbnREZWZpbml0aW9uPEV4cG9ydHMgZXh0ZW5kcyBDb21wb25lbnRFeHBvcnRzID0gYW55PiA9IHtcbiAgLyoqXG4gICAqIEluc3RhbGwgYSBjb21wb25lbnQgd2l0aCB0aGUgZ2l2ZW4gZGVmaW5pdGlvbiBpbiB0aGlzIGNvbXBvbmVudCBkZWZpbml0aW9uLlxuICAgKlxuICAgKiBUYWtlcyBhIGNvbXBvbmVudCBkZWZpbml0aW9uIGFuZCBhbiBvcHRpb25hbCBuYW1lLlxuICAgKlxuICAgKiBGb3IgZWRpdG9yIHRvb2xpbmcgdGhpcyBtZXRob2QgZXhwZWN0cyBhIHtAbGluayBDb21wb25lbnREZWZpbml0aW9ufVxuICAgKiBidXQgYXQgcnVudGltZSB0aGUgb2JqZWN0IHRoYXQgaXMgaW1wb3J0ZWQgd2lsbCBiZSBhIHtAbGluayBJbXBvcnRlZENvbXBvbmVudERlZmluaXRpb259XG4gICAqL1xuICB1c2U8RGVmaW5pdGlvbiBleHRlbmRzIENvbXBvbmVudERlZmluaXRpb248YW55Pj4oXG4gICAgZGVmaW5pdGlvbjogRGVmaW5pdGlvbixcbiAgICBvcHRpb25zPzoge1xuICAgICAgbmFtZT86IHN0cmluZztcbiAgICB9LFxuICApOiBJbnN0YWxsZWRDb21wb25lbnQ8RGVmaW5pdGlvbj47XG5cbiAgLyoqXG4gICAqIEludGVybmFsIHR5cGUtb25seSBwcm9wZXJ0eSB0cmFja2luZyBleHBvcnRzIHByb3ZpZGVkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBUaGlzIGlzIGEgdHlwZS1vbmx5IHByb3BlcnR5LCBkb24ndCB1c2UgaXQuXG4gICAqL1xuICBfX2V4cG9ydHM6IEV4cG9ydHM7XG59O1xuXG50eXBlIENvbXBvbmVudERlZmluaXRpb25FeHBvcnRzPFQgZXh0ZW5kcyBDb21wb25lbnREZWZpbml0aW9uPGFueT4+ID1cbiAgVFtcIl9fZXhwb3J0c1wiXTtcblxuLyoqXG4gKiBBbiBvYmplY3Qgb2YgdGhpcyB0eXBlIHNob3VsZCBiZSB0aGUgZGVmYXVsdCBleHBvcnQgb2YgYVxuICogY29udmV4LmNvbmZpZy50cyBmaWxlIGluIGEgY29tcG9uZW50LWF3YXJlIGNvbnZleCBkaXJlY3RvcnkuXG4gKlxuICogVGhpcyBpcyBhIGZlYXR1cmUgb2YgY29tcG9uZW50cywgd2hpY2ggYXJlIGluIGJldGEuXG4gKiBUaGlzIEFQSSBpcyB1bnN0YWJsZSBhbmQgbWF5IGNoYW5nZSBpbiBzdWJzZXF1ZW50IHJlbGVhc2VzLlxuICovXG5leHBvcnQgdHlwZSBBcHBEZWZpbml0aW9uID0ge1xuICAvKipcbiAgICogSW5zdGFsbCBhIGNvbXBvbmVudCB3aXRoIHRoZSBnaXZlbiBkZWZpbml0aW9uIGluIHRoaXMgY29tcG9uZW50IGRlZmluaXRpb24uXG4gICAqXG4gICAqIFRha2VzIGEgY29tcG9uZW50IGRlZmluaXRpb24gYW5kIGFuIG9wdGlvbmFsIG5hbWUuXG4gICAqXG4gICAqIEZvciBlZGl0b3IgdG9vbGluZyB0aGlzIG1ldGhvZCBleHBlY3RzIGEge0BsaW5rIENvbXBvbmVudERlZmluaXRpb259XG4gICAqIGJ1dCBhdCBydW50aW1lIHRoZSBvYmplY3QgdGhhdCBpcyBpbXBvcnRlZCB3aWxsIGJlIGEge0BsaW5rIEltcG9ydGVkQ29tcG9uZW50RGVmaW5pdGlvbn1cbiAgICovXG4gIHVzZTxEZWZpbml0aW9uIGV4dGVuZHMgQ29tcG9uZW50RGVmaW5pdGlvbjxhbnk+PihcbiAgICBkZWZpbml0aW9uOiBEZWZpbml0aW9uLFxuICAgIG9wdGlvbnM/OiB7XG4gICAgICBuYW1lPzogc3RyaW5nO1xuICAgIH0sXG4gICk6IEluc3RhbGxlZENvbXBvbmVudDxEZWZpbml0aW9uPjtcbn07XG5cbmludGVyZmFjZSBFeHBvcnRUcmVlIHtcbiAgLy8gVHJlZSB3aXRoIHNlcmlhbGl6ZWQgYFJlZmVyZW5jZWBzIGFzIGxlYXZlcy5cbiAgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgRXhwb3J0VHJlZTtcbn1cblxudHlwZSBDb21tb25EZWZpbml0aW9uRGF0YSA9IHtcbiAgX2lzUm9vdDogYm9vbGVhbjtcbiAgX2NoaWxkQ29tcG9uZW50czogW1xuICAgIHN0cmluZyxcbiAgICBJbXBvcnRlZENvbXBvbmVudERlZmluaXRpb24sXG4gICAgUmVjb3JkPHN0cmluZywgYW55PiB8IG51bGwsXG4gIF1bXTtcbiAgX2V4cG9ydFRyZWU6IEV4cG9ydFRyZWU7XG59O1xuXG50eXBlIENvbXBvbmVudERlZmluaXRpb25EYXRhID0gQ29tbW9uRGVmaW5pdGlvbkRhdGEgJiB7XG4gIF9hcmdzOiBQcm9wZXJ0eVZhbGlkYXRvcnM7XG4gIF9uYW1lOiBzdHJpbmc7XG4gIF9vbkluaXRDYWxsYmFja3M6IFJlY29yZDxzdHJpbmcsIChhcmdzU3RyOiBzdHJpbmcpID0+IHN0cmluZz47XG59O1xudHlwZSBBcHBEZWZpbml0aW9uRGF0YSA9IENvbW1vbkRlZmluaXRpb25EYXRhO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVmZXIgdG8gYW4gYWxyZWFkeS1pbnN0YWxsZWQgY29tcG9uZW50LlxuICovXG5jbGFzcyBJbnN0YWxsZWRDb21wb25lbnQ8RGVmaW5pdGlvbiBleHRlbmRzIENvbXBvbmVudERlZmluaXRpb248YW55Pj4ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfZGVmaW5pdGlvbjogRGVmaW5pdGlvbjtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfbmFtZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKGRlZmluaXRpb246IERlZmluaXRpb24sIG5hbWU6IHN0cmluZykge1xuICAgIHRoaXMuX2RlZmluaXRpb24gPSBkZWZpbml0aW9uO1xuICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgIHNldFJlZmVyZW5jZVBhdGgodGhpcywgYF9yZWZlcmVuY2UvY2hpbGRDb21wb25lbnQvJHtuYW1lfWApO1xuICB9XG5cbiAgZ2V0IGV4cG9ydHMoKTogQ29tcG9uZW50RGVmaW5pdGlvbkV4cG9ydHM8RGVmaW5pdGlvbj4ge1xuICAgIHJldHVybiBjcmVhdGVFeHBvcnRzKHRoaXMuX25hbWUsIFtdKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFeHBvcnRzKG5hbWU6IHN0cmluZywgcGF0aFBhcnRzOiBzdHJpbmdbXSk6IGFueSB7XG4gIGNvbnN0IGhhbmRsZXI6IFByb3h5SGFuZGxlcjxhbnk+ID0ge1xuICAgIGdldChfLCBwcm9wOiBzdHJpbmcgfCBzeW1ib2wpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBuZXdQYXJ0cyA9IFsuLi5wYXRoUGFydHMsIHByb3BdO1xuICAgICAgICByZXR1cm4gY3JlYXRlRXhwb3J0cyhuYW1lLCBuZXdQYXJ0cyk7XG4gICAgICB9IGVsc2UgaWYgKHByb3AgPT09IHRvUmVmZXJlbmNlUGF0aCkge1xuICAgICAgICBsZXQgcmVmZXJlbmNlID0gYF9yZWZlcmVuY2UvY2hpbGRDb21wb25lbnQvJHtuYW1lfWA7XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXRoUGFydHMpIHtcbiAgICAgICAgICByZWZlcmVuY2UgKz0gYC8ke3BhcnR9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVmZXJlbmNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9LFxuICB9O1xuICByZXR1cm4gbmV3IFByb3h5KHt9LCBoYW5kbGVyKTtcbn1cblxuZnVuY3Rpb24gdXNlPERlZmluaXRpb24gZXh0ZW5kcyBDb21wb25lbnREZWZpbml0aW9uPGFueT4+KFxuICB0aGlzOiBDb21tb25EZWZpbml0aW9uRGF0YSxcbiAgZGVmaW5pdGlvbjogRGVmaW5pdGlvbixcbiAgb3B0aW9ucz86IHtcbiAgICBuYW1lPzogc3RyaW5nO1xuICB9LFxuKTogSW5zdGFsbGVkQ29tcG9uZW50PERlZmluaXRpb24+IHtcbiAgLy8gQXQgcnVudGltZSBhbiBpbXBvcnRlZCBjb21wb25lbnQgd2lsbCBoYXZlIHRoaXMgc2hhcGUuXG4gIGNvbnN0IGltcG9ydGVkQ29tcG9uZW50RGVmaW5pdGlvbiA9XG4gICAgZGVmaW5pdGlvbiBhcyB1bmtub3duIGFzIEltcG9ydGVkQ29tcG9uZW50RGVmaW5pdGlvbjtcbiAgaWYgKHR5cGVvZiBpbXBvcnRlZENvbXBvbmVudERlZmluaXRpb24uY29tcG9uZW50RGVmaW5pdGlvblBhdGggIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkNvbXBvbmVudCBkZWZpbml0aW9uIGRvZXMgbm90IGhhdmUgdGhlIHJlcXVpcmVkIGNvbXBvbmVudERlZmluaXRpb25QYXRoIHByb3BlcnR5LiBUaGlzIGNvZGUgb25seSB3b3JrcyBpbiBDb252ZXggcnVudGltZS5cIixcbiAgICApO1xuICB9XG4gIGNvbnN0IG5hbWUgPVxuICAgIG9wdGlvbnM/Lm5hbWUgfHxcbiAgICAvLyBhZGRlZCByZWNlbnRseVxuICAgIGltcG9ydGVkQ29tcG9uZW50RGVmaW5pdGlvbi5kZWZhdWx0TmFtZSB8fFxuICAgIC8vIGNhbiBiZSByZW1vdmVkIG9uY2UgYmFja2VuZCBpcyBvdXRcbiAgICBpbXBvcnRlZENvbXBvbmVudERlZmluaXRpb24uY29tcG9uZW50RGVmaW5pdGlvblBhdGguc3BsaXQoXCIvXCIpLnBvcCgpITtcbiAgdGhpcy5fY2hpbGRDb21wb25lbnRzLnB1c2goW25hbWUsIGltcG9ydGVkQ29tcG9uZW50RGVmaW5pdGlvbiwge31dKTtcbiAgcmV0dXJuIG5ldyBJbnN0YWxsZWRDb21wb25lbnQoZGVmaW5pdGlvbiwgbmFtZSk7XG59XG5cbi8qKlxuICogVGhlIHJ1bnRpbWUgdHlwZSBvZiBhIENvbXBvbmVudERlZmluaXRpb24uIFR5cGVTY3JpcHQgd2lsbCBjbGFpbVxuICogdGhlIGRlZmF1bHQgZXhwb3J0IG9mIGEgbW9kdWxlIGxpa2UgXCJjb29sLWNvbXBvbmVudC9jb252ZXguY29uZmlnLmpzXCJcbiAqIGlzIGEgYEBsaW5rIENvbXBvbmVudERlZmluaXRpb259LCBidXQgZHVyaW5nIGNvbXBvbmVudCBkZWZpbml0aW9uIGV2YWx1YXRpb25cbiAqIHRoaXMgaXMgaXRzIHR5cGUgaW5zdGVhZC5cbiAqXG4gKiBUaGlzIGlzIGEgZmVhdHVyZSBvZiBjb21wb25lbnRzLCB3aGljaCBhcmUgaW4gYmV0YS5cbiAqIFRoaXMgQVBJIGlzIHVuc3RhYmxlIGFuZCBtYXkgY2hhbmdlIGluIHN1YnNlcXVlbnQgcmVsZWFzZXMuXG4gKi9cbmV4cG9ydCB0eXBlIEltcG9ydGVkQ29tcG9uZW50RGVmaW5pdGlvbiA9IHtcbiAgY29tcG9uZW50RGVmaW5pdGlvblBhdGg6IHN0cmluZztcbiAgZGVmYXVsdE5hbWU6IHN0cmluZztcbn07XG5cbmZ1bmN0aW9uIGV4cG9ydEFwcEZvckFuYWx5c2lzKFxuICB0aGlzOiBDb21wb25lbnREZWZpbml0aW9uPGFueT4gJiBBcHBEZWZpbml0aW9uRGF0YSxcbik6IEFwcERlZmluaXRpb25BbmFseXNpcyB7XG4gIGNvbnN0IGRlZmluaXRpb25UeXBlID0geyB0eXBlOiBcImFwcFwiIGFzIGNvbnN0IH07XG4gIGNvbnN0IGNoaWxkQ29tcG9uZW50cyA9IHNlcmlhbGl6ZUNoaWxkQ29tcG9uZW50cyh0aGlzLl9jaGlsZENvbXBvbmVudHMpO1xuICByZXR1cm4ge1xuICAgIGRlZmluaXRpb25UeXBlLFxuICAgIGNoaWxkQ29tcG9uZW50czogY2hpbGRDb21wb25lbnRzIGFzIGFueSxcbiAgICBodHRwTW91bnRzOiB7fSxcbiAgICBleHBvcnRzOiBzZXJpYWxpemVFeHBvcnRUcmVlKHRoaXMuX2V4cG9ydFRyZWUpLFxuICB9O1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVFeHBvcnRUcmVlKHRyZWU6IEV4cG9ydFRyZWUpOiBhbnkge1xuICBjb25zdCBicmFuY2g6IGFueVtdID0gW107XG4gIGZvciAoY29uc3QgW2tleSwgY2hpbGRdIG9mIE9iamVjdC5lbnRyaWVzKHRyZWUpKSB7XG4gICAgbGV0IG5vZGU7XG4gICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgbm9kZSA9IHsgdHlwZTogXCJsZWFmXCIsIGxlYWY6IGNoaWxkIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUgPSBzZXJpYWxpemVFeHBvcnRUcmVlKGNoaWxkKTtcbiAgICB9XG4gICAgYnJhbmNoLnB1c2goW2tleSwgbm9kZV0pO1xuICB9XG4gIHJldHVybiB7IHR5cGU6IFwiYnJhbmNoXCIsIGJyYW5jaCB9O1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVDaGlsZENvbXBvbmVudHMoXG4gIGNoaWxkQ29tcG9uZW50czogW1xuICAgIHN0cmluZyxcbiAgICBJbXBvcnRlZENvbXBvbmVudERlZmluaXRpb24sXG4gICAgUmVjb3JkPHN0cmluZywgYW55PiB8IG51bGwsXG4gIF1bXSxcbik6IHtcbiAgbmFtZTogc3RyaW5nO1xuICBwYXRoOiBzdHJpbmc7XG4gIGFyZ3M6IFtzdHJpbmcsIHsgdHlwZTogXCJ2YWx1ZVwiOyB2YWx1ZTogc3RyaW5nIH1dW10gfCBudWxsO1xufVtdIHtcbiAgcmV0dXJuIGNoaWxkQ29tcG9uZW50cy5tYXAoKFtuYW1lLCBkZWZpbml0aW9uLCBwXSkgPT4ge1xuICAgIGxldCBhcmdzOiBbc3RyaW5nLCB7IHR5cGU6IFwidmFsdWVcIjsgdmFsdWU6IHN0cmluZyB9XVtdIHwgbnVsbCA9IG51bGw7XG4gICAgaWYgKHAgIT09IG51bGwpIHtcbiAgICAgIGFyZ3MgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwKSkge1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGFyZ3MucHVzaChbXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgeyB0eXBlOiBcInZhbHVlXCIsIHZhbHVlOiBKU09OLnN0cmluZ2lmeShjb252ZXhUb0pzb24odmFsdWUpKSB9LFxuICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHdlIGtub3cgdGhhdCBjb21wb25lbnRzIGNhcnJ5IHRoaXMgZXh0cmEgaW5mb3JtYXRpb25cbiAgICBjb25zdCBwYXRoID0gZGVmaW5pdGlvbi5jb21wb25lbnREZWZpbml0aW9uUGF0aDtcbiAgICBpZiAoIXBhdGgpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwibm8gLmNvbXBvbmVudFBhdGggZm9yIGNvbXBvbmVudCBkZWZpbml0aW9uIFwiICtcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeShkZWZpbml0aW9uLCBudWxsLCAyKSxcbiAgICAgICk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSEsXG4gICAgICBwYXRoOiBwYXRoISxcbiAgICAgIGFyZ3MsXG4gICAgfTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGV4cG9ydENvbXBvbmVudEZvckFuYWx5c2lzKFxuICB0aGlzOiBDb21wb25lbnREZWZpbml0aW9uPGFueT4gJiBDb21wb25lbnREZWZpbml0aW9uRGF0YSxcbik6IENvbXBvbmVudERlZmluaXRpb25BbmFseXNpcyB7XG4gIGNvbnN0IGFyZ3M6IFtzdHJpbmcsIHsgdHlwZTogXCJ2YWx1ZVwiOyB2YWx1ZTogc3RyaW5nIH1dW10gPSBPYmplY3QuZW50cmllcyhcbiAgICB0aGlzLl9hcmdzLFxuICApLm1hcCgoW25hbWUsIHZhbGlkYXRvcl0pID0+IFtcbiAgICBuYW1lLFxuICAgIHtcbiAgICAgIHR5cGU6IFwidmFsdWVcIixcbiAgICAgIHZhbHVlOiBKU09OLnN0cmluZ2lmeSh2YWxpZGF0b3IuanNvbiksXG4gICAgfSxcbiAgXSk7XG4gIGNvbnN0IGRlZmluaXRpb25UeXBlOiBDb21wb25lbnREZWZpbml0aW9uVHlwZSA9IHtcbiAgICB0eXBlOiBcImNoaWxkQ29tcG9uZW50XCIgYXMgY29uc3QsXG4gICAgbmFtZTogdGhpcy5fbmFtZSxcbiAgICBhcmdzLFxuICB9O1xuICBjb25zdCBjaGlsZENvbXBvbmVudHMgPSBzZXJpYWxpemVDaGlsZENvbXBvbmVudHModGhpcy5fY2hpbGRDb21wb25lbnRzKTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiB0aGlzLl9uYW1lLFxuICAgIGRlZmluaXRpb25UeXBlLFxuICAgIGNoaWxkQ29tcG9uZW50czogY2hpbGRDb21wb25lbnRzIGFzIGFueSxcbiAgICBodHRwTW91bnRzOiB7fSxcbiAgICBleHBvcnRzOiBzZXJpYWxpemVFeHBvcnRUcmVlKHRoaXMuX2V4cG9ydFRyZWUpLFxuICB9O1xufVxuXG4vLyBUaGlzIGlzIHdoYXQgaXMgYWN0dWFsbHkgY29udGFpbmVkIGluIGEgQ29tcG9uZW50RGVmaW5pdGlvbi5cbnR5cGUgUnVudGltZUNvbXBvbmVudERlZmluaXRpb24gPSBPbWl0PENvbXBvbmVudERlZmluaXRpb248YW55PiwgXCJfX2V4cG9ydHNcIj4gJlxuICBDb21wb25lbnREZWZpbml0aW9uRGF0YSAmIHtcbiAgICBleHBvcnQ6ICgpID0+IENvbXBvbmVudERlZmluaXRpb25BbmFseXNpcztcbiAgfTtcbnR5cGUgUnVudGltZUFwcERlZmluaXRpb24gPSBBcHBEZWZpbml0aW9uICZcbiAgQXBwRGVmaW5pdGlvbkRhdGEgJiB7XG4gICAgZXhwb3J0OiAoKSA9PiBBcHBEZWZpbml0aW9uQW5hbHlzaXM7XG4gIH07XG5cbi8qKlxuICogRGVmaW5lIGEgY29tcG9uZW50LCBhIHBpZWNlIG9mIGEgQ29udmV4IGRlcGxveW1lbnQgd2l0aCBuYW1lc3BhY2VkIHJlc291cmNlcy5cbiAqXG4gKiBUaGUgZGVmYXVsdFxuICogdGhlIGRlZmF1bHQgZXhwb3J0IG9mIGEgbW9kdWxlIGxpa2UgXCJjb29sLWNvbXBvbmVudC9jb252ZXguY29uZmlnLmpzXCJcbiAqIGlzIGEgYEBsaW5rIENvbXBvbmVudERlZmluaXRpb259LCBidXQgZHVyaW5nIGNvbXBvbmVudCBkZWZpbml0aW9uIGV2YWx1YXRpb25cbiAqIHRoaXMgaXMgaXRzIHR5cGUgaW5zdGVhZC5cbiAqXG4gKiBAcGFyYW0gbmFtZSBOYW1lIG11c3QgYmUgYWxwaGFudW1lcmljIHBsdXMgdW5kZXJzY29yZXMuIFR5cGljYWxseSB0aGVzZSBhcmVcbiAqIGxvd2VyY2FzZSB3aXRoIHVuZGVyc2NvcmVzIGxpa2UgYFwib25ib2FyZGluZ19mbG93X3RyYWNrZXJcImAuXG4gKlxuICogVGhpcyBpcyBhIGZlYXR1cmUgb2YgY29tcG9uZW50cywgd2hpY2ggYXJlIGluIGJldGEuXG4gKiBUaGlzIEFQSSBpcyB1bnN0YWJsZSBhbmQgbWF5IGNoYW5nZSBpbiBzdWJzZXF1ZW50IHJlbGVhc2VzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVmaW5lQ29tcG9uZW50PEV4cG9ydHMgZXh0ZW5kcyBDb21wb25lbnRFeHBvcnRzID0gYW55PihcbiAgbmFtZTogc3RyaW5nLFxuKTogQ29tcG9uZW50RGVmaW5pdGlvbjxFeHBvcnRzPiB7XG4gIGNvbnN0IHJldDogUnVudGltZUNvbXBvbmVudERlZmluaXRpb24gPSB7XG4gICAgX2lzUm9vdDogZmFsc2UsXG4gICAgX25hbWU6IG5hbWUsXG4gICAgX2FyZ3M6IHt9LFxuICAgIF9jaGlsZENvbXBvbmVudHM6IFtdLFxuICAgIF9leHBvcnRUcmVlOiB7fSxcbiAgICBfb25Jbml0Q2FsbGJhY2tzOiB7fSxcblxuICAgIGV4cG9ydDogZXhwb3J0Q29tcG9uZW50Rm9yQW5hbHlzaXMsXG4gICAgdXNlLFxuXG4gICAgLy8gcHJldGVuZCB0byBjb25mb3JtIHRvIENvbXBvbmVudERlZmluaXRpb24sIHdoaWNoIHRlbXBvcmFyaWx5IGV4cGVjdHMgX19hcmdzXG4gICAgLi4uKHt9IGFzIHsgX19hcmdzOiBhbnk7IF9fZXhwb3J0czogYW55IH0pLFxuICB9O1xuICByZXR1cm4gcmV0IGFzIGFueSBhcyBDb21wb25lbnREZWZpbml0aW9uPEV4cG9ydHM+O1xufVxuXG4vKipcbiAqIEF0dGFjaCBjb21wb25lbnRzLCByZXVzZWFibGUgcGllY2VzIG9mIGEgQ29udmV4IGRlcGxveW1lbnQsIHRvIHRoaXMgQ29udmV4IGFwcC5cbiAqXG4gKiBUaGlzIGlzIGEgZmVhdHVyZSBvZiBjb21wb25lbnRzLCB3aGljaCBhcmUgaW4gYmV0YS5cbiAqIFRoaXMgQVBJIGlzIHVuc3RhYmxlIGFuZCBtYXkgY2hhbmdlIGluIHN1YnNlcXVlbnQgcmVsZWFzZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZpbmVBcHAoKTogQXBwRGVmaW5pdGlvbiB7XG4gIGNvbnN0IHJldDogUnVudGltZUFwcERlZmluaXRpb24gPSB7XG4gICAgX2lzUm9vdDogdHJ1ZSxcbiAgICBfY2hpbGRDb21wb25lbnRzOiBbXSxcbiAgICBfZXhwb3J0VHJlZToge30sXG5cbiAgICBleHBvcnQ6IGV4cG9ydEFwcEZvckFuYWx5c2lzLFxuICAgIHVzZSxcbiAgfTtcbiAgcmV0dXJuIHJldCBhcyBBcHBEZWZpbml0aW9uO1xufVxuXG50eXBlIEFueUludGVyZmFjZVR5cGUgPSB7XG4gIFtrZXk6IHN0cmluZ106IEFueUludGVyZmFjZVR5cGU7XG59ICYgQW55RnVuY3Rpb25SZWZlcmVuY2U7XG5leHBvcnQgdHlwZSBBbnlDb21wb25lbnRSZWZlcmVuY2UgPSBSZWNvcmQ8c3RyaW5nLCBBbnlJbnRlcmZhY2VUeXBlPjtcblxuZXhwb3J0IHR5cGUgQW55Q2hpbGRDb21wb25lbnRzID0gUmVjb3JkPHN0cmluZywgQW55Q29tcG9uZW50UmVmZXJlbmNlPjtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGN1cnJlbnRTeXN0ZW1VZGZJbkNvbXBvbmVudChcbiAgY29tcG9uZW50SWQ6IHN0cmluZyxcbik6IEFueUNvbXBvbmVudFJlZmVyZW5jZSB7XG4gIHJldHVybiB7XG4gICAgW3RvUmVmZXJlbmNlUGF0aF06IGBfcmVmZXJlbmNlL2N1cnJlbnRTeXN0ZW1VZGZJbkNvbXBvbmVudC8ke2NvbXBvbmVudElkfWAsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNoaWxkQ29tcG9uZW50cyhcbiAgcm9vdDogc3RyaW5nLFxuICBwYXRoUGFydHM6IHN0cmluZ1tdLFxuKTogQW55Q2hpbGRDb21wb25lbnRzIHtcbiAgY29uc3QgaGFuZGxlcjogUHJveHlIYW5kbGVyPG9iamVjdD4gPSB7XG4gICAgZ2V0KF8sIHByb3A6IHN0cmluZyB8IHN5bWJvbCkge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnN0IG5ld1BhcnRzID0gWy4uLnBhdGhQYXJ0cywgcHJvcF07XG4gICAgICAgIHJldHVybiBjcmVhdGVDaGlsZENvbXBvbmVudHMocm9vdCwgbmV3UGFydHMpO1xuICAgICAgfSBlbHNlIGlmIChwcm9wID09PSB0b1JlZmVyZW5jZVBhdGgpIHtcbiAgICAgICAgaWYgKHBhdGhQYXJ0cy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgY29uc3QgZm91bmQgPSBbcm9vdCwgLi4ucGF0aFBhcnRzXS5qb2luKFwiLlwiKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgQVBJIHBhdGggaXMgZXhwZWN0ZWQgdG8gYmUgb2YgdGhlIGZvcm0gXFxgJHtyb290fS5jaGlsZENvbXBvbmVudC5mdW5jdGlvbk5hbWVcXGAuIEZvdW5kOiBcXGAke2ZvdW5kfVxcYGAsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYF9yZWZlcmVuY2UvY2hpbGRDb21wb25lbnQvYCArIHBhdGhQYXJ0cy5qb2luKFwiL1wiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSxcbiAgfTtcbiAgcmV0dXJuIG5ldyBQcm94eSh7fSwgaGFuZGxlcik7XG59XG5cbmV4cG9ydCBjb25zdCBjb21wb25lbnRzR2VuZXJpYyA9ICgpID0+IGNyZWF0ZUNoaWxkQ29tcG9uZW50cyhcImNvbXBvbmVudHNcIiwgW10pO1xuXG5leHBvcnQgdHlwZSBBbnlDb21wb25lbnRzID0gQW55Q2hpbGRDb21wb25lbnRzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuaW1wb3J0IHtcbiAgaXNWYWxpZGF0b3IsXG4gIHZcbn0gZnJvbSBcIi4uL3ZhbHVlcy92YWxpZGF0b3IuanNcIjtcbmV4cG9ydCBjbGFzcyBUYWJsZURlZmluaXRpb24ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudFR5cGUpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaW5kZXhlc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic3RhZ2VkRGJJbmRleGVzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzZWFyY2hJbmRleGVzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzdGFnZWRTZWFyY2hJbmRleGVzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ2ZWN0b3JJbmRleGVzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzdGFnZWRWZWN0b3JJbmRleGVzXCIpO1xuICAgIC8vIFRoZSB0eXBlIG9mIGRvY3VtZW50cyBzdG9yZWQgaW4gdGhpcyB0YWJsZS5cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidmFsaWRhdG9yXCIpO1xuICAgIHRoaXMuaW5kZXhlcyA9IFtdO1xuICAgIHRoaXMuc3RhZ2VkRGJJbmRleGVzID0gW107XG4gICAgdGhpcy5zZWFyY2hJbmRleGVzID0gW107XG4gICAgdGhpcy5zdGFnZWRTZWFyY2hJbmRleGVzID0gW107XG4gICAgdGhpcy52ZWN0b3JJbmRleGVzID0gW107XG4gICAgdGhpcy5zdGFnZWRWZWN0b3JJbmRleGVzID0gW107XG4gICAgdGhpcy52YWxpZGF0b3IgPSBkb2N1bWVudFR5cGU7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbDogaXQgbWF5IGNoYW5nZSBvciBkaXNhcHBlYXIuXG4gICAqXG4gICAqIFJldHVybnMgaW5kZXhlcyBkZWZpbmVkIG9uIHRoaXMgdGFibGUuXG4gICAqIEludGVuZGVkIGZvciB0aGUgYWR2YW5jZWQgdXNlIGNhc2VzIG9mIGR5bmFtaWNhbGx5IGRlY2lkaW5nIHdoaWNoIGluZGV4IHRvIHVzZSBmb3IgYSBxdWVyeS5cbiAgICogSWYgeW91IHRoaW5rIHlvdSBuZWVkIHRoaXMsIHBsZWFzZSBjaGltZSBpbiBvbiB0aHMgaXNzdWUgaW4gdGhlIENvbnZleCBKUyBHaXRIdWIgcmVwby5cbiAgICogaHR0cHM6Ly9naXRodWIuY29tL2dldC1jb252ZXgvY29udmV4LWpzL2lzc3Vlcy80OVxuICAgKi9cbiAgXCIgaW5kZXhlc1wiKCkge1xuICAgIHJldHVybiB0aGlzLmluZGV4ZXM7XG4gIH1cbiAgaW5kZXgobmFtZSwgaW5kZXhDb25maWcpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbmRleENvbmZpZykpIHtcbiAgICAgIHRoaXMuaW5kZXhlcy5wdXNoKHtcbiAgICAgICAgaW5kZXhEZXNjcmlwdG9yOiBuYW1lLFxuICAgICAgICBmaWVsZHM6IGluZGV4Q29uZmlnXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGluZGV4Q29uZmlnLnN0YWdlZCkge1xuICAgICAgdGhpcy5zdGFnZWREYkluZGV4ZXMucHVzaCh7XG4gICAgICAgIGluZGV4RGVzY3JpcHRvcjogbmFtZSxcbiAgICAgICAgZmllbGRzOiBpbmRleENvbmZpZy5maWVsZHNcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmluZGV4ZXMucHVzaCh7XG4gICAgICAgIGluZGV4RGVzY3JpcHRvcjogbmFtZSxcbiAgICAgICAgZmllbGRzOiBpbmRleENvbmZpZy5maWVsZHNcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzZWFyY2hJbmRleChuYW1lLCBpbmRleENvbmZpZykge1xuICAgIGlmIChpbmRleENvbmZpZy5zdGFnZWQpIHtcbiAgICAgIHRoaXMuc3RhZ2VkU2VhcmNoSW5kZXhlcy5wdXNoKHtcbiAgICAgICAgaW5kZXhEZXNjcmlwdG9yOiBuYW1lLFxuICAgICAgICBzZWFyY2hGaWVsZDogaW5kZXhDb25maWcuc2VhcmNoRmllbGQsXG4gICAgICAgIGZpbHRlckZpZWxkczogaW5kZXhDb25maWcuZmlsdGVyRmllbGRzIHx8IFtdXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZWFyY2hJbmRleGVzLnB1c2goe1xuICAgICAgICBpbmRleERlc2NyaXB0b3I6IG5hbWUsXG4gICAgICAgIHNlYXJjaEZpZWxkOiBpbmRleENvbmZpZy5zZWFyY2hGaWVsZCxcbiAgICAgICAgZmlsdGVyRmllbGRzOiBpbmRleENvbmZpZy5maWx0ZXJGaWVsZHMgfHwgW11cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB2ZWN0b3JJbmRleChuYW1lLCBpbmRleENvbmZpZykge1xuICAgIGlmIChpbmRleENvbmZpZy5zdGFnZWQpIHtcbiAgICAgIHRoaXMuc3RhZ2VkVmVjdG9ySW5kZXhlcy5wdXNoKHtcbiAgICAgICAgaW5kZXhEZXNjcmlwdG9yOiBuYW1lLFxuICAgICAgICB2ZWN0b3JGaWVsZDogaW5kZXhDb25maWcudmVjdG9yRmllbGQsXG4gICAgICAgIGRpbWVuc2lvbnM6IGluZGV4Q29uZmlnLmRpbWVuc2lvbnMsXG4gICAgICAgIGZpbHRlckZpZWxkczogaW5kZXhDb25maWcuZmlsdGVyRmllbGRzIHx8IFtdXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy52ZWN0b3JJbmRleGVzLnB1c2goe1xuICAgICAgICBpbmRleERlc2NyaXB0b3I6IG5hbWUsXG4gICAgICAgIHZlY3RvckZpZWxkOiBpbmRleENvbmZpZy52ZWN0b3JGaWVsZCxcbiAgICAgICAgZGltZW5zaW9uczogaW5kZXhDb25maWcuZGltZW5zaW9ucyxcbiAgICAgICAgZmlsdGVyRmllbGRzOiBpbmRleENvbmZpZy5maWx0ZXJGaWVsZHMgfHwgW11cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogV29yayBhcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvNTcwMzVcbiAgICovXG4gIHNlbGYoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEV4cG9ydCB0aGUgY29udGVudHMgb2YgdGhpcyBkZWZpbml0aW9uLlxuICAgKlxuICAgKiBUaGlzIGlzIGNhbGxlZCBpbnRlcm5hbGx5IGJ5IHRoZSBDb252ZXggZnJhbWV3b3JrLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGV4cG9ydCgpIHtcbiAgICBjb25zdCBkb2N1bWVudFR5cGUgPSB0aGlzLnZhbGlkYXRvci5qc29uO1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnRUeXBlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiSW52YWxpZCB2YWxpZGF0b3I6IHBsZWFzZSBtYWtlIHN1cmUgdGhhdCB0aGUgcGFyYW1ldGVyIG9mIGBkZWZpbmVUYWJsZWAgaXMgdmFsaWQgKHNlZSBodHRwczovL2RvY3MuY29udmV4LmRldi9kYXRhYmFzZS9zY2hlbWFzKVwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaW5kZXhlczogdGhpcy5pbmRleGVzLFxuICAgICAgc3RhZ2VkRGJJbmRleGVzOiB0aGlzLnN0YWdlZERiSW5kZXhlcyxcbiAgICAgIHNlYXJjaEluZGV4ZXM6IHRoaXMuc2VhcmNoSW5kZXhlcyxcbiAgICAgIHN0YWdlZFNlYXJjaEluZGV4ZXM6IHRoaXMuc3RhZ2VkU2VhcmNoSW5kZXhlcyxcbiAgICAgIHZlY3RvckluZGV4ZXM6IHRoaXMudmVjdG9ySW5kZXhlcyxcbiAgICAgIHN0YWdlZFZlY3RvckluZGV4ZXM6IHRoaXMuc3RhZ2VkVmVjdG9ySW5kZXhlcyxcbiAgICAgIGRvY3VtZW50VHlwZVxuICAgIH07XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWZpbmVUYWJsZShkb2N1bWVudFNjaGVtYSkge1xuICBpZiAoaXNWYWxpZGF0b3IoZG9jdW1lbnRTY2hlbWEpKSB7XG4gICAgcmV0dXJuIG5ldyBUYWJsZURlZmluaXRpb24oZG9jdW1lbnRTY2hlbWEpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgVGFibGVEZWZpbml0aW9uKHYub2JqZWN0KGRvY3VtZW50U2NoZW1hKSk7XG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBTY2hlbWFEZWZpbml0aW9uIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IodGFibGVzLCBvcHRpb25zKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInRhYmxlc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic3RyaWN0VGFibGVOYW1lVHlwZXNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNjaGVtYVZhbGlkYXRpb25cIik7XG4gICAgdGhpcy50YWJsZXMgPSB0YWJsZXM7XG4gICAgdGhpcy5zY2hlbWFWYWxpZGF0aW9uID0gb3B0aW9ucz8uc2NoZW1hVmFsaWRhdGlvbiA9PT0gdm9pZCAwID8gdHJ1ZSA6IG9wdGlvbnMuc2NoZW1hVmFsaWRhdGlvbjtcbiAgfVxuICAvKipcbiAgICogRXhwb3J0IHRoZSBjb250ZW50cyBvZiB0aGlzIGRlZmluaXRpb24uXG4gICAqXG4gICAqIFRoaXMgaXMgY2FsbGVkIGludGVybmFsbHkgYnkgdGhlIENvbnZleCBmcmFtZXdvcmsuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZXhwb3J0KCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICB0YWJsZXM6IE9iamVjdC5lbnRyaWVzKHRoaXMudGFibGVzKS5tYXAoKFt0YWJsZU5hbWUsIGRlZmluaXRpb25dKSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBpbmRleGVzLFxuICAgICAgICAgIHN0YWdlZERiSW5kZXhlcyxcbiAgICAgICAgICBzZWFyY2hJbmRleGVzLFxuICAgICAgICAgIHN0YWdlZFNlYXJjaEluZGV4ZXMsXG4gICAgICAgICAgdmVjdG9ySW5kZXhlcyxcbiAgICAgICAgICBzdGFnZWRWZWN0b3JJbmRleGVzLFxuICAgICAgICAgIGRvY3VtZW50VHlwZVxuICAgICAgICB9ID0gZGVmaW5pdGlvbi5leHBvcnQoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0YWJsZU5hbWUsXG4gICAgICAgICAgaW5kZXhlcyxcbiAgICAgICAgICBzdGFnZWREYkluZGV4ZXMsXG4gICAgICAgICAgc2VhcmNoSW5kZXhlcyxcbiAgICAgICAgICBzdGFnZWRTZWFyY2hJbmRleGVzLFxuICAgICAgICAgIHZlY3RvckluZGV4ZXMsXG4gICAgICAgICAgc3RhZ2VkVmVjdG9ySW5kZXhlcyxcbiAgICAgICAgICBkb2N1bWVudFR5cGVcbiAgICAgICAgfTtcbiAgICAgIH0pLFxuICAgICAgc2NoZW1hVmFsaWRhdGlvbjogdGhpcy5zY2hlbWFWYWxpZGF0aW9uXG4gICAgfSk7XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWZpbmVTY2hlbWEoc2NoZW1hLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgU2NoZW1hRGVmaW5pdGlvbihzY2hlbWEsIG9wdGlvbnMpO1xufVxuY29uc3QgX3N5c3RlbVNjaGVtYSA9IGRlZmluZVNjaGVtYSh7XG4gIF9zY2hlZHVsZWRfZnVuY3Rpb25zOiBkZWZpbmVUYWJsZSh7XG4gICAgbmFtZTogdi5zdHJpbmcoKSxcbiAgICBhcmdzOiB2LmFycmF5KHYuYW55KCkpLFxuICAgIHNjaGVkdWxlZFRpbWU6IHYuZmxvYXQ2NCgpLFxuICAgIGNvbXBsZXRlZFRpbWU6IHYub3B0aW9uYWwodi5mbG9hdDY0KCkpLFxuICAgIHN0YXRlOiB2LnVuaW9uKFxuICAgICAgdi5vYmplY3QoeyBraW5kOiB2LmxpdGVyYWwoXCJwZW5kaW5nXCIpIH0pLFxuICAgICAgdi5vYmplY3QoeyBraW5kOiB2LmxpdGVyYWwoXCJpblByb2dyZXNzXCIpIH0pLFxuICAgICAgdi5vYmplY3QoeyBraW5kOiB2LmxpdGVyYWwoXCJzdWNjZXNzXCIpIH0pLFxuICAgICAgdi5vYmplY3QoeyBraW5kOiB2LmxpdGVyYWwoXCJmYWlsZWRcIiksIGVycm9yOiB2LnN0cmluZygpIH0pLFxuICAgICAgdi5vYmplY3QoeyBraW5kOiB2LmxpdGVyYWwoXCJjYW5jZWxlZFwiKSB9KVxuICAgIClcbiAgfSksXG4gIF9zdG9yYWdlOiBkZWZpbmVUYWJsZSh7XG4gICAgc2hhMjU2OiB2LnN0cmluZygpLFxuICAgIHNpemU6IHYuZmxvYXQ2NCgpLFxuICAgIGNvbnRlbnRUeXBlOiB2Lm9wdGlvbmFsKHYuc3RyaW5nKCkpXG4gIH0pXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjaGVtYS5qcy5tYXBcbiIsIi8qKlxuICogVXRpbGl0aWVzIGZvciBkZWZpbmluZyB0aGUgc2NoZW1hIG9mIHlvdXIgQ29udmV4IHByb2plY3QuXG4gKlxuICogIyMgVXNhZ2VcbiAqXG4gKiBTY2hlbWFzIHNob3VsZCBiZSBwbGFjZWQgaW4gYSBgc2NoZW1hLnRzYCBmaWxlIGluIHlvdXIgYGNvbnZleC9gIGRpcmVjdG9yeS5cbiAqXG4gKiBTY2hlbWEgZGVmaW5pdGlvbnMgc2hvdWxkIGJlIGJ1aWx0IHVzaW5nIHtAbGluayBkZWZpbmVTY2hlbWF9LFxuICoge0BsaW5rIGRlZmluZVRhYmxlfSwgYW5kIHtAbGluayB2YWx1ZXMudn0uIE1ha2Ugc3VyZSB0byBleHBvcnQgdGhlIHNjaGVtYSBhcyB0aGVcbiAqIGRlZmF1bHQgZXhwb3J0LlxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBkZWZpbmVTY2hlbWEsIGRlZmluZVRhYmxlIH0gZnJvbSBcImNvbnZleC9zZXJ2ZXJcIjtcbiAqIGltcG9ydCB7IHYgfSBmcm9tIFwiY29udmV4L3ZhbHVlc1wiO1xuICpcbiAqICBleHBvcnQgZGVmYXVsdCBkZWZpbmVTY2hlbWEoe1xuICogICAgbWVzc2FnZXM6IGRlZmluZVRhYmxlKHtcbiAqICAgICAgYm9keTogdi5zdHJpbmcoKSxcbiAqICAgICAgdXNlcjogdi5pZChcInVzZXJzXCIpLFxuICogICAgfSksXG4gKiAgICB1c2VyczogZGVmaW5lVGFibGUoe1xuICogICAgICBuYW1lOiB2LnN0cmluZygpLFxuICogICAgfSksXG4gKiAgfSk7XG4gKiBgYGBcbiAqXG4gKiBUbyBsZWFybiBtb3JlIGFib3V0IHNjaGVtYXMsIHNlZSBbRGVmaW5pbmcgYSBTY2hlbWFdKGh0dHBzOi8vZG9jcy5jb252ZXguZGV2L3VzaW5nL3NjaGVtYXMpLlxuICogQG1vZHVsZVxuICovXG5pbXBvcnQge1xuICBBbnlEYXRhTW9kZWwsXG4gIEdlbmVyaWNEYXRhTW9kZWwsXG4gIEdlbmVyaWNUYWJsZUluZGV4ZXMsXG4gIEdlbmVyaWNUYWJsZVNlYXJjaEluZGV4ZXMsXG4gIEdlbmVyaWNUYWJsZVZlY3RvckluZGV4ZXMsXG4gIFRhYmxlTmFtZXNJbkRhdGFNb2RlbCxcbn0gZnJvbSBcIi4uL3NlcnZlci9kYXRhX21vZGVsLmpzXCI7XG5pbXBvcnQge1xuICBJZEZpZWxkLFxuICBJbmRleFRpZWJyZWFrZXJGaWVsZCxcbiAgU3lzdGVtRmllbGRzLFxuICBTeXN0ZW1JbmRleGVzLFxufSBmcm9tIFwiLi4vc2VydmVyL3N5c3RlbV9maWVsZHMuanNcIjtcbmltcG9ydCB7IEV4cGFuZCB9IGZyb20gXCIuLi90eXBlX3V0aWxzLmpzXCI7XG5pbXBvcnQge1xuICBHZW5lcmljVmFsaWRhdG9yLFxuICBPYmplY3RUeXBlLFxuICBpc1ZhbGlkYXRvcixcbiAgdixcbn0gZnJvbSBcIi4uL3ZhbHVlcy92YWxpZGF0b3IuanNcIjtcbmltcG9ydCB7IFZPYmplY3QsIFZhbGlkYXRvciB9IGZyb20gXCIuLi92YWx1ZXMvdmFsaWRhdG9ycy5qc1wiO1xuXG4vKipcbiAqIEV4dHJhY3QgYWxsIG9mIHRoZSBpbmRleCBmaWVsZCBwYXRocyB3aXRoaW4gYSB7QGxpbmsgVmFsaWRhdG9yfS5cbiAqXG4gKiBUaGlzIGlzIHVzZWQgd2l0aGluIHtAbGluayBkZWZpbmVUYWJsZX0uXG4gKiBAcHVibGljXG4gKi9cbnR5cGUgRXh0cmFjdEZpZWxkUGF0aHM8VCBleHRlbmRzIFZhbGlkYXRvcjxhbnksIGFueSwgYW55Pj4gPVxuICAvLyBBZGQgaW4gdGhlIHN5c3RlbSBmaWVsZHMgYXZhaWxhYmxlIGluIGluZGV4IGRlZmluaXRpb25zLlxuICAvLyBUaGlzIHNob3VsZCBiZSBldmVyeXRoaW5nIGV4Y2VwdCBmb3IgYF9pZGAgYmVjYXVzZSB0aGF0cyBhZGRlZCB0byBpbmRleGVzXG4gIC8vIGF1dG9tYXRpY2FsbHkuXG4gIFRbXCJmaWVsZFBhdGhzXCJdIHwga2V5b2YgU3lzdGVtRmllbGRzO1xuXG4vKipcbiAqIEV4dHJhY3QgdGhlIHtAbGluayBHZW5lcmljRG9jdW1lbnR9IHdpdGhpbiBhIHtAbGluayBWYWxpZGF0b3J9IGFuZFxuICogYWRkIG9uIHRoZSBzeXN0ZW0gZmllbGRzLlxuICpcbiAqIFRoaXMgaXMgdXNlZCB3aXRoaW4ge0BsaW5rIGRlZmluZVRhYmxlfS5cbiAqIEBwdWJsaWNcbiAqL1xudHlwZSBFeHRyYWN0RG9jdW1lbnQ8VCBleHRlbmRzIFZhbGlkYXRvcjxhbnksIGFueSwgYW55Pj4gPVxuICAvLyBBZGQgdGhlIHN5c3RlbSBmaWVsZHMgdG8gYFZhbHVlYCAoZXhjZXB0IGBfaWRgIGJlY2F1c2UgaXQgZGVwZW5kcyBvblxuICAvL3RoZSB0YWJsZSBuYW1lKSBhbmQgdHJpY2sgVHlwZVNjcmlwdCBpbnRvIGV4cGFuZGluZyB0aGVtLlxuICBFeHBhbmQ8U3lzdGVtRmllbGRzICYgVFtcInR5cGVcIl0+O1xuXG5leHBvcnQgaW50ZXJmYWNlIERiSW5kZXhDb25maWc8XG4gIEZpcnN0RmllbGRQYXRoIGV4dGVuZHMgc3RyaW5nLFxuICBSZXN0RmllbGRQYXRocyBleHRlbmRzIHN0cmluZ1tdLFxuPiB7XG4gIC8qKlxuICAgKiBUaGUgZmllbGRzIHRvIGluZGV4LCBpbiBvcmRlci4gTXVzdCBzcGVjaWZ5IGF0IGxlYXN0IG9uZSBmaWVsZC5cbiAgICovXG4gIGZpZWxkczogW0ZpcnN0RmllbGRQYXRoLCAuLi5SZXN0RmllbGRQYXRoc107XG59XG5cbi8qKlxuICogVGhlIGNvbmZpZ3VyYXRpb24gZm9yIGEgZnVsbCB0ZXh0IHNlYXJjaCBpbmRleC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2VhcmNoSW5kZXhDb25maWc8XG4gIFNlYXJjaEZpZWxkIGV4dGVuZHMgc3RyaW5nLFxuICBGaWx0ZXJGaWVsZHMgZXh0ZW5kcyBzdHJpbmcsXG4+IHtcbiAgLyoqXG4gICAqIFRoZSBmaWVsZCB0byBpbmRleCBmb3IgZnVsbCB0ZXh0IHNlYXJjaC5cbiAgICpcbiAgICogVGhpcyBtdXN0IGJlIGEgZmllbGQgb2YgdHlwZSBgc3RyaW5nYC5cbiAgICovXG4gIHNlYXJjaEZpZWxkOiBTZWFyY2hGaWVsZDtcblxuICAvKipcbiAgICogQWRkaXRpb25hbCBmaWVsZHMgdG8gaW5kZXggZm9yIGZhc3QgZmlsdGVyaW5nIHdoZW4gcnVubmluZyBzZWFyY2ggcXVlcmllcy5cbiAgICovXG4gIGZpbHRlckZpZWxkcz86IEZpbHRlckZpZWxkc1tdO1xufVxuXG4vKipcbiAqIFRoZSBjb25maWd1cmF0aW9uIGZvciBhIHZlY3RvciBpbmRleC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVmVjdG9ySW5kZXhDb25maWc8XG4gIFZlY3RvckZpZWxkIGV4dGVuZHMgc3RyaW5nLFxuICBGaWx0ZXJGaWVsZHMgZXh0ZW5kcyBzdHJpbmcsXG4+IHtcbiAgLyoqXG4gICAqIFRoZSBmaWVsZCB0byBpbmRleCBmb3IgdmVjdG9yIHNlYXJjaC5cbiAgICpcbiAgICogVGhpcyBtdXN0IGJlIGEgZmllbGQgb2YgdHlwZSBgdi5hcnJheSh2LmZsb2F0NjQoKSlgIChvciBhIHVuaW9uKVxuICAgKi9cbiAgdmVjdG9yRmllbGQ6IFZlY3RvckZpZWxkO1xuICAvKipcbiAgICogVGhlIGxlbmd0aCBvZiB0aGUgdmVjdG9ycyBpbmRleGVkLiBUaGlzIG11c3QgYmUgYmV0d2VlbiAyIGFuZCAyMDQ4IGluY2x1c2l2ZS5cbiAgICovXG4gIGRpbWVuc2lvbnM6IG51bWJlcjtcbiAgLyoqXG4gICAqIEFkZGl0aW9uYWwgZmllbGRzIHRvIGluZGV4IGZvciBmYXN0IGZpbHRlcmluZyB3aGVuIHJ1bm5pbmcgdmVjdG9yIHNlYXJjaGVzLlxuICAgKi9cbiAgZmlsdGVyRmllbGRzPzogRmlsdGVyRmllbGRzW107XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCB0eXBlIFZlY3RvckluZGV4ID0ge1xuICBpbmRleERlc2NyaXB0b3I6IHN0cmluZztcbiAgdmVjdG9yRmllbGQ6IHN0cmluZztcbiAgZGltZW5zaW9uczogbnVtYmVyO1xuICBmaWx0ZXJGaWVsZHM6IHN0cmluZ1tdO1xufTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IHR5cGUgSW5kZXggPSB7XG4gIGluZGV4RGVzY3JpcHRvcjogc3RyaW5nO1xuICBmaWVsZHM6IHN0cmluZ1tdO1xufTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IHR5cGUgU2VhcmNoSW5kZXggPSB7XG4gIGluZGV4RGVzY3JpcHRvcjogc3RyaW5nO1xuICBzZWFyY2hGaWVsZDogc3RyaW5nO1xuICBmaWx0ZXJGaWVsZHM6IHN0cmluZ1tdO1xufTtcblxuLyoqXG4gKiBPcHRpb25zIGZvciBkZWZpbmluZyBhbiBpbmRleC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW5kZXhPcHRpb25zIHtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGluZGV4IHNob3VsZCBiZSBzdGFnZWQuXG4gICAqXG4gICAqIEZvciBsYXJnZSB0YWJsZXMsIGluZGV4IGJhY2tmaWxsIGNhbiBiZSBzbG93LiBTdGFnaW5nIGFuIGluZGV4IGFsbG93cyB5b3VcbiAgICogdG8gcHVzaCB0aGUgc2NoZW1hIGFuZCBlbmFibGUgdGhlIGluZGV4IGxhdGVyLlxuICAgKlxuICAgKiBJZiBgc3RhZ2VkYCBpcyBgdHJ1ZWAsIHRoZSBpbmRleCB3aWxsIGJlIHN0YWdlZCBhbmQgd2lsbCBub3QgYmUgZW5hYmxlZFxuICAgKiB1bnRpbCB0aGUgc3RhZ2VkIGZsYWcgaXMgcmVtb3ZlZC4gU3RhZ2VkIGluZGV4ZXMgZG8gbm90IGJsb2NrIHB1c2hcbiAgICogY29tcGxldGlvbi4gU3RhZ2VkIGluZGV4ZXMgY2Fubm90IGJlIHVzZWQgaW4gcXVlcmllcy5cbiAgICovXG4gIHN0YWdlZD86IGJvb2xlYW47XG59XG5cbi8qKlxuICogVGhlIGRlZmluaXRpb24gb2YgYSB0YWJsZSB3aXRoaW4gYSBzY2hlbWEuXG4gKlxuICogVGhpcyBzaG91bGQgYmUgcHJvZHVjZWQgYnkgdXNpbmcge0BsaW5rIGRlZmluZVRhYmxlfS5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFRhYmxlRGVmaW5pdGlvbjxcbiAgRG9jdW1lbnRUeXBlIGV4dGVuZHMgVmFsaWRhdG9yPGFueSwgYW55LCBhbnk+ID0gVmFsaWRhdG9yPGFueSwgYW55LCBhbnk+LFxuICBJbmRleGVzIGV4dGVuZHMgR2VuZXJpY1RhYmxlSW5kZXhlcyA9IHt9LFxuICBTZWFyY2hJbmRleGVzIGV4dGVuZHMgR2VuZXJpY1RhYmxlU2VhcmNoSW5kZXhlcyA9IHt9LFxuICBWZWN0b3JJbmRleGVzIGV4dGVuZHMgR2VuZXJpY1RhYmxlVmVjdG9ySW5kZXhlcyA9IHt9LFxuPiB7XG4gIHByaXZhdGUgaW5kZXhlczogSW5kZXhbXTtcbiAgcHJpdmF0ZSBzdGFnZWREYkluZGV4ZXM6IEluZGV4W107XG4gIHByaXZhdGUgc2VhcmNoSW5kZXhlczogU2VhcmNoSW5kZXhbXTtcbiAgcHJpdmF0ZSBzdGFnZWRTZWFyY2hJbmRleGVzOiBTZWFyY2hJbmRleFtdO1xuICBwcml2YXRlIHZlY3RvckluZGV4ZXM6IFZlY3RvckluZGV4W107XG4gIHByaXZhdGUgc3RhZ2VkVmVjdG9ySW5kZXhlczogVmVjdG9ySW5kZXhbXTtcbiAgLy8gVGhlIHR5cGUgb2YgZG9jdW1lbnRzIHN0b3JlZCBpbiB0aGlzIHRhYmxlLlxuICB2YWxpZGF0b3I6IERvY3VtZW50VHlwZTtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudFR5cGU6IERvY3VtZW50VHlwZSkge1xuICAgIHRoaXMuaW5kZXhlcyA9IFtdO1xuICAgIHRoaXMuc3RhZ2VkRGJJbmRleGVzID0gW107XG4gICAgdGhpcy5zZWFyY2hJbmRleGVzID0gW107XG4gICAgdGhpcy5zdGFnZWRTZWFyY2hJbmRleGVzID0gW107XG4gICAgdGhpcy52ZWN0b3JJbmRleGVzID0gW107XG4gICAgdGhpcy5zdGFnZWRWZWN0b3JJbmRleGVzID0gW107XG4gICAgdGhpcy52YWxpZGF0b3IgPSBkb2N1bWVudFR5cGU7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBBUEkgaXMgZXhwZXJpbWVudGFsOiBpdCBtYXkgY2hhbmdlIG9yIGRpc2FwcGVhci5cbiAgICpcbiAgICogUmV0dXJucyBpbmRleGVzIGRlZmluZWQgb24gdGhpcyB0YWJsZS5cbiAgICogSW50ZW5kZWQgZm9yIHRoZSBhZHZhbmNlZCB1c2UgY2FzZXMgb2YgZHluYW1pY2FsbHkgZGVjaWRpbmcgd2hpY2ggaW5kZXggdG8gdXNlIGZvciBhIHF1ZXJ5LlxuICAgKiBJZiB5b3UgdGhpbmsgeW91IG5lZWQgdGhpcywgcGxlYXNlIGNoaW1lIGluIG9uIHRocyBpc3N1ZSBpbiB0aGUgQ29udmV4IEpTIEdpdEh1YiByZXBvLlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vZ2V0LWNvbnZleC9jb252ZXgtanMvaXNzdWVzLzQ5XG4gICAqL1xuICBcIiBpbmRleGVzXCIoKTogeyBpbmRleERlc2NyaXB0b3I6IHN0cmluZzsgZmllbGRzOiBzdHJpbmdbXSB9W10ge1xuICAgIHJldHVybiB0aGlzLmluZGV4ZXM7XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lIGFuIGluZGV4IG9uIHRoaXMgdGFibGUuXG4gICAqXG4gICAqIFRvIGxlYXJuIGFib3V0IGluZGV4ZXMsIHNlZSBbRGVmaW5pbmcgSW5kZXhlc10oaHR0cHM6Ly9kb2NzLmNvbnZleC5kZXYvdXNpbmcvaW5kZXhlcykuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGluZGV4LlxuICAgKiBAcGFyYW0gaW5kZXhDb25maWcgLSBUaGUgaW5kZXggY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAqIEByZXR1cm5zIEEge0BsaW5rIFRhYmxlRGVmaW5pdGlvbn0gd2l0aCB0aGlzIGluZGV4IGluY2x1ZGVkLlxuICAgKi9cbiAgaW5kZXg8XG4gICAgSW5kZXhOYW1lIGV4dGVuZHMgc3RyaW5nLFxuICAgIEZpcnN0RmllbGRQYXRoIGV4dGVuZHMgRXh0cmFjdEZpZWxkUGF0aHM8RG9jdW1lbnRUeXBlPixcbiAgICBSZXN0RmllbGRQYXRocyBleHRlbmRzIEV4dHJhY3RGaWVsZFBhdGhzPERvY3VtZW50VHlwZT5bXSxcbiAgPihcbiAgICBuYW1lOiBJbmRleE5hbWUsXG4gICAgaW5kZXhDb25maWc6IEV4cGFuZDxcbiAgICAgIERiSW5kZXhDb25maWc8Rmlyc3RGaWVsZFBhdGgsIFJlc3RGaWVsZFBhdGhzPiAmXG4gICAgICAgIEluZGV4T3B0aW9ucyAmIHsgc3RhZ2VkPzogZmFsc2UgfVxuICAgID4sXG4gICk6IFRhYmxlRGVmaW5pdGlvbjxcbiAgICBEb2N1bWVudFR5cGUsXG4gICAgRXhwYW5kPFxuICAgICAgSW5kZXhlcyAmXG4gICAgICAgIFJlY29yZDxcbiAgICAgICAgICBJbmRleE5hbWUsXG4gICAgICAgICAgW0ZpcnN0RmllbGRQYXRoLCAuLi5SZXN0RmllbGRQYXRocywgSW5kZXhUaWVicmVha2VyRmllbGRdXG4gICAgICAgID5cbiAgICA+LFxuICAgIFNlYXJjaEluZGV4ZXMsXG4gICAgVmVjdG9ySW5kZXhlc1xuICA+O1xuXG4gIC8qKlxuICAgKiBEZWZpbmUgYW4gaW5kZXggb24gdGhpcyB0YWJsZS5cbiAgICpcbiAgICogVG8gbGVhcm4gYWJvdXQgaW5kZXhlcywgc2VlIFtEZWZpbmluZyBJbmRleGVzXShodHRwczovL2RvY3MuY29udmV4LmRldi91c2luZy9pbmRleGVzKS5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgaW5kZXguXG4gICAqIEBwYXJhbSBmaWVsZHMgLSBUaGUgZmllbGRzIHRvIGluZGV4LCBpbiBvcmRlci4gTXVzdCBzcGVjaWZ5IGF0IGxlYXN0IG9uZVxuICAgKiBmaWVsZC5cbiAgICogQHJldHVybnMgQSB7QGxpbmsgVGFibGVEZWZpbml0aW9ufSB3aXRoIHRoaXMgaW5kZXggaW5jbHVkZWQuXG4gICAqL1xuICBpbmRleDxcbiAgICBJbmRleE5hbWUgZXh0ZW5kcyBzdHJpbmcsXG4gICAgRmlyc3RGaWVsZFBhdGggZXh0ZW5kcyBFeHRyYWN0RmllbGRQYXRoczxEb2N1bWVudFR5cGU+LFxuICAgIFJlc3RGaWVsZFBhdGhzIGV4dGVuZHMgRXh0cmFjdEZpZWxkUGF0aHM8RG9jdW1lbnRUeXBlPltdLFxuICA+KFxuICAgIG5hbWU6IEluZGV4TmFtZSxcbiAgICBmaWVsZHM6IFtGaXJzdEZpZWxkUGF0aCwgLi4uUmVzdEZpZWxkUGF0aHNdLFxuICApOiBUYWJsZURlZmluaXRpb248XG4gICAgRG9jdW1lbnRUeXBlLFxuICAgIEV4cGFuZDxcbiAgICAgIEluZGV4ZXMgJlxuICAgICAgICBSZWNvcmQ8XG4gICAgICAgICAgSW5kZXhOYW1lLFxuICAgICAgICAgIFtGaXJzdEZpZWxkUGF0aCwgLi4uUmVzdEZpZWxkUGF0aHMsIEluZGV4VGllYnJlYWtlckZpZWxkXVxuICAgICAgICA+XG4gICAgPixcbiAgICBTZWFyY2hJbmRleGVzLFxuICAgIFZlY3RvckluZGV4ZXNcbiAgPjtcblxuICAvKipcbiAgICogRGVmaW5lIGEgc3RhZ2VkIGluZGV4IG9uIHRoaXMgdGFibGUuXG4gICAqXG4gICAqIEZvciBsYXJnZSB0YWJsZXMsIGluZGV4IGJhY2tmaWxsIGNhbiBiZSBzbG93LiBTdGFnaW5nIGFuIGluZGV4IGFsbG93cyB5b3VcbiAgICogdG8gcHVzaCB0aGUgc2NoZW1hIGFuZCBlbmFibGUgdGhlIGluZGV4IGxhdGVyLlxuICAgKlxuICAgKiBJZiBgc3RhZ2VkYCBpcyBgdHJ1ZWAsIHRoZSBpbmRleCB3aWxsIGJlIHN0YWdlZCBhbmQgd2lsbCBub3QgYmUgZW5hYmxlZFxuICAgKiB1bnRpbCB0aGUgc3RhZ2VkIGZsYWcgaXMgcmVtb3ZlZC4gU3RhZ2VkIGluZGV4ZXMgZG8gbm90IGJsb2NrIHB1c2hcbiAgICogY29tcGxldGlvbi4gU3RhZ2VkIGluZGV4ZXMgY2Fubm90IGJlIHVzZWQgaW4gcXVlcmllcy5cbiAgICpcbiAgICogVG8gbGVhcm4gYWJvdXQgaW5kZXhlcywgc2VlIFtEZWZpbmluZyBJbmRleGVzXShodHRwczovL2RvY3MuY29udmV4LmRldi91c2luZy9pbmRleGVzKS5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgaW5kZXguXG4gICAqIEBwYXJhbSBpbmRleENvbmZpZyAtIFRoZSBpbmRleCBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICogQHJldHVybnMgQSB7QGxpbmsgVGFibGVEZWZpbml0aW9ufSB3aXRoIHRoaXMgaW5kZXggaW5jbHVkZWQuXG4gICAqL1xuICBpbmRleDxcbiAgICBJbmRleE5hbWUgZXh0ZW5kcyBzdHJpbmcsXG4gICAgRmlyc3RGaWVsZFBhdGggZXh0ZW5kcyBFeHRyYWN0RmllbGRQYXRoczxEb2N1bWVudFR5cGU+LFxuICAgIFJlc3RGaWVsZFBhdGhzIGV4dGVuZHMgRXh0cmFjdEZpZWxkUGF0aHM8RG9jdW1lbnRUeXBlPltdLFxuICA+KFxuICAgIG5hbWU6IEluZGV4TmFtZSxcbiAgICBpbmRleENvbmZpZzogRXhwYW5kPFxuICAgICAgRGJJbmRleENvbmZpZzxGaXJzdEZpZWxkUGF0aCwgUmVzdEZpZWxkUGF0aHM+ICZcbiAgICAgICAgSW5kZXhPcHRpb25zICYgeyBzdGFnZWQ6IHRydWUgfVxuICAgID4sXG4gICk6IFRhYmxlRGVmaW5pdGlvbjxEb2N1bWVudFR5cGUsIEluZGV4ZXMsIFNlYXJjaEluZGV4ZXMsIFZlY3RvckluZGV4ZXM+O1xuXG4gIGluZGV4PFxuICAgIEluZGV4TmFtZSBleHRlbmRzIHN0cmluZyxcbiAgICBGaXJzdEZpZWxkUGF0aCBleHRlbmRzIEV4dHJhY3RGaWVsZFBhdGhzPERvY3VtZW50VHlwZT4sXG4gICAgUmVzdEZpZWxkUGF0aHMgZXh0ZW5kcyBFeHRyYWN0RmllbGRQYXRoczxEb2N1bWVudFR5cGU+W10sXG4gID4oXG4gICAgbmFtZTogSW5kZXhOYW1lLFxuICAgIGluZGV4Q29uZmlnOlxuICAgICAgfCBFeHBhbmQ8RGJJbmRleENvbmZpZzxGaXJzdEZpZWxkUGF0aCwgUmVzdEZpZWxkUGF0aHM+ICYgSW5kZXhPcHRpb25zPlxuICAgICAgfCBbRmlyc3RGaWVsZFBhdGgsIC4uLlJlc3RGaWVsZFBhdGhzXSxcbiAgKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaW5kZXhDb25maWcpKSB7XG4gICAgICAvLyBpbmRleENvbmZpZyBpcyBbRmlyc3RGaWVsZFBhdGgsIC4uLlJlc3RGaWVsZFBhdGhzXVxuICAgICAgdGhpcy5pbmRleGVzLnB1c2goe1xuICAgICAgICBpbmRleERlc2NyaXB0b3I6IG5hbWUsXG4gICAgICAgIGZpZWxkczogaW5kZXhDb25maWcsXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGluZGV4Q29uZmlnLnN0YWdlZCkge1xuICAgICAgLy8gaW5kZXhDb25maWcgaXMgb2JqZWN0IHdpdGggZmllbGRzIGFuZCBzdGFnZWQ6IHRydWVcbiAgICAgIHRoaXMuc3RhZ2VkRGJJbmRleGVzLnB1c2goe1xuICAgICAgICBpbmRleERlc2NyaXB0b3I6IG5hbWUsXG4gICAgICAgIGZpZWxkczogaW5kZXhDb25maWcuZmllbGRzLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGluZGV4Q29uZmlnIGlzIG9iamVjdCB3aXRoIGZpZWxkcyAoYW5kIG1heWJlIHN0YWdlZDogZmFsc2UvdW5kZWZpbmVkKVxuICAgICAgdGhpcy5pbmRleGVzLnB1c2goe1xuICAgICAgICBpbmRleERlc2NyaXB0b3I6IG5hbWUsXG4gICAgICAgIGZpZWxkczogaW5kZXhDb25maWcuZmllbGRzLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZSBhIHNlYXJjaCBpbmRleCBvbiB0aGlzIHRhYmxlLlxuICAgKlxuICAgKiBUbyBsZWFybiBhYm91dCBzZWFyY2ggaW5kZXhlcywgc2VlIFtTZWFyY2hdKGh0dHBzOi8vZG9jcy5jb252ZXguZGV2L3RleHQtc2VhcmNoKS5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgaW5kZXguXG4gICAqIEBwYXJhbSBpbmRleENvbmZpZyAtIFRoZSBzZWFyY2ggaW5kZXggY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAqIEByZXR1cm5zIEEge0BsaW5rIFRhYmxlRGVmaW5pdGlvbn0gd2l0aCB0aGlzIHNlYXJjaCBpbmRleCBpbmNsdWRlZC5cbiAgICovXG4gIHNlYXJjaEluZGV4PFxuICAgIEluZGV4TmFtZSBleHRlbmRzIHN0cmluZyxcbiAgICBTZWFyY2hGaWVsZCBleHRlbmRzIEV4dHJhY3RGaWVsZFBhdGhzPERvY3VtZW50VHlwZT4sXG4gICAgRmlsdGVyRmllbGRzIGV4dGVuZHMgRXh0cmFjdEZpZWxkUGF0aHM8RG9jdW1lbnRUeXBlPiA9IG5ldmVyLFxuICA+KFxuICAgIG5hbWU6IEluZGV4TmFtZSxcbiAgICBpbmRleENvbmZpZzogRXhwYW5kPFxuICAgICAgU2VhcmNoSW5kZXhDb25maWc8U2VhcmNoRmllbGQsIEZpbHRlckZpZWxkcz4gJlxuICAgICAgICBJbmRleE9wdGlvbnMgJiB7IHN0YWdlZD86IGZhbHNlIH1cbiAgICA+LFxuICApOiBUYWJsZURlZmluaXRpb248XG4gICAgRG9jdW1lbnRUeXBlLFxuICAgIEluZGV4ZXMsXG4gICAgLy8gVXBkYXRlIGBTZWFyY2hJbmRleGVzYCB0byBpbmNsdWRlIHRoZSBuZXcgaW5kZXggYW5kIHVzZSBgRXhwYW5kYCB0byBtYWtlXG4gICAgLy8gdGhlIHR5cGVzIGxvb2sgcHJldHR5IGluIGVkaXRvcnMuXG4gICAgRXhwYW5kPFxuICAgICAgU2VhcmNoSW5kZXhlcyAmXG4gICAgICAgIFJlY29yZDxcbiAgICAgICAgICBJbmRleE5hbWUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgc2VhcmNoRmllbGQ6IFNlYXJjaEZpZWxkO1xuICAgICAgICAgICAgZmlsdGVyRmllbGRzOiBGaWx0ZXJGaWVsZHM7XG4gICAgICAgICAgfVxuICAgICAgICA+XG4gICAgPixcbiAgICBWZWN0b3JJbmRleGVzXG4gID47XG5cbiAgLyoqXG4gICAqIERlZmluZSBhIHN0YWdlZCBzZWFyY2ggaW5kZXggb24gdGhpcyB0YWJsZS5cbiAgICpcbiAgICogRm9yIGxhcmdlIHRhYmxlcywgaW5kZXggYmFja2ZpbGwgY2FuIGJlIHNsb3cuIFN0YWdpbmcgYW4gaW5kZXggYWxsb3dzIHlvdVxuICAgKiB0byBwdXNoIHRoZSBzY2hlbWEgYW5kIGVuYWJsZSB0aGUgaW5kZXggbGF0ZXIuXG4gICAqXG4gICAqIElmIGBzdGFnZWRgIGlzIGB0cnVlYCwgdGhlIGluZGV4IHdpbGwgYmUgc3RhZ2VkIGFuZCB3aWxsIG5vdCBiZSBlbmFibGVkXG4gICAqIHVudGlsIHRoZSBzdGFnZWQgZmxhZyBpcyByZW1vdmVkLiBTdGFnZWQgaW5kZXhlcyBkbyBub3QgYmxvY2sgcHVzaFxuICAgKiBjb21wbGV0aW9uLiBTdGFnZWQgaW5kZXhlcyBjYW5ub3QgYmUgdXNlZCBpbiBxdWVyaWVzLlxuICAgKlxuICAgKiBUbyBsZWFybiBhYm91dCBzZWFyY2ggaW5kZXhlcywgc2VlIFtTZWFyY2hdKGh0dHBzOi8vZG9jcy5jb252ZXguZGV2L3RleHQtc2VhcmNoKS5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgaW5kZXguXG4gICAqIEBwYXJhbSBpbmRleENvbmZpZyAtIFRoZSBzZWFyY2ggaW5kZXggY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAqIEByZXR1cm5zIEEge0BsaW5rIFRhYmxlRGVmaW5pdGlvbn0gd2l0aCB0aGlzIHNlYXJjaCBpbmRleCBpbmNsdWRlZC5cbiAgICovXG4gIHNlYXJjaEluZGV4PFxuICAgIEluZGV4TmFtZSBleHRlbmRzIHN0cmluZyxcbiAgICBTZWFyY2hGaWVsZCBleHRlbmRzIEV4dHJhY3RGaWVsZFBhdGhzPERvY3VtZW50VHlwZT4sXG4gICAgRmlsdGVyRmllbGRzIGV4dGVuZHMgRXh0cmFjdEZpZWxkUGF0aHM8RG9jdW1lbnRUeXBlPiA9IG5ldmVyLFxuICA+KFxuICAgIG5hbWU6IEluZGV4TmFtZSxcbiAgICBpbmRleENvbmZpZzogRXhwYW5kPFxuICAgICAgU2VhcmNoSW5kZXhDb25maWc8U2VhcmNoRmllbGQsIEZpbHRlckZpZWxkcz4gJlxuICAgICAgICBJbmRleE9wdGlvbnMgJiB7IHN0YWdlZDogdHJ1ZSB9XG4gICAgPixcbiAgKTogVGFibGVEZWZpbml0aW9uPERvY3VtZW50VHlwZSwgSW5kZXhlcywgU2VhcmNoSW5kZXhlcywgVmVjdG9ySW5kZXhlcz47XG5cbiAgc2VhcmNoSW5kZXg8XG4gICAgSW5kZXhOYW1lIGV4dGVuZHMgc3RyaW5nLFxuICAgIFNlYXJjaEZpZWxkIGV4dGVuZHMgRXh0cmFjdEZpZWxkUGF0aHM8RG9jdW1lbnRUeXBlPixcbiAgICBGaWx0ZXJGaWVsZHMgZXh0ZW5kcyBFeHRyYWN0RmllbGRQYXRoczxEb2N1bWVudFR5cGU+ID0gbmV2ZXIsXG4gID4oXG4gICAgbmFtZTogSW5kZXhOYW1lLFxuICAgIGluZGV4Q29uZmlnOiBFeHBhbmQ8XG4gICAgICBTZWFyY2hJbmRleENvbmZpZzxTZWFyY2hGaWVsZCwgRmlsdGVyRmllbGRzPiAmIEluZGV4T3B0aW9uc1xuICAgID4sXG4gICkge1xuICAgIGlmIChpbmRleENvbmZpZy5zdGFnZWQpIHtcbiAgICAgIHRoaXMuc3RhZ2VkU2VhcmNoSW5kZXhlcy5wdXNoKHtcbiAgICAgICAgaW5kZXhEZXNjcmlwdG9yOiBuYW1lLFxuICAgICAgICBzZWFyY2hGaWVsZDogaW5kZXhDb25maWcuc2VhcmNoRmllbGQsXG4gICAgICAgIGZpbHRlckZpZWxkczogaW5kZXhDb25maWcuZmlsdGVyRmllbGRzIHx8IFtdLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VhcmNoSW5kZXhlcy5wdXNoKHtcbiAgICAgICAgaW5kZXhEZXNjcmlwdG9yOiBuYW1lLFxuICAgICAgICBzZWFyY2hGaWVsZDogaW5kZXhDb25maWcuc2VhcmNoRmllbGQsXG4gICAgICAgIGZpbHRlckZpZWxkczogaW5kZXhDb25maWcuZmlsdGVyRmllbGRzIHx8IFtdLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZSBhIHZlY3RvciBpbmRleCBvbiB0aGlzIHRhYmxlLlxuICAgKlxuICAgKiBUbyBsZWFybiBhYm91dCB2ZWN0b3IgaW5kZXhlcywgc2VlIFtWZWN0b3IgU2VhcmNoXShodHRwczovL2RvY3MuY29udmV4LmRldi92ZWN0b3Itc2VhcmNoKS5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgaW5kZXguXG4gICAqIEBwYXJhbSBpbmRleENvbmZpZyAtIFRoZSB2ZWN0b3IgaW5kZXggY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAqIEByZXR1cm5zIEEge0BsaW5rIFRhYmxlRGVmaW5pdGlvbn0gd2l0aCB0aGlzIHZlY3RvciBpbmRleCBpbmNsdWRlZC5cbiAgICovXG4gIHZlY3RvckluZGV4PFxuICAgIEluZGV4TmFtZSBleHRlbmRzIHN0cmluZyxcbiAgICBWZWN0b3JGaWVsZCBleHRlbmRzIEV4dHJhY3RGaWVsZFBhdGhzPERvY3VtZW50VHlwZT4sXG4gICAgRmlsdGVyRmllbGRzIGV4dGVuZHMgRXh0cmFjdEZpZWxkUGF0aHM8RG9jdW1lbnRUeXBlPiA9IG5ldmVyLFxuICA+KFxuICAgIG5hbWU6IEluZGV4TmFtZSxcbiAgICBpbmRleENvbmZpZzogRXhwYW5kPFxuICAgICAgVmVjdG9ySW5kZXhDb25maWc8VmVjdG9yRmllbGQsIEZpbHRlckZpZWxkcz4gJlxuICAgICAgICBJbmRleE9wdGlvbnMgJiB7IHN0YWdlZD86IGZhbHNlIH1cbiAgICA+LFxuICApOiBUYWJsZURlZmluaXRpb248XG4gICAgRG9jdW1lbnRUeXBlLFxuICAgIEluZGV4ZXMsXG4gICAgU2VhcmNoSW5kZXhlcyxcbiAgICBFeHBhbmQ8XG4gICAgICBWZWN0b3JJbmRleGVzICZcbiAgICAgICAgUmVjb3JkPFxuICAgICAgICAgIEluZGV4TmFtZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2ZWN0b3JGaWVsZDogVmVjdG9yRmllbGQ7XG4gICAgICAgICAgICBkaW1lbnNpb25zOiBudW1iZXI7XG4gICAgICAgICAgICBmaWx0ZXJGaWVsZHM6IEZpbHRlckZpZWxkcztcbiAgICAgICAgICB9XG4gICAgICAgID5cbiAgICA+XG4gID47XG5cbiAgLyoqXG4gICAqIERlZmluZSBhIHN0YWdlZCB2ZWN0b3IgaW5kZXggb24gdGhpcyB0YWJsZS5cbiAgICpcbiAgICogRm9yIGxhcmdlIHRhYmxlcywgaW5kZXggYmFja2ZpbGwgY2FuIGJlIHNsb3cuIFN0YWdpbmcgYW4gaW5kZXggYWxsb3dzIHlvdVxuICAgKiB0byBwdXNoIHRoZSBzY2hlbWEgYW5kIGVuYWJsZSB0aGUgaW5kZXggbGF0ZXIuXG4gICAqXG4gICAqIElmIGBzdGFnZWRgIGlzIGB0cnVlYCwgdGhlIGluZGV4IHdpbGwgYmUgc3RhZ2VkIGFuZCB3aWxsIG5vdCBiZSBlbmFibGVkXG4gICAqIHVudGlsIHRoZSBzdGFnZWQgZmxhZyBpcyByZW1vdmVkLiBTdGFnZWQgaW5kZXhlcyBkbyBub3QgYmxvY2sgcHVzaFxuICAgKiBjb21wbGV0aW9uLiBTdGFnZWQgaW5kZXhlcyBjYW5ub3QgYmUgdXNlZCBpbiBxdWVyaWVzLlxuICAgKlxuICAgKiBUbyBsZWFybiBhYm91dCB2ZWN0b3IgaW5kZXhlcywgc2VlIFtWZWN0b3IgU2VhcmNoXShodHRwczovL2RvY3MuY29udmV4LmRldi92ZWN0b3Itc2VhcmNoKS5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgaW5kZXguXG4gICAqIEBwYXJhbSBpbmRleENvbmZpZyAtIFRoZSB2ZWN0b3IgaW5kZXggY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAqIEByZXR1cm5zIEEge0BsaW5rIFRhYmxlRGVmaW5pdGlvbn0gd2l0aCB0aGlzIHZlY3RvciBpbmRleCBpbmNsdWRlZC5cbiAgICovXG4gIHZlY3RvckluZGV4PFxuICAgIEluZGV4TmFtZSBleHRlbmRzIHN0cmluZyxcbiAgICBWZWN0b3JGaWVsZCBleHRlbmRzIEV4dHJhY3RGaWVsZFBhdGhzPERvY3VtZW50VHlwZT4sXG4gICAgRmlsdGVyRmllbGRzIGV4dGVuZHMgRXh0cmFjdEZpZWxkUGF0aHM8RG9jdW1lbnRUeXBlPiA9IG5ldmVyLFxuICA+KFxuICAgIG5hbWU6IEluZGV4TmFtZSxcbiAgICBpbmRleENvbmZpZzogRXhwYW5kPFxuICAgICAgVmVjdG9ySW5kZXhDb25maWc8VmVjdG9yRmllbGQsIEZpbHRlckZpZWxkcz4gJlxuICAgICAgICBJbmRleE9wdGlvbnMgJiB7IHN0YWdlZDogdHJ1ZSB9XG4gICAgPixcbiAgKTogVGFibGVEZWZpbml0aW9uPERvY3VtZW50VHlwZSwgSW5kZXhlcywgU2VhcmNoSW5kZXhlcywgVmVjdG9ySW5kZXhlcz47XG5cbiAgdmVjdG9ySW5kZXg8XG4gICAgSW5kZXhOYW1lIGV4dGVuZHMgc3RyaW5nLFxuICAgIFZlY3RvckZpZWxkIGV4dGVuZHMgRXh0cmFjdEZpZWxkUGF0aHM8RG9jdW1lbnRUeXBlPixcbiAgICBGaWx0ZXJGaWVsZHMgZXh0ZW5kcyBFeHRyYWN0RmllbGRQYXRoczxEb2N1bWVudFR5cGU+ID0gbmV2ZXIsXG4gID4oXG4gICAgbmFtZTogSW5kZXhOYW1lLFxuICAgIGluZGV4Q29uZmlnOiBFeHBhbmQ8XG4gICAgICBWZWN0b3JJbmRleENvbmZpZzxWZWN0b3JGaWVsZCwgRmlsdGVyRmllbGRzPiAmIEluZGV4T3B0aW9uc1xuICAgID4sXG4gICkge1xuICAgIGlmIChpbmRleENvbmZpZy5zdGFnZWQpIHtcbiAgICAgIHRoaXMuc3RhZ2VkVmVjdG9ySW5kZXhlcy5wdXNoKHtcbiAgICAgICAgaW5kZXhEZXNjcmlwdG9yOiBuYW1lLFxuICAgICAgICB2ZWN0b3JGaWVsZDogaW5kZXhDb25maWcudmVjdG9yRmllbGQsXG4gICAgICAgIGRpbWVuc2lvbnM6IGluZGV4Q29uZmlnLmRpbWVuc2lvbnMsXG4gICAgICAgIGZpbHRlckZpZWxkczogaW5kZXhDb25maWcuZmlsdGVyRmllbGRzIHx8IFtdLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudmVjdG9ySW5kZXhlcy5wdXNoKHtcbiAgICAgICAgaW5kZXhEZXNjcmlwdG9yOiBuYW1lLFxuICAgICAgICB2ZWN0b3JGaWVsZDogaW5kZXhDb25maWcudmVjdG9yRmllbGQsXG4gICAgICAgIGRpbWVuc2lvbnM6IGluZGV4Q29uZmlnLmRpbWVuc2lvbnMsXG4gICAgICAgIGZpbHRlckZpZWxkczogaW5kZXhDb25maWcuZmlsdGVyRmllbGRzIHx8IFtdLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFdvcmsgYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzU3MDM1XG4gICAqL1xuICBwcm90ZWN0ZWQgc2VsZigpOiBUYWJsZURlZmluaXRpb248XG4gICAgRG9jdW1lbnRUeXBlLFxuICAgIEluZGV4ZXMsXG4gICAgU2VhcmNoSW5kZXhlcyxcbiAgICBWZWN0b3JJbmRleGVzXG4gID4ge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBFeHBvcnQgdGhlIGNvbnRlbnRzIG9mIHRoaXMgZGVmaW5pdGlvbi5cbiAgICpcbiAgICogVGhpcyBpcyBjYWxsZWQgaW50ZXJuYWxseSBieSB0aGUgQ29udmV4IGZyYW1ld29yay5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBleHBvcnQoKSB7XG4gICAgY29uc3QgZG9jdW1lbnRUeXBlID0gdGhpcy52YWxpZGF0b3IuanNvbjtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50VHlwZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkludmFsaWQgdmFsaWRhdG9yOiBwbGVhc2UgbWFrZSBzdXJlIHRoYXQgdGhlIHBhcmFtZXRlciBvZiBgZGVmaW5lVGFibGVgIGlzIHZhbGlkIChzZWUgaHR0cHM6Ly9kb2NzLmNvbnZleC5kZXYvZGF0YWJhc2Uvc2NoZW1hcylcIixcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGluZGV4ZXM6IHRoaXMuaW5kZXhlcyxcbiAgICAgIHN0YWdlZERiSW5kZXhlczogdGhpcy5zdGFnZWREYkluZGV4ZXMsXG4gICAgICBzZWFyY2hJbmRleGVzOiB0aGlzLnNlYXJjaEluZGV4ZXMsXG4gICAgICBzdGFnZWRTZWFyY2hJbmRleGVzOiB0aGlzLnN0YWdlZFNlYXJjaEluZGV4ZXMsXG4gICAgICB2ZWN0b3JJbmRleGVzOiB0aGlzLnZlY3RvckluZGV4ZXMsXG4gICAgICBzdGFnZWRWZWN0b3JJbmRleGVzOiB0aGlzLnN0YWdlZFZlY3RvckluZGV4ZXMsXG4gICAgICBkb2N1bWVudFR5cGUsXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIERlZmluZSBhIHRhYmxlIGluIGEgc2NoZW1hLlxuICpcbiAqIFlvdSBjYW4gZWl0aGVyIHNwZWNpZnkgdGhlIHNjaGVtYSBvZiB5b3VyIGRvY3VtZW50cyBhcyBhbiBvYmplY3QgbGlrZVxuICogYGBgdHNcbiAqIGRlZmluZVRhYmxlKHtcbiAqICAgZmllbGQ6IHYuc3RyaW5nKClcbiAqIH0pO1xuICogYGBgXG4gKlxuICogb3IgYXMgYSBzY2hlbWEgdHlwZSBsaWtlXG4gKiBgYGB0c1xuICogZGVmaW5lVGFibGUoXG4gKiAgdi51bmlvbihcbiAqICAgIHYub2JqZWN0KHsuLi59KSxcbiAqICAgIHYub2JqZWN0KHsuLi59KVxuICogIClcbiAqICk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZG9jdW1lbnRTY2hlbWEgLSBUaGUgdHlwZSBvZiBkb2N1bWVudHMgc3RvcmVkIGluIHRoaXMgdGFibGUuXG4gKiBAcmV0dXJucyBBIHtAbGluayBUYWJsZURlZmluaXRpb259IGZvciB0aGUgdGFibGUuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gZGVmaW5lVGFibGU8XG4gIERvY3VtZW50U2NoZW1hIGV4dGVuZHMgVmFsaWRhdG9yPFJlY29yZDxzdHJpbmcsIGFueT4sIFwicmVxdWlyZWRcIiwgYW55Pixcbj4oZG9jdW1lbnRTY2hlbWE6IERvY3VtZW50U2NoZW1hKTogVGFibGVEZWZpbml0aW9uPERvY3VtZW50U2NoZW1hPjtcbi8qKlxuICogRGVmaW5lIGEgdGFibGUgaW4gYSBzY2hlbWEuXG4gKlxuICogWW91IGNhbiBlaXRoZXIgc3BlY2lmeSB0aGUgc2NoZW1hIG9mIHlvdXIgZG9jdW1lbnRzIGFzIGFuIG9iamVjdCBsaWtlXG4gKiBgYGB0c1xuICogZGVmaW5lVGFibGUoe1xuICogICBmaWVsZDogdi5zdHJpbmcoKVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBvciBhcyBhIHNjaGVtYSB0eXBlIGxpa2VcbiAqIGBgYHRzXG4gKiBkZWZpbmVUYWJsZShcbiAqICB2LnVuaW9uKFxuICogICAgdi5vYmplY3Qoey4uLn0pLFxuICogICAgdi5vYmplY3Qoey4uLn0pXG4gKiAgKVxuICogKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBkb2N1bWVudFNjaGVtYSAtIFRoZSB0eXBlIG9mIGRvY3VtZW50cyBzdG9yZWQgaW4gdGhpcyB0YWJsZS5cbiAqIEByZXR1cm5zIEEge0BsaW5rIFRhYmxlRGVmaW5pdGlvbn0gZm9yIHRoZSB0YWJsZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZpbmVUYWJsZTxcbiAgRG9jdW1lbnRTY2hlbWEgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBHZW5lcmljVmFsaWRhdG9yPixcbj4oXG4gIGRvY3VtZW50U2NoZW1hOiBEb2N1bWVudFNjaGVtYSxcbik6IFRhYmxlRGVmaW5pdGlvbjxWT2JqZWN0PE9iamVjdFR5cGU8RG9jdW1lbnRTY2hlbWE+LCBEb2N1bWVudFNjaGVtYT4+O1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmluZVRhYmxlPFxuICBEb2N1bWVudFNjaGVtYSBleHRlbmRzXG4gICAgfCBWYWxpZGF0b3I8UmVjb3JkPHN0cmluZywgYW55PiwgXCJyZXF1aXJlZFwiLCBhbnk+XG4gICAgfCBSZWNvcmQ8c3RyaW5nLCBHZW5lcmljVmFsaWRhdG9yPixcbj4oZG9jdW1lbnRTY2hlbWE6IERvY3VtZW50U2NoZW1hKTogVGFibGVEZWZpbml0aW9uPGFueSwgYW55LCBhbnk+IHtcbiAgaWYgKGlzVmFsaWRhdG9yKGRvY3VtZW50U2NoZW1hKSkge1xuICAgIHJldHVybiBuZXcgVGFibGVEZWZpbml0aW9uKGRvY3VtZW50U2NoZW1hKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IFRhYmxlRGVmaW5pdGlvbih2Lm9iamVjdChkb2N1bWVudFNjaGVtYSkpO1xuICB9XG59XG5cbi8qKlxuICogQSB0eXBlIGRlc2NyaWJpbmcgdGhlIHNjaGVtYSBvZiBhIENvbnZleCBwcm9qZWN0LlxuICpcbiAqIFRoaXMgc2hvdWxkIGJlIGNvbnN0cnVjdGVkIHVzaW5nIHtAbGluayBkZWZpbmVTY2hlbWF9LCB7QGxpbmsgZGVmaW5lVGFibGV9LFxuICogYW5kIHtAbGluayB2fS5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IHR5cGUgR2VuZXJpY1NjaGVtYSA9IFJlY29yZDxzdHJpbmcsIFRhYmxlRGVmaW5pdGlvbj47XG5cbi8qKlxuICpcbiAqIFRoZSBkZWZpbml0aW9uIG9mIGEgQ29udmV4IHByb2plY3Qgc2NoZW1hLlxuICpcbiAqIFRoaXMgc2hvdWxkIGJlIHByb2R1Y2VkIGJ5IHVzaW5nIHtAbGluayBkZWZpbmVTY2hlbWF9LlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgU2NoZW1hRGVmaW5pdGlvbjxcbiAgU2NoZW1hIGV4dGVuZHMgR2VuZXJpY1NjaGVtYSxcbiAgU3RyaWN0VGFibGVUeXBlcyBleHRlbmRzIGJvb2xlYW4sXG4+IHtcbiAgcHVibGljIHRhYmxlczogU2NoZW1hO1xuICBwdWJsaWMgc3RyaWN0VGFibGVOYW1lVHlwZXMhOiBTdHJpY3RUYWJsZVR5cGVzO1xuICBwdWJsaWMgcmVhZG9ubHkgc2NoZW1hVmFsaWRhdGlvbjogYm9vbGVhbjtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0YWJsZXM6IFNjaGVtYSwgb3B0aW9ucz86IERlZmluZVNjaGVtYU9wdGlvbnM8U3RyaWN0VGFibGVUeXBlcz4pIHtcbiAgICB0aGlzLnRhYmxlcyA9IHRhYmxlcztcbiAgICB0aGlzLnNjaGVtYVZhbGlkYXRpb24gPVxuICAgICAgb3B0aW9ucz8uc2NoZW1hVmFsaWRhdGlvbiA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdGlvbnMuc2NoZW1hVmFsaWRhdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvcnQgdGhlIGNvbnRlbnRzIG9mIHRoaXMgZGVmaW5pdGlvbi5cbiAgICpcbiAgICogVGhpcyBpcyBjYWxsZWQgaW50ZXJuYWxseSBieSB0aGUgQ29udmV4IGZyYW1ld29yay5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBleHBvcnQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgdGFibGVzOiBPYmplY3QuZW50cmllcyh0aGlzLnRhYmxlcykubWFwKChbdGFibGVOYW1lLCBkZWZpbml0aW9uXSkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaW5kZXhlcyxcbiAgICAgICAgICBzdGFnZWREYkluZGV4ZXMsXG4gICAgICAgICAgc2VhcmNoSW5kZXhlcyxcbiAgICAgICAgICBzdGFnZWRTZWFyY2hJbmRleGVzLFxuICAgICAgICAgIHZlY3RvckluZGV4ZXMsXG4gICAgICAgICAgc3RhZ2VkVmVjdG9ySW5kZXhlcyxcbiAgICAgICAgICBkb2N1bWVudFR5cGUsXG4gICAgICAgIH0gPSBkZWZpbml0aW9uLmV4cG9ydCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRhYmxlTmFtZSxcbiAgICAgICAgICBpbmRleGVzLFxuICAgICAgICAgIHN0YWdlZERiSW5kZXhlcyxcbiAgICAgICAgICBzZWFyY2hJbmRleGVzLFxuICAgICAgICAgIHN0YWdlZFNlYXJjaEluZGV4ZXMsXG4gICAgICAgICAgdmVjdG9ySW5kZXhlcyxcbiAgICAgICAgICBzdGFnZWRWZWN0b3JJbmRleGVzLFxuICAgICAgICAgIGRvY3VtZW50VHlwZSxcbiAgICAgICAgfTtcbiAgICAgIH0pLFxuICAgICAgc2NoZW1hVmFsaWRhdGlvbjogdGhpcy5zY2hlbWFWYWxpZGF0aW9uLFxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogT3B0aW9ucyBmb3Ige0BsaW5rIGRlZmluZVNjaGVtYX0uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIERlZmluZVNjaGVtYU9wdGlvbnM8U3RyaWN0VGFibGVOYW1lVHlwZXMgZXh0ZW5kcyBib29sZWFuPiB7XG4gIC8qKlxuICAgKiBXaGV0aGVyIENvbnZleCBzaG91bGQgdmFsaWRhdGUgYXQgcnVudGltZSB0aGF0IGFsbCBkb2N1bWVudHMgbWF0Y2hcbiAgICogeW91ciBzY2hlbWEuXG4gICAqXG4gICAqIElmIGBzY2hlbWFWYWxpZGF0aW9uYCBpcyBgdHJ1ZWAsIENvbnZleCB3aWxsOlxuICAgKiAxLiBDaGVjayB0aGF0IGFsbCBleGlzdGluZyBkb2N1bWVudHMgbWF0Y2ggeW91ciBzY2hlbWEgd2hlbiB5b3VyIHNjaGVtYVxuICAgKiBpcyBwdXNoZWQuXG4gICAqIDIuIENoZWNrIHRoYXQgYWxsIGluc2VydGlvbnMgYW5kIHVwZGF0ZXMgbWF0Y2ggeW91ciBzY2hlbWEgZHVyaW5nIG11dGF0aW9ucy5cbiAgICpcbiAgICogSWYgYHNjaGVtYVZhbGlkYXRpb25gIGlzIGBmYWxzZWAsIENvbnZleCB3aWxsIG5vdCB2YWxpZGF0ZSB0aGF0IG5ldyBvclxuICAgKiBleGlzdGluZyBkb2N1bWVudHMgbWF0Y2ggeW91ciBzY2hlbWEuIFlvdSdsbCBzdGlsbCBnZXQgc2NoZW1hLXNwZWNpZmljXG4gICAqIFR5cGVTY3JpcHQgdHlwZXMsIGJ1dCB0aGVyZSB3aWxsIGJlIG5vIHZhbGlkYXRpb24gYXQgcnVudGltZSB0aGF0IHlvdXJcbiAgICogZG9jdW1lbnRzIG1hdGNoIHRob3NlIHR5cGVzLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBgc2NoZW1hVmFsaWRhdGlvbmAgaXMgYHRydWVgLlxuICAgKi9cbiAgc2NoZW1hVmFsaWRhdGlvbj86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIFR5cGVTY3JpcHQgdHlwZXMgc2hvdWxkIGFsbG93IGFjY2Vzc2luZyB0YWJsZXMgbm90IGluIHRoZSBzY2hlbWEuXG4gICAqXG4gICAqIElmIGBzdHJpY3RUYWJsZU5hbWVUeXBlc2AgaXMgYHRydWVgLCB1c2luZyB0YWJsZXMgbm90IGxpc3RlZCBpbiB0aGUgc2NoZW1hXG4gICAqIHdpbGwgZ2VuZXJhdGUgYSBUeXBlU2NyaXB0IGNvbXBpbGF0aW9uIGVycm9yLlxuICAgKlxuICAgKiBJZiBgc3RyaWN0VGFibGVOYW1lVHlwZXNgIGlzIGBmYWxzZWAsIHlvdSdsbCBiZSBhYmxlIHRvIGFjY2VzcyB0YWJsZXMgbm90XG4gICAqIGxpc3RlZCBpbiB0aGUgc2NoZW1hIGFuZCB0aGVpciBkb2N1bWVudCB0eXBlIHdpbGwgYmUgYGFueWAuXG4gICAqXG4gICAqIGBzdHJpY3RUYWJsZU5hbWVUeXBlczogZmFsc2VgIGlzIHVzZWZ1bCBmb3IgcmFwaWQgcHJvdG90eXBpbmcuXG4gICAqXG4gICAqIFJlZ2FyZGxlc3Mgb2YgdGhlIHZhbHVlIG9mIGBzdHJpY3RUYWJsZU5hbWVUeXBlc2AsIHlvdXIgc2NoZW1hIHdpbGwgb25seVxuICAgKiB2YWxpZGF0ZSBkb2N1bWVudHMgaW4gdGhlIHRhYmxlcyBsaXN0ZWQgaW4gdGhlIHNjaGVtYS4gWW91IGNhbiBzdGlsbCBjcmVhdGVcbiAgICogYW5kIG1vZGlmeSBvdGhlciB0YWJsZXMgb24gdGhlIGRhc2hib2FyZCBvciBpbiBKYXZhU2NyaXB0IG11dGF0aW9ucy5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgYHN0cmljdFRhYmxlTmFtZVR5cGVzYCBpcyBgdHJ1ZWAuXG4gICAqL1xuICBzdHJpY3RUYWJsZU5hbWVUeXBlcz86IFN0cmljdFRhYmxlTmFtZVR5cGVzO1xufVxuXG4vKipcbiAqIERlZmluZSB0aGUgc2NoZW1hIG9mIHRoaXMgQ29udmV4IHByb2plY3QuXG4gKlxuICogVGhpcyBzaG91bGQgYmUgZXhwb3J0ZWQgZnJvbSBhIGBzY2hlbWEudHNgIGZpbGUgaW4geW91ciBgY29udmV4L2AgZGlyZWN0b3J5XG4gKiBsaWtlOlxuICpcbiAqIGBgYHRzXG4gKiBleHBvcnQgZGVmYXVsdCBkZWZpbmVTY2hlbWEoe1xuICogICAuLi5cbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHNjaGVtYSAtIEEgbWFwIGZyb20gdGFibGUgbmFtZSB0byB7QGxpbmsgVGFibGVEZWZpbml0aW9ufSBmb3IgYWxsIG9mXG4gKiB0aGUgdGFibGVzIGluIHRoaXMgcHJvamVjdC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwgY29uZmlndXJhdGlvbi4gU2VlIHtAbGluayBEZWZpbmVTY2hlbWFPcHRpb25zfSBmb3JcbiAqIGEgZnVsbCBkZXNjcmlwdGlvbi5cbiAqIEByZXR1cm5zIFRoZSBzY2hlbWEuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gZGVmaW5lU2NoZW1hPFxuICBTY2hlbWEgZXh0ZW5kcyBHZW5lcmljU2NoZW1hLFxuICBTdHJpY3RUYWJsZU5hbWVUeXBlcyBleHRlbmRzIGJvb2xlYW4gPSB0cnVlLFxuPihcbiAgc2NoZW1hOiBTY2hlbWEsXG4gIG9wdGlvbnM/OiBEZWZpbmVTY2hlbWFPcHRpb25zPFN0cmljdFRhYmxlTmFtZVR5cGVzPixcbik6IFNjaGVtYURlZmluaXRpb248U2NoZW1hLCBTdHJpY3RUYWJsZU5hbWVUeXBlcz4ge1xuICByZXR1cm4gbmV3IFNjaGVtYURlZmluaXRpb24oc2NoZW1hLCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBJbnRlcm5hbCB0eXBlIHVzZWQgaW4gQ29udmV4IGNvZGUgZ2VuZXJhdGlvbiFcbiAqXG4gKiBDb252ZXJ0IGEge0BsaW5rIFNjaGVtYURlZmluaXRpb259IGludG8gYSB7QGxpbmsgc2VydmVyLkdlbmVyaWNEYXRhTW9kZWx9LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IHR5cGUgRGF0YU1vZGVsRnJvbVNjaGVtYURlZmluaXRpb248XG4gIFNjaGVtYURlZiBleHRlbmRzIFNjaGVtYURlZmluaXRpb248YW55LCBib29sZWFuPixcbj4gPSBNYXliZU1ha2VMb29zZURhdGFNb2RlbDxcbiAge1xuICAgIFtUYWJsZU5hbWUgaW4ga2V5b2YgU2NoZW1hRGVmW1widGFibGVzXCJdICZcbiAgICAgIHN0cmluZ106IFNjaGVtYURlZltcInRhYmxlc1wiXVtUYWJsZU5hbWVdIGV4dGVuZHMgVGFibGVEZWZpbml0aW9uPFxuICAgICAgaW5mZXIgRG9jdW1lbnRUeXBlLFxuICAgICAgaW5mZXIgSW5kZXhlcyxcbiAgICAgIGluZmVyIFNlYXJjaEluZGV4ZXMsXG4gICAgICBpbmZlciBWZWN0b3JJbmRleGVzXG4gICAgPlxuICAgICAgPyB7XG4gICAgICAgICAgLy8gV2UndmUgYWxyZWFkeSBhZGRlZCBhbGwgb2YgdGhlIHN5c3RlbSBmaWVsZHMgZXhjZXB0IGZvciBgX2lkYC5cbiAgICAgICAgICAvLyBBZGQgdGhhdCBoZXJlLlxuICAgICAgICAgIGRvY3VtZW50OiBFeHBhbmQ8SWRGaWVsZDxUYWJsZU5hbWU+ICYgRXh0cmFjdERvY3VtZW50PERvY3VtZW50VHlwZT4+O1xuICAgICAgICAgIGZpZWxkUGF0aHM6XG4gICAgICAgICAgICB8IGtleW9mIElkRmllbGQ8VGFibGVOYW1lPlxuICAgICAgICAgICAgfCBFeHRyYWN0RmllbGRQYXRoczxEb2N1bWVudFR5cGU+O1xuICAgICAgICAgIGluZGV4ZXM6IEV4cGFuZDxJbmRleGVzICYgU3lzdGVtSW5kZXhlcz47XG4gICAgICAgICAgc2VhcmNoSW5kZXhlczogU2VhcmNoSW5kZXhlcztcbiAgICAgICAgICB2ZWN0b3JJbmRleGVzOiBWZWN0b3JJbmRleGVzO1xuICAgICAgICB9XG4gICAgICA6IG5ldmVyO1xuICB9LFxuICBTY2hlbWFEZWZbXCJzdHJpY3RUYWJsZU5hbWVUeXBlc1wiXVxuPjtcblxudHlwZSBNYXliZU1ha2VMb29zZURhdGFNb2RlbDxcbiAgRGF0YU1vZGVsIGV4dGVuZHMgR2VuZXJpY0RhdGFNb2RlbCxcbiAgU3RyaWN0VGFibGVOYW1lVHlwZXMgZXh0ZW5kcyBib29sZWFuLFxuPiA9IFN0cmljdFRhYmxlTmFtZVR5cGVzIGV4dGVuZHMgdHJ1ZVxuICA/IERhdGFNb2RlbFxuICA6IEV4cGFuZDxEYXRhTW9kZWwgJiBBbnlEYXRhTW9kZWw+O1xuXG5jb25zdCBfc3lzdGVtU2NoZW1hID0gZGVmaW5lU2NoZW1hKHtcbiAgX3NjaGVkdWxlZF9mdW5jdGlvbnM6IGRlZmluZVRhYmxlKHtcbiAgICBuYW1lOiB2LnN0cmluZygpLFxuICAgIGFyZ3M6IHYuYXJyYXkodi5hbnkoKSksXG4gICAgc2NoZWR1bGVkVGltZTogdi5mbG9hdDY0KCksXG4gICAgY29tcGxldGVkVGltZTogdi5vcHRpb25hbCh2LmZsb2F0NjQoKSksXG4gICAgc3RhdGU6IHYudW5pb24oXG4gICAgICB2Lm9iamVjdCh7IGtpbmQ6IHYubGl0ZXJhbChcInBlbmRpbmdcIikgfSksXG4gICAgICB2Lm9iamVjdCh7IGtpbmQ6IHYubGl0ZXJhbChcImluUHJvZ3Jlc3NcIikgfSksXG4gICAgICB2Lm9iamVjdCh7IGtpbmQ6IHYubGl0ZXJhbChcInN1Y2Nlc3NcIikgfSksXG4gICAgICB2Lm9iamVjdCh7IGtpbmQ6IHYubGl0ZXJhbChcImZhaWxlZFwiKSwgZXJyb3I6IHYuc3RyaW5nKCkgfSksXG4gICAgICB2Lm9iamVjdCh7IGtpbmQ6IHYubGl0ZXJhbChcImNhbmNlbGVkXCIpIH0pLFxuICAgICksXG4gIH0pLFxuICBfc3RvcmFnZTogZGVmaW5lVGFibGUoe1xuICAgIHNoYTI1Njogdi5zdHJpbmcoKSxcbiAgICBzaXplOiB2LmZsb2F0NjQoKSxcbiAgICBjb250ZW50VHlwZTogdi5vcHRpb25hbCh2LnN0cmluZygpKSxcbiAgfSksXG59KTtcblxuZXhwb3J0IGludGVyZmFjZSBTeXN0ZW1EYXRhTW9kZWxcbiAgZXh0ZW5kcyBEYXRhTW9kZWxGcm9tU2NoZW1hRGVmaW5pdGlvbjx0eXBlb2YgX3N5c3RlbVNjaGVtYT4ge31cblxuZXhwb3J0IHR5cGUgU3lzdGVtVGFibGVOYW1lcyA9IFRhYmxlTmFtZXNJbkRhdGFNb2RlbDxTeXN0ZW1EYXRhTW9kZWw+O1xuIl0sIm5hbWVzIjpbIm1vZGlmaWNhdGlvbiIsInZhbHVlIiwidiIsImFMZW5ndGgiLCJiTGVuZ3RoIiwibWFyayIsImFyZ3MiLCJyZXNwb25zZSIsIm5hbWUiXSwidmVyc2lvbiI6MywiZmlsZSI6ImluZGV4LmpzLm1hcCJ9
 globalThis.define=__define;  })(globalThis.define);